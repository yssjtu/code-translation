def countSubsequence ( s , n ) : cntG = 0 cntF = 0 result = 0 C = 0 for i in range ( n ) : if ( s [ i ] == 'G' ) : cntG += 1 result += C continue if ( s [ i ] == 'F' ) : cntF += 1 C += cntG continue else : continue print ( result )
def minProduct ( arr , n , k ) : heapq . heapify ( arr ) count = 0 ans = 1 while ( arr ) and count < k : x = heapq . heappop ( arr ) ans = ans * x count = count + 1 return ans
def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return a [ n - 1 ] + b [ n - 1 ]
def findElements ( arr , n ) : first = - sys . maxsize second = - sys . maxsize for i in range ( 0 , n ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] for i in range ( 0 , n ) : if ( arr [ i ] < second ) : print ( arr [ i ] , end = "" )
def minJumps ( arr , l , h ) : if ( h == l ) : return 0 if ( arr [ l ] == 0 ) : return float ( 'inf' ) min = float ( 'inf' ) for i in range ( l + 1 , h + 1 ) : if ( i < l + arr [ l ] + 1 ) : jumps = minJumps ( arr , i , h ) if ( jumps != float ( 'inf' ) and jumps + 1 < min ) : min = jumps + 1 return min
def printInSortedOrder ( arr , n ) : index = [ 0 ] * n for i in range ( n ) : index [ i ] = i for i in range ( n - 1 ) : min = i for j in range ( i + 1 , n ) : if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : min = j if ( min != i ) : index [ min ] , index [ i ] = index [ i ] , index [ min ] for i in range ( n ) : print ( arr [ index [ i ] ] , end = "" )
def minDiff ( arr , n , k ) : result = + 2147483647 arr . sort ( ) for i in range ( n - k + 1 ) : result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) return result
def arcLength ( diameter , angle ) : if angle >= 360 : print ( "Anglecannotbeformed" ) return 0 else : arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) return arc
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def minDifferenceAmongMaxMin ( arr , N , K ) : arr . sort ( ) res = 2147483647 for i in range ( ( N - K ) + 1 ) : curSeqDiff = arr [ i + K - 1 ] - arr [ i ] res = min ( res , curSeqDiff ) return res
def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x i = 1 result = 1 while ( result <= x ) : i += 1 result = i * i return i - 1
def countDivisbleby4 ( s ) : n = len ( s ) count = 0 for i in range ( 0 , n , 1 ) : if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : count += 1 for i in range ( 0 , n - 1 , 1 ) : h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) if ( h % 4 == 0 ) : count = count + i + 1 return count
def countPairs ( arr , n ) : ans = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : ans += 1 return ans
def isDivisibleBy7 ( num ) : if num < 0 : return isDivisibleBy7 ( - num ) if ( num == 0 or num == 7 ) : return True if ( num < 10 ) : return False return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) )
def minDaysToEmpty ( C , l ) : if ( l >= C ) : return C eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 return math . ceil ( eq_root ) + l
def cutRod ( price , n ) : val = [ 0 for x in range ( n + 1 ) ] val [ 0 ] = 0 for i in range ( 1 , n + 1 ) : max_val = INT_MIN for j in range ( i ) : max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) val [ i ] = max_val return val [ n ]
def getTotalNumberOfSequences ( m , n ) : if m < n : return 0 if n == 0 : return 1 res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) return res
def maxSum ( arr , n ) : cum_sum = 0 for i in range ( 0 , n ) : cum_sum += arr [ i ] curr_val = 0 for i in range ( 0 , n ) : curr_val += i * arr [ i ] res = curr_val for i in range ( 1 , n ) : next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) curr_val = next_val res = max ( res , next_val ) return res
def first ( str , i ) : if ( str [ i ] == '\0' ) : return 0 if ( str [ i ] . isupper ( ) ) : return str [ i ] return first ( str , i + 1 )
def findSmallest ( m , s ) : if ( s == 0 ) : if ( m == 1 ) : print ( "Smallestnumberis0" ) else : print ( "Notpossible" ) return if ( s > 9 * m ) : print ( "Notpossible" ) return res = [ 0 for i in range ( m + 1 ) ] s -= 1 for i in range ( m - 1 , 0 , - 1 ) : if ( s > 9 ) : res [ i ] = 9 s -= 9 else : res [ i ] = s s = 0 res [ 0 ] = s + 1 print ( "Smallestnumberis" , end = "" ) for i in range ( m ) : print ( res [ i ] , end = "" )
def areEqual ( arr1 , arr2 , n , m ) : if ( n != m ) : return False ; arr1 . sort ( ) ; arr2 . sort ( ) ; for i in range ( 0 , n - 1 ) : if ( arr1 [ i ] != arr2 [ i ] ) : return False ; return True ;
def countNums ( n , x , y ) : arr = [ False for i in range ( n + 2 ) ] if ( x <= n ) : arr [ x ] = True if ( y <= n ) : arr [ y ] = True result = 0 for i in range ( min ( x , y ) , n + 1 ) : if ( arr [ i ] ) : if ( i + x <= n ) : arr [ i + x ] = True if ( i + y <= n ) : arr [ i + y ] = True result = result + 1 return result
def bonacciseries ( n , m ) : a = [ 0 for i in range ( m ) ] a [ n - 1 ] = 1 a [ n ] = 1 for i in range ( n + 1 , m ) : a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] for i in range ( 0 , m ) : print ( a [ i ] , end = "" )
def isSubSequence ( string1 , string2 , m , n ) : if m == 0 : return True if n == 0 : return False if string1 [ m - 1 ] == string2 [ n - 1 ] : return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) return isSubSequence ( string1 , string2 , m , n - 1 )
def findNth ( n ) : count = 0 for curr in itertools . count ( ) : sum = 0 x = curr while ( x ) : sum = sum + x % 10 x = x // 10 if ( sum == 10 ) : count = count + 1 if ( count == n ) : return curr return - 1
def rangeGCD ( n , m ) : return n if ( n == m ) else 1
def lbs ( arr ) : n = len ( arr ) lis = [ 1 for i in range ( n + 1 ) ] for i in range ( 1 , n ) : for j in range ( 0 , i ) : if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : lis [ i ] = lis [ j ] + 1 lds = [ 1 for i in range ( n + 1 ) ] for i in reversed ( range ( n - 1 ) ) : for j in reversed ( range ( i - 1 , n ) ) : if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : lds [ i ] = lds [ j ] + 1 maximum = lis [ 0 ] + lds [ 0 ] - 1 for i in range ( 1 , n ) : maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) return maximum
def answerQuery ( a , n , l , r ) : count = 0 l = l - 1 for i in range ( l , r , 1 ) : element = a [ i ] divisors = 0 for j in range ( l , r , 1 ) : if ( a [ j ] % a [ i ] == 0 ) : divisors += 1 else : break if ( divisors == ( r - l ) ) : count += 1 return count
def printShortestSuperSeq ( x , y ) : m = len ( x ) n = len ( y ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if i == 0 : dp [ i ] [ j ] = j elif j == 0 : dp [ i ] [ j ] = i elif x [ i - 1 ] == y [ j - 1 ] : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] string = "" i = m j = n while i > 0 and j > 0 : if x [ i - 1 ] == y [ j - 1 ] : string += x [ i - 1 ] i -= 1 j -= 1 index -= 1 elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] : string += y [ j - 1 ] j -= 1 index -= 1 else : string += x [ i - 1 ] i -= 1 index -= 1 while i > 0 : string += x [ i - 1 ] i -= 1 index -= 1 while j > 0 : string += y [ j - 1 ] j -= 1 index -= 1 string = list ( string ) string . reverse ( ) return '' . join ( string )
def findSum ( str1 ) : temp = "" Sum = 0 for ch in str1 : if ( ch . isdigit ( ) ) : temp += ch else : Sum += int ( temp ) temp = "0" return Sum + int ( temp )
def countRotationsDivBy8 ( n ) : l = len ( n ) count = 0 if ( l == 1 ) : oneDigit = int ( n [ 0 ] ) if ( oneDigit % 8 == 0 ) : return 1 return 0 if ( l == 2 ) : first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) if ( first % 8 == 0 ) : count += 1 if ( second % 8 == 0 ) : count += 1 return count threeDigit = 0 for i in range ( 0 , ( l - 2 ) ) : threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 return count
def check ( s ) : if ( len ( s ) >= 10 ) : return True for i in range ( 1 , len ( s ) ) : for j in range ( i + 1 , len ( s ) ) : for k in range ( j + 1 , len ( s ) ) : s1 = s [ 0 : i ] s2 = s [ i : j - i ] s3 = s [ j : k - j ] s4 = s [ k : len ( s ) - k ] if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : return True return False
def eggDrop ( n , k ) : if ( k == 1 or k == 0 ) : return k if ( n == 1 ) : return k min = sys . maxsize for x in range ( 1 , k + 1 ) : res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) if ( res < min ) : min = res return min + 1
def decToBinary ( n ) : binaryNum = [ 0 ] * n i = 0 while ( n > 0 ) : binaryNum [ i ] = n % 2 n = int ( n / 2 ) i += 1 for j in range ( i - 1 , - 1 , - 1 ) : print ( binaryNum [ j ] , end = "" )
def isSubsetSum ( set , n , sum ) : subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) for i in range ( n + 1 ) : subset [ i ] [ 0 ] = True for i in range ( 1 , sum + 1 ) : subset [ 0 ] [ i ] = False for i in range ( 1 , n + 1 ) : for j in range ( 1 , sum + 1 ) : if j < set [ i - 1 ] : subset [ i ] [ j ] = subset [ i - 1 ] [ j ] if j >= set [ i - 1 ] : subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) return subset [ n ] [ sum ]
def checkStar ( mat ) : global size vertexD1 = 0 vertexDn_1 = 0 if ( size == 1 ) : return ( mat [ 0 ] [ 0 ] == 0 ) if ( size == 2 ) : return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) for i in range ( 0 , size ) : degreeI = 0 for j in range ( 0 , size ) : if ( mat [ i ] [ j ] ) : degreeI = degreeI + 1 if ( degreeI == 1 ) : vertexD1 = vertexD1 + 1 elif ( degreeI == size - 1 ) : vertexDn_1 = vertexDn_1 + 1 return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 )
def sortUsingHash ( a , n ) : Max = max ( a ) Hash = [ 0 ] * ( Max + 1 ) for i in range ( 0 , n ) : Hash [ a [ i ] ] += 1 for i in range ( 0 , Max + 1 ) : if Hash [ i ] != 0 : for j in range ( 0 , Hash [ i ] ) : print ( i , end = "" )
def findArea ( a , b , c ) : if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : print ( 'Notavalidtrianglen' ) return s = ( a + b + c ) / 2 area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 print ( 'Areaofatraingleis%f' % area )
def maxDistance ( arr , n ) : mp = { } maxDict = 0 for i in range ( n ) : if arr [ i ] not in mp . keys ( ) : mp [ arr [ i ] ] = i else : maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) return maxDict
def minCost ( cost ) : dist = [ 0 for i in range ( N ) ] for i in range ( N ) : dist [ i ] = INF dist [ 0 ] = 0 for i in range ( N ) : for j in range ( i + 1 , N ) : if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]
def countSub ( arr , n ) : count = [ 0 for i in range ( 10 ) ] for i in range ( n ) : for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : count [ arr [ i ] ] += count [ j ] count [ arr [ i ] ] += 1 result = 0 for i in range ( 10 ) : result += count [ i ] return result
def printPascal ( n ) : for line in range ( 1 , n + 1 ) : C = 1 for i in range ( 1 , line + 1 ) : print ( C , end = "" ) C = int ( C * ( line - i ) / i ) print ( "" )
def sequence ( n ) : if n == 1 or n == 2 : return 1 else : return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;
def checkCollision ( a , b , c , x , y , radius ) : dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) if ( radius == dist ) : print ( "Touch" ) elif ( radius > dist ) : print ( "Intersect" ) else : print ( "Outside" )
def numofAP ( a , n ) : minarr = + 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( minarr , a [ i ] ) maxarr = max ( maxarr , a [ i ] ) dp = [ 0 for i in range ( n + 1 ) ] ans = n + 1 for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : sum = [ 0 for i in range ( MAX + 1 ) ] for i in range ( n ) : dp [ i ] = 1 if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : dp [ i ] += sum [ a [ i ] - d ] ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] return ans
def MinOperation ( a , b , n ) : a . sort ( reverse = False ) b . sort ( reverse = False ) result = 0 for i in range ( 0 , n , 1 ) : if ( a [ i ] > b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) elif ( a [ i ] < b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) return result
def sumOfSeries ( n ) : return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n )
def recursiveReverse ( str , i = 0 ) : n = len ( str ) if i == n // 2 : return str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] recursiveReverse ( str , i + 1 )
def countOccurrences ( arr , n , x ) : res = 0 for i in range ( n ) : if x == arr [ i ] : res += 1 return res
def kthNonRepeating ( str , k ) : n = len ( str ) count = [ 0 ] * MAX_CHAR index = [ 0 ] * MAX_CHAR for i in range ( MAX_CHAR ) : count [ i ] = 0 index [ i ] = n for i in range ( n ) : x = str [ i ] count [ ord ( x ) ] += 1 if ( count [ ord ( x ) ] == 1 ) : index [ ord ( x ) ] = i if ( count [ ord ( x ) ] == 2 ) : index [ ord ( x ) ] = n index . sort ( ) return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1
def check ( degree , n ) : deg_sum = sum ( degree ) if ( 2 * ( n - 1 ) == deg_sum ) : return True else : return False
def isPowerOfTwo ( x ) : return ( x and ( not ( x & ( x - 1 ) ) ) )
def superSeq ( X , Y , m , n ) : if ( not m ) : return n if ( not n ) : return m if ( X [ m - 1 ] == Y [ n - 1 ] ) : return 1 + superSeq ( X , Y , m - 1 , n - 1 ) return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) )
def lis ( arr ) : global maximum n = len ( arr ) maximum = 1 _lis ( arr , n ) return maximum
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : s = set ( ) for i in range ( n1 ) : s . add ( a1 [ i ] ) for i in range ( n2 ) : for j in range ( n3 ) : if sum - a2 [ i ] - a3 [ j ] in s : return True return False
def maxLen ( arr , n ) : hash_map = { } curr_sum = 0 max_len = 0 ending_index = - 1 for i in range ( 0 , n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 else : arr [ i ] = 1 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if ( curr_sum == 0 ) : max_len = i + 1 ending_index = i if ( curr_sum + n ) in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum + n ] ) else : hash_map [ curr_sum ] = i for i in range ( 0 , n ) : if ( arr [ i ] == - 1 ) : arr [ i ] = 0 else : arr [ i ] = 1 print ( ending_index - max_len + 1 , end = "" ) print ( "to" , end = "" ) print ( ending_index ) return max_len
def SumOfKsubArray ( arr , n , k ) : Sum = 0 S = deque ( ) G = deque ( ) for i in range ( k ) : while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : S . pop ( ) while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : G . pop ( ) G . append ( i ) S . append ( i ) for i in range ( k , n ) : Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] while ( len ( S ) > 0 and S [ 0 ] <= i - k ) : S . popleft ( ) while ( len ( G ) > 0 and G [ 0 ] <= i - k ) : G . popleft ( ) while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : S . pop ( ) while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : G . pop ( ) G . append ( i ) S . append ( i ) Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] return Sum
def sortString ( str ) : str = '' . join ( sorted ( str ) ) print ( str )
def ReversespiralPrint ( m , n , a ) : b = [ 0 for i in range ( 100 ) ] i , k , l = 0 , 0 , 0 z = 0 size = m * n while ( k < m and l < n ) : val = 0 for i in range ( l , n ) : val = a [ k ] [ i ] b [ z ] = val z += 1 k += 1 for i in range ( k , m ) : val = a [ i ] [ n - 1 ] b [ z ] = val z += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : val = a [ m - 1 ] [ i ] b [ z ] = val z += 1 m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : val = a [ i ] [ l ] b [ z ] = val z += 1 l += 1 for i in range ( size - 1 , - 1 , - 1 ) : print ( b [ i ] , end = "" )
def maxSumSubarrayRemovingOneEle ( arr , n ) : fw = [ 0 for k in range ( n ) ] bw = [ 0 for k in range ( n ) ] cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] for i in range ( n ) : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) fw [ i ] = cur_max cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] i = n - 2 while i >= 0 : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) bw [ i ] = cur_max i -= 1 fans = max_so_far for i in range ( 1 , n - 1 ) : fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) return fans
def linearSearch ( arr , n ) : for i in range ( n ) : if arr [ i ] is i : return i return - 1
def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( n ) : for j in range ( m ) : if ( arr2 [ i ] == arr1 [ j ] ) : break if ( j == m ) : return 0 return 1
def findSmallestDifference ( A , B , m , n ) : A . sort ( ) B . sort ( ) a = 0 b = 0 result = sys . maxsize while ( a < m and b < n ) : if ( abs ( A [ a ] - B [ b ] ) < result ) : result = abs ( A [ a ] - B [ b ] ) if ( A [ a ] < B [ b ] ) : a += 1 else : b += 1 return result
def equilibrium ( arr ) : total_sum = sum ( arr ) leftsum = 0 for i , num in enumerate ( arr ) : total_sum -= num if leftsum == total_sum : return i leftsum += num return - 1
def sequence ( n ) : f = [ 0 , 1 , 1 ] print ( f [ 1 ] , end = "" ) , print ( f [ 2 ] , end = "" ) , for i in range ( 3 , n + 1 ) : f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) print ( f [ i ] , end = "" ) ,
def eggDrop ( n , k ) : eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : eggFloor [ i ] [ 1 ] = 1 eggFloor [ i ] [ 0 ] = 0 for j in range ( 1 , k + 1 ) : eggFloor [ 1 ] [ j ] = j for i in range ( 2 , n + 1 ) : for j in range ( 2 , k + 1 ) : eggFloor [ i ] [ j ] = INT_MAX for x in range ( 1 , j + 1 ) : res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) if res < eggFloor [ i ] [ j ] : eggFloor [ i ] [ j ] = res return eggFloor [ n ] [ k ]
def findgroups ( arr , n ) : c = [ 0 , 0 , 0 ] res = 0 for i in range ( 0 , n ) : c [ arr [ i ] % 3 ] += 1 res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) res += c [ 1 ] * c [ 2 ] res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) res += c [ 0 ] * c [ 1 ] * c [ 2 ] return res
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) return math . ceil ( d // ( 2 * r ) )
def findLargestd ( S , n ) : found = False S . sort ( ) for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( 0 , n ) : if ( i == j ) : continue for k in range ( j + 1 , n ) : if ( i == k ) : continue for l in range ( k + 1 , n ) : if ( i == l ) : continue if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = True return S [ i ] if ( found == False ) : return - 1
def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24
def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] start = 0 i = 1 while i <= n : while curr_sum > sum and start < i - 1 : curr_sum = curr_sum - arr [ start ] start += 1 if curr_sum == sum : print ( "Sumfoundbetweenindexes" ) print ( "%dand%d" % ( start , i - 1 ) ) return 1 if i < n : curr_sum = curr_sum + arr [ i ] i += 1 print ( "Nosubarrayfound" ) return 0
def isNumber ( s ) : for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) != True : return False return True
def minStringValue ( str , k ) : l = len ( str ) if ( k >= l ) : return 0 frequency = [ 0 ] * MAX_CHAR for i in range ( 0 , l ) : frequency [ ord ( str [ i ] ) - 97 ] += 1 q = PriorityQueue ( ) for i in range ( 0 , MAX_CHAR ) : q . put ( - frequency [ i ] ) while ( k > 0 ) : temp = q . get ( ) temp = temp + 1 q . put ( temp , temp ) k = k - 1 result = 0 ; while not q . empty ( ) : temp = q . get ( ) temp = temp * ( - 1 ) result += temp * temp return result
def productSubSeqCount ( arr , k ) : n = len ( arr ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] for i in range ( 1 , k + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 return dp [ k ] [ n ]
def isDiagonalMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False return True
def nobleInteger ( arr ) : arr . sort ( ) n = len ( arr ) for i in range ( n - 1 ) : if arr [ i ] == arr [ i + 1 ] : continue if arr [ i ] == n - i - 1 : return arr [ i ] if arr [ n - 1 ] == 0 : return arr [ n - 1 ] return - 1
def findElement ( arr , n , key ) : for i in range ( n ) : if ( arr [ i ] == key ) : return i return - 1
def lis ( arr , n ) : mpis = [ 0 ] * ( n ) for i in range ( n ) : mpis [ i ] = arr [ i ] for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] return max ( mpis )
def sumEqualProduct ( a , n ) : zero = 0 two = 0 for i in range ( n ) : if a [ i ] == 0 : zero += 1 if a [ i ] == 2 : two += 1 cnt = ( zero * ( zero - 1 ) ) // 2 + \ ( two * ( two - 1 ) ) // 2 return cnt
def fact ( n ) : if ( n == 0 ) : return 1 return n * fact ( n - 1 )
def decimalToBinary ( num , k_prec ) : binary = "" Integral = int ( num ) fractional = num - Integral while ( Integral ) : rem = Integral % 2 binary += str ( rem ) Integral //= 2 binary = binary [ : : - 1 ] binary += '.' while ( k_prec ) : fractional *= 2 fract_bit = int ( fractional ) if ( fract_bit == 1 ) : fractional -= fract_bit binary += '1' else : binary += '0' k_prec -= 1 return binary
def getLevenstein ( inpt ) : revInput = inpt [ : : - 1 ] n = len ( inpt ) dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ 0 ] [ i ] = i dp [ i ] [ 0 ] = i for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if inpt [ i - 1 ] == revInput [ j - 1 ] : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) res = INT_MAX i , j = n , 0 while i >= 0 : res = min ( res , dp [ i ] [ j ] ) if i < n : res = min ( res , dp [ i + 1 ] [ j ] ) if i > 0 : res = min ( res , dp [ i - 1 ] [ j ] ) i -= 1 j += 1 return res
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( y2 - y1 ) slope_error_new = m_new - ( x2 - x1 ) y = y1 for x in range ( x1 , x2 + 1 ) : print ( "(" , x , "," , y , ")\n" ) slope_error_new = slope_error_new + m_new if ( slope_error_new >= 0 ) : y = y + 1 slope_error_new = slope_error_new - 2 * ( x2 - x1 )
def printUnsorted ( arr , n ) : e = n - 1 for s in range ( 0 , n - 1 ) : if arr [ s ] > arr [ s + 1 ] : break if s == n - 1 : print ( "Thecompletearrayissorted" ) exit ( ) e = n - 1 while e > 0 : if arr [ e ] < arr [ e - 1 ] : break e -= 1 max = arr [ s ] min = arr [ s ] for i in range ( s + 1 , e + 1 ) : if arr [ i ] > max : max = arr [ i ] if arr [ i ] < min : min = arr [ i ] for i in range ( s ) : if arr [ i ] > min : s = i break i = n - 1 while i >= e + 1 : if arr [ i ] < max : e = i break i -= 1 print ( "Theunsortedsubarraywhichmakesthegivenarray" ) print ( "sortedliesbetweentheindexes%dand%d" % ( s , e ) )
def find_max ( A , N , K ) : Count = dict ( ) for i in range ( K - 1 ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 Myset = dict ( ) for x in Count : if ( Count [ x ] == 1 ) : Myset [ x ] = 1 for i in range ( K - 1 , N ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 if ( Count [ A [ i ] ] == 1 ) : Myset [ A [ i ] ] = 1 else : del Myset [ A [ i ] ] if ( len ( Myset ) == 0 ) : print ( "Nothing" ) else : maxm = - 10 ** 9 for i in Myset : maxm = max ( i , maxm ) print ( maxm ) x = A [ i - K + 1 ] if x in Count . keys ( ) : Count [ x ] -= 1 if ( Count [ x ] == 1 ) : Myset [ x ] = 1 if ( Count [ x ] == 0 ) : del Myset [ x ]
def segregateElements ( arr , n ) : temp = [ 0 for k in range ( n ) ] j = 0 for i in range ( n ) : if ( arr [ i ] >= 0 ) : temp [ j ] = arr [ i ] j += 1 if ( j == n or j == 0 ) : return for i in range ( n ) : if ( arr [ i ] < 0 ) : temp [ j ] = arr [ i ] j += 1 for k in range ( n ) : arr [ k ] = temp [ k ]
def KMaxCombinations ( A , B , N , K ) : pq = PriorityQueue ( ) for i in range ( 0 , N ) : for j in range ( 0 , N ) : a = A [ i ] + B [ j ] pq . put ( ( - a , a ) ) count = 0 while ( count < K ) : print ( pq . get ( ) [ 1 ] ) count = count + 1
def lenghtOfLongestAP ( set , n ) : if ( n <= 2 ) : return n L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] llap = 2 for i in range ( n ) : L [ i ] [ n - 1 ] = 2 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while ( i >= 0 and k <= n - 1 ) : if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : k += 1 elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : L [ i ] [ j ] = 2 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) i -= 1 k += 1 while ( i >= 0 ) : L [ i ] [ j ] = 2 i -= 1 return llap
def prefixSum2D ( a ) : global C , R psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] for i in range ( 1 , C ) : psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) for i in range ( 0 , R ) : psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) for i in range ( 1 , R ) : for j in range ( 1 , C ) : psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) for i in range ( 0 , R ) : for j in range ( 0 , C ) : print ( psa [ i ] [ j ] , end = "" ) print ( )
def round ( n ) : a = ( n // 10 ) * 10 b = a + 10 return ( b if n - a > b - n else a )
def getMinSquares ( n ) : dp = [ 0 , 1 , 2 , 3 ] for i in range ( 4 , n + 1 ) : dp . append ( i ) for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : temp = x * x ; if temp > i : break else : dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) return dp [ n ]
def noAdjacentDup ( s ) : n = len ( s ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = "a" while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 return s
def printDistinct ( arr , n ) : for i in range ( 0 , n ) : d = 0 for j in range ( 0 , i ) : if ( arr [ i ] == arr [ j ] ) : d = 1 break if ( d == 0 ) : print ( arr [ i ] )
def rectCount ( n , m ) : return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4
def greatest ( s ) : n = len ( s ) a = [ 0 for i in range ( n ) ] Sum = 0 for i in range ( n ) : a [ i ] = ord ( s [ i ] ) - ord ( '0' ) Sum += a [ i ] if ( a [ n - 1 ] % 2 ) : if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) % 3 != 0 ) : print ( "-1" ) else : print ( n ) else : re = Sum % 3 dell = - 1 flag = 0 for i in range ( n - 1 ) : if ( ( a [ i ] ) % 3 == re ) : if ( a [ i + 1 ] > a [ i ] ) : dell = i flag = 1 break else : dell = i if ( flag == 0 ) : if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : dell = n - 1 if ( dell == - 1 ) : print ( "-1" ) else : print ( dell + 1 )
def maximumSum ( arr , n , k ) : for i in range ( 1 , k + 1 ) : min = + 2147483647 index = - 1 for j in range ( n ) : if ( arr [ j ] < min ) : min = arr [ j ] index = j if ( min == 0 ) : break arr [ index ] = - arr [ index ] sum = 0 for i in range ( n ) : sum += arr [ i ] return sum
def mirrorImage ( a , b , c , x1 , y1 ) : temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) x = temp * a + x1 y = temp * b + y1 return ( x , y )
def firstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : allocation [ i ] = j blockSize [ j ] -= processSize [ i ] break print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( "" , i + 1 , "" , processSize [ i ] , "" , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )
def simplify ( Str ) : Len = len ( Str ) res = [ None ] * Len index = 0 i = 0 s = [ ] s . append ( 0 ) while ( i < Len ) : if ( Str [ i ] == '+' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '-' index += 1 if ( s [ - 1 ] == 0 ) : res [ index ] = '+' index += 1 elif ( Str [ i ] == '-' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '+' index += 1 elif ( s [ - 1 ] == 0 ) : res [ index ] = '-' index += 1 elif ( Str [ i ] == '(' and i > 0 ) : if ( Str [ i - 1 ] == '-' ) : x = 0 if ( s [ - 1 ] == 1 ) else 1 s . append ( x ) elif ( Str [ i - 1 ] == '+' ) : s . append ( s [ - 1 ] ) elif ( Str [ i ] == ')' ) : s . pop ( ) else : res [ index ] = Str [ i ] index += 1 i += 1 return res