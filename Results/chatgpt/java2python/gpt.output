def countSubsequence(s, n):     cntG = 0     cntF = 0     result = 0     C = 0     for i in range(n):         ch = s[i]         if ch == 'G':             cntG += 1             result += C         elif ch == 'F':             cntF += 1             C += cntG         else:             continue     print(result)
def minProduct(arr, n, k):     pq = []     for i in range(n):         heapq.heappush(pq, arr[i])     count, ans = 0, 1     while pq and count < k:         ans *= heapq.heappop(pq)         count += 1     return ans
def countStrings(n):     a = [0] * n     b = [0] * n     a[0] = b[0] = 1     for i in range(1, n):         a[i] = a[i-1] + b[i-1]         b[i] = a[i-1]     return a[n-1] + b[n-1]
def findElements(arr, n):     first = float('-inf')     second = float('inf')     for i in range(n):         if arr[i] > first:             second = first             first = arr[i]         elif arr[i] > second:             second = arr[i]     for i in range(n):         if arr[i] < second:             print(arr[i], end=' ')
def minJumps(arr, l, h):     if h == l:         return 0     if arr[l] == 0:         return float("inf")     min_jumps = float("inf")     for i in range(l + 1, min(h + 1, l + arr[l] + 1)):         jumps = minJumps(arr, i, h)         if jumps != float("inf") and jumps + 1 < min_jumps:             min_jumps = jumps + 1     return min_jumps
def printInSortedOrder(arr, n):     index = [i for i in range(n)]     for i in range(n-1):         min_index = i         for j in range(i+1, n):             if arr[index[min_index]] > arr[index[j]]:                 min_index = j         if min_index != i:             index[min_index], index[i] = index[i], index[min_index]     for i in range(n):         print(arr[index[i]], end=' ')
def minDiff(arr, n, k):     result = float('inf')     arr.sort()     for i in range(n - k + 1):         result = min(result, arr[i + k - 1] - arr[i])     return result
def arcLength(diameter, angle):     pi = 22.0 / 7.0     if angle >= 360:         print("Angle cannot be formed")         return 0     else:         arc = (pi * diameter) * (angle / 360.0)         return arc
def factorial(n):     return 1 if n == 1 or n == 0 else n * factorial(n - 1)
def minDifferenceAmongMaxMin(arr, N, K):     arr.sort()     res = sys.maxsize     for i in range(N - K + 1):         curSeqDiff = arr[i + K - 1] - arr[i]         res = min(res, curSeqDiff)     return res
def floorSqrt(x):     if x == 0 or x == 1:         return x     i, result = 1, 1     while result <= x:         i += 1         result = i * i     return i - 1
def countDivisbleby4(s):     n = len(s)     count = 0     for i in range(n):         if s[i] == '4' or s[i] == '8' or s[i] == '0':             count += 1     for i in range(n - 1):         h = int(s[i:i+2])         if h % 4 == 0:             count += i + 1     return count
def countPairs(arr, n):     ans = 0     for i in range(n):         for j in range(i + 1, n):             if arr[i] == arr[j]:                 ans += 1     return ans
def isDivisibleBy7(num):     if num < 0:         return isDivisibleBy7(-num)     if num == 0 or num == 7:         return True     if num < 10:         return False     return isDivisibleBy7(num // 10 - 2 * (num - (num // 10) * 10))
def minDaysToEmpty(C, l):     if l >= C:         return C     eq_root = (math.sqrt(1 + 8 * (C - l)) - 1) / 2     return int(math.ceil(eq_root) + l)
def cutRod(price, n):     val = [0] * (n + 1)     val[0] = 0     for i in range(1, n + 1):         max_val = float('-inf')         for j in range(i):             max_val = max(max_val, price[j] + val[i - j - 1])         val[i] = max_val     return val[n]
def getTotalNumberOfSequences(m, n):     if m < n:         return 0     if n == 0:         return 1     return getTotalNumberOfSequences(m-1, n) + getTotalNumberOfSequences(m//2, n-1)      
def maxSum(arr, n):     cum_sum = sum(arr)     curr_val = sum(i * arr[i] for i in range(n))     res = curr_val     for i in range(1, n):         next_val = curr_val - (cum_sum - arr[i - 1]) + arr[i - 1] * (n - 1)         curr_val = next_val         res = max(res, next_val)     return res
def first(str, i):     if i >= len(str):         return '\0'     if str[i].isupper():         return str[i]     return first(str, i + 1)
def findSmallest(m, s):     if s == 0:         if m == 1:             print("Smallest number is 0")         else:             print("Not possible")         return     if s > 9 * m:         print("Not possible")         return     res = [0] * m     s -= 1     for i in range(m - 1, 0, -1):         if s > 9:             res[i] = 9             s -= 9         else:             res[i] = s             s = 0     res[0] = s + 1     print("Smallest number is ", end="")     for i in range(m):         print(res[i], end="")     print()      
def areEqual(arr1, arr2):     n = len(arr1)     m = len(arr2)     if n != m:         return False     arr1.sort()     arr2.sort()     for i in range(n):         if arr1[i] != arr2[i]:             return False     return True      
def countNums(n, x, y):     arr = [False] * (n + 1)     if x <= n:         arr[x] = True     if y <= n:         arr[y] = True     result = 0     for i in range(min(x, y), n+1):         if arr[i]:             if i + x <= n:                 arr[i+x] = True             if i + y <= n:                 arr[i+y] = True             result += 1     return result
def bonacciseries(n, m):     a = [0] * m     a[n - 1] = 1     a[n] = 1     for i in range(n + 1, m):         a[i] = 2 * a[i - 1] - a[i - n - 1]     for i in range(m):         print(a[i], end=' ')
def isSubSequence(str1, str2, m, n):     if m == 0:         return True     if n == 0:         return False     if str1[m-1] == str2[n-1]:         return isSubSequence(str1, str2, m-1, n-1)     return isSubSequence(str1, str2, m, n-1)
def findNth(n):     count = 0     curr = 1     while True:         sum = 0         x = curr         while x > 0:             sum = sum + x % 10             x = x // 10         if sum == 10:             count += 1         if count == n:             return curr         curr += 1
def rangeGCD(n, m):     return n if n == m else 1
def lbs(arr, n):     lis = [1] * n          for i in range(1, n):         for j in range(i):             if arr[i] > arr[j] and lis[i] < lis[j] + 1:                 lis[i] = lis[j] + 1                      lds = [1] * n          for i in range(n - 2, -1, -1):         for j in range(n - 1, i, -1):             if arr[i] > arr[j] and lds[i] < lds[j] + 1:                 lds[i] = lds[j] + 1                      max_lbs = lis[0] + lds[0] - 1          for i in range(1, n):         if lis[i] + lds[i] - 1 > max_lbs:             max_lbs = lis[i] + lds[i] - 1                  return max_lbs
def answerQuery(a, n, l, r):     count = 0     l = l - 1     for i in range(l, r):         element = a[i]         divisors = 0         for j in range(l, r):             if a[j] % a[i] == 0:                 divisors += 1             else:                 break         if divisors == (r - l):             count += 1     return count
def printShortestSuperSeq(X, Y):     m = len(X)     n = len(Y)     dp = [[0 for j in range(n + 1)] for i in range(m + 1)]     for i in range(m + 1):         for j in range(n + 1):             if i == 0:                 dp[i][j] = j             elif j == 0:                 dp[i][j] = i             elif X[i - 1] == Y[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]             else:                 dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])     index = dp[m][n]     str = ""     i = m     j = n         while i > 0 and j > 0:         if X[i - 1] == Y[j - 1]:             str += X[i - 1]             i -= 1             j -= 1             index -= 1         elif dp[i - 1][j] > dp[i][j - 1]:             str += Y[j - 1]             j -= 1             index -= 1         else:             str += X[i - 1]             i -= 1             index -= 1                while i > 0:         str += X[i - 1]         i -= 1         index -= 1            while j > 0:         str += Y[j - 1]         j -= 1         index -= 1             str = str[::-1]     return str      
def findSum(str):     temp = ""     sum = 0     for i in range(len(str)):         ch = str[i]         if ch.isdigit():             temp += ch         else:             sum += int(temp)             temp = "0"     return sum + int(temp)
def countRotationsDivBy8(n):     len_n = len(n)     count = 0       if len_n == 1:         one_digit = int(n)         if one_digit % 8 == 0:             return 1         return 0         if len_n == 2:         first = int(n)         second = int(n[1] + n[0])         if first % 8 == 0:             count += 1         if second % 8 == 0:             count += 1         return count        for i in range(len_n-2):         three_digit = int(n[i:i+3])         if three_digit % 8 == 0:             count += 1                three_digit = int(n[-1] + n[0] + n[1])     if three_digit % 8 == 0:         count += 1            three_digit = int(n[-2] + n[-1] + n[0])     if three_digit % 8 == 0:         count += 1            return count
def check(s):     if len(s) >= 10:         return True     for i in range(1, len(s)):         for j in range(i+1, len(s)):             for k in range(j+1, len(s)):                 s1, s2, s3, s4 = "", "", "", ""                 try:                     s1 = s[:i]                     s2 = s[i:j]                     s3 = s[j:k]                     s4 = s[k:]                 except IndexError:                     pass                 if (strcheck(s1, s2) and strcheck(s1, s3) and strcheck(s1, s4)                     and strcheck(s2, s3) and strcheck(s2, s4) and strcheck(s3, s4)):                     return True     return False
def eggDrop(n, k):     if k == 1 or k == 0:         return k     if n == 1:         return k     min_val = float('inf')     for x in range(1, k + 1):         res = max(eggDrop(n - 1, x - 1), eggDrop(n, k - x))         if res < min_val:             min_val = res     return min_val + 1
def decToBinary(n):     binaryNum = [0] * 32     i = 0     while n > 0:         binaryNum[i] = n % 2         n //= 2         i += 1     for j in range(i - 1, -1, -1):         print(binaryNum[j], end="")
def isSubsetSum(set, n, sum):     subset = [[False for i in range(n+1)] for j in range(sum+1)]     for i in range(n+1):         subset[0][i] = True     for i in range(1, sum+1):         subset[i][0] = False     for i in range(1, sum+1):         for j in range(1, n+1):             subset[i][j] = subset[i][j-1]             if i >= set[j-1]:                 subset[i][j] = subset[i][j] or subset[i-set[j-1]][j-1]     return subset[sum][n]
def checkStar(mat):     size = len(mat)     vertexD1 = 0     vertexDn_1 = 0      if (size == 1):         return (mat[0][0] == 0)     if (size == 2):         return (mat[0][0] == 0 and mat[0][1] == 1 and mat[1][0] == 1 and mat[1][1] == 0)     for i in range(size):         degreeI = 0         for j in range(size):             if (mat[i][j] == 1):                 degreeI += 1         if (degreeI == 1):             vertexD1 += 1         elif (degreeI == size - 1):             vertexDn_1 += 1            return (vertexD1 == (size - 1) and vertexDn_1 == 1)
def sortUsingHash(a, n):     max_val = np.max(a)     hash_table = np.zeros(max_val+1, dtype=int)          for i in range(n):         hash_table[a[i]] += 1          for i in range(max_val+1):         if hash_table[i] != 0:             for j in range(hash_table[i]):                 print(i, end=' ')
def findArea(a, b, c):     if a < 0 or b < 0 or c < 0 or (a + b <= c) or (a + c <= b) or (b + c <= a):         print("Not a valid triangle")         exit(0)     s = (a + b + c) / 2     return math.sqrt(s * (s - a) * (s - b) * (s - c))
def maxDistance(arr, n):     map = {}     max_dist = 0     for i in range(n):         if arr[i] not in map:             map[arr[i]] = i         else:             max_dist = max(max_dist, i - map[arr[i]])     return max_dist
def minCost(cost):     N = len(cost)     INF = float('inf')     dist = [INF] * N     dist[0] = 0          for i in range(N):         for j in range(i+1, N):             if dist[j] > dist[i] + cost[i][j]:                 dist[j] = dist[i] + cost[i][j]          return dist[N-1]
def countSub(arr, n):     count = [0] * 10     for i in range(n):         for j in range(arr[i]-1, -1, -1):             count[arr[i]] += count[j]         count[arr[i]] += 1     result = 0     for i in range(10):         result += count[i]     return result
def printPascal(n):     for line in range(1, n+1):         C = 1         for i in range(1, line+1):             print(C, end=" ")             C = C * (line - i) // i         print()
def sequence(n):     if n == 1 or n == 2:         return 1     else:         return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))
def checkCollision(a, b, c, x, y, radius):     dist = abs(a*x + b*y + c) / math.sqrt(a*a + b*b)     if radius == dist:         print("Touch")     elif radius > dist:         print("Intersect")     else:         print("Outside")
def numofAP(a, n):     MAX = 1000001     minarr = float('inf')     maxarr = float('-inf')        for i in range(n):         minarr = min(minarr, a[i])         maxarr = max(maxarr, a[i])     dp = [0] * n     sum = [0] * MAX     ans = n + 1        for d in range(minarr - maxarr, maxarr - minarr + 1):         sum = [0] * MAX               for i in range(n):             dp[i] = 1                        if (a[i] - d >= 1 and a[i] - d <= 1000000):                 dp[i] += sum[a[i] - d]                            ans += dp[i] - 1             sum[a[i]] += dp[i]               return ans
def MinOperation(a, b, n):     a.sort()     b.sort()     result = 0     for i in range(n):         if a[i] > b[i]:             result += abs(a[i] - b[i])         elif a[i] < b[i]:             result += abs(a[i] - b[i])     return result
def sumOfSeries(n):     return int(0.6172 * (pow(10, n) - 1) - 0.55 * n)
def recursiveReverse(str, i):     n = len(str)     if i == n // 2:         return     str[i], str[n-i-1] = str[n-i-1], str[i]     recursiveReverse(str, i+1)
def countOccurrences(arr, n, x):     res = 0     for i in range(n):         if x == arr[i]:             res += 1     return res
def kthNonRepeating(str, k):     n = len(str)     MAX_CHAR = 256     count = [0] * MAX_CHAR     index = [n] * MAX_CHAR     for i in range(n):         x = str[i]         count[ord(x)] += 1         if count[ord(x)] == 1:             index[ord(x)] = i         if count[ord(x)] == 2:             index[ord(x)] = n     index = sorted(index)     if index[k - 1] != n:         return index[k - 1]     else:         return -1
def check(degree, n):     deg_sum = sum(degree)     return 2 * (n - 1) == deg_sum
def isPowerOfTwo(x):     return x != 0 and (x & (x - 1)) == 0
def superSeq(X, Y, m, n):     if m == 0:         return n     if n == 0:         return m     if X[m-1] == Y[n-1]:         return 1 + superSeq(X, Y, m-1, n-1)     return 1 + min(superSeq(X, Y, m-1, n), superSeq(X, Y, m, n-1))
def lis(arr, n):     global max_ref     max_ref = 1     _lis(arr, n)     return max_ref
def findTriplet(a1, a2, a3, n1, n2, n3, sum):     s = set(a1)     al = list(s)     for i in range(n2):         for j in range(n3):             if sum - a2[i] - a3[j] in al and al.index(sum - a2[i] - a3[j]) != len(al) - 1:                 return True     return False
def maxLen(arr, n):     hM = {}     sum = 0     max_len = 0     ending_index = -1     start_index = 0          for i in range(n):         arr[i] = -1 if arr[i] == 0 else 1          for i in range(n):         sum += arr[i]                  if sum == 0:             max_len = i + 1             ending_index = i                      if (sum + n) in hM:             if max_len < i - hM[sum + n]:                 max_len = i - hM[sum + n]                 ending_index = i                          else:             hM[sum + n] = i                  for i in range(n):         arr[i] = 0 if arr[i] == -1 else 1          end = ending_index - max_len + 1     print(end, "to", ending_index)     return max_len
def SumOfKsubArray(arr, k):     sum = 0     S, G = deque(), deque()     i = 0        for i in range(k):         while S and arr[S[-1]] >= arr[i]:             S.pop()         while G and arr[G[-1]] <= arr[i]:             G.pop()         G.append(i)         S.append(i)        for i in range(i, len(arr)):         sum += arr[S[0]] + arr[G[0]]                while S and S[0] <= i - k:             S.popleft()         while G and G[0] <= i - k:             G.popleft()         while S and arr[S[-1]] >= arr[i]:             S.pop()         while G and arr[G[-1]] <= arr[i]:             G.pop()         G.append(i)         S.append(i)        sum += arr[S[0]] + arr[G[0]]     return sum
def sortString(str):     arr = list(str)     arr.sort()     print("".join(arr))
def reverse_spiral_print(m, n, a):     b = []     k, l = 0, 0     z = 0     size = m * n        while k < m and l < n:         for i in range(l, n):             val = a[k][i]             b.append(val)             z += 1         k += 1                for i in range(k, m):             val = a[i][n - 1]             b.append(val)             z += 1         n -= 1                if k < m:             for i in range(n - 1, l - 1, -1):                 val = a[m - 1][i]                 b.append(val)                 z += 1             m -= 1                    if l < n:             for i in range(m - 1, k - 1, -1):                 val = a[i][l]                 b.append(val)                 z += 1             l += 1       for x in range(size - 1, -1, -1):         print(b[x], end=" ")     print()
def maxSumSubarrayRemovingOneEle(arr, n):     fw = [0] * n     bw = [0] * n         cur_max = max_so_far = arr[0]     fw[0] = arr[0]        for i in range(1, n):         cur_max = max(arr[i], cur_max + arr[i])         max_so_far = max(max_so_far, cur_max)         fw[i] = cur_max        cur_max = max_so_far = bw[n-1] = arr[n-1]        for i in range(n-2, -1, -1):         cur_max = max(arr[i], cur_max + arr[i])         max_so_far = max(max_so_far, cur_max)         bw[i] = cur_max       fans = max_so_far       for i in range(1, n-1):         fans = max(fans, fw[i-1] + bw[i+1])       return fans
def linearSearch(arr, n):     for i in range(n):         if arr[i] == i:             return i     return -1
def isSubset(arr1, arr2, m, n):     for i in range(n):         if arr2[i] not in arr1:             return False     return True
def findSmallestDifference(A, B, m, n):     A.sort()     B.sort()     a, b = 0, 0     result = float('inf')     while a < m and b < n:         if abs(A[a] - B[b]) < result:             result = abs(A[a] - B[b])         if A[a] < B[b]:             a += 1         else:             b += 1     return result
def equilibrium(arr, n):     sum = 0     leftsum = 0     for i in range(n):         sum += arr[i]     for i in range(n):         sum -= arr[i]         if leftsum == sum:             return i         leftsum += arr[i]     return -1
def sequence(n):     f = [0] * (n + 1)     f[1], f[2] = 1, 1     print(f[1], f[2], end=" ")     for i in range(3, n + 1):         f[i] = f[f[i - 1]] + f[i - f[i - 1]]         print(f[i], end=" ")
def eggDrop(n, k):     eggFloor = [[0 for j in range(k+1)] for i in range(n+1)]         for i in range(1, n+1):         eggFloor[i][1] = 1         eggFloor[i][0] = 0           for j in range(1, k+1):         eggFloor[1][j] = j           for i in range(2, n+1):         for j in range(2, k+1):             eggFloor[i][j] = float('inf')             for x in range(1, j+1):                 res = 1 + max(eggFloor[i-1][x-1], eggFloor[i][j-x])                 if res < eggFloor[i][j]:                     eggFloor[i][j] = res                       return eggFloor[n][k]
def findgroups(arr, n):     c = [0, 0, 0]     res = 0     for i in range(n):         c[arr[i] % 3] += 1     res += (c[0] * (c[0] - 1)) // 2     res += c[1] * c[2]     res += (c[0] * (c[0] - 1) * (c[0] - 2)) // 6     res += (c[1] * (c[1] - 1) * (c[1] - 2)) // 6     res += (c[2] * (c[2] - 1) * (c[2] - 2)) // 6     res += c[0] * c[1] * c[2]     return res
def minRevolutions(r, x1, y1, x2, y2):     d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)     return math.ceil(d / (2 * r))
def findLargestd(S, n):     found = False     S.sort()     for i in range(n-1, -1, -1):         for j in range(n):             if i == j:                 continue             for k in range(j+1, n):                 if i == k:                     continue                 for l in range(k+1, n):                     if i == l:                         continue                     if S[i] == S[j] + S[k] + S[l]:                         found = True                         return S[i]     if not found:         return float('inf')     return -1
def findSum(n):     return n * (n + 1) * (n + 2) * (3 * n + 1) // 24
def subArraySum(arr, n, sum):     curr_sum = arr[0]     start = 0     i = 1     while i <= n:         while curr_sum > sum and start < i - 1:             curr_sum -= arr[start]             start += 1         if curr_sum == sum:             p = i - 1             print("Sum found between indexes", start, "and", p)             return 1         if i < n:             curr_sum += arr[i]         i += 1     print("No subarray found")     return 0
def isNumber(s):     for i in range(len(s)):         if s[i].isdigit() == False:             return False     return True
def minStringValue(str, k):     l = len(str)     if k >= l:         return 0     MAX_CHAR = 26     frequency = defaultdict(int)     for i in range(l):         frequency[str[i]] += 1     q = []     for i in range(MAX_CHAR):         if frequency[chr(ord('a')+i)] != 0:             heapq.heappush(q, -frequency[chr(ord('a')+i)])      while k != 0:         temp = -heapq.heappop(q)         temp -= 1         heapq.heappush(q, -temp)         k -= 1     result = 0     while q:         temp = -heapq.heappop(q)         result += temp * temp     return result
def productSubSeqCount(arr, k):     n = len(arr)     dp = [[0 for j in range(n+1)] for i in range(k+1)]     for i in range(1, k+1):         for j in range(1, n+1):             dp[i][j] = dp[i][j-1]             if arr[j-1] <= i and arr[j-1] > 0:                 dp[i][j] += dp[i//arr[j-1]][j-1] + 1     return dp[k][n]
def isDiagonalMatrix(mat):     N = len(mat)     for i in range(N):         for j in range(N):             if i != j and mat[i][j] != 0:                 return False     return True
def nobleInteger(arr):     arr.sort()     n = len(arr)     for i in range(n-1):         if arr[i] == arr[i+1]:             continue         if arr[i] == n-i-1:             return arr[i]     if arr[n-1] == 0:         return arr[n-1]     return -1
def findElement(arr, n, key):     for i in range(n):         if arr[i] == key:             return i     return -1
def lis(arr, n):     mpis = [0] * n     max_val = float('-inf')     for i in range(n):         mpis[i] = arr[i]     for i in range(1, n):         for j in range(i):             if arr[i] > arr[j] and mpis[i] < mpis[j] * arr[i]:                 mpis[i] = mpis[j] * arr[i]     for k in range(len(mpis)):         if mpis[k] > max_val:             max_val = mpis[k]     return max_val
def sumEqualProduct(a, n):     zero, two = 0, 0     for i in range(n):         if a[i] == 0:             zero += 1         if a[i] == 2:             two += 1     cnt = (zero * (zero - 1)) // 2 + (two * (two - 1)) // 2     return cnt
def fact(n):     if n == 0:         return 1     return n * fact(n - 1)
def decimalToBinary(num, k_prec):     binary = ""     Integral = int(num)     fractional = num - Integral     while Integral > 0:         rem = Integral % 2         binary += str(rem)         Integral //= 2     binary = binary[::-1] + '.'     while k_prec > 0:         fractional *= 2         fract_bit = int(fractional)         if fract_bit == 1:             fractional -= fract_bit             binary += str(1)         else:             binary += str(0)         k_prec -= 1     return binary
def getLevenstein(input):     revInput = input[::-1]     n = len(input)     dp = [[0 for j in range(n+1)] for i in range(n+1)]     for i in range(n+1):         dp[0][i] = i         dp[i][0] = i     for i in range(1, n+1):         for j in range(1, n+1):             if input[i-1] == revInput[j-1]:                 dp[i][j] = dp[i-1][j-1]             else:                 dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])     res = float('inf')     for i in range(n, -1, -1):         j = n - i         res = min(res, dp[i][j])         if i < n:             res = min(res, dp[i+1][j])         if i > 0:             res = min(res, dp[i-1][j])     return res
def factorial(n):     if n == 0:         return 1     return n * factorial(n-1)
def bresenham(x1, y1, x2, y2):     m_new = 2 * (y2 - y1)     slope_error_new = m_new - (x2 - x1)     x, y = x1, y1     while x <= x2:         print("(", x, ",", y, ")")         slope_error_new += m_new         if slope_error_new >= 0:             y += 1             slope_error_new -= 2 * (x2 - x1)         x += 1
def printUnsorted(arr, n):     s, e, i, max_val, min_val = 0, n - 1, 0, arr[0], arr[n-1]     for s in range(n - 1):         if arr[s] > arr[s + 1]:             break     if s == n - 1:         print("The complete array is sorted")         return     for e in range(n - 1, 0, -1):         if arr[e] < arr[e - 1]:             break     for i in range(s + 1, e):         if arr[i] > max_val:             max_val = arr[i]         if arr[i] < min_val:             min_val = arr[i]     for i in range(s):         if arr[i] > min_val:             s = i             break     for i in range(n - 1, e, -1):         if arr[i] < max_val:             e = i             break     print("The unsorted subarray which makes the given array sorted lies between the indices", s, "and", e)     return
def find_max(A, N, K):     Count = {}     for i in range(K-1):         if A[i] in Count:             Count[A[i]] += 1         else:             Count[A[i]] = 1     Myset = set()     for x in Count.items():         if x[1] == 1:             Myset.add(x[0])     for i in range(K-1, N):         if A[i] in Count:             Count[A[i]] += 1         else:             Count[A[i]] = 1         if Count[A[i]] == 1:             Myset.add(A[i])         else:             Myset.discard(A[i])         if len(Myset) == 0:             print("Nothing")         else:             print(max(Myset))         x = A[i-K+1]         Count[x] -= 1         if Count[x] == 1:             Myset.add(x)         elif Count[x] == 0:             Myset.discard(x)
def segregateElements(arr, n):     temp = [0] * n     j = 0     for i in range(n):         if arr[i] >= 0:             temp[j] = arr[i]             j += 1     if j == n or j == 0:         return     for i in range(n):         if arr[i] < 0:             temp[j] = arr[i]             j += 1     for i in range(n):         arr[i] = temp[i]
def KMaxCombinations(A, B, N, K):     pq = []     for i in range(N):         for j in range(N):             heapq.heappush(pq, -(A[i]+B[j]))     count = 0     while count < K:         print(-heapq.heappop(pq))         count += 1
def lengthOfLongestAP(set, n):     if n <= 2:         return n        L = [[0 for i in range(n)] for j in range(n)]     llap = 2       for i in range(n):         L[i][n-1] = 2      for j in range(n-2, 0, -1):         i, k = j - 1, j + 1              while i >= 0 and k <= n-1:             if set[i] + set[k] < 2*set[j]:                 k += 1             elif set[i] + set[k] > 2*set[j]:                 L[i][j] = 2                 i -= 1             else:                 L[i][j] = L[j][k] + 1                 llap = max(llap, L[i][j])                 i -= 1                 k += 1               while i >= 0:             L[i][j] = 2             i -= 1     return llap
def prefixSum2D(a):     R = len(a)     C = len(a[0])     psa = [[0 for j in range(C)] for i in range(R)]     psa[0][0] = a[0][0]     for i in range(1, C):         psa[0][i] = psa[0][i - 1] + a[0][i]     for i in range(1, R):         psa[i][0] = psa[i - 1][0] + a[i][0]     for i in range(1, R):         for j in range(1, C):             psa[i][j] = psa[i - 1][j] + psa[i][j - 1] - psa[i - 1][j - 1] + a[i][j]     for i in range(R):         for j in range(C):             print(psa[i][j], end=" ")         print()
def round(n):     a = (n // 10) * 10     b = a + 10     return b if n - a > b - n else a
def getMinSquares(n):     if n <= 3:         return n     dp = [0] * (n + 1)     dp[0] = 0     dp[1] = 1     dp[2] = 2     dp[3] = 3     for i in range(4, n + 1):         dp[i] = i         for x in range(1, int(i ** 0.5) + 1):             temp = x * x             if temp > i:                 break             else:                 dp[i] = min(dp[i], 1 + dp[i - temp])     res = dp[n]     return res
def noAdjacentDup(s1):     n = len(s1)     s = list(s1)     for i in range(1, n):         if s[i] == s[i - 1]:             s[i] = 'a'             while s[i] == s[i - 1] or (i + 1 < n and s[i] == s[i + 1]):                 s[i] = chr(ord(s[i]) + 1)                 i += 1     return ''.join(s)
def printDistinct(arr, n):     for i in range(n):         j = 0         while j < i:             if arr[i] == arr[j]:                 break             j += 1         if i == j:             print(arr[i], end=" ")
def rectCount(n, m):     return (m * n * (n + 1) * (m + 1)) // 4
def greatest(s):     n = len(s)     a = [int(s[i]) for i in range(n)]     sum = 0     for i in range(n):         sum += a[i]        if a[n-1] % 2 != 0:         if a[n-2] % 2 != 0 or (sum - a[n-1]) % 3 != 0:             print("-1")         else:             print(n)     else:         re = sum % 3         del_idx = -1         flag = 0                  for i in range(n-1):             if a[i] % 3 == re:                 if a[i+1] > a[i]:                     del_idx = i                     flag = 1                     break                 else:                     del_idx = i              if flag == 0:             if a[n-2] % 2 == 0 and re == a[n-1] % 3:                 del_idx = n - 1         if del_idx == -1:             print("-1")         else:             print(del_idx + 1)
def maximumSum(arr, n, k):     for i in range(1, k+1):         min_val = float('inf')         index = -1         for j in range(n):             if arr[j] < min_val:                 min_val = arr[j]                 index = j         if min_val == 0:             break         arr[index] = -arr[index]        sum = 0     for i in range(n):         sum += arr[i]      return sum
def mirrorImage(a, b, c, x1, y1):     temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b)     x = temp * a + x1     y = temp * b + y1     return (x, y)
def firstFit(blockSize, m, processSize, n):     allocation = [-1] * n      for i in range(n):         for j in range(m):             if blockSize[j] >= processSize[i]:                 allocation[i] = j                 blockSize[j] -= processSize[i]                 break     print("\nProcess No.\tProcess Size\tBlock no.")     for i in range(n):         print(f" {i+1}\t\t{processSize[i]}\t\t", end="")         if allocation[i] != -1:             print(allocation[i]+1)         else:             print("Not Allocated")
def simplify(str):     len_str = len(str)     res = ['']*len_str     index = 0     i = 0     s = [0]     while i < len_str:         if str[i] == '+':             if s[-1] == 1:                 res[index] = '-'             elif s[-1] == 0:                 res[index] = '+'         elif str[i] == '-':             if s[-1] == 1:                 res[index] = '+'             elif s[-1] == 0:                 res[index] = '-'         elif str[i] == '(' and i > 0:             if str[i-1] == '-':                 x = 0 if s[-1] == 1 else 1                 s.append(x)             elif str[i-1] == '+':                 s.append(s[-1])         elif str[i] == ')':             s.pop()         else:             res[index] = str[i]         i += 1         index += 1     return ''.join(res)