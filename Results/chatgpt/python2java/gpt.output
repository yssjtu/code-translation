static void countSubsequence(String s, int n) {     int cntG = 0;     int cntF = 0;     int result = 0;     int C = 0;        for (int i = 0; i < n; i++) {         if (s.charAt(i) == 'G') {             cntG++;             result += C;             continue;         }         if (s.charAt(i) == 'F') {             cntF++;             C += cntG;             continue;         } else {             continue;         }     }     System.out.println(result); }
public static long minProduct(int[] arr, int n, int k) {     PriorityQueue<Integer> heap = new PriorityQueue<>();     for (int i = 0; i < n; i++) {         heap.offer(arr[i]);     }     long count = 0;     long ans = 1;     while (!heap.isEmpty() && count < k) {         int x = heap.poll();         ans = ans * x;         count++;     }     return ans; }
static int countStrings(int n) {     int[] a = new int[n];     int[] b = new int[n];     a[0] = b[0] = 1;     for (int i = 1; i < n; i++) {         a[i] = a[i - 1] + b[i - 1];         b[i] = a[i - 1];     }     return a[n - 1] + b[n - 1]; }
void findElements(int[] arr, int n) {     int first = Integer.MIN_VALUE;     int second = Integer.MIN_VALUE;     for (int i = 0; i < n; i++) {         if (arr[i] > first) {             second = first;             first = arr[i];         } else if (arr[i] > second) {             second = arr[i];         }     }     for (int i = 0; i < n; i++) {         if (arr[i] < second) {             System.out.print(arr[i] + " ");         }     } }
static int minJumps(int[] arr, int l, int h) {     if (h == l) {         return 0;     }     if (arr[l] == 0) {         return Integer.MAX_VALUE;     }     int min = Integer.MAX_VALUE;     for (int i = l + 1; i <= h && i <= l + arr[l]; i++) {         int jumps = minJumps(arr, i, h);         if (jumps != Integer.MAX_VALUE && jumps + 1 < min) {             min = jumps + 1;         }     }     return min; }
static void printInSortedOrder(int[] arr, int n) {     int[] index = new int[n];     for (int i = 0; i < n; i++) {         index[i] = i;     }     for (int i = 0; i < n - 1; i++) {         int min = i;         for (int j = i + 1; j < n; j++) {             if (arr[index[min]] > arr[index[j]]) {                 min = j;             }         }         if (min != i) {             int temp = index[min];             index[min] = index[i];             index[i] = temp;         }     }     for (int i = 0; i < n; i++) {         System.out.print(arr[index[i]] + " ");     } }
static int minDiff(int[] arr, int n, int k) {     int result = Integer.MAX_VALUE;     Arrays.sort(arr);     for (int i = 0; i <= n - k; i++) {         result = Math.min(result, arr[i + k - 1] - arr[i]);     }     return result; }
static double arcLength(double diameter, double angle) {     if (angle >= 360) {         System.out.println("Angle cannot be formed");         return 0;     } else {         double arc = (3.142857142857143 * diameter) * (angle / 360.0);         return arc;     } }
static int factorial(int n) {     if (n == 1 || n == 0) {         return 1;     } else {         return n * factorial(n - 1);     } }
static int minDifferenceAmongMaxMin(int[] arr, int N, int K) {     Arrays.sort(arr);     int res = Integer.MAX_VALUE;     for (int i = 0; i <= N - K; i++) {         int curSeqDiff = arr[i + K - 1] - arr[i];         res = Math.min(res, curSeqDiff);     }     return res; }
static int floorSqrt(int x) {     if (x == 0 || x == 1)         return x;     int i = 1, result = 1;     while (result <= x) {         i++;         result = i * i;     }     return i - 1; }
static int countDivisbleby4(String s) {     int n = s.length();     int count = 0;     for (int i = 0; i < n; i++) {         char ch = s.charAt(i);         if (ch == '4' || ch == '8' || ch == '0') {             count++;         }     }     for (int i = 0; i < n - 1; i++) {         int h = (s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0');         if (h % 4 == 0) {             count = count + i + 1;         }     }     return count; }
static int countPairs(int[] arr, int n) {     int ans = 0;     for (int i = 0; i < n; i++) {         for (int j = i + 1; j < n; j++) {             if (arr[i] == arr[j]) {                 ans++;             }         }     }     return ans; }
static boolean isDivisibleBy7(int num) {     if (num < 0) {         return isDivisibleBy7(-num);     }     if (num == 0 || num == 7) {         return true;     }     if (num < 10) {         return false;     }     return isDivisibleBy7(num / 10 - 2 * (num - num / 10 * 10)); }
static int minDaysToEmpty(int C, int l) {     if (l >= C) {         return C;     }     double eq_root = (Math.sqrt(1 + 8 * (C - l)) - 1) / 2;     return (int)Math.ceil(eq_root) + l; }
static int cutRod(int price[], int n) {     int[] val = new int[n+1];     val[0] = 0;     for (int i = 1; i <= n; i++) {         int max_val = Integer.MIN_VALUE;         for (int j = 0; j < i; j++) {             max_val = Math.max(max_val, price[j] + val[i - j - 1]);         }         val[i] = max_val;     }     return val[n]; }
static int getTotalNumberOfSequences(int m, int n) {     if (m < n)         return 0;     if (n == 0)         return 1;     int res = getTotalNumberOfSequences(m - 1, n) + getTotalNumberOfSequences(m / 2, n - 1);     return res; }
static int maxSum(int arr[], int n) {     int cum_sum = 0;     for (int i = 0; i < n; i++) {         cum_sum += arr[i];     }         int curr_val = 0;     for (int i = 0; i < n; i++) {         curr_val += i * arr[i];     }        int res = curr_val;     for (int i = 1; i < n; i++) {         int next_val = curr_val - (cum_sum - arr[i-1]) + arr[i-1] * (n-1);         curr_val = next_val;         res = Math.max(res, next_val);     }        return res; }
public static char first(String str, int i) {     if (str.charAt(i) == '\0') {         return 0;     }     if (Character.isUpperCase(str.charAt(i))) {         return str.charAt(i);     }     return first(str, i + 1); }
static void findSmallest(int m, int s) {     if (s == 0) {         if (m == 1) {             System.out.println("Smallest number is 0");         } else {             System.out.println("Not possible");         }         return;     }     if (s > 9 * m) {         System.out.println("Not possible");         return;     }     int[] res = new int[m + 1];     s -= 1;     for (int i = m - 1; i > 0; i--) {         if (s > 9) {             res[i] = 9;             s -= 9;         } else {             res[i] = s;             s = 0;         }     }     res[0] = s + 1;     System.out.print("Smallest number is ");     for (int i = 0; i < m; i++) {         System.out.print(res[i]);     } }
static boolean areEqual(int[] arr1, int[] arr2, int n, int m) {     if (n != m) {         return false;     }     Arrays.sort(arr1);     Arrays.sort(arr2);     for (int i = 0; i < n; i++) {         if (arr1[i] != arr2[i]) {             return false;         }     }     return true; }
static int countNums(int n, int x, int y) {     boolean[] arr = new boolean[n + 2];     if (x <= n) {         arr[x] = true;     }     if (y <= n) {         arr[y] = true;     }     int result = 0;     for (int i = Math.min(x, y); i <= n; i++) {         if (arr[i]) {             if (i + x <= n) {                 arr[i + x] = true;             }             if (i + y <= n) {                 arr[i + y] = true;             }             result++;         }     }     return result; }
static void bonacciseries(int n, int m) {     int[] a = new int[m];     a[n - 1] = 1;     a[n] = 1;     for (int i = n + 1; i < m; i++) {         a[i] = 2 * a[i - 1] - a[i - n - 1];     }     for (int i = 0; i < m; i++) {         System.out.print(a[i] + " ");     } }
static boolean isSubSequence(String string1, String string2, int m, int n) {     if (m == 0)         return true;     if (n == 0)         return false;     if (string1.charAt(m - 1) == string2.charAt(n - 1))         return isSubSequence(string1, string2, m - 1, n - 1);     return isSubSequence(string1, string2, m, n - 1); }
public static int findNth(int n) {     int count = 0;     for (int curr = 1;; curr++) {         int sum = 0;         int x = curr;         while (x > 0) {             sum += x % 10;             x /= 10;         }         if (sum == 10) {             count++;         }         if (count == n) {             return curr;         }     } }
public static int rangeGCD(int n, int m) {     return (n == m) ? n : 1; }
static int lbs(int[] arr) {     int n = arr.length;     int[] lis = new int[n+1];     Arrays.fill(lis, 1);     for (int i = 1; i < n; i++) {         for (int j = 0; j < i; j++) {             if (arr[i] > arr[j] && lis[i] < lis[j] + 1) {                 lis[i] = lis[j] + 1;             }         }     }     int[] lds = new int[n+1];     Arrays.fill(lds, 1);     for (int i = n-2; i >= 0; i--) {         for (int j = n-1; j > i; j--) {             if (arr[i] > arr[j] && lds[i] < lds[j] + 1) {                 lds[i] = lds[j] + 1;             }         }     }     int maximum = lis[0] + lds[0] - 1;     for (int i = 1; i < n; i++) {         maximum = Math.max(lis[i] + lds[i] - 1, maximum);     }     return maximum; }
static int answerQuery(int[] a, int n, int l, int r) {     int count = 0;     l = l - 1;     for (int i = l; i < r; i++) {         int element = a[i];         int divisors = 0;         for (int j = l; j < r; j++) {             if (a[j] % a[i] == 0) {                 divisors += 1;             } else {                 break;             }         }         if (divisors == (r - l)) {             count += 1;         }     }     return count; }
static String printShortestSuperSeq(String x, String y) {     int m = x.length();     int n = y.length();     int[][] dp = new int[m + 1][n + 1];     for (int i = 0; i <= m; i++) {         for (int j = 0; j <= n; j++) {             if (i == 0) {                 dp[i][j] = j;             } else if (j == 0) {                 dp[i][j] = i;             } else if (x.charAt(i - 1) == y.charAt(j - 1)) {                 dp[i][j] = 1 + dp[i - 1][j - 1];             } else {                 dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);             }         }     }     int index = dp[m][n];     StringBuilder sb = new StringBuilder();     int i = m, j = n;     while (i > 0 && j > 0) {         if (x.charAt(i - 1) == y.charAt(j - 1)) {             sb.append(x.charAt(i - 1));             i--;             j--;             index--;         } else if (dp[i - 1][j] > dp[i][j - 1]) {             sb.append(y.charAt(j - 1));             j--;             index--;         } else {             sb.append(x.charAt(i - 1));             i--;             index--;         }     }     while (i > 0) {         sb.append(x.charAt(i - 1));         i--;         index--;     }     while (j > 0) {         sb.append(y.charAt(j - 1));         j--;         index--;     }     sb.reverse();     return sb.toString(); }
static int findSum(String str) {     String temp = "";     int sum = 0;     for (char ch : str.toCharArray()) {         if (Character.isDigit(ch)) {             temp += ch;         } else {             sum += Integer.parseInt(temp);             temp = "0";         }     }     return sum + Integer.parseInt(temp); }
static int countRotationsDivBy8(String n) {     int l = n.length();     int count = 0;     if (l == 1) {         int oneDigit = Integer.parseInt(n);         if (oneDigit % 8 == 0) {             return 1;         }         return 0;     }     if (l == 2) {         int first = Integer.parseInt(n);         int second = Integer.parseInt(new StringBuilder(n).reverse().toString());         if (first % 8 == 0) {             count += 1;         }         if (second % 8 == 0) {             count += 1;         }         return count;     }     int threeDigit = 0;     for (int i = 0; i < l - 2; i++) {         threeDigit = Integer.parseInt(n.substring(i, i + 3));         if (threeDigit % 8 == 0) {             count += 1;         }     }     threeDigit = Integer.parseInt(n.substring(l - 1) + n.substring(0, 2));     if (threeDigit % 8 == 0) {         count += 1;     }     threeDigit = Integer.parseInt(n.substring(l - 2) + n.substring(l - 1) + n.substring(0, 1));     if (threeDigit % 8 == 0) {         count += 1;     }     return count; }
static boolean check(String s) {     if (s.length() >= 10) {         return true;     }     for (int i = 1; i < s.length(); i++) {         for (int j = i + 1; j < s.length(); j++) {             for (int k = j + 1; k < s.length(); k++) {                 String s1 = s.substring(0, i);                 String s2 = s.substring(i, j);                 String s3 = s.substring(j, k);                 String s4 = s.substring(k, s.length());                 if (!s1.equals(s2) && !s1.equals(s3) && !s1.equals(s4) && !s2.equals(s3) && !s2.equals(s4) && !s3.equals(s4)) {                     return true;                 }             }         }     }     return false; }
public static int eggDrop(int n, int k) {     if (k == 1 || k == 0) {         return k;     }     if (n == 1) {         return k;     }     int min = Integer.MAX_VALUE;     for (int x = 1; x <= k; x++) {         int res = Math.max(eggDrop(n - 1, x - 1), eggDrop(n, k - x));         if (res < min) {             min = res;         }     }     return min + 1; }
static void decToBinary(int n) {     int[] binaryNum = new int[n];     int i = 0;     while (n > 0) {         binaryNum[i] = n % 2;         n /= 2;         i++;     }     for (int j = i - 1; j >= 0; j--) {         System.out.print(binaryNum[j]);     } }
static boolean isSubsetSum(int[] set, int n, int sum) {     boolean[][] subset = new boolean[n + 1][sum + 1];     for (int i = 0; i <= n; i++) {         subset[i][0] = true;     }     for (int i = 1; i <= sum; i++) {         subset[0][i] = false;     }     for (int i = 1; i <= n; i++) {         for (int j = 1; j <= sum; j++) {             if (j < set[i - 1]) {                 subset[i][j] = subset[i - 1][j];             }             if (j >= set[i - 1]) {                 subset[i][j] = subset[i - 1][j] || subset[i - 1][j - set[i - 1]];             }         }     }     return subset[n][sum]; }
public static boolean checkStar(int[][] mat) {     int size = mat.length;     int vertexD1 = 0;     int vertexDn_1 = 0;     if (size == 1) {         return (mat[0][0] == 0);     }     if (size == 2) {         return (mat[0][0] == 0 && mat[0][1] == 1 && mat[1][0] == 1 && mat[1][1] == 0);     }     for (int i = 0; i < size; i++) {         int degreeI = 0;         for (int j = 0; j < size; j++) {             if (mat[i][j] == 1) {                 degreeI++;             }         }         if (degreeI == 1) {             vertexD1++;         } else if (degreeI == size - 1) {             vertexDn_1++;         }     }     return (vertexD1 == (size - 1) && vertexDn_1 == 1); }
static void sortUsingHash(int[] a, int n) {     int max = Arrays.stream(a).max().getAsInt();     int[] hash = new int[max + 1];     for (int i = 0; i < n; i++) {         hash[a[i]]++;     }     for (int i = 0; i <= max; i++) {         if (hash[i] != 0) {             for (int j = 0; j < hash[i]; j++) {                 System.out.print(i + " ");             }         }     } }
static void findArea(double a, double b, double c) {     if (a < 0 || b < 0 || c < 0 || (a + b <= c) || (a + c <= b) || (b + c <= a)) {         System.out.println("Not a valid triangle");         return;     }     double s = (a + b + c) / 2;     double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));     System.out.printf("Area of a triangle is %f\n", area); }
static int maxDistance(int[] arr, int n) {     HashMap<Integer, Integer> mp = new HashMap<Integer, Integer>();     int maxDict = 0;     for (int i = 0; i < n; i++) {         if (!mp.containsKey(arr[i])) {             mp.put(arr[i], i);         } else {             maxDict = Math.max(maxDict, i - mp.get(arr[i]));         }     }     return maxDict; }
static int minCost(int[][] cost) {     int N = cost.length;     int[] dist = new int[N];     for (int i = 0; i < N; i++) {         dist[i] = Integer.MAX_VALUE;     }     dist[0] = 0;     for (int i = 0; i < N; i++) {         for (int j = i + 1; j < N; j++) {             if (dist[j] > dist[i] + cost[i][j]) {                 dist[j] = dist[i] + cost[i][j];             }         }     }     return dist[N - 1]; }
static int countSub(int[] arr, int n) {     int[] count = new int[10];     for (int i = 0; i < n; i++) {         for (int j = arr[i] - 1; j >= 0; j--) {             count[arr[i]] += count[j];         }         count[arr[i]]++;     }     int result = 0;     for (int i = 0; i < 10; i++) {         result += count[i];     }     return result; }
static void printPascal(int n) {     for (int line = 1; line <= n; line++) {         int C = 1;         for (int i = 1; i <= line; i++) {             System.out.print(C + " ");             C = (int) (C * (line - i) / i);         }         System.out.println();     } }
static int sequence ( int n ) {     if (n == 1 || n == 2)         return 1;     else         return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1)); }
static void checkCollision(double a, double b, double c, double x, double y, double radius) {     double dist = (Math.abs(a * x + b * y + c)) / Math.sqrt(a * a + b * b);     if (radius == dist) {         System.out.println("Touch");     } else if (radius > dist) {         System.out.println("Intersect");     } else {         System.out.println("Outside");     } }
static int numofAP ( int a[], int n ) {     int minarr = Integer.MAX_VALUE;     int maxarr = Integer.MIN_VALUE;     for ( int i = 0; i < n; i++ ) {         minarr = Math.min(minarr, a[i]);         maxarr = Math.max(maxarr, a[i]);     }     int[] dp = new int[n+1];     int ans = n+1;     int MAX = 1000000;     for ( int d = (minarr - maxarr); d <= (maxarr - minarr); d++ ) {         int[] sum = new int[MAX+1];         for ( int i = 0; i < n; i++ ) {             dp[i] = 1;             if (a[i] - d >= 1 && a[i] - d <= MAX) {                 dp[i] += sum[a[i]-d];             }             ans += dp[i] - 1;             sum[a[i]] += dp[i];         }     }     return ans; }
static int MinOperation(int[] a, int[] b, int n) {     Arrays.sort(a);     Arrays.sort(b);     int result = 0;     for (int i = 0; i < n; i++) {         if (a[i] > b[i]) {             result += Math.abs(a[i] - b[i]);         } else if (a[i] < b[i]) {             result += Math.abs(a[i] - b[i]);         }     }     return result; }
static int sumOfSeries(int n) {     return (int) (0.6172 * (Math.pow(10, n) - 1) - 0.55 * n); }
static void recursiveReverse(char[] str, int i) {     int n = str.length;     if (i == n / 2) {         return;     }     char temp = str[i];     str[i] = str[n - i - 1];     str[n - i - 1] = temp;     recursiveReverse(str, i + 1); }
static int countOccurrences(int[] arr, int n, int x) {     int res = 0;     for (int i = 0; i < n; i++) {         if (x == arr[i]) {             res += 1;         }     }     return res; }
static int kthNonRepeating(String str, int k) {     int n = str.length();     int[] count = new int[MAX_CHAR];     int[] index = new int[MAX_CHAR];     Arrays.fill(count, 0);     Arrays.fill(index, n);     for (int i = 0; i < n; i++) {         char x = str.charAt(i);         count[x]++;         if (count[x] == 1) {             index[x] = i;         }         if (count[x] == 2) {             in             dex[x] = n;         }     }     Arrays.sort(index);     return (index[k - 1] != n) ? index[k - 1] : -1; }
static boolean check(int[] degree, int n) {     int deg_sum = 0;     for (int i = 0; i < degree.length; i++) {         deg_sum += degree[i];     }     if (2 * (n - 1) == deg_sum) {         return true;     } else {         return false;     } }
static boolean isPowerOfTwo(int x) {     return (x != 0) && ((x & (x - 1)) == 0); }
static int superSeq(String X, String Y, int m, int n) {     if (m == 0) return n;     if (n == 0) return m;     if (X.charAt(m - 1) == Y.charAt(n - 1)) {         return 1 + superSeq(X, Y, m - 1, n - 1);     }     return 1 + Math.min(superSeq(X, Y, m - 1, n), superSeq(X, Y, m, n - 1)); }
public static int lis(int[] arr) {     int n = arr.length;     int[] dp = new int[n];     Arrays.fill(dp, 1);     int max = 1;     for (int i = 1; i < n; i++) {         for (int j = 0; j < i; j++) {             if (arr[i] > arr[j]) {                 dp[i] = Math.max(dp[i], dp[j] + 1);             }         }         max = Math.max(max, dp[i]);     }     return max; }
static boolean findTriplet(int[] a1, int[] a2, int[] a3, int n1, int n2, int n3, int sum) {     Set<Integer> s = new HashSet<>();     for (int i = 0; i < n1; i++) {         s.add(a1[i]);     }     for (int i = 0; i < n2; i++) {         for (int j = 0; j < n3; j++) {             if (s.contains(sum - a2[i] - a3[j])) {                 return true;             }         }     }     return false; }
static int maxLen(int[] arr, int n) {     HashMap<Integer, Integer> hashMap = new HashMap<>();     int curr_sum = 0;     int max_len = 0;     int ending_index = -1;     for (int i = 0; i < n; i++) {         if (arr[i] == 0) {             arr[i] = -1;         } else {             arr[i] = 1;         }     }     for (int i = 0; i < n; i++) {         curr_sum += arr[i];         if (curr_sum == 0) {             max_len = i + 1;             ending_index = i;         }         if (hashMap.containsKey(curr_sum + n)) {             max_len = Math.max(max_len, i - hashMap.get(curr_sum + n));         } else {             hashMap.put(curr_sum + n, i);         }     }     for (int i = 0; i < n; i++) {         if (arr[i] == -1) {             arr[i] = 0;         } else {             arr[i] = 1;         }     }     System.out.print(ending_index - max_len + 1);     System.out.print("to");     System.out.print(ending_index);     return max_len; }
public static int SumOfKsubArray(int[] arr, int n, int k) {     int Sum = 0;     Deque<Integer> S = new ArrayDeque<>();     Deque<Integer> G = new ArrayDeque<>();     for (int i = 0; i < k; i++) {         while (S.size() > 0 && arr[S.peekLast()] >= arr[i]) {             S.removeLast();         }         while (G.size() > 0 && arr[G.peekLast()] <= arr[i]) {             G.removeLast();         }         G.add(i);         S.add(i);     }     for (int i = k; i < n; i++) {         Sum += arr[S.peekFirst()] + arr[G.peekFirst()];         while (S.size() > 0 && S.peekFirst() <= i - k) {             S.removeFirst();         }         while (G.size() > 0 && G.peekFirst() <= i - k) {             G.removeFirst();         }         while (S.size() > 0 && arr[S.peekLast()] >= arr[i]) {             S.removeLast();         }         while (G.size() > 0 && arr[G.peekLast()] <= arr[i]) {             G.removeLast();         }         G.add(i);         S.add(i);         Sum += arr[S.peekFirst()] + arr[G.peekFirst()];     }     return Sum; }
static void sortString(String str) {     char[] chars = str.toCharArray();     Arrays.sort(chars);     String sortedStr = new String(chars);     System.out.println(sortedStr); }
static void reverseSpiralPrint(int m, int n, int[][] a) {     int[] b = new int[100];     int i = 0, k = 0, l = 0, z = 0;     int size = m * n;     while (k < m && l < n) {         int val = 0;         for (i = l; i < n; i++) {             val = a[k][i];             b[z] = val;             z++;         }         k++;         for (i = k; i < m; i++) {             val = a[i][n - 1];             b[z] = val;             z++;         }         n--;         if (k < m) {             for (i = n - 1; i >= l; i--) {                 val = a[m - 1][i];                 b[z] = val;                 z++;             }             m--;         }         if (l < n) {             for (i = m - 1; i >= k; i--) {                 val = a[i][l];                 b[z] = val;                 z++;             }             l++;         }     }     for (i = size - 1; i >= 0; i--) {         System.out.print(b[i] + " ");     } }
static int maxSumSubarrayRemovingOneEle(int[] arr, int n) {     int[] fw = new int[n];     int[] bw = new int[n];     int cur_max = arr[0], max_so_far = arr[0];     for (int i = 0; i < n; i++) {         cur_max = Math.max(arr[i], cur_max + arr[i]);         max_so_far = Math.max(max_so_far, cur_max);         fw[i] = cur_max;     }     cur_max = max_so_far = bw[n - 1] = arr[n - 1];     for (int i = n - 2; i >= 0; i--) {         cur_max = Math.max(arr[i], cur_max + arr[i]);         max_so_far = Math.max(max_so_far, cur_max);         bw[i] = cur_max;     }     int fans = max_so_far;     for (int i = 1; i < n - 1; i++) {         fans = Math.max(fans, fw[i - 1] + bw[i + 1]);     }     return fans; }
static int linearSearch(int[] arr, int n) {     for (int i = 0; i < n; i++) {         if (arr[i] == i) {             return i;         }     }     return -1; }
static int isSubset(int arr1[], int arr2[], int m, int n) {     int i, j;     for (i = 0; i < n; i++) {         for (j = 0; j < m; j++) {             if (arr2[i] == arr1[j]) {                 break;             }         }         if (j == m) {             return 0;         }     }     return 1; }
static int findSmallestDifference(int[] A, int[] B, int m, int n) {         Arrays.sort(A);         Arrays.sort(B);         int a = 0, b = 0, result = Integer.MAX_VALUE;         while (a < m && b < n) {             if (Math.abs(A[a] - B[b]) < result) {                 result = Math.abs(A[a] - B[b]);             }             if (A[a] < B[b]) {                 a++;             } else {                 b++;             }         }         return result;     }
static int equilibrium(int[] arr) {     int totalSum = 0;     for (int num : arr) {         totalSum += num;     }     int leftSum = 0;     for (int i = 0; i < arr.length; i++) {         totalSum -= arr[i];         if (leftSum == totalSum) {             return i;         }         leftSum += arr[i];     }     return -1; }
static void sequence(int n) {     List<Integer> f = new ArrayList<>(Arrays.asList(0, 1, 1));     System.out.print(f.get(1) + " ");     System.out.print(f.get(2) + " ");     for (int i = 3; i <= n; i++) {         f.add(f.get(f.get(i - 1)) + f.get(i - f.get(i - 1)));         System.out.print(f.get(i) + " ");     } }
public static int eggDrop(int n, int k) {     int[][] eggFloor = new int[n + 1][k + 1];     for (int i = 1; i <= n; i++) {         eggFloor[i][1] = 1;         eggFloor[i][0] = 0;     }     for (int j = 1; j <= k; j++) {         eggFloor[1][j] = j;     }     for (int i = 2; i <= n; i++) {         for (int j = 2; j <= k; j++) {             eggFloor[i][j] = Integer.MAX_VALUE;             for (int x = 1; x <= j; x++) {                 int res = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);                 if (res < eggFloor[i][j]) {                     eggFloor[i][j] = res;                 }             }         }     }     return eggFloor[n][k]; }
static int findgroups(int[] arr, int n) {     int[] c = new int[]{0, 0, 0};     int res = 0;     for (int i = 0; i < n; i++) {         c[arr[i] % 3]++;         res += ((c[0] * (c[0] - 1)) >> 1);         res += c[1] * c[2];         res += (c[0] * (c[0] - 1) * (c[0] - 2)) / 6;         res += (c[1] * (c[1] - 1) * (c[1] - 2)) / 6;         res += ((c[2] * (c[2] - 1) * (c[2] - 2)) / 6);         res += c[0] * c[1] * c[2];     }     return res; }
static int minRevolutions(double r, double x1, double y1, double x2, double y2) {     double d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));     return (int) Math.ceil(d / (2 * r)); }
static int findLargestd(int[] S, int n) {     boolean found = false;     Arrays.sort(S);     for (int i = n - 1; i >= 0; i--) {         for (int j = 0; j < n; j++) {             if (i == j)                 continue;             for (int k = j + 1; k < n; k++) {                 if (i == k)                     continue;                 for (int l = k + 1; l < n; l++) {                     if (i == l)                         continue;                     if (S[i] == S[j] + S[k] + S[l]) {                         found = true;                         return S[i];                     }                 }             }         }     }     if (found == false) {         return -1;     } }
static int findSum(int n) {     return n * (n + 1) * (n + 2) * (3 * n + 1) / 24; }
public static int subArraySum(int[] arr, int n, int sum) { int curr_sum = arr[0]; int start = 0; int i = 1; while (i <= n) { while (curr_sum > sum && start < i - 1) { curr_sum = curr_sum - arr[start]; start++; } if (curr_sum == sum) { System.out.println("Sum found between indexes " + start + " and " + (i - 1)); return 1; } if (i < n) { curr_sum = curr_sum + arr[i]; i++; } } System.out.println("No subarray found"); return 0; }
public static boolean isNumber(String s) { for (int i = 0; i < s.length(); i++) { if (!Character.isDigit(s.charAt(i))) { return false; } } return true; }
static int minStringValue(String str, int k) {         int l = str.length();         if (k >= l) {             return 0;         }         int[] frequency = new int[MAX_CHAR];         for (int i = 0; i < l; i++) {             frequency[str.charAt(i) - 'a']++;         }         PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());         for (int i = 0; i < MAX_CHAR; i++) {             q.add(-frequency[i]);         }  while (k > 0) {             int temp = q.remove();                         temp++;             q.add(temp);             k--;         }         int result = 0;         while (!q.isEmpty()) {             int temp = q.remove() * -1;             result += temp * temp;         }         return result;     }
public static int productSubSeqCount(int[] arr, int k) { int n = arr.length; int[][] dp = new int[k + 1][n + 1]; for (int i = 1; i <= k; i++) { for (int j = 1; j <= n; j++) { dp[i][j] = dp[i][j - 1]; if (arr[j - 1] <= i && arr[j - 1] > 0) { dp[i][j] += dp[i / arr[j - 1]][j - 1] + 1; } } } return dp[k][n]; }
public static boolean isDiagonalMatrix(int[][] mat) { int n = mat.length; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (i != j && mat[i][j] != 0) { return false; } } } return true; }
public static int nobleInteger(int[] arr) {     Arrays.sort(arr);     int n = arr.length;     for (int i = 0; i < n - 1; i++) {         if (arr[i] == arr[i + 1]) {             continue;         }         if (arr[i] == n - i - 1) {             return arr[i];         }             }     if (arr[n - 1] == 0) {         return arr[n - 1];     }     return -1; }
public static int findElement(int[] arr, int n, int key) {     for (int i = 0; i < n; i++) {         if (arr[i] == key) {             return i;         }     }     return -1; }
public static int lis(int[] arr, int n) {     int[] mpis = new int[n];     for (int i = 0; i < n; i++) {         mpis[i] = arr[i];     }     for (int i = 1; i < n; i++) {         for (int j = 0; j < i; j++) {             if (arr[i] > arr[j] && mpis[i] < mpis[j] * arr[i]) {                 mpis[i] = mpis[j] * arr[i];             }                     }     }     int max_mpis = mpis[0];     for (int i = 1; i < n; i++) {         if (mpis[i] > max_mpis) {             max_mpis = mpis[i];         }     }     return max_mpis; }
public static int sumEqualProduct(int[] a, int n) {     int zero = 0, two = 0;     for (int i = 0; i < n; i++) {         if (a[i] == 0) zero++;         if (a[i] == 2) two++;     }     int cnt = (zero * (zero - 1)) / 2 + (two * (two - 1)) / 2;     return cnt; }
public static int fact(int n) {     if (n == 0) {         return 1;     }     return n * fact(n-1); }
public static String decimalToBinary(double num, int k_prec) {     String binary = "";     int Integral = (int) num;     double fractional = num - Integral;     while (Integral > 0) {         int rem = Integral % 2;         binary += Integer.toString(rem);         Integral /= 2;     }     binary = new StringBuilder(binary).reverse().toString();     binary += '.';     while (k_prec > 0) {         fractional *= 2;         int fract_bit = (int) fractional;         if (fract_bit == 1) {             fractional -= fract_bit;             binary += '1';         } else {             binary += '0';         }         k_prec--;     }     return binary; }
public static int getLevenstein(String inpt) {     String revInput = new StringBuilder(inpt).reverse().toString();     int n = inpt.length();     int[][] dp = new int[n + 1][n + 1];     for (int i = 0; i <= n; i++) {         dp[0][i] = i;         dp[i][0] = i;     }     for (int i = 1; i <= n; i++) {         for (int j = 1; j <= n; j++) {             if (inpt.charAt(i - 1) == revInput.charAt(j - 1)) {                 dp[i][j] = dp[i - 1][j - 1];             } else {                 dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);             }         }     }     int res = Integer.MAX_VALUE;     int i = n;     int j = 0;     while (i >= 0) {         res = Math.min(res, dp[i][j]);         if (i < n) {             res = Math.min(res, dp[i + 1][j]);         }         if (i > 0) {             res = Math.min(res, dp[i - 1][j]);         }         i--;         j++;     }     return res; }
public static int factorial(int n) {     if (n == 1 || n == 0) {         return 1;     } else {         return n * factorial(n - 1);     } }
public static void bresenham(int x1, int y1, int x2, int y2) {     int m_new = 2 * (y2 - y1);     int slope_error_new = m_new - (x2 - x1);     int y = y1;     for (int x = x1; x <= x2; x++) {         System.out.print("(" + x + "," + y + ")\n");         slope_error_new += m_new;         if (slope_error_new >= 0) {             y++;             slope_error_new -= 2 * (x2 - x1);         }     } }
public static void printUnsorted(int[] arr, int n) {     int e = n - 1;     int s;     for (s = 0; s < n - 1; s++) {         if (arr[s] > arr[s + 1]) {             break;         }     }     if (s == n - 1) {         System.out.println("The complete array is sorted");         return;     }     while (e > 0) {         if (arr[e] < arr[e - 1]) {             break;         }         e--;     }     int max = arr[s];     int min = arr[s];     for (int i = s + 1; i <= e; i++) {         if (arr[i] > max) {             max = arr[i];         }         if (arr[i] < min) {             min = arr[i];         }     }     for (s = 0; s < n; s++) {         if (arr[s] > min) {             break;         }     }     for (e = n - 1; e >= 0; e--) {         if (arr[e] < max) {             break;         }     }     System.out.println("The unsorted subarray which makes the given array sorted lies between the indexes " + s + " and " + e); }
static void find_max(int[] A, int N, int K) {         Map<Integer, Integer> Count = new HashMap<Integer, Integer>();         for (int i = 0; i < K - 1; i++) {             Count.put(A[i], Count.getOrDefault(A[i], 0) + 1);         }         Map<Integer, Integer> Myset = new HashMap<Integer, Integer>();         for (int x : Count.keySet()) {             if (Count.get(x) == 1) {                 Myset.put(x, 1);             }         }         for (int i = K - 1; i < N; i++) {             Count.put(A[i], Count.getOrDefault(A[i], 0) + 1);             if (Count.get(A[i]) == 1) {                 Myset.put(A[i], 1);             } else {                 Myset.remove(A[i]);             }                          if (Myset.size() == 0) {                 System.out.println("Nothing");             } else {                 int maxm = -1000000000;                 for (int x : Myset.keySet()) {                     maxm = Math.max(x, maxm);                 }                 System.out.println(maxm);             }             int x = A[i - K + 1];             if (Count.containsKey(x)) {                 Count.put(x, Count.get(x) - 1);                 if (Count.get(x) == 1) {                     Myset.put(x, 1);                 }                 if (Count.get(x) == 0) {                     Myset.remove(x);                 }             }         }     }
public static void segregateElements(int[] arr, int n) {     int[] temp = new int[n];     int j = 0;     for (int i = 0; i < n; i++) {         if (arr[i] >= 0) {             temp[j] = arr[i];             j++;         }         if (j == n || j == 0) {             return;         }     }     for (int i = 0; i < n; i++) {         if (arr[i] < 0) {             temp[j] = arr[i];             j++;         }     }     for (int k = 0; k < n; k++) {         arr[k] = temp[k];     } }
public class KMaxCombinations {     public static void findKMaxCombinations(int[] A, int[] B, int N, int K) {         PriorityQueue<Integer> pq = new PriorityQueue<>();         for (int i = 0; i < N; i++) {             for (int j = 0; j < N; j++) {                 int a = A[i] + B[j];                 pq.add(-a);             }         }         int count = 0;         while (count < K && !pq.isEmpty()) {             System.out.println(-pq.poll());             count++;         }     } }
public static int lengthOfLongestAP(int[] set, int n) {     if (n <= 2) {         return n;     }     int[][] L = new int[n][n];     int llap = 2;     for (int i = 0; i < n; i++) {         L[i][n-1] = 2;     }     for (int j = n-2; j > 0; j--) {         int i = j - 1;         int k = j + 1;         while (i >= 0 && k <= n - 1) {             if (set[i] + set[k] < 2 * set[j]) {                 k++;             } else if (set[i] + set[k] > 2 * set[j]) {                 L[i][j] = 2;                 i--;             } else {                 L[i][j] = L[j][k] + 1;                 llap = Math.max(llap, L[i][j]);                 i--;                 k++;             }         }         while (i >= 0) {             L[i][j] = 2;             i--;         }     }     return llap; }
public static void prefixSum2D(int[][] a) { int C = a[0].length; int R = a.length; int[][] psa = new int[R][C]; psa[0][0] = a[0][0]; for (int i = 1; i < C; i++) { psa[0][i] = psa[0][i - 1] + a[0][i]; } for (int i = 1; i < R; i++) { psa[i][0] = psa[i - 1][0] + a[i][0]; } for (int i = 1; i < R; i++) { for (int j = 1; j < C; j++) { psa[i][j] = psa[i - 1][j] + psa[i][j - 1] - psa[i - 1][j - 1] + a[i][j]; } } for (int i = 0; i < R; i++) { for (int j = 0; j < C; j++) { System.out.print(psa[i][j] + " "); } System.out.println(); } }
public static int round(int n) {     int a = (n / 10) * 10;     int b = a + 10;     return (n - a > b - n) ? b : a; }
public static int getMinSquares(int n) {     int[] dp = new int[n + 1];     dp[0] = 0;     dp[1] = 1;     dp[2] = 2;     dp[3] = 3;     for (int i = 4; i <= n; i++) {         dp[i] = i;         for (int x = 1; x <= Math.ceil(Math.sqrt(i)); x++) {             int temp = x * x;             if (temp > i) {                 break;             } else {                 dp[i] = Math.min(dp[i], 1 + dp[i - temp]);             }         }     }     return dp[n]; }
public static String noAdjacentDup(String s) {     int n = s.length();     char[] arr = s.toCharArray();     for (int i = 1; i < n; i++) {         if (arr[i] == arr[i - 1]) {             arr[i] = 'a';         }              while (arr[i] == arr[i - 1] || (i + 1 < n && arr[i] == arr[i + 1])) {             arr[i]++;             i++;         }     }     return new String(arr); }
public static void printDistinct(int[] arr, int n) {     for (int i = 0; i < n; i++) {         boolean distinct = true;         for (int j = 0; j < i; j++) {             if (arr[i] == arr[j]) {                 distinct = false;                 break;             }         }         if (distinct) {             System.out.println(arr[i]);         }     } }
public static int rectCount(int n, int m) {     return (m * n * (n + 1) * (m + 1)) / 4; }
public static void greatest(String s) {     int n = s.length();     int[] a = new int[n];     int Sum = 0;     for (int i = 0; i < n; i++) {         a[i] = s.charAt(i) - '0';         Sum += a[i];     }     if (a[n - 1] % 2 != 0) {         if (a[n - 2] % 2 != 0 || (Sum - a[n - 1]) % 3 != 0) {             System.out.println("-1");         } else {             System.out.println(n);         }     } else {         int re = Sum % 3;         int dell = -1;         boolean flag = false;         for (int i = n - 2; i >= 0; i--) {             if (a[i] % 3 == re) {                 if (a[i + 1] > a[i]) {                     dell = i;                     flag = true;                     break;                 } else {                     dell = i;                 }             }         }         if (!flag) {             if (a[n - 2] % 2 == 0 && re == a[n - 1] % 3) {                 dell = n - 1;             }         }         if (dell == -1) {             System.out.println("-1");         } else {             System.out.println(dell + 1);         }     } }
public static int maximumSum(int[] arr, int n, int k) {     for (int i = 1; i <= k; i++) {         int min = Integer.MAX_VALUE;         int index = -1;         for (int j = 0; j < n; j++) {             if (arr[j] < min) {                 min = arr[j];                 index = j;             }             if (min == 0) {                 break;             }         }         arr[index] = -arr[index];     }     int sum = 0;     for (int i = 0; i < n; i++) {         sum += arr[i];     }     return sum; }
public static double[] mirrorImage(double a, double b, double c, double x1, double y1) {     double temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b);     double x = temp * a + x1;     double y = temp * b + y1;     double[] result = new double[2];     result[0] = x;     result[1] = y;     return result; }
public static void firstFit(int[] blockSize, int m, int[] processSize, int n) {     int[] allocation = new int[n];     Arrays.fill(allocation, -1);     for (int i = 0; i < n; i++) {         for (int j = 0; j < m; j++) {             if (blockSize[j] >= processSize[i]) {                 allocation[i] = j;                 blockSize[j] -= processSize[i];                 break;             }         }     }     System.out.println("ProcessNo.ProcessSizeBlockno.");     for (int i = 0; i < n; i++) {         System.out.print(" " + (i + 1) + " " + processSize[i] + " ");         if (allocation[i] != -1) {             System.out.println(allocation[i] + 1);         } else {             System.out.println("NotAllocated");         }     } }
public static char[] simplify(String str) {     int len = str.length();     char[] res = new char[len];     int index = 0;     Stack<Integer> s = new Stack<>();     s.push(0);     for (int i = 0; i < len; i++) {         char ch = str.charAt(i);         if (ch == '+') {             if (s.peek() == 1) {                 res[index++] = '-';             } else if (s.peek() == 0) {                 res[index++] = '+';             }         } else if (ch == '-') {             if (s.peek() == 1) {                 res[index++] = '+';             } else if (s.peek() == 0) {                 res[index++] = '-';             }         } else if (ch == '(' && i > 0) {             if (str.charAt(i - 1) == '-') {                 int x = (s.peek() == 1) ? 0 : 1;                 s.push(x);             } else if (str.charAt(i - 1) == '+') {                 s.push(s.peek());             }         } else if (ch == ')') {             s.pop();         } else {             res[index++] = ch;         }     }     char[] simplified = new char[index];     for (int i = 0; i < index; i++) {         simplified[i] = res[i];     }     return simplified; }