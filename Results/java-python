CodeT5_bleu,
CodeT5_codebleu,
FSCT_bleu,
FSCT_codebleu 
src,
gold, 
CodeT5_translation 
FSCT_translation
total num: 1402
0.0
2.97
42.07
39.71
static int lenOfLongestGP ( int set [ ] , int n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) ; } Arrays . sort ( set ) ; int L [ ] [ ] = new int [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) { llgp = L [ i ] [ j ] ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } } return llgp ; }

def lenOfLongestGP ( sett , n ) : if n < 2 : return n if n == 2 : return ( sett [ 1 ] % sett [ 0 ] == 0 ) sett . sort ( ) L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] llgp = 1 for i in range ( 0 , n ) : if sett [ n - 1 ] % sett [ i ] == 0 : L [ i ] [ n - 1 ] = 2 else : L [ i ] [ n - 1 ] = 1 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while i >= 0 and k <= n - 1 : if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : k += 1 elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 if L [ i ] [ j ] > llgp : llgp = L [ i ] [ j ] i -= 1 k + 1 while i >= 0 : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 return llgp

def lenOfLongestGP ( set , n ) : if ( n == 1 ) : return lenOfLongestGP ( set , n ) else : return lenOfLongestGP ( set , n )

def lenOfLongestGP ( set , n ) : llgp = 1 for i in range ( n ) : if ( set [ n - 1 ] % set [ i ] == 0 ) : L [ i ] [ n - 1 ] = 2 else : L [ i ] [ n - 1 ] = 1 -- i i = j - 1 k = j + 1 while i >= 0 and k <= n - 1 : if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) : ++ k ; else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) : if ( set [ j ] % set [ i ] == 0 ) : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 -- i i = j - 1 while i >= 0 and k <= n - 1 : if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) : if ( set [ j ] * set [ k ] > set [ j ] * set [ j ] ) : if ( set [ j ] % set [ i ] == 0 ) : L [

0.12
10.94
0.12
10.94
static int sparseSearch ( String arr [ ] , String x , int n ) { return binarySearch ( arr , 0 , n - 1 , x ) ; }

def sparseSearch ( arr , key , low , high ) : left = 0 right = 0 while low <= high : mid = ( low + high ) // 2 if arr [ mid ] == '' : left = mid - 1 right = mid + 1 if left < low and right > high : return - 1 elif right <= high and arr [ right ] != '' : mid = right elif left >= low and arr [ left ] != '' : mid = left if arr [ mid ] == key : print ( 'Foundstring{}atindex{}' . format ( arr [ mid ] , mid ) ) return elif arr [ mid ] > key : high = mid - 1 elif arr [ mid ] < key : low = mid + 1 left -= 1 right += 1 return - 1

def sparseSearch ( arr , x , n ) : return binarySearch ( arr , 0 , n - 1 , x )

def sparseSearch ( arr , x , n ) : return binarySearch ( arr , 0 , n - 1 , x )

0.18
3.38
1.65
11.22
public static String sortString ( String inputString ) { char tempArray [ ] = inputString . toCharArray ( ) ; Arrays . sort ( tempArray ) ; return new String ( tempArray ) ; }

def sortString ( str ) : charCount = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( 0 , len ( str ) , 1 ) : charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( 0 , MAX_CHAR , 1 ) : for j in range ( 0 , charCount [ i ] , 1 ) : print ( chr ( ord ( 'a' ) + i ) , end = "" )

def sortString ( inputString ) : tempArray = [ inputString ] return tempArray [ 0 ]

def sortString ( inputString ) : tempArray = [ inputString . split ( ) for input in inputString ] list ( sort ( tempArray ) ) return list ( tempArray )

0.5
13.24
25.13
34.0
static int findMaxPoints ( int A [ ] [ ] ) { int [ ] [ ] P1S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P1E = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2E = new int [ M + 2 ] [ N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }

def findMaxPoints ( A ) : P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] for i in range ( 1 , N + 1 ) : for j in range ( 1 , M + 1 ) : P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( N , 0 , - 1 ) : for j in range ( M , 0 , - 1 ) : P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( N , 0 , - 1 ) : for j in range ( 1 , M + 1 ) : P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( 1 , N + 1 ) : for j in range ( M , 0 , - 1 ) : P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ans = 0 for i in range ( 2 , N ) : for j in range ( 2 , M ) : op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + \ P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + \ P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ans = max ( ans , max ( op1 , op2 ) ) return ans

def findMaxPoints ( A , M , N , 2 ) : P1S = [ 1 ] [ N + 2 ] P1E = [ 1 ] [ N + 2 ] P2S = [ 1 ] [ N + 2 ] P2E = [ 1 ] [ N + 2 ] for i in range ( 1 , N , M ) : for j in range ( 1 , M ) : P2S [ i ] [ j ] = max ( P2

def findMaxPoints ( A , P1S , P1E , P2S , P2E ) : for i in range ( 1 , N , 2 ) : P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( 1 , N , 2 ) : P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( 1 , N , 2 ) : P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( 1 , N , 2 ) : P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j + 1 ] ) + A

1.05
19.89
13.35
15.08
static void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r , y = 0 ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; if ( r > 0 ) { System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . println ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; } int P = 1 - r ; while ( x > y ) { y ++ ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { x -- ; P = P + 2 * y - 2 * x + 1 ; } if ( x < y ) break ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; System . out . print ( "(" + ( - x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; System . out . println ( "(" + ( - x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; if ( x != y ) { System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . print ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . print ( "(" + ( y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ; System . out . println ( "(" + ( - y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ; } } }

def midPointCircleDraw ( x_centre , y_centre , r ) : x = r y = 0 print ( "(" , x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) if ( r > 0 ) : print ( "(" , x + x_centre , "," , - y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , x + y_centre , ")" , sep = "" ) P = 1 - r while ( x > y ) : y += 1 if ( P <= 0 ) : P = P + 2 * y + 1 else : x -= 1 P = P + 2 * y - 2 * x + 1 if ( x < y ) : break print ( "(" , x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , x + x_centre , "," , - y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - x + x_centre , "," , - y + y_centre , ")" , sep = "" ) if ( x != y ) : print ( "(" , y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , y + x_centre , "," , - x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , - x + y_centre , ")" , sep = "" )

def midPointCircleDraw ( x , y , r ) : x = r y = 0 while x > y : print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) print ( "(" + ( - x + x_centre ) + ", " + ( y + y_centre ) + ")" ) print ( "(" + ( - x + x_centre ) + ", " + ( y +

def midPointCircleDraw ( x_centre , y_centre , r ) : x = r y = 0 while x > y : y += 1 if ( P <= 0 ) : P = P + 2 * y + 1 else : x -- P = P + 2 * y - 2 * x + 1 if x < y : break if ( x > y ) : y -= 1 if ( P <= 0 ) : P = P + 2 * y - 2 * x + 1 else : x -= 1 P = P + 2 * y - 2 * x + 1 if x < y : break if ( x > y ) : y -= 1 if ( P <= 0 ) : P = P + 2 * y - 2 * x + 1 else : x -= 1 P = P + 2 * y - 2 * x + 1 if x < y : break

1.33
16.23
48.71
61.64
static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) { if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ; else return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }

def gcd ( a , b ) : if ( a == b ) : return a if ( a == 0 ) : return b if ( b == 0 ) : return a if ( ( ~ a & 1 ) == 1 ) : if ( ( b & 1 ) == 1 ) : return gcd ( a >> 1 , b ) else : return ( gcd ( a >> 1 , b >> 1 ) << 1 ) if ( ( ~ b & 1 ) == 1 ) : return gcd ( a , b >> 1 ) if ( a > b ) : return gcd ( ( a - b ) >> 1 , b ) return gcd ( ( b - a ) >> 1 , a )

def gcd ( a , b ) : if ( a == b ) : return a if ( b == 0 ) : return a

def gcd ( a , b ) : if a == b : return a if b == 0 : return a if a == b : return b if b == 0 : return a if a == b : return b if b == 0 : return a if b == 0 : return a if b == 0 : return b if ~ a & 1 == 1 : return gcd ( a , b >> 1 ) if ~ b & 1 : return gcd ( a , b >> 1 ) if a > b : return gcd ( ( a - b ) >> 1 , a ) return gcd ( ( b - a ) >> 1 , a )

1.37
13.13
65.66
56.88
static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) { if ( k == 0 ) { return 0 ; } if ( l < 0 | r < 0 ) { return ( int ) 1e9 ; } if ( dp [ l ] [ r ] [ k ] != - 1 ) { return dp [ l ] [ r ] [ k ] ; } int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ; return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ; }

def solve ( X , Y , l , r , k , dp ) : if k == 0 : return 0 if l < 0 or r < 0 : return 1000000000 if dp [ l ] [ r ] [ k ] != - 1 : return dp [ l ] [ r ] [ k ] cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) ) dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] ) return dp [ l ] [ r ] [ k ]

def solve ( X , Y , l , r , k , dp ) : dp . sort ( reverse = True ) return dp [ l ] [ r ] [ k ]

def solve ( X , Y , l , r , k , dp [ ] [ ] ) : if k == 0 : return 0 if l < 0 | r < 0 : return ( int ) 1e9 if dp [ l ] [ r ] [ k ] != - 1 : return dp [ l ] [ r ] [ k ] cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) return dp [ l ] [ r ] [ k ] = min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) )

1.63
28.28
10.38
29.15
static void reverse ( char str [ ] ) { int n = str . length , i ; for ( i = 0 ; i < n / 2 ; i ++ ) { swap ( str , i , n - i - 1 ) ; } }

def reverse ( string ) : string = string [ : : - 1 ] return string

def reverse ( str ) : n = str . length for i in range ( n ) : swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , n - i , n - i ) if ( str [ i ] ) : str [ i ] = n - i - 1 , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , i , n - i - 1 ) swap ( str , n - i )

def reverse ( str ) : n = str . length for i in range ( n ) : swap ( str , i , n - i - 1 )

2.75
9.83
59.23
57.29
public static int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; double e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }

def stirlingFactorial ( n ) : if ( n == 1 ) : return 1 e = 2.71 z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) return math . floor ( z )

def stirlingFactorial ( n ) : n = n * n return 1

def stirlingFactorial ( n ) : if n == 1 : return 1 z = math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) return ( int ( z ) )

2.97
15.91
19.33
22.95
static void zodiac_sign ( int day , String month ) { String astro_sign = "" ; if ( month == "december" ) { if ( day < 22 ) astro_sign = "Sagittarius" ; else astro_sign = "capricorn" ; } else if ( month == "january" ) { if ( day < 20 ) astro_sign = "Capricorn" ; else astro_sign = "aquarius" ; } else if ( month == "february" ) { if ( day < 19 ) astro_sign = "Aquarius" ; else astro_sign = "pisces" ; } else if ( month == "march" ) { if ( day < 21 ) astro_sign = "Pisces" ; else astro_sign = "aries" ; } else if ( month == "april" ) { if ( day < 20 ) astro_sign = "Aries" ; else astro_sign = "taurus" ; } else if ( month == "may" ) { if ( day < 21 ) astro_sign = "Taurus" ; else astro_sign = "gemini" ; } else if ( month == "june" ) { if ( day < 21 ) astro_sign = "Gemini" ; else astro_sign = "cancer" ; } else if ( month == "july" ) { if ( day < 23 ) astro_sign = "Cancer" ; else astro_sign = "leo" ; } else if ( month == "august" ) { if ( day < 23 ) astro_sign = "Leo" ; else astro_sign = "virgo" ; } else if ( month == "september" ) { if ( day < 23 ) astro_sign = "Virgo" ; else astro_sign = "libra" ; } else if ( month == "october" ) { if ( day < 23 ) astro_sign = "Libra" ; else astro_sign = "scorpio" ; } else if ( month == "november" ) { if ( day < 22 ) astro_sign = "scorpio" ; else astro_sign = "sagittarius" ; } System . out . println ( astro_sign ) ; }

def zodiac_sign ( day , month ) : if month == 'december' : astro_sign = 'Sagittarius' if ( day < 22 ) else 'capricorn' elif month == 'january' : astro_sign = 'Capricorn' if ( day < 20 ) else 'aquarius' elif month == 'february' : astro_sign = 'Aquarius' if ( day < 19 ) else 'pisces' elif month == 'march' : astro_sign = 'Pisces' if ( day < 21 ) else 'aries' elif month == 'april' : astro_sign = 'Aries' if ( day < 20 ) else 'taurus' elif month == 'may' : astro_sign = 'Taurus' if ( day < 21 ) else 'gemini' elif month == 'june' : astro_sign = 'Gemini' if ( day < 21 ) else 'cancer' elif month == 'july' : astro_sign = 'Cancer' if ( day < 23 ) else 'leo' elif month == 'august' : astro_sign = 'Leo' if ( day < 23 ) else 'virgo' elif month == 'september' : astro_sign = 'Virgo' if ( day < 23 ) else 'libra' elif month == 'october' : astro_sign = 'Libra' if ( day < 23 ) else 'scorpio' elif month == 'november' : astro_sign = 'scorpio' if ( day < 22 ) else 'sagittarius' print ( astro_sign )

def zodiac_sign ( day , month ) : astro_sign = "" if ( month == "january" ) : if ( day < 20 ) astro_sign = "Sagittarius" else : astro_sign = "aquarius" } else : if ( month == "february" ) : if ( day < 19 ) astro_sign = "Aquarius" else : astro_sign =

def zodiac_sign ( day , month ) : astro_sign = "" if month == "december" : if ( day < 22 ) : astro_sign = "Sagittarius" else : astro_sign = "capricorn" elif month == "february" : if ( day < 19 ) : astro_sign = "Aquarius" else : astro_sign = "aries" elif month == "march" : if ( day < 21 ) : astro_sign = "Aries" else : astro_sign = "taurus" elif month == "may" : if ( day < 21 ) : astro_sign = "Taurus" else : astro_sign = "gemini" elif month == "june" : if ( day < 21 ) : astro_sign = "Gemini" else : astro_sign = "cancer" return astro_sign

4.8
7.12
57.66
39.79
static long exponentiation ( long base , long exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return base % N ; long t = exponentiation ( base , exp / 2 ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( base % N ) * t ) % N ; }

def exponentiation ( bas , exp ) : if ( exp == 0 ) : return 1 if ( exp == 1 ) : return bas % N t = exponentiation ( bas , int ( exp / 2 ) ) t = ( t * t ) % N if ( exp % 2 == 0 ) : return t else : return ( ( bas % N ) * t ) % N

def exponentiation ( base , exp ) : if exp == 0 : return 1 elif exp == 1 : return base % N

def exponentiation ( base , exp ) : if exp == 0 : return 1 if exp == 1 : return base % N t = exponentiation ( base , exp / 2 ) t = ( t * t ) % N if exp % 2 == 0 : return t else : return ( ( base % N ) * t ) % N

4.91
16.15
5.05
19.39
static void printRoman ( int number ) { char c [ ] = new char [ 10001 ] ; int i = 0 ; if ( number <= 0 ) { System . out . printf ( "Invalid number" ) ; return ; } while ( number != 0 ) { if ( number >= 1000 ) { i = digit ( 'M' , number / 1000 , i , c ) ; number = number % 1000 ; } else if ( number >= 500 ) { if ( number < 900 ) { i = digit ( 'D' , number / 500 , i , c ) ; number = number % 500 ; } else { i = sub_digit ( 'C' , 'M' , i , c ) ; number = number % 100 ; } } else if ( number >= 100 ) { if ( number < 400 ) { i = digit ( 'C' , number / 100 , i , c ) ; number = number % 100 ; } else { i = sub_digit ( 'C' , 'D' , i , c ) ; number = number % 100 ; } } else if ( number >= 50 ) { if ( number < 90 ) { i = digit ( 'L' , number / 50 , i , c ) ; number = number % 50 ; } else { i = sub_digit ( 'X' , 'C' , i , c ) ; number = number % 10 ; } } else if ( number >= 10 ) { if ( number < 40 ) { i = digit ( 'X' , number / 10 , i , c ) ; number = number % 10 ; } else { i = sub_digit ( 'X' , 'L' , i , c ) ; number = number % 10 ; } } else if ( number >= 5 ) { if ( number < 9 ) { i = digit ( 'V' , number / 5 , i , c ) ; number = number % 5 ; } else { i = sub_digit ( 'I' , 'X' , i , c ) ; number = 0 ; } } else if ( number >= 1 ) { if ( number < 4 ) { i = digit ( 'I' , number , i , c ) ; number = 0 ; } else { i = sub_digit ( 'I' , 'V' , i , c ) ; number = 0 ; } } } System . out . printf ( "Roman numeral is: " ) ; for ( int j = 0 ; j < i ; j ++ ) { System . out . printf ( "%c" , c [ j ] ) ; } }

def printRoman ( number ) : num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] sym = [ "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" , "C" , "CD" , "D" , "CM" , "M" ] i = 12 while number : div = number // num [ i ] number %= num [ i ] while div : print ( sym [ i ] , end = "" ) div -= 1 i -= 1

def printRoman ( number ) : c = [ ' ' for i in range ( 10001 ) ] for number in range ( 1000 , 50000 ) : if ( number < 100 ) : i = digit ( 'M' , number / 1000 , i , c ) number = number % 1000 else : i = sub_digit ( 'C' , 'M' , i , c ) number = number % 100 ; } else : if ( number >= 1000 ) : i = digit ( 'D' , number , c ) = number % 1000 if ( number < 900 ) : i = digit ( 'D' , number / 500 , i , c ) number = number % 500 else : i = sub_digit ( 'X' , 'C' , i , c ) number = number % 10 else : i = sub_digit ( 'X' , 'C' , i , c ) number = number % 10 if ( number >= 20 ) : i = digit ( 'X' , number / 10 , c ) number = number % 10 else : i = digit ( 'X' , 'C' , i , c ) number = number % 10 else : i = sub_digit ( 'X' ,

def printRoman ( number ) : c = [ '' for k in range ( 10 ) ] number = number % 10 while number != 0 : if number >= 1000 : i = digit ( 'M' , number , i , c ) number = number % 1000 if number >= 500 : if number < 900 : i = digit ( 'D' , number / 500 , i , c ) number = number % 500 if number >= 100 : if number < 400 : i = digit ( 'C' , number / 100 , i , c ) number = number % 100 if number >= 50 : if number < 90 : i = digit ( 'L' , number / 50 , i , c ) number = number % 50 else : i = sub_digit ( 'C' , 'D' , i , c ) number = number % 10 if number >= 40 : if number < 40 : i = digit ( 'X' , 'C' , i , c ) number = number % 10 if number >= 10 : if number < 50 : i = digit ( 'L' , number / 50 , i , c ) number = number % 10 if number >= 10 : i = sub_digit ( 'X' , 'C'

5.02
8.1
81.87
82.55
static int lcs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) { return count ; } if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }

def lcs ( i , j , count ) : if ( i == 0 or j == 0 ) : return count if ( X [ i - 1 ] == Y [ j - 1 ] ) : count = lcs ( i - 1 , j - 1 , count + 1 ) count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) return count

def lcs ( i , j , count ) : if ( i == 0 || j == 0 ) : return count

def lcs ( i , j , count ) : if i == 0 or j == 0 : return count if X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) : count = lcs ( i - 1 , j - 1 , count + 1 ) count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) return count

5.61
19.81
17.54
20.05
static String decode ( String str ) { Stack < Integer > integerstack = new Stack < > ( ) ; Stack < Character > stringstack = new Stack < > ( ) ; String temp = "" , result = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( Character . isDigit ( str . charAt ( i ) ) ) { while ( Character . isDigit ( str . charAt ( i ) ) ) { count = count * 10 + str . charAt ( i ) - '0' ; i ++ ; } i -- ; integerstack . push ( count ) ; } else if ( str . charAt ( i ) == ']' ) { temp = "" ; count = 0 ; if ( ! integerstack . isEmpty ( ) ) { count = integerstack . peek ( ) ; integerstack . pop ( ) ; } while ( ! stringstack . isEmpty ( ) && stringstack . peek ( ) != '[' ) { temp = stringstack . peek ( ) + temp ; stringstack . pop ( ) ; } if ( ! stringstack . empty ( ) && stringstack . peek ( ) == '[' ) stringstack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) stringstack . push ( result . charAt ( j ) ) ; result = "" ; } else if ( str . charAt ( i ) == '[' ) { if ( Character . isDigit ( str . charAt ( i - 1 ) ) ) stringstack . push ( str . charAt ( i ) ) ; else { stringstack . push ( str . charAt ( i ) ) ; integerstack . push ( 1 ) ; } } else stringstack . push ( str . charAt ( i ) ) ; } while ( ! stringstack . isEmpty ( ) ) { result = stringstack . peek ( ) + result ; stringstack . pop ( ) ; } return result ; }

def decode ( Str ) : integerstack = [ ] stringstack = [ ] temp = "" result = "" for i in range ( len ( Str ) ) : count = 0 if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) i += 1 i -= 1 integerstack . append ( count ) elif ( Str [ i ] == ']' ) : temp = "" count = 0 if ( len ( integerstack ) != 0 ) : count = integerstack [ - 1 ] integerstack . pop ( ) while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) : temp = stringstack [ - 1 ] + temp stringstack . pop ( ) if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) : stringstack . pop ( ) for j in range ( count ) : result = result + temp for j in range ( len ( result ) ) : stringstack . append ( result [ j ] ) result = "" elif ( Str [ i ] == '[' ) : if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : stringstack . append ( Str [ i ] ) else : stringstack . append ( Str [ i ] ) integerstack . append ( 1 ) else : stringstack . append ( Str [ i ] ) while len ( stringstack ) != 0 : result = stringstack [ - 1 ] + result stringstack . pop ( ) return result

def decode ( str ) : integerstack = list ( ) stringstack = list ( ) for i in range ( len ( str ) ) : count = 0 if ( str [ i ] == '.' ) : count = count * 10 + str [ i ] - '0' i ++ elif ( str [ i ] == '_' ) : temp = "" count = 0 if ( stringstack [ - 1 ] != '[' ) : temp = stringstack [ - 1 ] stringstack . pop ( )

def decode ( str ) : integerstack = [ 0 for i in range ( len ( str ) ) ] stringstack = [ '' for i in range ( len ( str ) ) ] temp = "" count = 0 if not integerstack . isEmpty ( ) : count = integerstack . peek ( ) integerstack . pop ( ) while not stringstack . isEmpty ( ) and stringstack . peek ( ) != '[' : temp = stringstack . peek ( ) + temp stringstack . pop ( ) } while not stringstack . empty ( ) and stringstack . peek ( ) != ']' : temp = stringstack . peek ( ) + temp stringstack . pop ( ) if not stringstack . empty ( ) and stringstack . peek ( ) == '[' : stringstack . pop ( ) for j in range ( 0 , count ) : stringstack . push ( result . charAt ( j ) ) result = "" return result

5.92
20.68
20.41
24.87
static void PrintMinNumberForPattern ( String arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case 'I' : j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == 'D' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; System . out . print ( " " + ++ last_entry ) ; System . out . print ( " " + curr_max ) ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; System . out . print ( " " + last_entry ) ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( " " + -- last_entry ) ; i ++ ; } break ; case 'D' : if ( i == 0 ) { j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == 'D' ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; System . out . print ( " " + curr_max + " " + ( curr_max - 1 ) ) ; last_entry = curr_max - 1 ; } else { System . out . print ( " " + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } System . out . println ( ) ; }

def PrintMinNumberForPattern ( arr ) : curr_max = 0 last_entry = 0 i = 0 while i < len ( arr ) : noOfNextD = 0 if arr [ i ] == "I" : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 if i == 0 : curr_max = noOfNextD + 2 last_entry += 1 print ( "" , last_entry , end = "" ) print ( "" , curr_max , end = "" ) last_entry = curr_max else : curr_max += noOfNextD + 1 last_entry = curr_max print ( "" , last_entry , end = "" ) for k in range ( noOfNextD ) : last_entry -= 1 print ( "" , last_entry , end = "" ) i += 1 elif arr [ i ] == "D" : if i == 0 : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 curr_max = noOfNextD + 2 print ( "" , curr_max , curr_max - 1 , end = "" ) last_entry = curr_max - 1 else : print ( "" , last_entry - 1 , end = "" ) last_entry -= 1 i += 1 print ( )

def PrintMinNumberForPattern ( arr ) : curr_max = 0 last_entry = 0 for i in range ( len ( arr ) ) : noOfNextD = 0 for j in range ( i + 1 , len ( arr ) ) : if ( j == 0 ) : curr_max = noOfNextD + 2 else : curr_max = curr_max + noOfNextD + 1 last_entry = curr_max break if ( i == 0

def PrintMinNumberForPattern ( arr ) : curr_max = 0 last_entry = 0 for k in range ( 0 , len ( arr ) , - 1 ) : curr_max = curr_max + noOfNextD + 2 if i == 0 : curr_max = noOfNextD + 2 System . out . print ( " " + ++ last_entry ) last_entry = curr_max elif i == 0 : curr_max = curr_max + noOfNextD + 1 last_entry = curr_max elif i == 0 : curr_max = curr_max + noOfNextD + 1 last_entry = curr_max elif i == 1 : curr_max = curr_max + noOfNextD + 1 last_entry = curr_max elif i == 2 : curr_max = curr_max + noOfNextD + 1 last_entry = curr_max elif i == 3 : curr_max = curr_max + noOfNextD + 1 last_entry = curr_max elif i == 4 : curr_max = curr_max + noOfNextD + 1 last_entry = curr_max else : curr_max = curr_max + noOf

6.1
10.9
8.95
8.92
void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }

def reverse ( string ) : if len ( string ) == 0 : return temp = string [ 0 ] reverse ( string [ 1 : ] ) print ( temp , end = '' )

def reverse ( str ) : if ( str == null ) || ( str . length ( ) <= 1 ) : print ( str [ 0 ] ) reverse ( str [ 0 : len ( str ) - 1 ] ) reverse ( str [ len ( str ) - 1 ] ) reverse ( str [ 0 : len ( str ) - 1 ] ) reverse ( str [ 0 : len ( str ) - 1 ] ) reverse ( str [ 0 : len ( str ) - 1 ] )

def reverse ( str ) : if ( str == None ) or ( str . length ( ) <= 1 ) : print ( str ) else : print ( str [ 0 : str . length ( ) - 1 ] ) reverse ( str [ 0 : str . length ( ) - 1 ] )

6.26
16.15
41.03
40.34
static int maxSum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }

def maxSum ( mat , n ) : if n == 1 : return mat [ 0 ] [ 0 ] dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] maxSum = INT_MIN for j in range ( n ) : dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] for i in range ( n - 2 , - 1 , - 1 ) : for j in range ( n ) : maxi = INT_MIN if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : maxi = dp [ i + 1 ] [ j - 1 ] if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : maxi = dp [ i + 1 ] [ j + 1 ] dp [ i ] [ j ] = mat [ i ] [ j ] + maxi for j in range ( n ) : if ( maxSum < dp [ 0 ] [ j ] ) : maxSum = dp [ 0 ] [ j ] return maxSum

def maxSum ( mat , n ) : dp = [ INT_MAX for k in range ( n ) ] for k in range ( n ) : maxSum = float ( 'inf' ) for j in range ( 0 , n ) : if ( maxSum < dp [ 0 ] [ j ] ) : maxSum = dp [ 0 ] [ j ] return maxSum

def maxSum ( mat , n ) : dp = [ INT_MAX for i in range ( n ) ] for j in range ( 0 , n ) : max = INT_MAX for i in range ( n ) : if ( ( j - 1 ) >= 0 ) and ( max < dp [ i + 1 ] [ j - 1 ] ) : max = dp [ i + 1 ] [ j - 1 ] if ( ( j + 1 ) < n ) and ( max < dp [ i + 1 ] [ j + 1 ] ) : max = dp [ i + 1 ] [ j + 1 ] dp [ i ] [ j ] = mat [ i ] [ j ] + max return maxSum

6.36
9.18
57.12
64.79
static int calcAngle ( double h , double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }

def calcAngle ( h , m ) : if ( h < 0 or m < 0 or h > 12 or m > 60 ) : print ( 'Wronginput' ) if ( h == 12 ) : h = 0 if ( m == 60 ) : m = 0 hour_angle = 0.5 * ( h * 60 + m ) minute_angle = 6 * m angle = abs ( hour_angle - minute_angle ) angle = min ( 360 - angle , angle ) return angle

def calcAngle ( h , m ) : if ( h < 0 || m < 0 ) : print ( "Wrong input" ) return 0

def calcAngle ( h , m ) : if h < 0 or m < 0 : raise ValueError ( "Wrong input" ) if m == 60 : m = 0 hour_angle = ( 0.5 * ( h * 60 + m ) ) minute_angle = ( 0.5 * ( h * 60 + m ) ) angle = abs ( hour_angle - minute_angle ) angle = min ( 360 - angle , angle ) return angle

6.44
14.69
45.64
50.77
static int sumDigits ( int no ) { return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 ) ; }

def sumDigits ( no ) : return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) )

def sumDigits ( no ) : return no

def sumDigits ( no ) : return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 )

7.15
24.88
7.69
21.68
public static void printArray ( int arr [ ] [ ] , int row , int col ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { String s = "" ; for ( int j = 0 ; j < col ; j ++ ) s += String . valueOf ( arr [ i ] [ j ] ) ; if ( ! set . contains ( s ) ) { set . add ( s ) ; System . out . println ( s ) ; } } }

def printArray ( matrix ) : rowCount = len ( matrix ) if rowCount == 0 : return columnCount = len ( matrix [ 0 ] ) if columnCount == 0 : return row_output_format = "" . join ( [ "%s" ] * columnCount ) printed = { } for row in matrix : routput = row_output_format % tuple ( row ) if routput not in printed : printed [ routput ] = True print ( routput )

def printArray ( arr , row , col ) : set = new HashSet < String > ( ) for i in range ( row , col ) : s = "" for j in range ( 0 , col ) : s += String . valueOf ( arr [ i ] [ j ] ) if ( ! set . contains ( s ) ) : set . add ( s ) print ( s )

def printArray ( arr , row , col ) : set = list ( ) for i in range ( row ) : for j in range ( col ) : s = "" for j in range ( row ) : s += str ( arr [ i ] [ j ] ) if not set . contains ( s ) : set . add ( s ) System . out . println ( s )

7.15
14.54
31.98
27.4
static void printMaxOfMin ( int n ) { Stack < Integer > s = new Stack < > ( ) ; int left [ ] = new int [ n + 1 ] ; int right [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ; s . push ( i ) ; } int ans [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }

def printMaxOfMin ( arr , n ) : s = [ ] left = [ - 1 ] * ( n + 1 ) right = [ n ] * ( n + 1 ) for i in range ( n ) : while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : s . pop ( ) if ( len ( s ) != 0 ) : left [ i ] = s [ - 1 ] s . append ( i ) while ( len ( s ) != 0 ) : s . pop ( ) for i in range ( n - 1 , - 1 , - 1 ) : while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : s . pop ( ) if ( len ( s ) != 0 ) : right [ i ] = s [ - 1 ] s . append ( i ) ans = [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) : ans [ i ] = 0 for i in range ( n ) : Len = right [ i ] - left [ i ] - 1 ans [ Len ] = max ( ans [ Len ] , arr [ i ] ) for i in range ( n - 1 , 0 , - 1 ) : ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) for i in range ( 1 , n + 1 ) : print ( ans [ i ] , end = "" )

def printMaxOfMin ( arr , n ) : s = list ( ) for i in range ( n + 1 , - 1 , - 1 ) : while ( arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) right [ i ] = n if ( s . empty ( ) ) left [ i ] = - 1 right [ i ] = n while ( s . empty ( ) ) s . pop ( ) : while ( arr [ s .

def printMaxOfMin ( n ) : left = [ - 1 for i in range ( n ) ] right = [ n for i in range ( n ) ] for i in range ( n ) : left [ i ] = - 1 right [ i ] = n for i in range ( n ) : if ( not s . empty ( ) and arr [ s [ i ] ] >= arr [ i ] ) : s . pop ( ) if ( not s . empty ( ) ) : left [ i ] = s [ i ] s . push ( i ) for i in range ( n - 1 , - 1 ) : while ( not s . empty ( ) and arr [ s [ i ] ] >= arr [ i ] ) : s . pop ( ) if ( not s . empty ( ) ) : right [ i ] = s [ i ] s . push ( i )

7.6
19.33
32.93
39.71
public static int SumOfKsubArray ( int arr [ ] , int k ) { int sum = 0 ; Deque < Integer > S = new LinkedList < > ( ) , G = new LinkedList < > ( ) ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } for ( ; i < arr . length ; i ++ ) { sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ; while ( ! S . isEmpty ( ) && S . peekFirst ( ) <= i - k ) S . removeFirst ( ) ; while ( ! G . isEmpty ( ) && G . peekFirst ( ) <= i - k ) G . removeFirst ( ) ; while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ; return sum ; }

def SumOfKsubArray ( arr , n , k ) : Sum = 0 S = deque ( ) G = deque ( ) for i in range ( k ) : while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : S . pop ( ) while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : G . pop ( ) G . append ( i ) S . append ( i ) for i in range ( k , n ) : Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] while ( len ( S ) > 0 and S [ 0 ] <= i - k ) : S . popleft ( ) while ( len ( G ) > 0 and G [ 0 ] <= i - k ) : G . popleft ( ) while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : S . pop ( ) while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : G . pop ( ) G . append ( i ) S . append ( i ) Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] return Sum

def SumOfKsubArray ( arr , k ) : S = list ( ) G = list ( ) for i in range ( k ) : sum += arr [ S . peekLast ( ) ] >= arr [ i ] : S . removeLast ( ) while ( ! G . isEmpty ( ) and arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) sum += arr [ S . peekFirst ( ) ] + arr [ G .

def SumOfKsubArray ( arr , k ) : S = list ( ) G = list ( ) for i in range ( k ) : sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] while not S . isEmpty ( ) and arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) while not G . isEmpty ( ) and arr [ G . peekLast ( ) ] <= arr [ i ] : G . removeLast ( ) G . addLast ( i ) S . addLast ( i ) i = 0 for i in range ( k ) : sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] while not S . isEmpty ( ) and arr [ S . peekLast ( ) ] >= arr [ i ] : S . removeLast ( ) while not G . isEmpty ( ) and arr [ G . peekLast ( ) ] <= arr [ i ] : G . removeLast ( ) G . addLast ( i ) S . addLast ( i ) i += 1 return sum

7.87
20.14
22.59
35.75
static int getMinStepToReachEnd ( int arr [ ] , int N ) { boolean [ ] visit = new boolean [ N ] ; int [ ] distance = new int [ N ] ; Vector < Integer > [ ] digit = new Vector [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) digit [ i ] = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) visit [ i ] = false ; for ( int i = 1 ; i < N ; i ++ ) digit [ arr [ i ] ] . add ( i ) ; distance [ 0 ] = 0 ; visit [ 0 ] = true ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int idx = q . peek ( ) ; q . remove ( ) ; if ( idx == N - 1 ) break ; int d = arr [ idx ] ; for ( int i = 0 ; i < digit [ d ] . size ( ) ; i ++ ) { int nextidx = digit [ d ] . get ( i ) ; if ( ! visit [ nextidx ] ) { visit [ nextidx ] = true ; q . add ( nextidx ) ; distance [ nextidx ] = distance [ idx ] + 1 ; } } digit [ d ] . clear ( ) ; if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true ; q . add ( idx - 1 ) ; distance [ idx - 1 ] = distance [ idx ] + 1 ; } if ( idx + 1 < N && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true ; q . add ( idx + 1 ) ; distance [ idx + 1 ] = distance [ idx ] + 1 ; } } return distance [ N - 1 ] ; }

def getMinStepToReachEnd ( arr , N ) : visit = [ False for i in range ( N ) ] distance = [ 0 for i in range ( N ) ] digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ] for i in range ( 1 , N ) : digit [ arr [ i ] ] . append ( i ) distance [ 0 ] = 0 visit [ 0 ] = True q = [ ] q . append ( 0 ) while ( len ( q ) > 0 ) : idx = q [ 0 ] q . remove ( q [ 0 ] ) if ( idx == N - 1 ) : break d = arr [ idx ] for i in range ( len ( digit [ d ] ) ) : nextidx = digit [ d ] [ i ] if ( visit [ nextidx ] == False ) : visit [ nextidx ] = True q . append ( nextidx ) distance [ nextidx ] = distance [ idx ] + 1 if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : visit [ idx - 1 ] = True q . append ( idx - 1 ) distance [ idx - 1 ] = distance [ idx ] + 1 if ( idx + 1 < N and visit [ idx + 1 ] == False ) : visit [ idx + 1 ] = True q . append ( idx + 1 ) distance [ idx + 1 ] = distance [ idx ] + 1 return distance [ N - 1 ]

def getMinStepToReachEnd ( arr , N ) : visit = [ false for i in range ( 10 ) ] distance = [ 0 for i in range ( 10 ) ] for i in range ( 1 , N ) : digit [ arr [ i ] ] . add ( i ) visit [ i ] = true q = list ( ) for idx in range ( 0 , N - 1 ) : if ( ! visit [ idx ] ) : visit [ idx ] = true q .

def getMinStepToReachEnd ( arr , N ) : visit = [ False for k in range ( N ) ] distance = [ 0 for k in range ( N ) ] visit [ 0 ] = True q = list ( ) for i in range ( N ) : d = arr [ idx ] for i in range ( 0 , N ) : if not visit [ i ] : visit [ i ] = True q . add ( i ) distance [ i ] = distance [ idx ] + 1 if idx - 1 >= 0 and not visit [ idx - 1 ] : q . add ( idx - 1 ) distance [ idx - 1 ] = distance [ idx - 1 ] + 1 return visit

8.01
16.95
82.23
87.24
static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }

def seiresSum ( n , a ) : return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) )

def seiresSum ( n , a ) : a . sort ( reverse = True ) return n

def seiresSum ( n , a ) : a . sort ( reverse = True ) return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 )

8.27
16.49
69.71
63.56
static int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }

def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

def factorial ( n ) : return n

def factorial ( n ) : if n == 1 or n == 0 : return 1 return n * factorial ( n - 1 )

9.25
22.4
54.42
43.42
static String maximumPalinUsingKChanges ( String str , int k ) { char palin [ ] = str . toCharArray ( ) ; String ans = "" ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) { return "Not possible" ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < palin . length ; i ++ ) ans += palin [ i ] ; return ans ; }

def maximumPalinUsingKChanges ( strr , k ) : palin = strr l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( strr [ l ] != strr [ r ] ) : palin [ l ] = palin [ r ] = max ( strr [ l ] , strr [ r ] ) k -= 1 l += 1 r -= 1 if ( k < 0 ) : return "Notpossible" l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( l == r ) : if ( k > 0 ) : palin [ l ] = '9' if ( palin [ l ] < '9' ) : if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : k -= 1 palin [ l ] = palin [ r ] = '9' elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : k -= 1 palin [ l ] = palin [ r ] = '9' l += 1 r -= 1 return palin

def maximumPalinUsingKChanges ( str , k ) : palin = [ 0 for l in range ( len ( str ) ) ] for r in range ( l + 1 , len ( str ) ) : if ( str [ l ] != str [ r ] ) : palin [ l ] = palin [ r ] = ( char ) max ( str [ l ] , str [ r ] ) k -= 1 ans += maximumPalinUsingKChanges ( str , k )

<= r : if ( l == r ) : if ( k > 0 ) : palin [ l ] = '9' ; } if ( palin [ l ] < '9' ) : if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : k -= 2 palin [ l ] = palin [ r ] = '9' else : if ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) ) : k -- ; palin [ l ] = palin [ r ] = '9' else : if ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) ) : k -- ; palin [ l ] = palin [ r ] = '9' else : if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : k -= 2 palin [ l ] = palin [ r ] = '9' else : if ( k >= 1 and ( palin [ l ]

9.29
28.77
58.24
53.19
static double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }

def find ( p ) : return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) )

def find ( p ) : return find ( p )

def find ( p ) : return ceil ( 2 * 365 * Math . log ( 1 / ( 1 - p ) )

9.47
28.81
74.6
57.99
public static int gcdExtended ( int a , int b , int x , int y ) { if ( a == 0 ) { x = 0 ; y = 1 ; return b ; } int x1 = 1 , y1 = 1 ; int gcd = gcdExtended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 ; y = x1 ; return gcd ; }

def gcdExtended ( a , b , x , y ) : if a == 0 : x = 0 y = 1 return b x1 = 1 y1 = 1 gcd = gcdExtended ( b % a , a , x1 , y1 ) x = y1 - ( b / a ) * x1 y = x1 return gcd

def gcdExtended ( a , b , x , y ) : x = y = 1 return b

def gcdExtended ( a , b , x , y ) : x = 0 y = 1 gcd = gcdExtended ( b % a , a , x1 , y1 ) x = y1 - ( b / a ) * x1 y = x1 return gcd

9.48
18.67
50.64
43.02
static int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }

def lbs ( arr ) : n = len ( arr ) lis = [ 1 for i in range ( n + 1 ) ] for i in range ( 1 , n ) : for j in range ( 0 , i ) : if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : lis [ i ] = lis [ j ] + 1 lds = [ 1 for i in range ( n + 1 ) ] for i in reversed ( range ( n - 1 ) ) : for j in reversed ( range ( i - 1 , n ) ) : if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : lds [ i ] = lds [ j ] + 1 maximum = lis [ 0 ] + lds [ 0 ] - 1 for i in range ( 1 , n ) : maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) return maximum

def lbs ( arr , n ) : lis = [ 0 for i in range ( n ) ] for i in range ( n ) : if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 return max

def lbs ( arr , n ) : lis = [ 1 for i in range ( n ) ] for i in range ( n ) : lis [ i ] = 1 for j in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 lds [ i ] = lds [ j ] + 1 max = lis [ 0 ] + lds [ 0 ] - 1 for i in range ( 1 , n ) : if ( lis [ i ] + lds [ i ] - 1 > max ) : max = lis [ i ] + lds [ i ] - 1 return max

9.58
28.3
77.39
77.78
static int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }

def sumOfSeries ( n ) : return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 )

def sumOfSeries ( n ) : return n * n

def sumOfSeries ( n ) : return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) )

9.64
27.12
12.29
29.1
static void strToBinary ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = Integer . valueOf ( s . charAt ( i ) ) ; String bin = "" ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; System . out . print ( bin + " " ) ; } }

def strToBinary ( s ) : bin_conv = [ ] for c in s : ascii_val = ord ( c ) binary_val = bin ( ascii_val ) bin_conv . append ( binary_val [ 2 : ] ) return ( '' . join ( bin_conv ) )

def strToBinary ( s ) : n = len ( s ) for i in range ( n ) : val = int . valueOf ( s [ i ] ) bin = "" while ( val > 0 ) : bin += '1' val /= 2 bin = reverse ( bin ) print ( bin + " " ) if ( val % 2 == 1 ) : bin += '0' else : bin += '1' print ( bin + " " )

def strToBinary ( s ) : n = s . length ( ) for i in range ( n ) : val = int ( s [ i ] ) bin = "" while val > 0 : if val % 2 == 1 : bin += '1' else : bin += '0' val /= 2 bin = reverse ( bin ) print ( bin )

9.81
14.39
14.27
15.94
static void swap ( int xp , int yp ) { if ( xp == yp ) return ; xp = xp + yp ; yp = xp - yp ; xp = xp - yp ; }

def swap ( xp , yp ) : if ( xp [ 0 ] == yp [ 0 ] ) : return xp [ 0 ] = xp [ 0 ] + yp [ 0 ] yp [ 0 ] = xp [ 0 ] - yp [ 0 ] xp [ 0 ] = xp [ 0 ] - yp [ 0 ]

def swap ( xp , yp ) : if xp == yp : return xp = xp + yp yp = yp - xp

def swap ( xp , yp ) : if xp == yp : return xp = xp + yp yp = xp - yp xp = xp - yp

10.42
33.66
11.14
33.8
static int singleNumber ( int a [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i : a ) { s . add ( i ) ; } int arr_sum = 0 ; for ( int i : a ) { arr_sum += i ; } int set_sum = 0 ; for ( int i : s ) { set_sum += i ; } return ( 3 * set_sum - arr_sum ) / 2 ; }

def singleNumber ( nums ) : return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2

def singleNumber ( a , n ) : s = new HashSet < Integer > ( ) for i in range ( n ) : s . add ( i ) arr_sum = 0 for i in a : arr_sum += i set_sum = 0 for i in s : set_sum += i return ( 3 * set_sum - arr_sum ) / 2

def singleNumber ( a , n ) : s = list ( ) for i in range ( n ) : s . add ( i ) arr_sum = 0 for i in a : arr_sum += i set_sum = 0 for i in s : set_sum += i return ( 3 * set_sum - arr_sum ) / 2

10.62
27.51
71.45
72.65
static int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }

def countIntegralSolutions ( n ) : return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 )

def countIntegralSolutions ( n ) : return n

def countIntegralSolutions ( n ) : return ( ( n + 1 ) * ( n + 2 ) )

10.62
10.96
81.78
70.94
static double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }

def sumOfSeries ( n ) : return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) )

def sumOfSeries ( n ) : return 0.666

def sumOfSeries ( n ) : return ( 0.666 ) * ( 1 - 1 / math . pow ( 10 , n ) )

10.7
8.49
67.66
63.0
static boolean isPossibleTriangle ( int [ ] arr , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }

def isPossibleTriangle ( arr , N ) : if N < 3 : return False arr . sort ( ) for i in range ( N - 2 ) : if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] : return True

def isPossibleTriangle ( arr , N ) : if ( N < 2 ) : return false return true

def isPossibleTriangle ( arr , N ) : if N < 3 : return False sort ( arr ) for i in range ( 0 , N - 2 , - 1 ) : if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) : return True return False

11.21
29.03
34.87
42.15
static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) { return a [ low ] * turn ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }

def solve ( dp , a , low , high , turn ) : if ( low == high ) : return a [ low ] * turn if ( dp [ low ] [ high ] != 0 ) : return dp [ low ] [ high ] dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ]

def solve ( dp , a , low , high , turn ) : if low == high : return a [ low ] * turn if high == low : return dp [ low ] [ high ]

def solve ( dp , a , low , high , turn ) : if low == high : return a [ low ] * turn if dp [ low ] [ high ] != 0 : return dp [ low ] [ high ] if dp [ low ] [ high ] != 0 : return dp [ low ] [ high ]

11.31
24.21
95.58
73.03
int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 }; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }

def findgroups ( arr , n ) : c = [ 0 , 0 , 0 ] res = 0 for i in range ( 0 , n ) : c [ arr [ i ] % 3 ] += 1 res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) res += c [ 1 ] * c [ 2 ] res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) res += c [ 0 ] * c [ 1 ] * c [ 2 ] return res

def findgroups ( arr , n ) : c = [ 0 for i in range ( n ) ] for i in range ( n ) : res += ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 res += c [ 1 ] * c [ 2 ] return res

def findgroups ( arr , n ) : c = [ 0 , 0 , 0 ] res = 0 for i in range ( n ) : c [ arr [ i ] % 3 ] ++ res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) res += c [ 1 ] * c [ 2 ] res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 res += ( ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) res += c [ 0 ] * c [ 1 ] * c [ 2 ] return res

11.36
15.84
15.88
15.26
static int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }

def numberOfWays ( x ) : if x == 0 or x == 1 : return 1 else : return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )

def numberOfWays ( x ) : dp = [ 0 for i in range ( x + 1 ) ] dp [ 0 ] = dp [ 1 ] = dp [ x + 1 ] = dp [ x + 1 ] for i in range ( 2 , x ) : dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return dp [ x ]

def numberOfWays ( x ) : dp = [ INT_MAX for i in range ( x ) ] dp [ 0 ] = dp [ 1 ] = 1 for i in range ( 2 , x ) : dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] return dp [ x ]

11.73
15.24
61.86
44.51
static int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }

def insertSorted ( arr , n , key , capacity ) : if ( n >= capacity ) : return n i = n - 1 while i >= 0 and arr [ i ] > key : arr [ i + 1 ] = arr [ i ] i -= 1 arr [ i + 1 ] = key return ( n + 1 )

def insertSorted ( arr , n , key , capacity ) : if ( n >= capacity ) : return n

def insertSorted ( arr , n , key , capacity ) : if n >= capacity : return n for i in range ( n - 1 , - 1 , - 1 ) : arr [ i + 1 ] = arr [ i ] arr [ i + 1 ] = key return ( n + 1 )

12.0
27.64
77.29
67.96
int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { int sp [ ] [ ] [ ] = new int [ V ] [ V ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ; if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; if ( e > 1 ) { for ( int a = 0 ; a < V ; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } return sp [ u ] [ v ] [ k ] ; }

def shortestPath ( graph , u , v , k ) : global V , INF sp = [ [ None ] * V for i in range ( V ) ] for i in range ( V ) : for j in range ( V ) : sp [ i ] [ j ] = [ None ] * ( k + 1 ) for e in range ( k + 1 ) : for i in range ( V ) : for j in range ( V ) : sp [ i ] [ j ] [ e ] = INF if ( e == 0 and i == j ) : sp [ i ] [ j ] [ e ] = 0 if ( e == 1 and graph [ i ] [ j ] != INF ) : sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] if ( e > 1 ) : for a in range ( V ) : if ( graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF ) : sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) return sp [ u ] [ v ] [ k ]

def shortestPath ( graph , u , v , k ) : sp = [ 0 for e in range ( k ) ] for i in range ( 0 , V ) : if ( graph [ i ] [ j ] != INF ) : sp [ i ] [ j ] = min ( sp [ i ] [ j ] , graph [ i ] [ j ] [ e - 1 ] ) return sp [ u ] [ v ] [ k ]

def shortestPath ( graph , u , v , k ) : sp [ ] [ ] = [ INF for i in range ( V ) ] for e in range ( k ) : for j in range ( 0 , V ) : sp [ i ] [ j ] [ e ] = INF if ( e == 0 and i == j ) : sp [ i ] [ j ] [ e ] = 0 if ( e == 1 and graph [ i ] [ j ] != INF ) : sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] if ( e > 1 ) : for a in range ( 0 , V ) : if ( graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF ) : sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) return sp [ u ] [ v ] [ k ]

12.01
27.57
35.82
40.53
static int countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ ] [ ] = new int [ n ] [ n ] ; int T [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '|' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '^' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }

def countParenth ( symb , oper , n ) : F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n ) : if symb [ i ] == 'F' : F [ i ] [ i ] = 1 else : F [ i ] [ i ] = 0 if symb [ i ] == 'T' : T [ i ] [ i ] = 1 else : T [ i ] [ i ] = 0 for gap in range ( 1 , n ) : i = 0 for j in range ( gap , n ) : T [ i ] [ j ] = F [ i ] [ j ] = 0 for g in range ( gap ) : k = i + g tik = T [ i ] [ k ] + F [ i ] [ k ] tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] if oper [ k ] == '&' : T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) if oper [ k ] == '|' : F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) if oper [ k ] == '^' : T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) i += 1 return T [ 0 ] [ n - 1 ]

def countParenth ( symb , oper , n ) : F = [ 0 for i in range ( n ) ] T = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 T [ i ] [ j ] = ( symb [ i ] == 'T' ) : ( symb [ i ] == 'T' ) F [ i ] [ k ] = ( oper [ k ] == '&' ) : ( tkj * T [ k + 1 ] [ j ] ) F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) return ( countParenth ( symb , oper , n )

: T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) if oper [ k ] == '&' : T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) if oper [ k ] == '|' : T [ i ] [ j ] += T [ i ] [ k ] * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] if oper [ k ] == '&' : T [ i ] [ j ] += T [ i ] [ k ] * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] if oper [ k ] == '&' : T [ i ] [ j ] += T [ i ] [ k ] * tkj - T [ i ] [ k ] * T [ k + 1 ]

12.03
25.07
43.09
73.66
static int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }

def countNumberOfTriangles ( n ) : return ( n * ( n - 1 ) * ( n - 2 ) // 6 )

def countNumberOfTriangles ( n ) : return n

def countNumberOfTriangles ( n ) : n = len ( n ) * ( n - 1 ) * ( n - 2 ) / 6 return n * ( n - 1 ) * ( n - 2 ) / 6

12.12
26.7
7.32
22.68
private static void printDuplicates ( int [ ] arr , int n ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int count = 0 ; boolean dup = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , count + 1 ) ; } else { map . put ( arr [ i ] , 1 ) ; } } for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { System . out . print ( entry . getKey ( ) + " " ) ; dup = true ; } } if ( ! dup ) { System . out . println ( "-1" ) ; } }

def printDuplicates ( arr ) : dict = { } for ele in arr : try : dict [ ele ] += 1 except : dict [ ele ] = 1 for item in dict : if ( dict [ item ] > 1 ) : print ( item , end = "" ) print ( "\n" )

def printDuplicates ( arr , n ) : map = defaultdict ( int ) for i in range ( n ) : if ( map . containsKey ( arr [ i ] ) ) : count = map [ arr [ i ] ] else : count = 1 map . put ( arr [ i ] , count + 1 ) dup = true for entry in map . entrySet ( ) : if ( entry . getValue ( ) > 1 ) : print ( entry . getKey ( ) + " " ) dup = True

def printDuplicates ( arr , n ) : count = 0 dup = False for i in range ( n ) : if map . containsKey ( arr [ i ] ) : count = map [ arr [ i ] ] map . put ( arr [ i ] , count + 1 ) else : map . put ( arr [ i ] , 1 ) for entry in map . entrySet ( ) : if entry . getValue ( ) > 1 : print ( entry . getKey ( ) + " " ) dup = True if not dup : print ( "-1" )

12.12
20.65
61.6
48.21
static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) { minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( "The smallest range is [%d , %d]\n" , minel , maxel ) ; }

def findSmallestRange ( arr , n , k ) : i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 for i in range ( k + 1 ) : ptr [ i ] = 0 minrange = 10 ** 9 while ( 1 ) : minind = - 1 minval = 10 ** 9 maxval = - 10 ** 9 flag = 0 for i in range ( k ) : if ( ptr [ i ] == n ) : flag = 1 break if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : minind = i minval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] if ( flag ) : break ptr [ minind ] += 1 if ( ( maxval - minval ) < minrange ) : minel = minval maxel = maxval minrange = maxel - minel print ( "Thesmallestrangeis[" , minel , maxel , "]" )

def findSmallestRange ( ptr , n , k ) : minel = 0 maxel = 0 minrange = float ( 'inf' ) for i in range ( k ) : if ( ptr [ i ] == n ) : minind = i minval = maxval = float ( 'inf' ) elif ( ptr [ i ] < n ) : minval = arr [ i ] [ ptr [ i ] ] minrange = float ( 'inf' ) for i in range

def findSmallestRange ( arr , n , k ) : ptr = [ 0 for i in range ( k ) ] minrange = float ( 'inf' ) maxel = 0 minind = - 1 minval = 0 maxval = float ( 'inf' ) flag = 0 for i in range ( k ) : if ( ptr [ i ] == n ) : flag = 1 break if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : minind = i minval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] ] if ( maxval - minval ) < minrange : minel = minval maxel = maxval minrange = maxel - min

12.22
41.7
71.58
81.21
static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { System . out . println ( "Right" ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { System . out . println ( "Right" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { System . out . println ( "Right" ) ; return ; } }

def direction ( R , C ) : if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if R == C and R % 2 != 0 and C % 2 != 0 : print ( "Right" ) return if R == C and R % 2 == 0 and C % 2 == 0 : print ( "Left" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return

def direction ( R , C ) : if R == C and R % 2 == 0 and C % 2 != 0 and R < C : print ( "Left" ) return if R != C and R % 2 == 0 and C % 2 != 0 and R > C : print ( "Up" ) return if R != C and R % 2 != 0 and C % 2 != 0 and R < C : print ( "Right" ) return if R != C and R

def direction ( R , C ) : if R == C and R % 2 != 0 and C % 2 != 0 and R < C : print ( "Left" ) return if R == C and R % 2 != 0 and C % 2 != 0 and R > C : print ( "Down" ) return if R != C and R % 2 != 0 and C % 2 != 0 and R < C : print ( "Right" ) return if R != C and R % 2 != 0 and C % 2 != 0 and R > C : print ( "Up" ) return if R != C and R % 2 != 0 and C % 2 != 0 and R < C : print ( "Left" ) return if R != C and R % 2 != 0 and C % 2 != 0 and R > C : print ( "Down" ) return if R != C and R % 2 != 0 and C % 2 != 0 and R < C : print ( "Left" ) return if R != C and R % 2 != 0 and C % 2 != 0 and R > C : print ( "Up" ) return if R != C and R % 2 == 0 and C % 2 == 0 and R < C : print

12.3
16.85
69.77
75.01
static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; }

def multiply ( x , y ) : if ( y == 0 ) : return 0 if ( y > 0 ) : return ( x + multiply ( x , y - 1 ) ) if ( y < 0 ) : return - multiply ( x , - y )

def multiply ( x , y ) : if ( y == 1 ) : return x * y

def multiply ( x , y ) : if y == 0 : return 0 if y > 0 : return ( x + multiply ( x , y - 1 ) ) if y < 0 : return - multiply ( x , - y ) return - 1

12.44
20.11
19.42
18.1
static void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 . charAt ( i ) - 'a' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - 'a' ] == 1 || present [ str2 . charAt ( i ) - 'a' ] == - 1 ) { present [ str2 . charAt ( i ) - 'a' ] = - 1 ; } else { present [ str2 . charAt ( i ) - 'a' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { System . out . print ( ( char ) ( i + 'a' ) + " " ) ; } } }

def findAndPrintUncommonChars ( str1 , str2 ) : present = [ 0 ] * MAX_CHAR for i in range ( 0 , MAX_CHAR ) : present [ i ] = 0 l1 = len ( str1 ) l2 = len ( str2 ) for i in range ( 0 , l1 ) : present [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = 1 for i in range ( 0 , l2 ) : if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == - 1 ) : present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = - 1 else : present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = 2 for i in range ( 0 , MAX_CHAR ) : if ( present [ i ] == 1 or present [ i ] == 2 ) : print ( chr ( i + ord ( 'a' ) ) , end = "" )

def findAndPrintUncommonChars ( str1 , str2 ) : present = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( 0 , l1 ) : if ( present [ str1 [ i ] - 'a' ] == 1 ) : present [ str1 [ i ] - 'a' ] = 1 else : present [ str1 [ i ] - 'a' ] = 2 present [ str2 [ i ] - 'a

def findAndPrintUncommonChars ( str1 , str2 ) : present = [ 0 for k in range ( MAX_CHAR ) ] l1 = str1 . length l2 = str2 . length ( ) for i in range ( l1 , l2 ) : if ( present [ str2 [ i ] - 'a' ] == 1 or present [ str2 [ i ] - 'a' ] == - 1 ) : present [ str2 [ i ] - 'a' ] = - 1 else : present [ str2 [ i ] - 'a' ] = 2

12.77
13.5
35.4
30.12
static Boolean isOverflow ( long a , long b ) { if ( a == 0 || b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }

def isOverflow ( a , b ) : if ( a == 0 or b == 0 ) : return False result = a * b if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : result = 0 if ( a == ( result // b ) ) : print ( result // b ) return False else : return True

def isOverflow ( a , b ) : if ( a == 0 || b == 0 ) : return false return true

def isOverflow ( a , b ) : if a == 0 or b == 0 : return False result = a * b if a == result / b : return False else : return True

12.81
18.03
39.17
42.46
static int countDistictSubarray ( int arr [ ] , int n ) { HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) { @ Override public Integer get ( Object key ) { if ( ! containsKey ( key ) ) return 0 ; return super . get ( key ) ; } }; for ( int i = 0 ; i < n ; ++ i ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) ; if ( vis . get ( arr [ right ] ) == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) ; if ( vis . get ( arr [ left ] ) == 0 ) -- window ; } return ans ; }

def countDistictSubarray ( arr , n ) : vis = dict ( ) for i in range ( n ) : vis [ arr [ i ] ] = 1 k = len ( vis ) vid = dict ( ) ans = 0 right = 0 window = 0 for left in range ( n ) : while ( right < n and window < k ) : if arr [ right ] in vid . keys ( ) : vid [ arr [ right ] ] += 1 else : vid [ arr [ right ] ] = 1 if ( vid [ arr [ right ] ] == 1 ) : window += 1 right += 1 if ( window == k ) : ans += ( n - right + 1 ) vid [ arr [ left ] ] -= 1 if ( vid [ arr [ left ] ] == 0 ) : window -= 1 return ans

def countDistictSubarray ( arr , n ) : vis = new HashMap ( ) @ Override public Integer get ( Object key ) : return 0 for key in range ( n ) : if ( ! containsKey ( key ) ) : return 0 for key in range ( n ) : vis . put ( key , 1 ) if ( vis . get ( arr [ key ] ) == 1 ) : ++ window return ans

def countDistictSubarray ( arr , n ) : vis = new HashMap ( ) for i in range ( n ) : vis . put ( arr [ i ] , 1 ) if ( i < n and window < k ) : vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) if ( vis . get ( arr [ right ] ) == 1 ) ++ window right += 1 if ( window == k ) : ans += ( n - right + 1 ) vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) if ( vis . get ( arr [ left ] ) == 0 ) -- window

12.81
13.4
88.15
87.24
static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }

def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x i = 1 result = 1 while ( result <= x ) : i += 1 result = i * i return i - 1

def floorSqrt ( x ) : if ( x == 0 ) : return x

def floorSqrt ( x ) : if x == 0 or x == 1 : return x i = 1 result = 1 while ( result <= x ) : i += 1 result = i * i return i - 1

12.97
19.13
16.38
18.68
public static boolean checkPangram ( String str ) { boolean [ ] mark = new boolean [ 26 ] ; int index = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) - 'A' ; else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) - 'a' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }

def checkPangram ( s ) : List = [ ] for i in range ( 26 ) : List . append ( False ) for c in s . lower ( ) : if not c == "" : List [ ord ( c ) - ord ( 'a' ) ] = True for ch in List : if ch == False : return False return True

def checkPangram ( str ) : mark = [ false for i in range ( 26 ) ] for i in range ( 0 , len ( str ) ) : if ( 'A' <= str [ i ] and str [ i ] <= 'Z' ) : index = str [ i ] - 'A' else : if ( 'a' <= str [ i ] and str [ i ] <= 'z' ) : index = str [ i ] - 'a' else : mark [ index ] = true if ( 'a' <= str [ i ] and str [ i ] <= false : return ( false )

def checkPangram ( str ) : mark = [ 0 for i in range ( 26 ) ] index = 0 for i in range ( 26 ) : if ( 'A' <= str [ i ] and str [ i ] <= 'Z' ) : index = str [ i ] - 'A' elif ( 'a' <= str [ i ] and str [ i ] <= 'z' ) : index = str [ i ] - 'a' mark [ index ] = True

13.11
23.79
28.96
46.35
static void pointClip ( int XY [ ] [ ] , int n , int Xmin , int Ymin , int Xmax , int Ymax ) { System . out . printf ( "Point inside the viewing pane:\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) { if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } } System . out . printf ( "\nPoint outside the viewing pane:\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } }

def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : print ( "Pointinsidetheviewingpane:" ) for i in range ( n ) : if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) : if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) : print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" ) print ( "\n\nPointoutsidetheviewingpane:" ) for i in range ( n ) : if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) : print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" ) if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) ) : print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" )

def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : if ( XY [ i ] [ 0 ] >= Xmin and ( XY [ i ] [ 0 ] <= Xmax ) ) : print ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) else : print ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] )

def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : if ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) : if ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) : if ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) : System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] )

13.29
19.32
68.92
56.14
static double largestSumOfAverages ( int [ ] A , int K ) { int n = A . length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }

def largestSumOfAverages ( A , K ) : n = len ( A ) pre_sum = [ 0 ] * ( n + 1 ) pre_sum [ 0 ] = 0 for i in range ( n ) : pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] dp = [ 0 ] * n sum = 0 for i in range ( n ) : dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) for k in range ( K - 1 ) : for i in range ( n ) : for j in range ( i + 1 , n ) : dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) return int ( dp [ 0 ] )

def largestSumOfAverages ( A , K ) : pre_sum = [ 0 for k in range ( K ) ] dp = [ 0 for k in range ( K ) ] sum = max ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) + dp [ j ] return dp [ 0 ]

def largestSumOfAverages ( A , K ) : pre_sum = [ 0 for k in range ( K ) ] pre_sum [ 0 ] = 0 for i in range ( n ) : pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] dp = [ n ] sum = 0 for i in range ( n ) : dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) for k in range ( k ) : for i in range ( i + 1 , n ) : dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) + dp [ j ] return dp [ 0 ]

13.33
17.61
50.74
44.18
static void findpath ( int [ ] [ ] graph , int n ) { Vector < Integer > numofadj = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) numofadj . add ( accumulate ( graph [ i ] , 0 ) ) ; int startPoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj . elementAt ( i ) % 2 == 1 ) { numofodd ++ ; startPoint = i ; } } if ( numofodd > 2 ) { System . out . println ( "No Solution" ) ; return ; } Stack < Integer > stack = new Stack < > ( ) ; Vector < Integer > path = new Vector < > ( ) ; int cur = startPoint ; while ( ! stack . isEmpty ( ) || accumulate ( graph [ cur ] , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , 0 ) == 0 ) { path . add ( cur ) ; cur = stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . add ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( int ele : path ) System . out . print ( ele + " -> " ) ; System . out . println ( cur ) ; }

def findpath ( graph ) : n = len ( graph ) numofadj = list ( ) for i in range ( n ) : numofadj . append ( sum ( graph [ i ] ) ) startpoint = 0 numofodd = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( numofadj [ i ] % 2 == 1 ) : numofodd += 1 startpoint = i if ( numofodd > 2 ) : print ( "NoSolution" ) return stack = list ( ) path = list ( ) cur = startpoint while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) : if ( sum ( graph [ cur ] ) == 0 ) : path . append ( cur + 1 ) cur = stack . pop ( - 1 ) else : for i in range ( n ) : if graph [ cur ] [ i ] == 1 : stack . append ( cur ) graph [ cur ] [ i ] = 0 graph [ i ] [ cur ] = 0 cur = i break for ele in path : print ( ele , "->" , end = '' ) print ( cur + 1 )

def findpath ( graph , n ) : numofadj = new Vector < Integer > ( ) for i in range ( n ) : if ( accumulate ( graph [ i ] , 0 ) == 1 ) : startPoint = i elif ( accumulate ( graph [ cur ] , 0 ) == 0 ) : numofodd = 1 path . add ( cur ) cur = stack . pop ( ) elif ( accumulate ( graph [ cur ] , 0 ) == 0 ) : path . add ( cur )

def findpath ( graph , n ) : numofadj = list ( ) for i in range ( n ) : numofadj . add ( accumulate ( graph [ i ] , 0 ) ) startPoint = 0 numofodd = 0 for i in range ( n ) : if numofadj [ i ] % 2 == 1 : numofodd += startPoint cur = startPoint while not stack . isEmpty ( ) or accumulate ( graph [ cur ] , 0 ) != 0 : if accumulate ( graph [ cur ] , 0 ) == 0 : path . add ( cur ) cur = stack . pop ( ) else : for i in range ( n ) : if graph [ cur ] [ i ] == 1 : stack . add ( cur ) graph [ cur ] [ i ] = 0 graph [ i ] [ cur ] = 0 cur = i break else : for i in range ( n ) : if graph [ cur ] [ i ] == 1 : stack . add ( cur ) graph [ cur ] [ i ] = 0 graph [ i ] [ cur ] = 0 cur = i break

13.46
23.4
71.58
62.17
static int minAdjustmentCost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }

def minAdjustmentCost ( A , n , target ) : dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] for j in range ( M + 1 ) : dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) for i in range ( 1 , n ) : for j in range ( M + 1 ) : dp [ i ] [ j ] = 100000000 for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) res = 10000000 for j in range ( M + 1 ) : res = min ( res , dp [ n - 1 ] [ j ] ) return res

def minAdjustmentCost ( A , M , target ) : dp = [ INT_MAX for i in range ( n ) ] for j in range ( 0 , M + 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ n - 1 ] [ j ] ) return res

def minAdjustmentCost ( A , n , target ) : dp = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) for j in range ( 1 , M ) : dp [ i ] [ j ] = max ( j - target , 0 ) for k in range ( max ( j - target , 0 ) ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) res = float ( 'inf' ) for j in range ( 0 , M ) : res = min ( res , dp [ n - 1 ] [ j ] ) return res

13.67
18.86
54.28
42.01
static String simplify ( String str ) { int len = str . length ( ) ; char res [ ] = new char [ len ] ; int index = 0 , i = 0 ; Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; while ( i < len ) { if ( str . charAt ( i ) == '+' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = '-' ; if ( s . peek ( ) == 0 ) res [ index ++ ] = '+' ; } else if ( str . charAt ( i ) == '-' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = '+' ; else if ( s . peek ( ) == 0 ) res [ index ++ ] = '-' ; } else if ( str . charAt ( i ) == '(' && i > 0 ) { if ( str . charAt ( i - 1 ) == '-' ) { int x = ( s . peek ( ) == 1 ) ? 0 : 1 ; s . push ( x ) ; } else if ( str . charAt ( i - 1 ) == '+' ) s . push ( s . peek ( ) ) ; } else if ( str . charAt ( i ) == ')' ) s . pop ( ) ; else res [ index ++ ] = str . charAt ( i ) ; i ++ ; } return new String ( res ) ; }

def simplify ( Str ) : Len = len ( Str ) res = [ None ] * Len index = 0 i = 0 s = [ ] s . append ( 0 ) while ( i < Len ) : if ( Str [ i ] == '+' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '-' index += 1 if ( s [ - 1 ] == 0 ) : res [ index ] = '+' index += 1 elif ( Str [ i ] == '-' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '+' index += 1 elif ( s [ - 1 ] == 0 ) : res [ index ] = '-' index += 1 elif ( Str [ i ] == '(' and i > 0 ) : if ( Str [ i - 1 ] == '-' ) : x = 0 if ( s [ - 1 ] == 1 ) else 1 s . append ( x ) elif ( Str [ i - 1 ] == '+' ) : s . append ( s [ - 1 ] ) elif ( Str [ i ] == ')' ) : s . pop ( ) else : res [ index ] = Str [ i ] index += 1 i += 1 return res

def simplify ( str ) : res = [ 0 for i in range ( len ) ] s = list ( ) for i in range ( len ) : if ( str [ i ] == '+' ) : res [ index ++ ] = '+' else : if ( str [ i ] == '-' ) : res [ index ++ ] = '-' elif ( str [ i ] == '(' ) : s . append ( 1 ) else : res [ index ++ ] = str [ i ] if ( i > 0 ) : s . pop ( )

def simplify ( str ) : res = [ 0 for i in range ( len ) ] s . append ( 0 ) while i < len : if ( str [ i ] == '+' ) : if ( s [ - 1 ] == 1 ) : res [ index ++ ] = '-' if ( s [ - 1 ] == 0 ) : res [ index ++ ] = '-' elif ( str [ i ] == '-' ) : if ( s [ - 1 ] == 1 ) : res [ index ++ ] = '+' else : res [ index ++ ] = '-' else : if ( str [ i - 1 ] == '(' and i > 0 ) : if ( str [ i - 1 ] == '-' ) : x = ( s [ - 1 ] == 1 ) ? 0 : 1 s . push ( x ) else : if ( str [ i - 1 ] == '+' ) : s . push ( s . peek ( ) ) else : if ( str [ i - 1 ] == ')' ) : s . pop ( ) else : res [ index ++ ] = str . charAt ( i ) i ++

13.68
34.09
50.99
45.18
static void drawPattern ( int N ) { int n = N ; int row = 1 ; int nst = 1 ; int nsp1 = n - 1 ; int nsp2 = - 1 ; int val1 = row ; int val2 = 1 ; while ( row <= n ) { int csp1 = 1 ; while ( csp1 <= nsp1 ) { System . out . print ( " " ) ; csp1 = csp1 + 1 ; } int cst1 = 1 ; while ( cst1 <= nst ) { System . out . print ( val1 + " " ) ; val1 = val1 - 1 ; cst1 = cst1 + 1 ; } int csp2 = 1 ; while ( csp2 <= nsp2 ) { System . out . print ( " " ) ; csp2 = csp2 + 1 ; } if ( row != 1 && row != n ) { int cst2 = 1 ; while ( cst2 <= nst ) { System . out . print ( val2 + " " ) ; val2 = val2 + 1 ; cst2 = cst2 + 1 ; } } System . out . println ( ) ; if ( row <= n / 2 ) { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 + 2 ; val1 = row + 1 ; val2 = 1 ; } else { nst = nst - 1 ; nsp1 = nsp1 + 2 ; nsp2 = nsp2 - 2 ; val1 = n - row ; val2 = 1 ; } row = row + 1 ; } }

def drawPattern ( N ) : n = N row = 1 nst = 1 nsp1 = n - 1 nsp2 = - 1 val1 = row val2 = 1 while ( row <= n ) : csp1 = 1 while ( csp1 <= nsp1 ) : print ( "" , end = "" ) csp1 = csp1 + 1 cst1 = 1 while ( cst1 <= nst ) : print ( val1 , end = "" ) val1 = val1 - 1 cst1 = cst1 + 1 csp2 = 1 while ( csp2 <= nsp2 ) : print ( "" , end = "" ) csp2 = csp2 + 1 if ( row != 1 and row != n ) : cst2 = 1 while ( cst2 <= nst ) : print ( val2 , end = "" ) val2 = val2 + 1 cst2 = cst2 + 1 print ( ) if ( row <= n // 2 ) : nst = nst + 1 nsp1 = nsp1 - 2 nsp2 = nsp2 + 2 val1 = row + 1 val2 = 1 else : nst = nst - 1 nsp1 = nsp1 + 2 nsp2 = nsp2 - 2 val1 = n - row val2 = 1 row = row + 1

def drawPattern ( N ) : n = N * 2 nst = 1 nsp1 = - 1 nsp2 = - 1 val1 = row val2 = 1 row = 1 while ( row <= n ) : csp1 = 1 while ( csp1 <= nsp1 ) : val1 = val1 - 1 cst1 = cst1 + 1 csp2 = 1 while ( cst2 <= nst ) : val2 = val2 + 1 cst2 =

def drawPattern ( N ) : nst = nst nsp1 = nsp1 + 2 nsp2 = nsp2 + 2 val1 = row + 1 val2 = 1 while ( row <= n ) : csp1 = 1 while ( csp1 <= nsp1 ) : print ( val1 + " " ) val1 = val1 - 1 cst1 = cst1 + 1 csp2 = csp2 + 1 if row != 1 and row != n : cst2 = 1 while ( cst2 <= nsp2 ) : print ( val2 + " " ) val2 = val2 + 1 cst2 = cst2 + 1 row = n while ( row <= n ) : csp1 = 1 while ( csp1 <= nsp1 ) : print ( val1 + " " ) val1 = val1 - 1 cst1 = cst1 + 1 csp2 = 1 while ( cst2 <= nsp2 ) : print ( val2 + " " ) val2 = val2 + 1 cst2 = cst2 + 1 print ( )

13.81
22.92
12.18
23.71
private static String printNumbers ( int [ ] numbers ) { ArrayList < Integer > array = new ArrayList < > ( ) ; for ( int number : numbers ) { if ( findContainsOneTwoThree ( number ) ) array . add ( number ) ; } Collections . sort ( array ) ; StringBuffer strbuf = new StringBuffer ( ) ; Iterator it = array . iterator ( ) ; while ( it . hasNext ( ) ) { int value = ( int ) it . next ( ) ; if ( strbuf . length ( ) > 0 ) strbuf . append ( ", " ) ; strbuf . append ( Integer . toString ( value ) ) ; } return ( strbuf . length ( ) > 0 ) ? strbuf . toString ( ) : "-1" ; }

def printNumbers ( numbers ) : numbers = map ( str , numbers ) result = [ ] for num in numbers : if ( '1' in num and '2' in num and '3' in num ) : result . append ( num ) if not result : result = [ '-1' ] return sorted ( result ) ;

def printNumbers ( numbers ) : array = list ( ) for number in numbers : if ( findContainsOneTwoThree ( number ) ) : array . add ( number ) else : array . add ( number ) strbuf = new StringBuffer ( ) for it in array : if ( it . hasNext ( ) ) : strbuf . append ( ", " ) print ( value ) return ( strbuf . length ( ) > 0 ) ? strbuf . toString ( ) : "-1"

def printNumbers ( numbers ) : array = list ( ) for number in numbers : if findContainsOneTwoThree ( number ) : array . add ( number ) sort ( array ) strbuf = list ( ) for it in array : value = ( int ) it . next ( ) if ( strbuf . length ( ) > 0 ) : strbuf . append ( ", " ) strbuf . append ( value ) return ( strbuf . length ( ) > 0 ) ? strbuf . toString ( ) : "-1"

13.99
35.5
43.52
45.82
static int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }

def getMissingNo ( A ) : n = len ( A ) total = ( n + 1 ) * ( n + 2 ) / 2 sum_of_A = sum ( A ) return total - sum_of_A

def getMissingNo ( a , n ) : total = 0 for i in range ( n ) : total -= a [ i ] for i in range ( n + 1 , n + 2 ) : total -= a [ i ] for i in range ( n + 1 ) : total -= a [ i ] for i in range ( n + 2 ) : total -= a [ i ] return total

def getMissingNo ( a , n ) : total = ( n + 1 ) * ( n + 2 ) / 2 for i in range ( 0 , n ) : total -= a [ i ] return total

14.23
12.24
58.91
41.95
static boolean areAnagram ( char [ ] str1 , char [ ] str2 ) { int n1 = str1 . length ; int n2 = str2 . length ; if ( n1 != n2 ) return false ; Arrays . sort ( str1 ) ; Arrays . sort ( str2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; }

def areAnagram ( str1 , str2 ) : n1 = len ( str1 ) n2 = len ( str2 ) if n1 != n2 : return 0 str1 = sorted ( str1 ) str2 = sorted ( str2 ) for i in range ( 0 , n1 ) : if str1 [ i ] != str2 [ i ] : return 0 return 1

def areAnagram ( str1 , str2 ) : n1 = str1 . length n2 = str2 . length if ( n1 != n2 ) : return false ; return true

def areAnagram ( str1 , str2 ) : n1 = str1 . length n2 = str2 . length if n1 != n2 : return False sort ( str1 ) sort ( str2 ) for i in range ( 0 , n1 ) : if ( str1 [ i ] != str2 [ i ] ) : return False return True

14.3
17.56
60.51
43.24
static int find_maximum ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . min ( 1 + i , n - i ) ; if ( ! b . containsKey ( x ) ) b . put ( x , d ) ; else { b . put ( x , Math . min ( d , b . get ( x ) ) ) ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ; } return ans ; }

def find_maximum ( a , n , k ) : b = dict ( ) for i in range ( n ) : x = a [ i ] d = min ( 1 + i , n - i ) if x not in b . keys ( ) : b [ x ] = d else : b [ x ] = min ( d , b [ x ] ) ans = 10 ** 9 for i in range ( n ) : x = a [ i ] if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) return ans

def find_maximum ( a , n , k ) : b = new HashMap < Integer , Integer > ( ) for i in range ( 0 , n ) : if ( x != k - x ) : b . put ( x , min ( d , b . get ( x ) ) ) return ans

def find_maximum ( a , n , k ) : b = { } for i in range ( n ) : x = a [ i ] d = min ( 1 + i , n - i ) if not b . containsKey ( x ) : b . put ( x , d ) else : b . put ( x , min ( d , b . get ( x ) ) ) ans = float ( 'inf' ) for i in range ( n ) : x = a [ i ] if x != k - x and b . containsKey ( k - x ) : ans = min ( max ( b . get ( x ) , b . get ( k - x ) ) , ans ) return ans

14.31
19.52
39.01
36.47
static char [ ] replaceSpaces ( char [ ] str ) { int space_count = 0 , i = 0 ; for ( i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == ' ' ) space_count ++ ; while ( str [ i - 1 ] == ' ' ) { space_count -- ; i -- ; } int new_length = i + space_count * 2 ; if ( new_length > MAX ) return str ; int index = new_length - 1 ; char [ ] new_str = str ; str = new char [ new_length ] ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( new_str [ j ] == ' ' ) { str [ index ] = '0' ; str [ index - 1 ] = '2' ; str [ index - 2 ] = '%' ; index = index - 3 ; } else { str [ index ] = new_str [ j ] ; index -- ; } } return str ; }

def replaceSpaces ( string ) : string = string . strip ( ) i = len ( string ) space_count = string . count ( '' ) new_length = i + space_count * 2 if new_length > MAX : return - 1 index = new_length - 1 string = list ( string ) for f in range ( i - 2 , new_length - 2 ) : string . append ( '0' ) for j in range ( i - 1 , 0 , - 1 ) : if string [ j ] == '' : string [ index ] = '0' string [ index - 1 ] = '2' string [ index - 2 ] = '%' index = index - 3 else : string [ index ] = string [ j ] index -= 1 return '' . join ( string )

def replaceSpaces ( str ) : space_count = 0 for i in range ( len ( str ) ) : if ( str [ i ] == ' ' ) : space_count += 1 if ( str [ i - 1 ] == ' ' ) : space_count -= 1 new_length = i + space_count * 2 if ( new_str [ i ] == ' ' ) : str [ index ] = '0' str [ index - 1 ] = '2

def replaceSpaces ( str ) : space_count = 0 i = 0 for i in range ( len ( str ) ) : if ( str [ i ] == ' ' ) : space_count ++ while ( str [ i - 1 ] == ' ' ) : space_count -- i -- : new_length = i + space_count * 2 if new_length > MAX : return str index = new_length - 1 new_str = str str = new char [ new_length ] for j in i - 1 : if ( new_str [ j ] == ' ' ) : str [ index ] = '0' ; str [ index - 1 ] = '2' str [ index - 2 ] = '%' index = index - 3 else : str [ index ] = new_str [ j ] index -- return str

14.71
20.76
52.05
42.44
static int countEndless ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] ; boolean col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }

def countEndless ( input_mat , n ) : row = np . zeros ( ( n , n ) ) col = np . zeros ( ( n , n ) ) for j in range ( n ) : isEndless = 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 col [ i ] [ j ] = isEndless for i in range ( n ) : isEndless = 1 for j in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 row [ i ] [ j ] = isEndless ans = 0 for i in range ( n ) : for j in range ( 1 , n ) : if ( row [ i ] [ j ] and col [ i ] [ j ] ) : ans += 1 return ans

def countEndless ( input , n ) : row = [ False for k in range ( n ) ] col = [ False for k in range ( n ) ] for i in range ( n ) : if ( input [ i ] [ j ] == false ) isEndless = false row [ i ] [ j ] = isEndless col [ i ] [ j ] = isEndless return ans

def countEndless ( input , n ) : row = [ False for i in range ( n ) ] col = [ False for i in range ( n ) ] for j in range ( n ) : isEndless = True for i in range ( n ) : if ( input [ i ] [ j ] == false ) : isEndless = false row [ i ] [ j ] = isEndless col [ i ] [ j ] = isEndless } ans = 0 for i in range ( 0 , n ) : for j in range ( 1 , n ) : if ( row [ i ] [ j ] and col [ i ] [ j ] ) : ans += 1 return ans

14.78
14.15
10.38
13.81
static int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }

def countPaths ( n , m ) : if ( n == 0 or m == 0 ) : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )

def countPaths ( n , m ) : dp = [ 1 ] * ( n + 1 ) for i in range ( 1 , n + 1 , m + 1 ) : dp [ i ] = [ 1 , 1 ] for j in range ( 1 , n , m ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] return dp [ n ] [ m ]

def countPaths ( n , m ) : dp = [ 0 for i in range ( n ) ] for i in range ( n + 1 , m + 1 ) : dp [ i ] [ 0 ] = 1 for i in range ( 0 , n , m ) : dp [ 0 ] [ i ] = 1 for i in range ( 1 , n , i ) : dp [ i ] [ i ] = 1 for i in range ( 1 , n , i ) : for j in range ( 1 , m ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] return dp [ n ] [ m ]

14.85
24.07
36.26
43.11
static int arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 1 || n == 0 ) return 1 ; if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0 ; return arraySortedOrNot ( arr , n - 1 ) ; }

def arraySortedOrNot ( arr ) : n = len ( arr ) if n == 1 or n == 0 : return True return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] )

def arraySortedOrNot ( arr , n ) : if ( n == 0 ) : return 0 return arraySortedOrNot ( arr , n - 1 )

def arraySortedOrNot ( arr , n ) : if n == 1 or n == 0 : return 1 if arr [ n - 1 ] < arr [ n - 2 ] : return 0 return arraySortedOrNot ( arr , n - 1 )

14.88
29.55
100.0
100.0
static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }

def surface_area_octahedron ( side ) : return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) )

def surface_area_octahedron ( side ) : return ( surface_area_octahedron

def surface_area_octahedron ( side ) : return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) )

15.89
24.81
43.05
38.0
static int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == '} ' && ! s . empty ( ) ) { if ( s . peek ( ) == '{ ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == '{ ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } public static void main ( String [ ] args ) { String expr = " } }

def countMinReversals ( expr ) : lenn = len ( expr ) if ( lenn % 2 ) : return - 1 s = [ ] for i in range ( lenn ) : if ( expr [ i ] == '' and len ( s ) ) : if ( s [ 0 ] == '' ) : s . pop ( 0 ) else : s . insert ( 0 , expr [ i ] ) else : s . insert ( 0 , expr [ i ] ) red_len = len ( s ) n = 0 while ( len ( s ) and s [ 0 ] == '' ) : s . pop ( 0 ) n += 1 return ( red_len // 2 + n % 2 )

def countMinReversals ( expr ) : len = expr . length ( ) s = list ( ) for i in range ( len ) : c = expr [ i ] if ( c == '}' : s . append ( c ) else : s . append ( c ) red_len = len % 2 + n % 2 return ( red_len / 2 + n % 2 )

def countMinReversals ( expr ) : len = expr . length ( ) if len % 2 != 0 : return - 1 s = list ( ) for i in range ( len ) : c = expr [ i ] if ( c == '} ' and not s . empty ( ) ) : if ( s [ i ] == '{' ) : s . pop ( ) else : s . append ( c ) else : s . append ( c ) red_len = s . size ( ) n = 0 while not s . empty ( ) and s [ i ] == '{ ' : s . pop ( ) n += 1 print ( red_len / 2 + n % 2 )

15.94
23.41
27.99
33.94
boolean canRepresentBST ( int pre [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; int root = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( pre [ i ] < root ) { return false ; } while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) { root = s . peek ( ) ; s . pop ( ) ; } s . push ( pre [ i ] ) ; } return true ; }

def canRepresentBST ( pre ) : s = [ ] root = INT_MIN for value in pre : if value < root : return False while ( len ( s ) > 0 and s [ - 1 ] < value ) : root = s . pop ( ) s . append ( value ) return True

def canRepresentBST ( pre , n ) : s = list ( ) for i in range ( n ) : if ( pre [ i ] < root ) : return false root = pre [ i ] for i in range ( n ) : if ( pre [ i ] > root ) : return false

def canRepresentBST ( pre , n ) : s = list ( ) root = INT . MIN_VALUE for i in range ( n ) : if ( pre [ i ] < root ) : return False while ( not s . empty ( ) and s . peek ( ) < pre [ i ] ) : root = s . peek ( ) s . pop ( ) s . append ( pre [ i ] ) s . push ( pre [ i ] ) return True

16.03
28.53
77.39
69.87
static double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }

def areaOctagon ( side ) : return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side )

def areaOctagon ( side ) : return area ( side )

def areaOctagon ( side ) : return ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side

16.21
23.04
73.45
60.98
private static int minJumps ( int [ ] arr , int n ) { int jumps [ ] = new int [ n ] ; int i , j ; if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE ; jumps [ 0 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) { jumps [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX_VALUE ) { jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } } return jumps [ n - 1 ] ; }

def minJumps ( arr , n ) : jumps = [ 0 for i in range ( n ) ] if ( n == 0 ) or ( arr [ 0 ] == 0 ) : return float ( 'inf' ) jumps [ 0 ] = 0 for i in range ( 1 , n ) : jumps [ i ] = float ( 'inf' ) for j in range ( i ) : if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) : jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) break return jumps [ n - 1 ]

def minJumps ( arr , n ) : jumps = [ INT_MAX for k in range ( n ) ] for i in range ( 1 , n ) : if ( i == 0 || arr [ 0 ] == 0 ) : return jumps [ 0 ]

def minJumps ( arr , n ) : jumps = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : jumps [ i ] = 0 for i in range ( 1 , n ) : jumps [ i ] = float ( 'inf' ) for j in range ( i ) : if i <= j + arr [ j ] and jumps [ j ] != float ( 'inf' ) : jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) break return jumps [ n - 1 ]

16.27
18.8
15.43
19.11
static String reversingString ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . valueOf ( str ) ; }

def reversingString ( str , start , end ) : while ( start < end ) : str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) start += 1 end -= 1 return str

def reversingString ( str , start , end ) : while ( start < end ) : str [ end ] ^= str [ start ] str [ start ] ^= str [ end ] str [ end ] ^= str [ start ] return String . valueOf ( str [ start : end ] )

def reversingString ( str , start , end ) : while start < end : str [ start ] ^= str [ end ] str [ end ] ^= str [ start ] str [ end ] ^= str [ start ] str [ start ] ^= str [ end ] ++ start -- end return string . valueOf ( str )

16.46
14.12
39.3
23.65
static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }

def power ( x , y ) : if ( y == 0 ) : return 1 elif ( int ( y % 2 ) == 0 ) : return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) else : return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) )

def power ( x , y ) : if ( y == 1 ) : return x * power ( x , y ) else : return x * power ( x , y )

def power ( x , y ) : if y == 0 : return 1 else : if y % 2 == 0 : return power ( x , y / 2 ) * power ( x , y / 2 ) else : return x * power ( x , y ) * power ( x , y )

16.48
19.56
77.68
56.49
static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }

def binaryToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while ( temp ) : last_digit = temp % 10 temp = int ( temp / 10 ) dec_value += last_digit * base base = base * 2 return dec_value

def binaryToDecimal ( n ) : num = n * 2 dec_value = 0 base = 1 return dec_value

def binaryToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while temp > 0 : last_digit = temp % 10 temp = temp / 10 dec_value += last_digit * base base = base * 2 return dec_value

16.62
24.89
21.09
21.59
static void substringConversions ( String str , int k , int b ) { int i = 0 , sum = 0 , counter = k - 1 ; for ( i = 0 ; i < k ; i ++ ) { sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter -- ; } System . out . print ( sum + " " ) ; int prev = sum ; sum = 0 ; counter = 0 ; for ( ; i < str . length ( ) ; i ++ ) { sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) * Math . pow ( b , k - 1 ) ) ) ; sum = sum * b ; sum = sum + ( str . charAt ( i ) - '0' ) ; System . out . print ( sum + " " ) ; prev = sum ; counter ++ ; } }

def substringConversions ( str1 , k , b ) : for i in range ( 0 , len ( str1 ) - k + 1 ) : sub = str1 [ i : k + i ] Sum = 0 counter = 0 for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) counter += 1 print ( Sum , end = "" )

def substringConversions ( str , k , b ) : sum = 0 counter = k - 1 for i in range ( k ) : sum = sum + ( str [ i ] - '0' ) * Math . pow ( b , counter ) ) prev = sum sum = sum * b prev = sum sum = sum + ( str [ i - k ] - '0' ) System . out . print ( prev + " " ) prev = sum sum = sum * b sum = sum + ( str [ i ] - '0' sum = sum + ( str [ i - k ] - '0' counter = k - 1 for i in range ( k ) : sum = sum + ( str [ i ] - '0' ) print ( sum + " " ) prev = sum sum = sum * b prev = sum + ( str [ i - k ] - '0' ) System . out . print ( prev

def substringConversions ( str , k , b ) : sum = 0 counter = k - 1 for i in range ( k ) : sum = ( float ( prev - ( ( str [ i - k ] - '0' ) * Math . pow ( b , k - 1 ) ) ) sum = sum * b sum = sum + ( str [ i ] - '0' ) prev = sum counter ++

17.16
30.94
100.0
100.0
static double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }

def sumOfSeries ( n ) : return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) )

def sumOfSeries ( n ) : return 0.0246 * n

def sumOfSeries ( n ) : return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) )

17.17
28.17
28.28
40.07
public static void cycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle_start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle_start ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } }

def cycleSort ( array ) : writes = 0 for cycleStart in range ( 0 , len ( array ) - 1 ) : item = array [ cycleStart ] pos = cycleStart for i in range ( cycleStart + 1 , len ( array ) ) : if array [ i ] < item : pos += 1 if pos == cycleStart : continue while item == array [ pos ] : pos += 1 array [ pos ] , item = item , array [ pos ] writes += 1 while pos != cycleStart : pos = cycleStart for i in range ( cycleStart + 1 , len ( array ) ) : if array [ i ] < item : pos += 1 while item == array [ pos ] : pos += 1 array [ pos ] , item = item , array [ pos ] writes += 1 return writes

def cycleSort ( arr , n ) : writes = 0 for cycle_start in range ( n ) : item = arr [ cycle_start ] pos = cycle_start for i in range ( cycle_start + 1 , n ) : if ( arr [ i ] < item ) : pos += 1 while ( item == arr [ pos ] ) : pos += 1 if ( pos != cycle_start ) : int temp = item ; item = arr [ pos ] write ( writes )

def cycleSort ( arr , n ) : writes = 0 for cycle_start in range ( n ) : item = arr [ cycle_start ] pos = cycle_start for i in range ( cycle_start + 1 , n ) : if ( arr [ i ] < item ) : pos += 1 while ( item == arr [ pos ] ) : pos += 1 if ( pos != cycle_start ) : item = arr [ pos ] arr [ pos ] = temp writes ++ if pos != cycle_start : while ( item != arr [ pos ] ) : item = arr [ pos ] arr [ pos ] = temp writes += } while pos != cycle_start : pos = cycle_start for i in range ( cycle_start + 1 , n ) : if ( arr [ i ] < item ) : pos += 1 while ( item == arr [ pos ] ) : pos += 1 if ( item != arr [ pos ] ) : item = arr [ pos ] arr [ pos ] = temp writes ++

17.2
16.13
83.42
81.8
static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }

def Add ( x , y ) : while ( y != 0 ) : carry = x & y x = x ^ y y = carry << 1 return x

def Add ( x , y ) : x |= y ; return x

def Add ( x , y ) : while y != 0 : carry = x & y x = x ^ y y = carry << 1 return x

17.27
14.24
28.2
25.8
static int sumAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == '(' ) { if ( tree . charAt ( i ) == ')' ) return 0 ; int sum = 0 ; if ( level == k ) sum = tree . charAt ( i ) - '0' ; ++ i ; int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return sum + leftsum + rightsum ; } return Integer . MIN_VALUE ; }

def sumAtKthLevel ( tree , k , i , level ) : if ( tree [ i [ 0 ] ] == '(' ) : i [ 0 ] += 1 if ( tree [ i [ 0 ] ] == ')' ) : return 0 sum = 0 if ( level == k ) : sum = int ( tree [ i [ 0 ] ] ) i [ 0 ] += 1 leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) i [ 0 ] += 1 rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) i [ 0 ] += 1 return sum + leftsum + rightsum

def sumAtKthLevel ( tree , k , level ) : if ( level == k ) : return 0 if ( level == k ) : return sumAtKthLevel ( tree , k , level + 1 ) else : return sumAtKthLevel ( tree , k , level + 1 )

def sumAtKthLevel ( tree , k , level ) : sum = 0 if level == k : sum = 0 if level == k : sum = tree [ i ] - '0' ++ i leftsum = sumAtKthLevel ( tree , k , level + 1 ) ++ i rightsum = sumAtKthLevel ( tree , k , level + 1 ) ++ i return sum + leftsum + rightsum

17.3
25.7
91.0
74.33
static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; }

def countOps ( A , B , m , n ) : for i in range ( n ) : for j in range ( m ) : A [ i ] [ j ] -= B [ i ] [ j ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : return - 1 result = 0 for i in range ( n ) : result += abs ( A [ i ] [ 0 ] ) for j in range ( m ) : result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) return ( result )

def countOps ( A , B , m , n ) : A . sort ( reverse = True ) B . sort ( reverse = True ) result = 0 for i in range ( 0 , n ) : result += Math . abs ( A [ i ] [ j ] - A [ 0 ] [ 0 ] ) return ( result )

def countOps ( A , B , m , n ) : for i in range ( n ) : for j in range ( m ) : A [ i ] [ j ] -= B [ i ] [ j ] for i in range ( 1 , n ) : if ( A [ i ] [ j ] - A [ i ] [ j ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : return - 1 result = 0 for i in range ( 0 , n ) : result += abs ( A [ i ] [ 0 ] ) for j in range ( 0 , m ) : result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) return ( result )

17.51
30.71
76.79
74.86
static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }

def findMaximumPieces ( n ) : return int ( 1 + n * ( n + 1 ) / 2 )

def findMaximumPieces ( n ) : return n

def findMaximumPieces ( n ) : return 1 + n * ( n + 1 ) / 2

17.73
20.71
77.68
56.49
static int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }

def octalToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while ( temp ) : last_digit = temp % 10 temp = int ( temp / 10 ) dec_value += last_digit * base base = base * 8 return dec_value

def octalToDecimal ( n ) : num = n % 10 ; dec_value = 0 base = 1 return dec_value

def octalToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while temp > 0 : last_digit = temp % 10 temp = temp / 10 dec_value += last_digit * base base = base * 8 return dec_value

17.84
30.67
32.59
26.98
static void reverseStr ( String str ) { int n = str . length ( ) ; char [ ] ch = str . toCharArray ( ) ; char temp ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; } System . out . println ( ch ) ; }

def reverseStr ( str ) : n = len ( str ) i , j = 0 , n - 1 while i < j : str [ i ] , str [ j ] = str [ j ] , str [ i ] i += 1 j -= 1

def reverseStr ( str ) : n = len ( str ) for i in range ( n ) : j = n - 1 while i < j : temp = ch [ i ] ch [ i ] = ch [ j ] temp = ch [ i ] ch [ j ] = temp i = 0 j = n - 1 while i < j : temp = ch [ i ] ch [ i ] = ch [ j ] ch [ j ] = temp i += 1 ch [ i ] = ch [ j ] if ( temp ) : ch [ i ] = ch [ j ] if ( temp != ch [ i ] ) : ch [ i ] = ch [ j ] temp = ch [ i ] ch [ j ] = temp return ch

def reverseStr ( str ) : n = str . length ( ) ch = str . toCharArray ( ) for i in range ( 0 , n - 1 , - 1 ) : temp = ch [ i ] ch [ i ] = ch [ j ] ch [ j ] = temp

18.01
26.0
23.41
32.83
static int findSum ( int [ ] A , int [ ] B , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . containsKey ( A [ i ] ) ) hash . put ( A [ i ] , 1 + hash . get ( A [ i ] ) ) ; else hash . put ( A [ i ] , 1 ) ; if ( hash . containsKey ( B [ i ] ) ) hash . put ( B [ i ] , 1 + hash . get ( B [ i ] ) ) ; else hash . put ( B [ i ] , 1 ) ; } int sum = 0 ; for ( Map . Entry entry : hash . entrySet ( ) ) { if ( Integer . parseInt ( ( entry . getValue ( ) ) . toString ( ) ) == 1 ) sum += Integer . parseInt ( ( entry . getKey ( ) ) . toString ( ) ) ; } return sum ; }

def findSum ( A , B , n ) : Hash = defaultdict ( lambda : 0 ) for i in range ( 0 , n ) : Hash [ A [ i ] ] += 1 Hash [ B [ i ] ] += 1 Sum = 0 for x in Hash : if Hash [ x ] == 1 : Sum += x return Sum

def findSum ( A , B , n ) : hash = new HashMap < Integer , Integer > ( ) for i in range ( n ) : if ( hash . containsKey ( A [ i ] ) ) : hash . put ( A [ i ] , 1 + hash . get ( A [ i ] ) ) else : hash . put ( A [ i ] , 1 ) if ( hash . containsKey ( B [ i ] ) ) : hash . put ( B [ i ] , 1 ) if ( hash . containsKey ( B [ i ] ) : hash . put ( B [ i ] , 1 ) return sum

def findSum ( A , B , n ) : hash = new HashMap ( ) for i in range ( n ) : if ( hash . containsKey ( A [ i ] ) ) : hash [ A [ i ] ] = 1 + hash [ A [ i ] ] else : hash [ A [ i ] ] = 1 sum = 0 for entry in hash . entrySet ( ) : if ( Integer . parseInt ( ( entry . getValue ( ) ) ) == 1 ) : sum += Integer . parseInt ( ( entry . getKey ( ) ) ) return sum

18.16
27.27
40.72
37.94
public static void checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; boolean flag = false ; int i = 0 ; while ( i * i <= ab ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { double l = Math . sqrt ( ab - ( i * i + j * j + k * k ) ) ; if ( Math . floor ( l ) == Math . ceil ( l ) && l >= k ) { flag = true ; System . out . print ( "i = " + i + "\n" ) ; System . out . print ( "j = " + j + "\n" ) ; System . out . print ( "k = " + k + "\n" ) ; System . out . print ( "l = " + ( int ) l + "\n" ) ; System . out . print ( "Product of " + a + " and " + b + " can be written as sum of squares" + " of i, j, k, l \n" ) ; System . out . print ( ab + " = " + i + "*" + i + " + " + j + "*" + j + " + " + k + "*" + k + " + " + ( int ) l + "*" + ( int ) l + "\n" ) ; } k += 1 ; } j += 1 ; } i += 1 ; } if ( flag == false ) { System . out . println ( "Solution doesn't exist!" ) ; return ; } }

def checkEulerFourSquareIdentity ( a , b ) : ab = a * b flag = False i = 0 while i * i <= ab : j = i while i * i + j * j <= ab : k = j while i * i + j * j + k * k <= ab : l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) if l == int ( l ) and l >= k : flag = True print ( "i=" , i ) print ( "j=" , j ) print ( "k=" , k ) print ( "l=" , l ) print ( "Productof" , a , "and" , b , "canbewrittenassumofsquaresofi,j,k,l" ) print ( ab , "=" , i , "*" , i , "+" , j , "*" , j , "+" , k , "*" , k , "+" , l , "*" , l ) k += 1 j += 1 i += 1 if flag == False : print ( "Solutiondoesn'texist!" ) return

def checkEulerFourSquareIdentity ( a , b ) : ab = a * b for i in range ( a , b ) : while ( i * i + j * j + k * k <= ab ) : l = abs ( ab - ( i * i + j * j + k * k ) ) flag = true print ( "i = " + i + "\n" ) print ( "j = " + j + "\n" ) print ( " k =

def checkEulerFourSquareIdentity ( a , b ) : ab = a * b i = 0 while i * i <= ab ) : j = i while i * i + j * j + k <= ab : l = abs ( ab - ( i * i + j * j + k * k ) ) if ( math . floor ( l ) == math . ceil ( l ) and l >= k ) : flag = True ; System . out . print ( "i = " + i + "\n" ) System . out . print ( "j = " + j + "\n" ) System . out . print ( "k = " + k + "\n" ) System . out . print ( "l = " + ( int ) l + "\n" ) i += 1 j += 1 k += 1 if i * i + j * j + k * k <= ab : k = j while i * i + j * j + k * k <= ab : l = abs ( ab - ( i * i + j * j + k * k ) ) if ( math . floor ( l ) == math . ceil ( l ) ) : flag = True

18.4
24.68
64.15
63.14
static void counterClockspiralPrint ( int m , int n , int arr [ ] [ ] ) { int i , k = 0 , l = 0 ; int cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) break ; for ( i = k ; i < m ; ++ i ) { System . out . print ( arr [ i ] [ l ] + " " ) ; cnt ++ ; } l ++ ; if ( cnt == total ) break ; for ( i = l ; i < n ; ++ i ) { System . out . print ( arr [ m - 1 ] [ i ] + " " ) ; cnt ++ ; } m -- ; if ( cnt == total ) break ; if ( k < m ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( arr [ i ] [ n - 1 ] + " " ) ; cnt ++ ; } n -- ; } if ( cnt == total ) break ; if ( l < n ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( arr [ k ] [ i ] + " " ) ; cnt ++ ; } k ++ ; } } }

def counterClockspiralPrint ( m , n , arr ) : k = 0 l = 0 cnt = 0 total = m * n while ( k < m and l < n ) : if ( cnt == total ) : break for i in range ( k , m ) : print ( arr [ i ] [ l ] , end = "" ) cnt += 1 l += 1 if ( cnt == total ) : break for i in range ( l , n ) : print ( arr [ m - 1 ] [ i ] , end = "" ) cnt += 1 m -= 1 if ( cnt == total ) : break if ( k < m ) : for i in range ( m - 1 , k - 1 , - 1 ) : print ( arr [ i ] [ n - 1 ] , end = "" ) cnt += 1 n -= 1 if ( cnt == total ) : break if ( l < n ) : for i in range ( n - 1 , l - 1 , - 1 ) : print ( arr [ k ] [ i ] , end = "" ) cnt += 1 k += 1

def counterClockspiralPrint ( m , n , arr ) : cnt = 0 for k in range ( m , n ) : for i in range ( k , l ) : print ( arr [ i ] [ l ] + " " ) cnt ++ if ( cnt == total ) break for i in range ( l , n ) : print ( arr [ i ] [ n - 1 ] + " " ) cnt ++ if ( cnt == total ) break for i in range

def counterClockspiralPrint ( m , n , arr ) : cnt = 0 for k in range ( m ) : if ( cnt == total ) : break for i in range ( m ) : print ( arr [ i ] [ l ] , end = "" ) l += 1 if ( cnt == total ) : break if ( k < m ) : for i in range ( m ) : print ( arr [ i ] [ l ] , end = "" ) m -- if ( cnt == total ) : break if ( l < n ) : for i in range ( n ) : print ( arr [ i ] [ l ] , end = "" ) k += 1 if ( cnt == total ) : break if ( l < n ) : for i in range ( n ) : print ( arr [ k ] [ i ] , end = "" ) l += 1 if ( cnt == total ) : break if ( l < n ) : for i in range ( n ) : print ( arr [ k ] [ i ] , end = "" ) k += 1 if ( cnt == total ) : break

18.5
10.89
78.07
48.38
static boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }

def isDiagonalMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False return True

def isDiagonalMatrix ( mat , N ) : if ( mat [ 0 ] [ 0 ] != 0 ) : return false return true

def isDiagonalMatrix ( mat ) : for i in range ( N ) : for j in range ( N ) : if ( i != j ) and ( mat [ i ] [ j ] != 0 ) : return False return True

18.6
11.62
71.81
78.06
static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }

def isPrime ( n ) : if n <= 1 : return False for i in range ( 2 , n ) : if n % i == 0 : return False return True

def isPrime ( n ) : if ( n <= 2 ) : return false return true

def isPrime ( n ) : if ( n <= 1 ) : return False for i in range ( 2 , n ) : if ( n % i == 0 ) : return False return True

18.73
21.91
14.97
17.99
static int findLength ( String str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int lsum = 0 , rsum = 0 ; while ( r < n && l >= 0 ) { lsum += str . charAt ( l ) - '0' ; rsum += str . charAt ( r ) - '0' ; if ( lsum == rsum ) { ans = Math . max ( ans , r - l + 1 ) ; } l -- ; r ++ ; } } return ans ; }

def findLength ( st , n ) : total = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ans = 0 l = 2 while ( l <= n ) : for i in range ( n - l + 1 ) : j = i + l - 1 if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : ans = max ( ans , l ) l = l + 2 return ans

def findLength ( str , n ) : ans = 0 for i in range ( n - 2 , - 1 , - 1 ) : lsum = 0 rsum = 0 for i in range ( n - 2 , - 1 ) : lsum += str [ l ] rsum += str [ r ] l -= 1 r += 1 if ( lsum == rsum ) : ans = max ( ans , r - l + 1 ) return ans

def findLength ( str , n ) : ans = 0 for i in range ( n ) : l = i r = i + 1 lsum = 0 rsum = 0 while r < n and l >= 0 : lsum += str [ l ] - '0' rsum += str [ r ] - '0' if lsum == rsum : ans = max ( ans , r - l + 1 ) l -- r ++ return ans

18.75
30.13
44.78
40.52
static int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ ] = new int [ M ] ; Arrays . fill ( h , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }

def countSubSeq ( A , N , M ) : ans = 0 h = [ 0 ] * M for i in range ( 0 , N ) : A [ i ] = A [ i ] % M h [ A [ i ] ] = h [ A [ i ] ] + 1 for i in range ( 0 , M ) : for j in range ( i , M ) : rem = ( M - ( i + j ) % M ) % M if ( rem < j ) : continue if ( i == j and rem == j ) : ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 elif ( i == j ) : ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) elif ( i == rem ) : ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 elif ( rem == j ) : ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 else : ans = ans + h [ i ] * h [ j ] * h [ rem ] return ans

def countSubSeq ( A , N , M ) : h = [ 0 for i in range ( N , M ) ] for i in range ( N , M ) : if ( A [ i ] == 0 ) : ans = 0 for j in range ( i , M ) : if ( rem == j ) : ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 else : ans = ans + h [ i ] * h [ j ] * h [ rem ]

def countSubSeq ( A , N , M ) : ans = 0 for i in range ( N ) : h [ A [ i ] ] = 0 for i in range ( N ) : A [ i ] = A [ i ] % M h [ A [ i ] ] += 1 if i == j and rem == j : ans += h [ i ] * ( h [ i ] - 2 ) / 6 elif i == j : ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 elif i == j : ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 else : ans = ans + h [ i ] * h [ j ] * h [ rem ] return ans

18.87
27.15
22.77
38.43
static boolean isMajority ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; else mp . put ( a [ i ] , 1 ) ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ; return false ; }

def isMajority ( a ) : mp = { } for i in a : if i in mp : mp [ i ] += 1 else : mp [ i ] = 1 for x in mp : if mp [ x ] >= len ( a ) // 2 : return True return False

def isMajority ( a , n ) : mp = defaultdict ( int ) for i in range ( n ) : if ( mp . containsKey ( a [ i ] ) ) : mp . put ( a [ i ] , 1 ) for x in mp . entrySet ( ) : if ( x . getValue ( ) >= n / 2 ) : return true else : return false

def isMajority ( a , n ) : mp = new HashMap ( ) for i in range ( n ) : if ( mp . containsKey ( a [ i ] ) ) : mp [ a [ i ] ] = mp [ a [ i ] ] + 1 else : mp [ a [ i ] , 1 ) for map_entry in mp . entrySet ( ) : if ( x [ 1 ] >= n / 2 ) : return True return False

18.91
24.25
51.9
30.46
static int findRepeatingNumber ( int [ ] arr , int n ) { int sq = ( int ) Math . sqrt ( n ) ; int range = ( n / sq ) + 1 ; int [ ] count = new int [ range ] ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m . put ( arr [ i ] , 1 ) ; if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; } } return - 1 ; }

def findRepeatingNumber ( arr , n ) : sq = sqrt ( n ) range__ = int ( ( n / sq ) + 1 ) count = [ 0 for i in range ( range__ ) ] for i in range ( 0 , n + 1 , 1 ) : count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1 selected_block = range__ - 1 for i in range ( 0 , range__ - 1 , 1 ) : if ( count [ i ] > sq ) : selected_block = i break m = { i : 0 for i in range ( n ) } for i in range ( 0 , n + 1 , 1 ) : if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) : m [ arr [ i ] ] += 1 if ( m [ arr [ i ] ] > 1 ) : return arr [ i ] return - 1

def findRepeatingNumber ( arr , n ) : sq = 1 for i in range ( n ) : count [ i ] = 1 selected_block = range - 1 for i in range ( range - 1 , - 1 ) : if ( count [ i ] > sq ) : selected_block = i break if ( count [ i ] > sq ) : selected_block = i break if ( arr [ i ] > ( selected_block * sq ) ) : m

def findRepeatingNumber ( arr , n ) : sq = ( float ( n ) ) range = ( n // sq ) + 1 count = [ 0 for i in range ( range - 1 , - 1 ) ] for i in range ( range - 1 , - 1 ) : count [ i ] = sq if count [ i ] > sq : selected_block = i break m = new HashMap ( ) for i in range ( 0 , range - 1 ) : if ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) : m . put ( arr [ i ] , 1 ) if ( m . get ( arr [ i ] ) == 1 ) : return arr [ i ] return - 1

18.92
21.75
52.05
47.25
static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " " + b + " " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . print ( "-1" ) ; }

def findTriplets ( x ) : fact = [ ] factors = set ( ) for i in range ( 2 , int ( sqrt ( x ) ) ) : if ( x % i == 0 ) : fact . append ( i ) if ( x / i != i ) : fact . append ( x // i ) factors . add ( i ) factors . add ( x // i ) found = False k = len ( fact ) for i in range ( k ) : a = fact [ i ] for j in range ( k ) : b = fact [ j ] if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : print ( a , b , x // ( a * b ) ) found = True break if ( found ) : break if ( not found ) : print ( "-1" )

def findTriplets ( x ) : fact = new Vector < Integer > ( ) factors = new HashSet < Integer > ( ) for i in range ( 2 , 32 ) : if ( x % i == 0 ) : fact . add ( i ) if ( x / i != i ) : fact . add ( x / i ) factors . add ( i ) if ( x / i != i ) : fact . add ( x / i ) : factors . add ( i )

def findTriplets ( x ) : fact = [ 0 for i in range ( 2 ) ] factors = list ( ) for i in range ( 2 , k ) : a = fact [ i ] for j in range ( k ) : b = fact [ j ] if ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) : print ( a + " " + b + " " + ( x / ( a * b ) ) ) found = True break if not found : print ( "-1" )

19.07
21.79
48.72
35.99
static int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }

def countDivisibleSubseq ( str , n ) : l = len ( str ) dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 for i in range ( 1 , l ) : dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 for j in range ( n ) : dp [ i ] [ j ] += dp [ i - 1 ] [ j ] dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] return dp [ l - 1 ] [ 0 ]

def countDivisibleSubseq ( str , n ) : dp = [ 0 for k in range ( len ) ] dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] = 1 dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] += dp [ i - 1 ] [ j ] return dp [ len - 1 ] [ 0 ]

def countDivisibleSubseq ( str , n ) : dp = [ 0 for i in range ( len ) ] n = len ( str ) dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] += for i in range ( 1 , len ) : dp [ i ] [ ( str [ i ] - '0' ) % n ] += dp [ i - 1 ] [ j ] for j in range ( n ) : dp [ i ] [ j ] += dp [ i - 1 ] [ j ] return dp [ len - 1 ] [ 0 ]

19.52
27.26
89.85
76.68
static long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }

def count_of_ways ( n ) : count = 0 count = ( n + 1 ) * ( n + 2 ) // 2 return count

def count_of_ways ( n ) : count = n * n

def count_of_ways ( n ) : count = 0 count = ( n + 1 ) * ( n + 2 ) / 2 return count

19.56
25.78
65.08
65.45
static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }

def isPowerOfTwo ( x ) : return ( x and ( not ( x & ( x - 1 ) ) ) )

def isPowerOfTwo ( x ) : return x == 1

def isPowerOfTwo ( x ) : return x != 0 and ( ( x & ( x - 1 ) ) == 0

19.66
19.93
100.0
100.0
static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }

def isPrime ( n ) : if ( n <= 1 ) : return False for i in range ( 2 , n ) : if ( n % i == 0 ) : return False return True

def isPrime ( n ) : if ( n <= 2 ) : return false return true

def isPrime ( n ) : if ( n <= 1 ) : return False for i in range ( 2 , n ) : if ( n % i == 0 ) : return False return True

19.7
21.16
43.45
43.3
static String censor ( String text , String word ) { String [ ] word_list = text . split ( "\\s+" ) ; String result = "" ; String stars = "" ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) stars += '*' ; int index = 0 ; for ( String i : word_list ) { if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ; index ++ ; } for ( String i : word_list ) result += i + ' ' ; return result ; }

def censor ( text , word ) : word_list = text . split ( ) result = '' stars = '*' * len ( word ) count = 0 index = 0 for i in word_list : if i == word : word_list [ index ] = stars index += 1 result = '' . join ( word_list ) return result

def censor ( text , word ) : word_list = [ "" for i in word_list ] stars = "" for i in word_list : stars += i + ' ' return result

def censor ( text , word ) : word_list = text . split ( "\\s+" ) result = "" stars = "" for i in range ( 0 , len ( word ) ) : stars += '*' index = 0 for i in word_list : if ( i . compareTo ( word ) == 0 ) : word_list [ index ] = stars index ++ for i in word_list : result += i + ' ' return result

19.74
32.55
47.07
43.88
static void greatest ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . charAt ( i ) - '0' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 != 0 ) { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) { System . out . println ( "-1" ) ; } else { System . out . println ( n ) ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) System . out . println ( - 1 ) ; else { System . out . println ( del + 1 ) ; } } }

def greatest ( s ) : n = len ( s ) a = [ 0 for i in range ( n ) ] Sum = 0 for i in range ( n ) : a [ i ] = ord ( s [ i ] ) - ord ( '0' ) Sum += a [ i ] if ( a [ n - 1 ] % 2 ) : if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) % 3 != 0 ) : print ( "-1" ) else : print ( n ) else : re = Sum % 3 dell = - 1 flag = 0 for i in range ( n - 1 ) : if ( ( a [ i ] ) % 3 == re ) : if ( a [ i + 1 ] > a [ i ] ) : dell = i flag = 1 break else : dell = i if ( flag == 0 ) : if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : dell = n - 1 if ( dell == - 1 ) : print ( "-1" ) else : print ( dell + 1 )

def greatest ( s ) : a = [ 0 for i in range ( n ) ] sum = 0 for i in range ( n ) : a [ i ] = s [ i ] if ( a [ n - 1 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) : print ( "-1" ) else : print ( n ) ; } re = sum % 3 del = - 1 flag = 0 for i in range

def greatest ( s ) : a = [ 0 for i in range ( n ) ] sum = 0 for i in range ( n ) : a [ i ] = s [ i ] - '0' sum += a [ i ] if ( a [ n - 1 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) : if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) : if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) : if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) : print ( "-1" ) else : print ( n )

19.78
20.47
69.9
63.95
static double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }

def vol_tetra ( side ) : volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) return round ( volume , 2 )

def vol_tetra ( side ) : volume = ( side * side )

def vol_tetra ( side ) : volume = ( math . pow ( side , 3 ) / ( 6 * math . sqrt ( 2 ) ) ) return volume

19.84
31.84
100.0
100.0
public static int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }

def numberOfSticks ( x ) : return ( 3 * x * ( x + 1 ) ) / 2

def numberOfSticks ( x ) : return x

def numberOfSticks ( x ) : return ( 3 * x * ( x + 1 ) ) / 2

19.84
27.67
100.0
100.0
static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }

def multiplyWith3Point5 ( x ) : return ( x << 1 ) + x + ( x >> 1 )

def multiplyWith3Point5 ( x ) : return x

def multiplyWith3Point5 ( x ) : return ( x << 1 ) + x + ( x >> 1 )

20.03
25.84
58.69
43.02
static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = Integer . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }

def maxSumBitonicSubArr ( arr , n ) : msis = [ None ] * n msds = [ None ] * n max_sum = 0 msis [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ i - 1 ] ) : msis [ i ] = msis [ i - 1 ] + arr [ i ] else : msis [ i ] = arr [ i ] msds [ n - 1 ] = arr [ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : msds [ i ] = msds [ i + 1 ] + arr [ i ] else : msds [ i ] = arr [ i ] for i in range ( n ) : if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) return max_sum

def maxSumBitonicSubArr ( arr , n ) : msis = [ 0 for k in range ( n ) ] msds = [ 0 for k in range ( n ) ] for i in range ( n ) : if ( arr [ i ] > arr [ i - 1 ] ) : msis [ i ] = msis [ i - 1 ] + arr [ i ] else : msis [ i ] = arr [ i ] max_sum = float ( '

def maxSumBitonicSubArr ( arr , n ) : msis = [ 0 for k in range ( n ) ] msds = [ 0 for k in range ( n ) ] max_sum = float ( 'inf' ) for i in range ( n ) : if ( arr [ i ] > arr [ i - 1 ] ) : msis [ i ] = msis [ i - 1 ] + arr [ i ] else : msis [ i ] = arr [ i ] msds [ n - 1 ] = arr [ n - 1 ] i = n - 2 while i >= 0 : if ( arr [ i ] > arr [ i + 1 ] ) : msds [ i ] = msds [ i + 1 ] + arr [ i ] else : msds [ i ] = arr [ i ] i -= 1 return max_sum

20.03
28.01
28.18
27.76
static int find ( boolean arr [ ] [ ] ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == false ) { while ( j >= 0 && ( arr [ i ] [ j ] == false || i == j ) ) { j -- ; } if ( j == - 1 ) { res = i ; break ; } else { i ++ ; } } else { while ( i < n && ( arr [ i ] [ j ] == true || i == j ) ) { i ++ ; } if ( i == n ) { res = j ; break ; } else { j -- ; } } } if ( res == - 1 ) { return res ; } for ( int k = 0 ; k < n ; k ++ ) { if ( res != k && arr [ k ] [ res ] != true ) { return - 1 ; } } for ( int l = 0 ; l < n ; l ++ ) { if ( res != l && arr [ res ] [ l ] != false ) { return - 1 ; } } return res ; }

def find ( arr ) : n = len ( arr ) i = 0 j = n - 1 res = - 1 while i < n and j >= 0 : if arr [ i ] [ j ] == 0 : while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : j -= 1 if j == - 1 : res = i break else : i += 1 else : while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : i += 1 if i == n : res = j break else : j -= 1 if res == - 1 : return res for i in range ( 0 , n ) : if res != i and arr [ i ] [ res ] != 1 : return - 1 for j in range ( 0 , j ) : if res != j and arr [ res ] [ j ] != 0 : return - 1 ; return res ;

def find ( arr , n ) : i = 0 j = n - 1 while i < n and j >= 0 : if ( arr [ i ] [ j ] == false ) : res = i break if ( i == n : res = j break if ( j == - 1 ) : res = i break if ( i == n ) : res = j break if ( j == - 1 ) : res = i break if ( i == n ) : res = j break

def find ( arr , array ) : i = 0 j = n - 1 res = - 1 while i < n and j >= 0 : if ( arr [ i ] [ j ] == False ) : while ( j >= 0 and ( arr [ i ] [ j ] == false or i == j ) ) : j -- if ( j == - 1 ) : res = i break if i == n : res = j break if j == - 1 : res = i break return res

20.1
46.66
77.43
71.77
static int compute_average ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }

def compute_average ( a , b ) : return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 )

def compute_average ( a , b ) : return ( a + b )

def compute_average ( a , b ) : return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 )

20.28
21.05
47.92
38.02
static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }

def check ( s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] ) dp [ 0 ] [ 0 ] = True for i in range ( len ( s1 ) ) : for j in range ( len ( s2 ) + 1 ) : if ( dp [ i ] [ j ] ) : if ( ( j < len ( s2 ) and ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) : dp [ i + 1 ] [ j + 1 ] = True if ( s1 [ i ] . isupper ( ) == False ) : dp [ i + 1 ] [ j ] = True return ( dp [ n ] [ m ] )

def check ( s1 , s2 ) : dp = [ False for i in range ( n + 1 , m + 1 ) ] for j in range ( 0 , n + 1 , m + 1 ) : if ( dp [ i ] [ j ] ) : dp [ i ] [ j ] = true return ( dp [ n ] [ m ] )

def check ( s1 , s2 ) : n = s1 . length m = s2 . length dp [ ] [ 0 ] = True for i in range ( 0 , n , m ) : for j in range ( 0 , m ) : if ( dp [ i ] [ j ] ) : if ( j < s2 [ i ] ) : dp [ i + 1 ] [ j + 1 ] = True if ( not Character . isUpperCase ( s1 [ i ] ) ) : dp [ i + 1 ] [ j ] = True return ( dp [ n ] [ m ] )

20.35
22.13
19.07
20.49
static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = "" ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; }

def findSum ( str1 , str2 ) : if len ( str1 ) > len ( str2 ) : temp = str1 str1 = str2 str2 = temp str3 = "" n1 = len ( str1 ) n2 = len ( str2 ) diff = n2 - n1 carry = 0 for i in range ( n1 - 1 , - 1 , - 1 ) : sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 if ( carry ) : str3 + str ( carry + '0' ) str3 = str3 [ : : - 1 ] return str3

def findSum ( str1 , str2 ) : t = str1 str1 = str2 str2 = t str = "" n1 = 0 n2 = 0 for i in range ( n1 , n2 ) : sum = ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 [ i + diff ] - '0' ) + carry ) str += ( char ) ( sum % 10 + '0' ) carry = sum / 10 if ( carry > 0 ) : str += ( char ) ( carry + '0' ) return new StringBuilder ( str )

def findSum ( str1 , str2 ) : n1 = str1 . length n2 = str2 . length diff = n2 - n1 carry = 0 for i in range ( n1 , n2 ) : sum = ( ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 [ i + diff ] - '0' ) + carry ) str += ( char ) ( sum % 10 + '0' ) carry = sum / 10 if carry > 0 : str += ( char ) ( carry + '0' ) return str

20.53
31.59
22.44
32.62
static int getCount ( char keypad [ ] [ ] , int n ) { if ( keypad == null || n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }

def getCount ( keypad , n ) : if ( not keypad or n <= 0 ) : return 0 if ( n == 1 ) : return 10 odd = [ 0 ] * 10 even = [ 0 ] * 10 i = 0 j = 0 useOdd = 0 totalCount = 0 for i in range ( 10 ) : odd [ i ] = 1 for j in range ( 2 , n + 1 ) : useOdd = 1 - useOdd if ( useOdd == 1 ) : even [ 0 ] = odd [ 0 ] + odd [ 8 ] even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] else : odd [ 0 ] = even [ 0 ] + even [ 8 ] odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] totalCount = 0 if ( useOdd == 1 ) : for i in range ( 10 ) : totalCount += even [ i ] else : for i in range ( 10 ) : totalCount += odd [ i ] return totalCount

def getCount ( keypad , n ) : keypad = [ keypad [ ] ] for i in range ( 10 , n ) : odd = [ 0 for i in range ( 9 ) ] even = [ 0 for j in range ( 2 , n ) ] useOdd = 1 - useOdd for j in range ( 2 , n ) : even [ i ] = odd [ 0 ] + odd [ 1 ] + odd [ 2 ] + odd [ 4 ] even [ 3 ] = odd [ 3 ] + odd [ 5 ] if ( useOdd == 1 ) : even [ 0 ] = odd [ 1 ] + odd [ 3 ] + odd [ 5 ] + odd [ 7 ] even [ 8 ] = odd [ 9 ] + odd [ 4 ] + odd [ 9 ] even [ 9 ] = odd [ 10 ] + odd [ 9 ] even [ 10 ] = odd [ 10 ] + odd [ 1 ] + odd [ 2 ] + odd [ 8 ] even [ 7 ] = odd [ 7 ] + odd [ 9 ] if ( useOdd == 1 ) : even [ 7 ] = odd [ 7 ] + odd [ 7 ] + odd [ 9 ] even [ 8 ] = odd [ 9 ] + odd

def getCount ( keypad , n ) : odd = [ 0 for k in range ( 10 ) ] even = [ 0 for k in range ( 10 ) ] even [ 0 ] = odd [ 0 ] + odd [ 8 ] even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] even [ 8 ] = odd [ 8 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] totalCount += 1 return totalCount

20.59
40.16
37.23
45.42
int getOddOccurrence ( int ar [ ] , int ar_size ) { int i ; int res = 0 ; for ( i = 0 ; i < ar_size ; i ++ ) { res = res ^ ar [ i ] ; } return res ; }

def getOddOccurrence ( arr ) : res = 0 for element in arr : res = res ^ element return res

def getOddOccurrence ( ar , ar_size ) : res = 0 for i in range ( ar_size ) : res = res ^ ar [ i ] for i in range ( ar_size ) : res = res ^ ar [ i ] if ( res != 0 ) : return res

def getOddOccurrence ( ar , ar_size ) : res = 0 for i in range ( ar_size ) : res = res ^ ar [ i ] return res

20.61
43.31
66.39
61.6
static void rotate ( ) { int x = arr [ arr . length - 1 ] , i ; for ( i = arr . length - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }

def rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x

def rotate ( arr ) : arr . sort ( reverse = True ) x = arr [ 0 ] for i in range ( arr . length - 1 , - 1 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x i = arr . length - 1 while i > 0 : arr [ i ] = arr [ i - 1 ] i -= 1 x = arr [ 0 ] for i in range ( 1 , arr . length - 1 ) : arr [ i ] = arr [ i ] if ( i > 0 ) : arr [ i ] = arr [ i - 1 ] i -= 1 ] if ( i > 0 ) : arr [ i ] = arr [ i - 1 ] = arr [ i - 1 ] i -= 1 ] return arr [ 0 ]

def rotate ( arr ) : x = arr [ arr . length - 1 ] for i in range ( arr . length ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x

20.68
21.18
17.84
20.57
static void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { arr = swap ( arr , i , j ) ; i += 2 ; j -= 2 ; } Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ; Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ; int low = ( n + 1 ) / 2 , high = n - 1 ; while ( low < high ) { Integer temp = arr [ low ] ; arr [ low ] = arr [ high ] ; arr [ high ] = temp ; low ++ ; high -- ; } }

def bitonicGenerator ( arr , n ) : i = 1 j = n - 1 if ( j % 2 != 0 ) : j = j - 1 while ( i < j ) : arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ] i = i + 2 j = j - 2 arr_f = [ ] arr_s = [ ] for i in range ( int ( ( n + 1 ) / 2 ) ) : arr_f . append ( arr [ i ] ) i = int ( ( n + 1 ) / 2 ) while ( i < n ) : arr_s . append ( arr [ i ] ) i = i + 1 arr_f . sort ( ) arr_s . sort ( reverse = True ) for i in arr_s : arr_f . append ( i ) return arr_f

def bitonicGenerator ( arr , n ) : i = 1 j = n - 2 while ( i < j ) : i += 2 j -= 2 while ( i < j ) : arr = swap ( arr , i , j ) low = ( n + 1 ) // 2 high = n - 1 while low < high : temp = arr [ low ] arr [ low ] = arr [ high ] high -= 1 temp = arr [ low ] arr [ high ] = temp low

def bitonicGenerator ( arr , n ) : i = 1 j = n - 1 while i < j : arr = swap ( arr , i , j ) i += 2 j -= 2 arr = swap ( arr , i , j ) low = ( n + 1 ) / 2 , high = n - 1 while low < high : temp = arr [ low ] arr [ low ] = arr [ high ] arr [ high ] = temp low ++ high -- return arr

20.8
35.97
64.08
66.74
static boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }

def isPowerOfFour ( n ) : return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) )

def isPowerOfFour ( n ) : return n == 1 || n == 2 || n == 3 || n == 4

def isPowerOfFour ( n ) : return n != 0 and ( ( n & ( n - 1 ) ) == 0 )

20.87
26.49
45.78
37.17
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; int sum [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; int k = len / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ; } } return maxlen ; }

def findLength ( string ) : n = len ( string ) maxlen = 0 Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( 0 , n ) : Sum [ i ] [ i ] = int ( string [ i ] ) for length in range ( 2 , n + 1 ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 k = length // 2 Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : maxlen = length return maxlen

def findLength ( str ) : sum = [ 0 for i in range ( n ) ] for i in range ( n ) : sum [ i ] = [ 0 for i in range ( n ) ] for j in range ( n - len + 1 , - 1 , - 1 ) : if ( sum [ i ] [ j ] == sum [ j - k + 1 ] [ j ] ) : maxlen = len return maxlen

def findLength ( str ) : maxlen = 0 sum = [ 0 for i in range ( n ) ] for len in range ( 2 , n ) : for i in range ( n - len + 1 , - 1 , - 1 ) : j = i + len - 1 k = len // 2 sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] if len % 2 == 0 and sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] and len > maxlen : maxlen = len return maxlen

20.87
32.66
23.56
29.69
static void printSubStr ( String str , int low , int high ) { System . out . println ( str . substring ( low , high + 1 ) ) ; }

def printSubStr ( st , low , high ) : sys . stdout . write ( st [ low : high + 1 ] ) sys . stdout . flush ( ) return ''

def printSubStr ( str , low , high ) : printSubStr ( str , low , high + 1 )

def printSubStr ( str , low , high ) : print ( str . substring ( low , high + 1 ) )

20.91
25.21
60.41
41.01
public static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }

def fib ( n ) : if ( n == 0 ) : return 0 if ( n == 1 or n == 2 ) : f [ n ] = 1 return ( f [ n ] ) if ( f [ n ] ) : return f [ n ] if ( n & 1 ) : k = ( n + 1 ) // 2 else : k = n // 2 if ( ( n & 1 ) ) : f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) else : f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) return f [ n ]

def fib ( n ) : f = [ 0 for n in range ( 3 ) ] if ( n == 1 || n == 2 ) : ( n & 1 ) == 0 : ( n + 1 ) // 2 f [ n ] = ( fib ( k ) + fib ( k - 1 ) ) return f [ n ]

def fib ( n ) : if n == 0 : return 0 if n == 1 or n == 2 : return ( f [ n ] = 1 ) if n == 1 or n == 2 : return ( f [ n ] = 1 ) if f [ n ] != 0 : return f [ n ] k = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) return f [ n ]

20.98
40.11
3.25
7.19
static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }

def interchangeFirstLast ( mat , n , m ) : rows = n for i in range ( n ) : t = mat [ 0 ] [ i ] mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] mat [ rows - 1 ] [ i ] = t

def interchangeFirstLast ( m ) : m . sort ( reverse = True ) rows = m . length for i in range ( 0 , len ( m ) ) : t = m [ 0 ] [ i ] m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] m [ rows - 1 ] [ i ] = t rows -= 1 for i in range ( 0 , len ( m ) ) : t = m [ 0 ] [ i ] m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] = m [ rows - 1 ] [ i ] if ( t != m [ 0 ] [ i ] ) : m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] = t m [ rows - 1 ] [ i ] = t return m

def interchangeFirstLast ( m ) : m . sort ( reverse = True ) m . sort ( reverse = True )

21.05
28.62
19.68
21.91
static void solveWordWrap ( int arr [ ] , int n , int k ) { int i , j ; int currlen ; int cost ; int dp [ ] = new int [ n ] ; int ans [ ] = new int [ n ] ; dp [ n - 1 ] = 0 ; ans [ n - 1 ] = n - 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { currlen = - 1 ; dp [ i ] = Integer . MAX_VALUE ; for ( j = i ; j < n ; j ++ ) { currlen += ( arr [ j ] + 1 ) ; if ( currlen > k ) break ; if ( j == n - 1 ) cost = 0 ; else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } } i = 0 ; while ( i < n ) { System . out . print ( ( i + 1 ) + " " + ( ans [ i ] + 1 ) + " " ) ; i = ans [ i ] + 1 ; } }

def solveWordWrap ( arr , n , k ) : dp = [ 0 ] * n ans = [ 0 ] * n dp [ n - 1 ] = 0 ans [ n - 1 ] = n - 1 for i in range ( n - 2 , - 1 , - 1 ) : currlen = - 1 dp [ i ] = sys . maxsize for j in range ( i , n ) : currlen += ( arr [ j ] + 1 ) if ( currlen > k ) : break if ( j == n - 1 ) : cost = 0 else : cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) if ( cost < dp [ i ] ) : dp [ i ] = cost ans [ i ] = j i = 0 while ( i < n ) : print ( i + 1 , ans [ i ] + 1 , end = "" ) i = ans [ i ] + 1

def solveWordWrap ( arr , n , k ) : dp = [ 0 for i in range ( n ) ] ans = [ 0 for i in range ( n - 2 , - 1 , - 1 ) ] for j in range ( i + 1 , n ) : if ( arr [ j ] + 1 ) > k : break dp [ i ] = float ( 'inf' ) elif ( arr [ j ] + 1 ) > k : break cost = float ( '

def solveWordWrap ( arr , n , k ) : dp = [ 0 for k in range ( n ) ] ans = [ 0 for k in range ( n ) ] i = 0 while ( i < n ) : print ( ( i + 1 ) + " " + ( ans [ i ] + 1 ) + " " ) i = ans [ i ] + 1 print ( dp [ i ] ) ans [ i ] = i

21.16
27.8
17.46
21.04
static void moveSpaceInFront ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ' ; }

def moveSpaceInFront ( s ) : i = len ( s ) - 1 for j in range ( i , - 1 , - 1 ) : if ( s [ j ] != '' ) : s = s [ : i ] + s [ j ] + s [ i + 1 : ] i -= 1 while ( i >= 0 ) : s = s [ : i ] + '' + s [ i + 1 : ] i -= 1 return s

def moveSpaceInFront ( str ) : i = len ( str ) - 1 for j in range ( i + 1 , len ( str ) ) : if ( str [ j ] != ' ' ) : str [ i -- ] = str [ j ] return

def moveSpaceInFront ( str ) : i = str . length - 1 for j in range ( i ) : if str [ j ] != ' ' : str [ i -- ] = str [ j ] while i >= 0 : str [ i -- ] = ' '

21.37
28.12
63.09
47.0
static int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }

def sumOfDigitsFrom1ToN ( n ) : if ( n < 10 ) : return ( n * ( n + 1 ) / 2 ) d = ( int ) ( math . log10 ( n ) ) a = [ 0 ] * ( d + 1 ) a [ 0 ] = 0 a [ 1 ] = 45 for i in range ( 2 , d + 1 ) : a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) msd = n // p return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) )

def sumOfDigitsFrom1ToN ( n ) : n = int ( n ) d = ( int ) ( Math . log10 ( n ) ) a = [ 0 for i in range ( 2 , d ) ] p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) return ( n * ( n + 1 ) / 2 ) + sumOfDigitsFrom1ToN ( n % p ) )

def sumOfDigitsFrom1ToN ( n ) : a = [ 0 for k in range ( d ) ] a [ 0 ] = 0 a [ 1 ] = 45 for i in range ( 2 , d ) : a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ( ceil ( Math . pow ( 10 , i - 1 ) ) ) p = ( int ) ( ceil ( Math . pow ( 10 , d ) ) ) msd = n // p return ( msd * a [ d ] + ( msd * ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) )

21.41
22.5
29.37
29.11
static boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit || 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != 'X' && ( last < '0' || last > '9' ) ) return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }

def isValidISBN ( isbn ) : if len ( isbn ) != 10 : return False _sum = 0 for i in range ( 9 ) : if 0 <= int ( isbn [ i ] ) <= 9 : _sum += int ( isbn [ i ] ) * ( 10 - i ) else : return False if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : return False _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] ) return ( _sum % 11 == 0 )

def isValidISBN ( isbn ) : n = len ( isbn ) for i in range ( 0 , n ) : if ( i > 9 ) : return false sum = 0 for i in range ( 0 , 9 ) : sum += ( digit * ( 10 - i ) ) return ( sum % 11 == 0 )

def isValidISBN ( isbn ) : sum = 0 for i in range ( n ) : digit = isbn [ i ] - '0' if ( 0 > digit or 9 < digit ) : return False sum += ( digit * ( 10 - i ) ) last = isbn [ 9 ] if ( last != 'X' and ( last < '0' or last > '9' ) ) : return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) return ( sum % 11 == 0 )

21.46
38.98
27.42
43.06
static String longDivision ( String number , int divisor ) { String ans = "" ; int idx = 0 ; char [ ] num = number . toCharArray ( ) ; int temp = num [ idx ] - '0' ; while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ; idx += 1 ; while ( num . length > idx ) { ans += ( temp / divisor ) ; temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; }

def longDivision ( number , divisor ) : ans = "" idx = 0 temp = ord ( number [ idx ] ) - ord ( '0' ) while ( temp < divisor ) : temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) idx += 1 idx += 1 while ( ( len ( number ) ) > idx ) : ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) idx += 1 ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) if ( len ( ans ) == 0 ) : return "0" return ans

def longDivision ( number , divisor ) : ans = "" idx = 0 while ( num [ idx ] >= '0' ) : ans += ( temp / divisor ) temp = ( temp % divisor ) * 10 + num [ idx ] - '0' ans += ( temp / divisor ) * 10 + num [ idx ++ ] - '0' if ( ans . length ( ) == 0 ) : return "0" return ans

def longDivision ( number , divisor ) : ans = "" idx = 0 num = number . toCharArray ( ) temp = num [ idx ] - '0' while ( temp < divisor ) : temp = temp * 10 + ( num [ ++ idx ] - '0' ) idx += 1 while ( num [ idx ] > idx ) : ans += ( temp / divisor ) temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' return ans

21.54
27.85
84.95
82.71
double countSquares ( int a , int b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }

def CountSquares ( a , b ) : return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 )

def countSquares ( a , b ) : return ( 1 - countSquares ( a , b ) )

def countSquares ( a , b ) : return ( math . floor ( math . sqrt ( b ) ) - Math . ceil ( math . sqrt ( a ) ) + 1

21.72
24.93
69.52
49.82
static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }

def LowerInsertionPoint ( arr , n , X ) : if ( X < arr [ 0 ] ) : return 0 elif ( X > arr [ n - 1 ] ) : return n lowerPnt = 0 i = 1 while ( i < n and arr [ i ] < X ) : lowerPnt = i i = i * 2 while ( lowerPnt < n and arr [ lowerPnt ] < X ) : lowerPnt += 1 return lowerPnt

def LowerInsertionPoint ( arr , n , X ) : if ( X < arr [ 0 ] ) : return 0 else : X > arr [ n - 1 ] : return n

def LowerInsertionPoint ( arr , n , X ) : if X < arr [ 0 ] : return 0 else : if X > arr [ n - 1 ] : return n lowerPnt = 0 i = 1 while i < n and arr [ i ] < X : lowerPnt = i i = i * 2 while lowerPnt < n and arr [ lowerPnt ] < X : lowerPnt ++ return lowerPnt

21.76
22.89
70.79
48.27
static int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }

def solve ( A , B , C ) : i = len ( A ) - 1 j = len ( B ) - 1 k = len ( C ) - 1 min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) while i != - 1 and j != - 1 and k != - 1 : current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) if current_diff < min_diff : min_diff = current_diff max_term = max ( A [ i ] , B [ j ] , C [ k ] ) if A [ i ] == max_term : i -= 1 elif B [ j ] == max_term : j -= 1 else : k -= 1 return min_diff

def solve ( A , B , C ) : i = - 1 j = - 1 k = - 1 min_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) if ( min_diff < current_diff ) : min_diff = current_diff max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) if ( max_term == max_

def solve ( A , B , C ) : i = A . length - 1 j = B . length k = C . length - 1 min_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) while i != - 1 and j != - 1 and k != - 1 : current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) ) if ( current_diff < min_diff ) : min_diff = current_diff max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) if ( A [ i ] == max_term ) : i -= 1 else : if ( B [ j ] == max_term ) : j -= 1 else : k -= 1 return min_diff

21.78
25.85
28.4
20.31
static void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( "Input even number of integers." ) ; Stack < Integer > s = new Stack < > ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } }

def interLeaveQueue ( q ) : if ( q . qsize ( ) % 2 != 0 ) : print ( "Inputevennumberofintegers." ) s = [ ] halfSize = int ( q . qsize ( ) / 2 ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) for i in range ( halfSize ) : q . put ( q . queue [ 0 ] ) q . get ( ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) q . put ( q . queue [ 0 ] ) q . get ( )

def interLeaveQueue ( q ) : if ( q . size ( ) % 2 != 0 ) : print ( "Input odd number of integers." ) return s = new Stack < Integer > ( ) for i in range ( 0 , halfSize ) : s . append ( q . peek ( ) ) q . poll ( ) while ( ! s . empty ( ) ) : q . add ( s . peek ( ) ) s . pop ( ) q . add ( q .

def interLeaveQueue ( q ) : s = list ( ) halfSize = q . size // 2 for i in range ( 0 , halfSize ) : s . append ( q . peek ( ) ) q . poll ( ) for i in range ( 0 , halfSize ) : s . append ( q . peek ( ) ) q . pop ( ) for i in range ( 0 , halfSize ) : s . append ( q . peek ( ) ) q . poll ( ) for i in range ( 0 , halfSize ) : s . append ( q . peek ( ) ) q . poll ( )

21.98
57.94
58.8
79.75
public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) { int i = fromRow + ( toRow - fromRow ) / 2 ; int j = fromCol + ( toCol - fromCol ) / 2 ; if ( mat [ i ] [ j ] == key ) System . out . println ( "Found " + key + " at " + i + " " + j ) ; else { if ( i != toRow || j != fromCol ) search ( mat , fromRow , i , j , toCol , key ) ; if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) System . out . println ( "Found " + key + " at " + fromRow + " " + toCol ) ; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= toRow ) search ( mat , i + 1 , toRow , fromCol , toCol , key ) ; } else { if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ; } } }

def search ( mat , fromRow , toRow , fromCol , toCol , key ) : i = fromRow + ( toRow - fromRow ) // 2 j = fromCol + ( toCol - fromCol ) // 2 if ( mat [ i ] [ j ] == key ) : print ( "Found" , key , "at" , i , "" , j ) else : if ( i != toRow or j != fromCol ) : search ( mat , fromRow , i , j , toCol , key ) if ( fromRow == toRow and fromCol + 1 == toCol ) : if ( mat [ fromRow ] [ toCol ] == key ) : print ( "Found" , key , "at" , fromRow , "" , toCol ) if ( mat [ i ] [ j ] < key ) : if ( i + 1 <= toRow ) : search ( mat , i + 1 , toRow , fromCol , toCol , key ) else : if ( j - 1 >= fromCol ) : search ( mat , fromRow , toRow , fromCol , j - 1 , key )

def search ( mat , fromRow , toRow , fromCol , toCol ) : i = fromRow + ( toRow - fromRow ) // 2 j = fromCol + ( toCol - fromCol ) // 2 if ( mat [ i ] [ j ] == key ) : print ( "Found " + key ) if ( fromRow == toRow and fromCol + 1 == toCol ) : print ( mat [ fromRow ] [ toCol ] == key )

def search ( mat , fromRow , toRow , fromCol , toCol , key ) : i = fromRow + ( toRow - fromRow ) // 2 j = fromCol + ( toCol - fromCol ) // 2 if mat [ i ] [ j ] == key : if ( i + 1 <= toRow ) : search ( mat , i + 1 , toRow , fromCol , toCol , key ) else : if ( j - 1 >= fromCol ) : search ( mat , fromRow , toRow , fromCol , j - 1 , key ) : if ( j - 1 >= fromCol ) : search ( mat , fromRow , toRow , fromCol , j - 1 , key ) else : if ( j - 1 >= fromCol ) : search ( mat , fromRow , toRow , fromCol , j - 1 , key )

22.29
21.41
44.45
34.95
public static int nearestSmallerEqFib ( int n ) { if ( n == 0 || n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }

def nearestSmallerEqFib ( n ) : if ( n == 0 or n == 1 ) : return n f1 , f2 , f3 = 0 , 1 , 1 while ( f3 <= n ) : f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; return f2 ;

def nearestSmallerEqFib ( n ) : if ( n == 0 ) : return n f1 = 0 f2 = 1 f3 = 1 return f2

def nearestSmallerEqFib ( n ) : if n == 0 or n == 1 : return n f1 = 0 f2 = 1 f3 = 1 while f3 <= n : f1 = f2 f2 = f3 f3 = f1 + f2 return f2

22.42
23.21
17.04
16.55
public static void mergeIntervals ( Interval arr [ ] ) { Arrays . sort ( arr , new Comparator < Interval > ( ) { public int compare ( Interval i1 , Interval i2 ) { return i2 . start - i1 . start ; } } ) ; int index = 0 ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ index ] . end >= arr [ i ] . start ) { arr [ index ] . end = Math . max ( arr [ index ] . end , arr [ i ] . end ) ; arr [ index ] . start = Math . min ( arr [ index ] . start , arr [ i ] . start ) ; } else { arr [ index ] = arr [ i ] ; index ++ ; } } System . out . print ( "The Merged Intervals are: " ) ; for ( int i = 0 ; i <= index ; i ++ ) { System . out . print ( "[" + arr [ i ] . start + "," + arr [ i ] . end + "]" ) ; } }

def mergeIntervals ( arr ) : arr . sort ( key = lambda x : x [ 0 ] ) m = [ ] s = - 10000 max = - 100000 for i in range ( len ( arr ) ) : a = arr [ i ] if a [ 0 ] > max : if i != 0 : m . append ( [ s , max ] ) max = a [ 1 ] s = a [ 0 ] else : if a [ 1 ] >= max : max = a [ 1 ] if max != - 100000 and [ s , max ] not in m : m . append ( [ s , max ] ) print ( "TheMergedIntervalsare:" , end = "" ) for i in range ( len ( m ) ) : print ( m [ i ] , end = "" )

def mergeIntervals ( arr ) : arr . sort ( reverse = True ) index = 0 for i in range ( len ( arr ) ) : if ( i1 >= arr [ index ] . end ) : arr [ index ] . end = arr [ i ] . start else : arr [ index ] = arr [ i ] index = 1 for i in range ( len ( arr ) ) : if ( arr [ index ] . start >= arr [ i ] . end ) : arr [ index ] . start = max ( arr [ index ] . end , arr [ i ] . end ) : arr [ index ] . end = min ( arr [ index ] . start , arr [ i ] . end ) : arr [ index ] . start = max ( arr [ index ] . end , arr [ i ] . start ) print ( "[" + arr [ i ] . end + "]" )

def mergeIntervals ( arr ) : arr . sort ( reverse = True ) index = 0 for i in range ( 1 , len ( arr ) ) : if ( arr [ index ] . end >= arr [ i ] . start ) : arr [ index ] . end = max ( arr [ index ] . end , arr [ i ] . start ) arr [ index ] . start = min ( arr [ index ] . start , arr [ i ] . start ) else : arr [ index ] = arr [ i ] index += 1

22.51
22.04
45.46
35.11
int getNthUglyNo ( int n ) { int ugly [ ] = new int [ n ] ; int i2 = 0 , i3 = 0 , i5 = 0 ; int next_multiple_of_2 = 2 ; int next_multiple_of_3 = 3 ; int next_multiple_of_5 = 5 ; int next_ugly_no = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { next_ugly_no = Math . min ( next_multiple_of_2 , Math . min ( next_multiple_of_3 , next_multiple_of_5 ) ) ; ugly [ i ] = next_ugly_no ; if ( next_ugly_no == next_multiple_of_2 ) { i2 = i2 + 1 ; next_multiple_of_2 = ugly [ i2 ] * 2 ; } if ( next_ugly_no == next_multiple_of_3 ) { i3 = i3 + 1 ; next_multiple_of_3 = ugly [ i3 ] * 3 ; } if ( next_ugly_no == next_multiple_of_5 ) { i5 = i5 + 1 ; next_multiple_of_5 = ugly [ i5 ] * 5 ; } } return next_ugly_no ; }

def getNthUglyNo ( n ) : ugly = [ 0 ] * n ugly [ 0 ] = 1 i2 = i3 = i5 = 0 next_multiple_of_2 = 2 next_multiple_of_3 = 3 next_multiple_of_5 = 5 for l in range ( 1 , n ) : ugly [ l ] = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) if ugly [ l ] == next_multiple_of_2 : i2 += 1 next_multiple_of_2 = ugly [ i2 ] * 2 if ugly [ l ] == next_multiple_of_3 : i3 += 1 next_multiple_of_3 = ugly [ i3 ] * 3 if ugly [ l ] == next_multiple_of_5 : i5 += 1 next_multiple_of_5 = ugly [ i5 ] * 5 return ugly [ - 1 ]

def getNthUglyNo ( n ) : ugly = [ 1 for i in range ( n ) ] i2 = 0 i3 = 0 i5 = 0 next_multiple_of_2 = 1 next_multiple_of_3 = 1 next_multiple_of_5 = 1 next_ugly_no = min ( next_multiple_of_2 , min ( next_multiple_of_3 , next_multiple_of_5 ) ) if ( next_ugly_no == next_multiple_of_ugly_no == next_multiple_of_no == next_multiple_of_3 = next_multiple_of_5 = ugly [ i5 ] * 5 return next_ugly_no

def getNthUglyNo ( n ) : ugly = [ 0 for i in range ( n ) ] next_ugly_no = 1 for i in range ( 1 , n ) : next_ugly_no = min ( next_multiple_of_2 , min ( next_multiple_of_3 , next_multiple_of_5 ) ) ugly [ i ] = next_ugly_no if ( next_ugly_no == next_multiple_of_2 ) : i2 = i2 + 1 next_multiple_of_2 = ugly [ i2 ] * 2 if ( next_ugly_no == next_multiple_of_3 ) : i3 = i3 + 1 next_multiple_of_3 = ugly [ i3 ] * 3 if ( next_ugly_no == next_multiple_of_5 ) : i5 = i5 + 1 next_multiple_of_5 = ugly [ i5 ] * 5 return next_ugly_no

22.55
16.29
41.73
33.66
boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }

def isProduct ( arr , n , x ) : for i in arr : for j in arr : if i * j == x : return True return False

def isProduct ( arr , n , x ) : if ( arr [ 0 ] * arr [ 0 ] == x ) : return true for i in range ( n - 1 , - 1 , - 1 ) : if ( arr [ i ] * arr [ j ] == x ) : return true

def isProduct ( arr , n , x ) : for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] * arr [ j ] == x ) : return True return False

22.56
24.96
100.0
100.0
static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }

def maxSquare ( b , m ) : return ( b / m - 1 ) * ( b / m ) / 2

def maxSquare ( b , m ) : return b

def maxSquare ( b , m ) : return ( b / m - 1 ) * ( b / m ) / 2

22.6
32.42
48.87
40.23
static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 || last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }

def merge ( ar1 , ar2 , m , n ) : for i in range ( n - 1 , - 1 , - 1 ) : last = ar1 [ m - 1 ] j = m - 2 while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : ar1 [ j + 1 ] = ar1 [ j ] j -= 1 if ( j != m - 2 or last > ar2 [ i ] ) : ar1 [ j + 1 ] = ar2 [ i ] ar2 [ i ] = last

def merge ( m , n ) : arr1 = [ 0 for i in range ( n ) ] arr2 = [ 0 for i in range ( n ) ] for j in range ( m - 2 , - 1 , - 1 ) : if ( arr1 [ j ] > arr2 [ i ] ) : arr1 [ j + 1 ] = arr2 [ i ] arr2 [ i ] = last j = m - 2 if ( j != m - 2 || last > arr1 [ i ] ) : arr1 [ j ] = arr1 [ j ] if ( last > arr2 [ i ] ) : arr2 [ i ] = last j = m - 2 if ( last > arr2 [ i ] ) : arr1 [ j + 1 ] = arr2 [ i ] arr2 [ i ] = last last = arr2 [ i ] arr2 [ i ] = last j = m - 2 if ( j != m - 2 || last > arr2 [ i ] ) : arr1 [ j + 1 ] = arr2 [ i ] if ( last > arr2 [ i ] ) : arr2 [ i ] = last j = m - 2 else : arr1 [ j + 1 ] =

def merge ( m , n ) : for i in range ( n ) : last = arr1 [ m - 1 ] for j in range ( m - 1 , - 1 , - 1 ) : arr1 [ j + 1 ] = arr1 [ j ] for j in range ( m - 2 , - 1 , - 1 ) : arr1 [ j + 1 ] = arr1 [ j ] if j != m - 2 or last > arr2 [ i ] : arr1 [ j + 1 ] = arr2 [ i ] arr2 [ i ] = last

22.61
21.17
43.33
33.26
static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = "" ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ; str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ; return str ; }

def findSum ( str1 , str2 ) : if ( len ( str1 ) > len ( str2 ) ) : t = str1 str1 = str2 str2 = t str = "" n1 = len ( str1 ) n2 = len ( str2 ) str1 = str1 [ : : - 1 ] str2 = str2 [ : : - 1 ] carry = 0 for i in range ( n1 ) : sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ) str += chr ( sum % 10 + 48 ) carry = int ( sum / 10 ) for i in range ( n1 , n2 ) : sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry ) str += chr ( sum % 10 + 48 ) carry = ( int ) ( sum / 10 ) if ( carry ) : str += chr ( carry + 48 ) str = str [ : : - 1 ] return str

def findSum ( str1 , str2 ) : str1 = str1 str2 = str2 str1 = "" str2 = "" str = "" n1 = 0 n2 = 0 for i in range ( n1 , n2 ) : sum = ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 [ i ] - '0' ) + carry ) str += ( char ) ( sum % 10 + '0' ) carry = sum / 10 if ( carry > 0 ) : str += ( char ) ( carry + '0' ) return str

def findSum ( str1 , str2 ) : str1 = str1 str2 = str2 n1 = str1 . length , n2 = str2 . length str1 = str1 [ : - 1 ] str2 = str2 [ : - 1 ] carry = 0 for i in range ( n1 , n2 ) : sum = ( ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 [ i ] - '0' ) + carry ) str += ( char ) ( sum % 10 + '0' ) ) carry = sum / 10 for i in range ( n1 , n2 ) : sum = ( ( int ) ( str2 [ i ] - '0' ) + carry ) str += ( char ) ( sum % 10 + '0' ) ) carry = sum / 10 for i in range ( n1 , n2 ) : sum = ( ( int ) ( str2 [ i ] - '0' ) + carry ) str += ( char ) ( sum % 10 + '0' ) ) carry = sum / 10 for i in range ( n1 , n2 ) : sum = ( ( int ) ( str2 [ i ]

22.65
34.76
100.0
100.0
static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }

def findSumSubsets ( n ) : return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) )

def findSumSubsets ( n ) : return ( n * n )

def findSumSubsets ( n ) : return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) )

22.74
28.91
16.1
25.51
static int floorSearch ( int arr [ ] , int n , int x ) { if ( x >= arr [ n - 1 ] ) return n - 1 ; if ( x < arr [ 0 ] ) return - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ; return - 1 ; }

def floorSearch ( arr , low , high , x ) : if ( low > high ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )

def floorSearch ( arr , n , x ) : if ( x >= arr [ n - 1 ] ) : return n - 1 if ( x < arr [ 0 ] ) : return 1 else : for i in range ( 1 , n ) : if ( arr [ i ] > x ) : return ( i - 1 ) return - 1

def floorSearch ( arr , n , x ) : if x >= arr [ n - 1 ] : return n - 1 if x < arr [ 0 ] : return - 1 for i in range ( 1 , n ) : if ( arr [ i ] > x ) : return ( i - 1 ) return - 1

22.76
24.24
46.82
35.81
static char encodedChar ( String str , int k ) { String expand = "" ; String temp = "" ; int freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; ) { temp = "" ; freq = 0 ; while ( i < str . length ( ) && str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand . charAt ( k - 1 ) ; }

def encodedChar ( str , k ) : expand = "" freq = 0 i = 0 while ( i < len ( str ) ) : temp = "" freq = 0 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) : temp += str [ i ] i += 1 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) i += 1 for j in range ( 1 , freq + 1 , 1 ) : expand += temp if ( freq == 0 ) : expand += temp return expand [ k - 1 ]

def encodedChar ( str , k ) : expand = "" temp = "" freq = 0 for i in range ( k ) : temp += str [ i ] while i < str . length ( ) and str [ i ] >= 'a' and str [ i ] <= 'z' : freq = freq * 10 + str [ i ] - '0' i ++ if ( freq == 0 ) : expand += temp return expand . charAt ( k - 1 )

def encodedChar ( str , k ) : expand = "" freq = 0 for i in range ( k ) : temp = "" freq = 0 for i in range ( 0 , k ) : if ( i < str . length ( ) and str [ i ] >= 'a' and str [ i ] <= 'z' ) : temp += str [ i ] i += 1 while ( i < str . length ( ) and str [ i ] >= '1' and str [ i ] <= '9' ) : freq = freq * 10 + str [ i ] - '0' i += 1 for j in range ( 1 , freq ) : expand += temp if freq == 0 : expand += temp return expand . charAt ( k - 1 )

23.06
33.39
36.36
47.99
static int nextFit ( int weight [ ] , int n , int c ) { int res = 0 , bin_rem = c ; for ( int i = 0 ; i < n ; i ++ ) { if ( weight [ i ] > bin_rem ) { res ++ ; bin_rem = c - weight [ i ] ; } else bin_rem -= weight [ i ] ; } return res ; }

def nextfit ( weight , c ) : res = 0 rem = c for _ in range ( len ( weight ) ) : if rem >= weight [ _ ] : rem = rem - weight [ _ ] else : res += 1 rem = c - weight [ _ ] return res

def nextFit ( weight , n , c ) : res = 0 bin_rem = c for i in range ( 0 , n ) : if ( weight [ i ] > bin_rem ) : res += 1 bin_rem -= weight [ i ] if ( bin_rem > c ) : res += 1 bin_rem = c - weight [ i ] if ( bin_rem > weight [ i ] ) : res += 1 bin_rem -= weight [ i ] return

def nextFit ( weight , n , c ) : res = 0 bin_rem = c for i in range ( n ) : if ( weight [ i ] > bin_rem ) : res += 1 bin_rem = c - weight [ i ] else : bin_rem -= weight [ i ] return res

23.13
28.22
39.27
42.51
static String findTwoscomplement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return "1" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , "0" ) ; else str . replace ( k , k + 1 , "1" ) ; } return str . toString ( ) ; }

def findTwoscomplement ( str ) : n = len ( str ) i = n - 1 while ( i >= 0 ) : if ( str [ i ] == '1' ) : break i -= 1 if ( i == - 1 ) : return '1' + str k = i - 1 while ( k >= 0 ) : if ( str [ k ] == '1' ) : str = list ( str ) str [ k ] = '0' str = '' . join ( str ) else : str = list ( str ) str [ k ] = '1' str = '' . join ( str ) k -= 1 return str

def findTwoscomplement ( str ) : n = str . length ( ) for i in range ( n ) : if ( str [ i ] == '1' ) : break if ( str [ i ] == '1' ) : str [ i ] = "0" else : str [ i ] = "1" str . replace ( k , k + 1 , "1" ) return str

def findTwoscomplement ( str ) : n = str . length ( ) for i in range ( n ) : if ( str [ i ] == '1' ) : break if ( i == - 1 ) : return "1" + str for k in range ( i - 1 , - 1 ) : if ( str [ k ] == '1' ) : str . replace ( k , k + 1 , "0" ) else : str . replace ( k , k + 1 , "1" ) return str . toString ( )

23.23
53.53
68.86
75.35
static int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }

def findMinNumber ( n ) : count = 0 ans = 1 while n % 2 == 0 : count += 1 n //= 2 if count % 2 is not 0 : ans *= 2 for i in range ( 3 , ( int ) ( math . sqrt ( n ) ) + 1 , 2 ) : count = 0 while n % i == 0 : count += 1 n //= i if count % 2 is not 0 : ans *= i if n > 2 : ans *= n return ans

def findMinNumber ( n ) : count = 0 ans = 1 while n % 2 == 0 : count ++ ; n /= 2 if ( count % 2 == 1 ) : ans *= 2 if ( n > 2 ) ans *= n return ans

def findMinNumber ( n ) : count = 0 ans = 1 for i in range ( 3 , math . sqrt ( n ) ) : count += 1 while n % 2 == 0 : count += 1 n /= 2 if count % 2 == 1 : ans *= 2 for i in range ( 3 , math . sqrt ( n ) ) : count = 0 while n % i == 0 : count += 1 n /= i if count % 2 == 1 : ans *= i if n > 2 : ans *= n return ans

23.27
32.73
62.41
49.78
static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ; } else { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } } return true ; }

def isValidString ( str ) : freq = [ 0 ] * CHARS for i in range ( len ( str ) ) : freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 freq1 = 0 count_freq1 = 0 for i in range ( CHARS ) : if ( freq [ i ] != 0 ) : freq1 = freq [ i ] count_freq1 = 1 break freq2 = 0 count_freq2 = 0 for j in range ( i + 1 , CHARS ) : if ( freq [ j ] != 0 ) : if ( freq [ j ] == freq1 ) : count_freq1 += 1 else : count_freq2 = 1 freq2 = freq [ j ] break for k in range ( j + 1 , CHARS ) : if ( freq [ k ] != 0 ) : if ( freq [ k ] == freq1 ) : count_freq1 += 1 if ( freq [ k ] == freq2 ) : count_freq2 += 1 else : return False if ( count_freq1 > 1 and count_freq2 > 1 ) : return False return True

def isValidString ( str ) : freq = [ 0 for i in range ( CHARS ) ] for i in range ( len ( str ) ) : freq . append ( 0 ) count_freq1 = 0 count_freq2 = 0 for j in range ( i + 1 , CHARS ) : if ( freq [ j ] == freq1 ) : count_freq1 += 1 freq2 = freq [ j ] break if ( count_freq1 > 1 && count_freq2 > 1 ) : return false

def isValidString ( str ) : freq = [ 0 for i in range ( CHARS ) ] for i in range ( 0 , CHARS ) : freq [ i ] = 0 count_freq1 = 0 for i in range ( 0 , CHARS ) : if ( freq [ i ] != 0 ) : freq1 = freq [ i ] count_freq1 = 1 break if ( freq [ j ] != 0 ) : if ( freq [ j ] == freq1 ) : count_freq1 += 1 else : count_freq2 = 1 freq2 = freq [ j ] break if ( k in range ( j + 1 , CHARS ) ) : if ( freq [ k ] == freq1 ) : count_freq1 += 1 if ( freq [ k ] == freq2 ) : count_freq2 += 1 else : return false return True

23.28
27.78
51.85
41.48
static void sortUsingHash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int min = Math . abs ( Arrays . stream ( a ) . min ( ) . getAsInt ( ) ) ; int hashpos [ ] = new int [ max + 1 ] ; int hashneg [ ] = new int [ min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ; else hashneg [ Math . abs ( a [ i ] ) ] += 1 ; } for ( int i = min ; i > 0 ; i -- ) { if ( hashneg [ i ] > 0 ) { for ( int j = 0 ; j < hashneg [ i ] ; j ++ ) { System . out . print ( ( - 1 ) * i + " " ) ; } } } for ( int i = 0 ; i <= max ; i ++ ) { if ( hashpos [ i ] > 0 ) { for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) { System . out . print ( i + " " ) ; } } } }

def sortUsingHash ( a , n ) : Max = max ( a ) Min = abs ( min ( a ) ) hashpos = [ 0 ] * ( Max + 1 ) hashneg = [ 0 ] * ( Min + 1 ) for i in range ( 0 , n ) : if a [ i ] >= 0 : hashpos [ a [ i ] ] += 1 else : hashneg [ abs ( a [ i ] ) ] += 1 for i in range ( Min , 0 , - 1 ) : if hashneg [ i ] != 0 : for j in range ( 0 , hashneg [ i ] ) : print ( ( - 1 ) * i , end = "" ) for i in range ( 0 , Max + 1 ) : if hashpos [ i ] != 0 : for j in range ( 0 , hashpos [ i ] ) : print ( i , end = "" )

def sortUsingHash ( a , n ) : max = float ( 'inf' ) min = float ( 'inf' ) for i in range ( n ) : if ( a [ i ] >= 0 ) : hashpos [ a [ i ] ] += 1 else : hashneg [ a [ i ] ] += 1 } for i in range ( min , max ) : if ( hashpos [ i ] > 0 ) : print ( ( - 1 ) * i + "

def sortUsingHash ( a , n ) : max = abs ( a ) min = Math . abs ( a ) for i in range ( max + 1 , n ) : if ( a [ i ] >= 0 ) : hashpos [ a [ i ] ] += 1 else : hashneg [ Math . abs ( a [ i ] ) ] += 1 for i in range ( min + 1 , n ) : if ( a [ i ] > 0 ) : for j in range ( hashneg [ i ] ) : : print ( ( - 1 ) * i + " " ) for i in range ( min + 1 , n ) : if ( hashneg [ i ] > 0 ) : for j in range ( hashneg [ i ] ) : : print ( ( - 1 ) * i + " " )

23.31
27.52
23.4
31.11
static int findInteger ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) - 1 ) ; else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] ; return - 1 ; }

def findInteger ( arr , n ) : hash = dict ( ) maximum = 0 for i in arr : if ( i < 0 ) : if abs ( i ) not in hash . keys ( ) : hash [ abs ( i ) ] = - 1 else : hash [ abs ( i ) ] -= 1 else : hash [ i ] = hash . get ( i , 0 ) + 1 for i in arr : if i in hash . keys ( ) and hash [ i ] > 0 : return i return - 1

def findInteger ( arr , n ) : hash = new HashMap < Integer , Integer > ( ) for i in range ( 0 , n ) : if ( arr [ i ] < 0 ) : hash . put ( abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) - 1 ) else : hash . put ( abs ( arr [ i ] ) , ( hash ( arr [ i ] ) ) for i in range ( 0 , n ) : if ( arr [ i ] > 0 ) : return arr [ i ]

def findInteger ( arr , n ) : hash = list ( ) for i in range ( n ) : if arr [ i ] < 0 : hash [ abs ( arr [ i ] ) ] = ( hash . get ( abs ( arr [ i ] ) ) == null ? 0 : hash . get ( abs ( arr [ i ] ) ) - 1 ) else : hash . put ( abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) for i in range ( 0 , n ) : if ( hash [ i ] > 0 ) : return arr [ i ] maximum = max ( maximum , i ) return - 1

23.47
13.88
32.22
21.17
static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

def search ( arr , x ) : n = len ( arr ) for j in range ( 0 , n ) : if ( x == arr [ j ] ) : return j return - 1

def search ( arr , n , x ) : if ( arr [ i ] == x ) : return i

def search ( arr , n , x ) : for i in range ( n ) : if arr [ i ] == x : return i return - 1

23.51
23.9
51.18
64.38
static boolean isRectangle ( int matrix [ ] [ ] ) { int rows = matrix . length ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . length ; HashMap < Integer , HashSet < Integer >> table = new HashMap < > ( ) ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns - 1 ; j ++ ) { for ( int k = j + 1 ; k < columns ; k ++ ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( table . containsKey ( j ) && table . get ( j ) . contains ( k ) ) { return true ; } if ( table . containsKey ( k ) && table . get ( k ) . contains ( j ) ) { return true ; } if ( ! table . containsKey ( j ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( k ) ; table . put ( j , x ) ; } else { table . get ( j ) . add ( k ) ; } if ( ! table . containsKey ( k ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( j ) ; table . put ( k , x ) ; } else { table . get ( k ) . add ( j ) ; } } } } } return false ; }

def isRectangle ( matrix ) : rows = len ( matrix ) if ( rows == 0 ) : return False columns = len ( matrix [ 0 ] ) table = { } for i in range ( rows ) : for j in range ( columns - 1 ) : for k in range ( j + 1 , columns ) : if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : if ( j in table and k in table [ j ] ) : return True if ( k in table and j in table [ k ] ) : return True if j not in table : table [ j ] = set ( ) if k not in table : table [ k ] = set ( ) table [ j ] . add ( k ) table [ k ] . add ( j ) return False

def isRectangle ( matrix ) : rows = matrix . length columns = matrix [ 0 ] . length for i in range ( rows , columns ) : for j in range ( columns - 1 , - 1 ) : if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : return true if ( table [ j ] != null ) : return false

def isRectangle ( matrix ) : rows = matrix . length columns = matrix [ 0 ] . length table = new HashMap ( ) for i in range ( rows ) : for j in range ( rows ) : for k in range ( j + 1 , columns ) : if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : if ( table [ j ] and table [ j ] [ k ] == 1 ) : return True if ( table [ k ] and table [ k ] [ j ] == 1 ) : return True if ( not table [ j ] ) : HashSet < Integer > x = new HashSet ( ) x . add ( k ) table . put ( j , x ) else : table [ j ] . add ( k ) if ( not table [ k ] ) : HashSet < Integer > x = new HashSet ( ) x . add ( j ) table . put ( k , x ) else : table [ k ] . add ( j ) return ( not table [ k ] )

23.55
32.82
50.42
37.37
static void randomize ( int arr [ ] , int n ) { Random r = new Random ( ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int j = r . nextInt ( i + 1 ) ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } System . out . println ( Arrays . toString ( arr ) ) ; }

def randomize ( arr , n ) : for i in range ( n - 1 , 0 , - 1 ) : j = random . randint ( 0 , i + 1 ) arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] return arr

def randomize ( arr , n ) : r = new Random ( ) for i in range ( n ) : j = r . nextInt ( i + 1 ) arr [ i ] = arr [ j ] temp = arr [ i ] arr [ j ] = temp i = n - 1 while i > 0 : j = r . nextInt ( i + 1 ) arr [ i ] = arr [ j ] temp = arr [ i ] arr [ j ] = arr [ j ] if ( temp == arr [ i ] ) : arr [ j ] = arr [ j ] if ( arr [ i ] != arr [ j ] ) : arr [ j ] = temp return arr [ i ]

def randomize ( arr , n ) : r = random ( n ) for i in range ( n ) : j = r . nextInt ( i + 1 ) arr [ i ] = arr [ j ] arr [ j ] = temp

23.56
40.89
27.67
32.5
static void translate ( char str [ ] ) { int len = str . length ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) { j = j + 2 ; str [ i ++ ] = 'C' ; continue ; } str [ i ++ ] = str [ j ++ ] ; } if ( j == len - 1 ) str [ i ++ ] = str [ j ] ; str [ i ] = ' ' ; str [ len - 1 ] = ' ' ; }

def translate ( st ) : l = len ( st ) if ( l < 2 ) : return i = 0 j = 0 while ( j < l - 1 ) : if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) : j += 2 st [ i ] = 'C' i += 1 continue st [ i ] = st [ j ] i += 1 j += 1 if ( j == l - 1 ) : st [ i ] = st [ j ] i += 1 st [ i ] = '' st [ l - 1 ] = ''

def translate ( str ) : len = len ( str ) for j in range ( 0 , len ) : if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) : j = j + 2 str [ i ++ ] = str [ j ] str [ i ] = ' ' str [ len - 1 ] = ' ' str [ len - 1 ] = ' ' str [ len - 1 ] = ' ' str [ len -

def translate ( str ) : i = 0 j = 0 while j < len - 1 : if str [ j ] == 'A' and str [ j + 1 ] == 'B' : j = j + 2 str [ i ++ ] = 'C' continue if j == len - 1 : str [ i ++ ] = str [ j ] str [ i ] = str [ j ] str [ i ] = ' ' str [ len - 1 ] = ' '

23.76
22.74
23.16
22.32
static int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }

def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

def factorial ( n ) : res = 1 for i in range ( n ) : res *= i return res

def factorial ( n ) : res = 1 for i in range ( 2 , n ) : res *= i return res

23.76
22.74
23.16
22.32
static int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }

def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

def factorial ( n ) : res = 1 for i in range ( n ) : res *= i return res

def factorial ( n ) : res = 1 for i in range ( 2 , n ) : res *= i return res

23.94
24.02
57.22
48.67
static double sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }

def sumNodes ( l ) : leafNodeCount = math . pow ( 2 , l - 1 ) sumLastLevel = 0 sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) sum = sumLastLevel * l return int ( sum )

def sumNodes ( l ) : leafNodeCount = 2 ** l - 1 sumLastLevel = 0 sum = sumLastLevel * l return sum

def sumNodes ( l ) : leafNodeCount = float ( l ) sumLastLevel = 0 sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 sum = sumLastLevel * l return sum

23.98
31.45
12.21
22.71
static void findRandomIndexOfMax ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } int max_element = Integer . MIN_VALUE ; int max_so_far = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > p : mp . entrySet ( ) ) { if ( p . getValue ( ) > max_so_far ) { max_so_far = p . getValue ( ) ; max_element = p . getKey ( ) ; } } int r = ( int ) ( ( new Random ( ) . nextInt ( max_so_far ) % max_so_far ) + 1 ) ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) count ++ ; if ( count == r ) { System . out . print ( "Element with maximum frequency present " + "at index " + i + "\n" ) ; break ; } } }

def findRandomIndexOfMax ( arr , n ) : mp = dict ( ) for i in range ( n ) : if ( arr [ i ] in mp ) : mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 else : mp [ arr [ i ] ] = 1 max_element = - 323567 max_so_far = - 323567 for p in mp : if ( mp [ p ] > max_so_far ) : max_so_far = mp [ p ] max_element = p r = int ( ( ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) ) i = 0 count = 0 while ( i < n ) : if ( arr [ i ] == max_element ) : count = count + 1 if ( count == r ) : print ( "Elementwithmaximumfrequencypresentatindex" , i ) break i = i + 1

def findRandomIndexOfMax ( arr , n ) : mp = dict ( ) for i in range ( n ) : if ( arr [ i ] == max_element ) : max_so_far = float ( 'inf' ) elif ( arr [ i ] == max_element ) : max_so_far = float ( 'inf' ) for i in range ( n ) : if ( mp [ arr [ i ] ] > max_so_far ) : max_element = p .

def findRandomIndexOfMax ( arr , n ) : mp = new HashMap ( ) for i in range ( n ) : if ( arr [ i ] == max_element ) : count += 1 if ( count == r ) : print ( "Element with maximum frequency present " + "at index " + i + "\n" ) break

24.01
26.17
30.37
19.89
static void rotateMatrix ( int mat [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j >= 0 ; j -- ) System . out . print ( mat [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

def rotateMatrix ( mat ) : i = N - 1 while ( i >= 0 ) : j = N - 1 while ( j >= 0 ) : print ( mat [ i ] [ j ] , end = "" ) j = j - 1 print ( ) i = i - 1

def rotateMatrix ( N , mat ) : mat . sort ( reverse = True ) for i in range ( N ) : for j in range ( N ) : print ( mat [ i ] [ j ] + " " ) print ( ) if ( j >= 0 ) : print ( mat [ i ] [ j ] + " " ) print ( ) if ( i >= 0 ) : print ( mat [ i ] [ j ] + " " ) print ( ) if ( j >= 0 ) : print ( )

def rotateMatrix ( mat ) : for i in range ( N ) : for j in range ( N ) : print ( mat [ i ] [ j ] + " " ) print ( mat [ i ] [ j ] )

24.09
29.63
23.43
46.19
static void printRect ( Integer X [ ] , Integer Y [ ] , int n ) { int Xmax = Collections . max ( Arrays . asList ( X ) ) ; int Xmin = Collections . min ( Arrays . asList ( X ) ) ; int Ymax = Collections . max ( Arrays . asList ( Y ) ) ; int Ymin = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( "{" + Xmin + ", " + Ymin + "}" ) ; System . out . println ( "{" + Xmin + ", " + Ymax + "}" ) ; System . out . println ( "{" + Xmax + ", " + Ymax + "}" ) ; System . out . println ( "{" + Xmax + ", " + Ymin + "}" ) ; }

def printRect ( X , Y , n ) : Xmax = max ( X ) Xmin = min ( X ) Ymax = max ( Y ) Ymin = min ( Y ) print ( "{" , Xmin , "," , Ymin , "}" , sep = "" ) print ( "{" , Xmin , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymin , "}" , sep = "" )

def printRect ( X , Y , n ) : Xmax , Xmin = list ( range ( n ) ) Ymax = list ( range ( n ) ) Ymin = list ( range ( n ) ) out . println ( "{" + Xmin + ", " + Ymin + "}" ) print ( "{" + Xmax + ", " + Ymax + "}" ) print ( "{" + Xmin + ", " + Ymin + "}" ) print ( "{" + Xmax +

def printRect ( X , Y , n ) : Xmax = max ( list ( X ) ) Xmin = min ( list ( X ) ) Ymax = max ( list ( Y ) ) Ymin = min ( list ( Y ) ) print ( "{" + Xmin + ", " + Ymin + "}" ) sys . out . println ( "{" + Xmin + ", " + Ymax + "}" ) sys . out . println ( "{" + Xmax + ", " + Ymax + "}" ) sys . out . println ( "{" + Xmax + ", " + Ymin + "}" ) sys . out . println ( "{" + Xmax + ", " + Ymax + "}" ) sys . out . println ( "{" + Xmax + ", " + Ymin + "}" )

24.11
39.81
67.15
60.74
static int minimumSquare ( int m , int n ) { int vertical_min = Integer . MAX_VALUE ; int horizontal_min = Integer . MAX_VALUE ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] != 0 ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = Math . min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = Math . min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = Math . min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; }

def minimumSquare ( m , n ) : vertical_min = 10000000000 horizontal_min = 10000000000 if m == n : return 1 if dp [ m ] [ n ] != 0 : return dp [ m ] [ n ] for i in range ( 1 , m // 2 + 1 ) : horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) for j in range ( 1 , n // 2 + 1 ) : vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) return dp [ m ] [ n ]

def minimumSquare ( m , n ) : vertical_min = float ( 'inf' ) horizontal_min = float ( 'inf' ) for i in range ( 1 , m , n ) : horizontal_min = min ( horizontal_min , vertical_min ) dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) return dp [ m ] [ n ]

def minimumSquare ( m , n ) : vertical_min = float ( 'inf' ) horizontal_min = float ( 'inf' ) for i in range ( 1 , m , 2 ) : horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) for j in range ( 1 , n ) : vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) return dp [ m ] [ n ]

24.22
34.42
81.16
85.88
static int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }

def countStr ( n ) : return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) )

def countStr ( n ) : return 1 + ( n * 2 )

def countStr ( n ) : return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 )

24.27
19.3
50.04
31.61
static int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }

def isPowerOfFour ( n ) : count = 0 if ( n and ( not ( n & ( n - 1 ) ) ) ) : while ( n > 1 ) : n >>= 1 count += 1 if ( count % 2 == 0 ) : return True else : return False

def isPowerOfFour ( n ) : count = 0 x = n & ( n - 1 ) count += 1 if x == 0 : return 1

def isPowerOfFour ( n ) : count = 0 x = n & ( n - 1 ) if n > 0 and x == 0 : while n > 1 : n >>= 1 count += 1 return ( count % 2 == 0 ) ? 1 : 0

24.28
26.68
33.81
26.73
static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num . charAt ( i ++ ) - '0' ) * 100 ; group += ( num . charAt ( i ++ ) - '0' ) * 10 ; group += num . charAt ( i ) - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = Integer . toString ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ? 1 : 0 ; } return ( gSum == 999 ) ; }

def isDivisible999 ( num ) : n = len ( num ) ; if ( n == 0 or num [ 0 ] == '0' ) : return true if ( ( n % 3 ) == 1 ) : num = "00" + num if ( ( n % 3 ) == 2 ) : num = "0" + num gSum = 0 for i in range ( 0 , n , 3 ) : group = 0 group += ( ord ( num [ i ] ) - 48 ) * 100 group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 group += ( ord ( num [ i + 2 ] ) - 48 ) gSum += group if ( gSum > 1000 ) : num = str ( gSum ) n = len ( num ) gSum = isDivisible999 ( num ) return ( gSum == 999 )

def isDivisible999 ( num ) : n = num . length ( ) gSum = 0 for i in range ( 0 , n ) : group = 0 gSum += ( num [ i ] - '0' ) * 100 group += num [ i ] - '0' gSum += group if ( gSum > 1000 ) : num = Integer . toString ( gSum ) n = num . length ( ) gSum = isDivisible999 ( num ) : gSum =

def isDivisible999 ( num ) : n = num . length ( ) gSum = 0 for i in range ( 0 , n , - 1 , - 1 ) : group = 0 group += ( num [ i ] - '0' ) * 100 group += ( num [ i ] - '0' ) * 10 group += num [ i ] - '0' gSum += group if gSum > 1000 : num = float ( gSum ) n = num . length ( ) gSum = isDivisible999 ( num ) ? 1 : 0 return ( gSum == 999 )

24.53
26.26
41.22
37.82
static int kthNonRepeating ( String str , int k ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }

def kthNonRepeating ( str , k ) : n = len ( str ) count = [ 0 ] * MAX_CHAR index = [ 0 ] * MAX_CHAR for i in range ( MAX_CHAR ) : count [ i ] = 0 index [ i ] = n for i in range ( n ) : x = str [ i ] count [ ord ( x ) ] += 1 if ( count [ ord ( x ) ] == 1 ) : index [ ord ( x ) ] = i if ( count [ ord ( x ) ] == 2 ) : index [ ord ( x ) ] = n index . sort ( ) return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1

def kthNonRepeating ( str , k ) : count = [ 0 for i in range ( n ) ] index = [ MAX_CHAR ] for i in range ( n ) : if ( count [ i ] == 1 ) : index [ i ] = i if ( count [ x ] == 2 ) : index [ x ] = n return k - 1

def kthNonRepeating ( str , k ) : count = [ 0 for k in range ( k ) ] index = [ MAX_CHAR ] for i in range ( n ) : count [ i ] = 0 index [ i ] = n for i in range ( n ) : x = str [ i ] if count [ x ] == 1 : index [ x ] = i if count [ x ] == 2 : index [ x ] = n return ( index [ k - 1 ] != n )

24.6
34.91
58.59
55.41
static void KMP ( int m , int n , String str2 , String str1 ) { int pos = 0 , len = 0 ; int [ ] p = new int [ m + 1 ] ; int k = 0 ; char [ ] ch1 = str1 . toCharArray ( ) ; char [ ] ch2 = str2 . toCharArray ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] ; if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p [ j ] ; if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } System . out . println ( "Shift = " + pos ) ; System . out . println ( "Prefix = " + str1 . substring ( 0 , len ) ) ; }

def KMP ( m , n , str2 , str1 ) : pos = 0 Len = 0 p = [ 0 for i in range ( m + 1 ) ] k = 0 for i in range ( 2 , n + 1 ) : while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) : k = p [ k ] if ( str1 [ k ] == str1 [ i - 1 ] ) : k += 1 p [ i ] = k j = 0 for i in range ( m ) : while ( j > 0 and j < n and str1 [ j ] != str2 [ i ] ) : j = p [ j ] if ( j < n and str1 [ j ] == str2 [ i ] ) : j += 1 if ( j > Len ) : Len = j pos = i - j + 1 print ( "Shift=" , pos ) print ( "Prefix=" , str1 [ : Len ] )

def KMP ( m , n , str1 , str2 ) : p = [ 0 for i in range ( m , n ) ] for i in range ( 2 , n ) : while ( k > 0 and ch1 [ k ] != ch1 [ i - 1 ] ) : k = p [ k ] if ( ch1 [ k ] == ch1 [ i - 1 ] ) : j += 1 if ( j > len ) : len = j pos =

def KMP ( m , n , str1 , str2 ) : pos = 0 len = 0 p = [ m + 1 ] for i in range ( 2 , n ) : k = 0 while ( k > 0 and ch1 [ k ] != ch1 [ i - 1 ] ) : k = p [ k ] if ( ch1 [ k ] == ch1 [ i - 1 ] ) : ++ k k p [ i ] = k } for j in range ( 0 , i < m ) : while ( j > 0 and ch1 [ j ] != ch2 [ i ] ) : j = p [ j ] if ( j < n and ch1 [ j ] == ch2 [ i ] ) : j += 1 if ( j > len ) : len = j pos = i - j + 1 print ( "Prefix = " + str1 [ 0 , len ] )

24.7
35.66
59.16
68.31
static void PerformQueries ( int [ ] a , int [ ] [ ] vec ) { Vector < Integer > ans = new Vector < > ( ) ; int n = ( int ) a . length - 1 ; int q = ( int ) vec . length ; for ( int i = 0 ; i < q ; ++ i ) { long t = vec [ i ] [ 0 ] ; int m = vec [ i ] [ 1 ] ; if ( m > n ) { ans . add ( - 1 ) ; continue ; } int turn = ( int ) ( t / n ) ; int rem = ( int ) ( t % n ) ; if ( rem == 0 && turn % 2 == 1 ) { ans . add ( - 1 ) ; continue ; } if ( rem == 0 && turn % 2 == 0 ) { ans . add ( a [ m ] ) ; continue ; } if ( turn % 2 == 0 ) { int cursize = n - rem ; if ( cursize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m + rem ] ) ; } else { int cursize = rem ; if ( cursize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m ] ) ; } } for ( int i : ans ) System . out . print ( i + "\n" ) ; }

def PerformQueries ( a , vec ) : ans = [ ] n = len ( a ) - 1 q = len ( vec ) for i in range ( q ) : t = vec [ i ] [ 0 ] m = vec [ i ] [ 1 ] if ( m > n ) : ans . append ( - 1 ) continue turn = t // n rem = t % n if ( rem == 0 and turn % 2 == 1 ) : ans . append ( - 1 ) continue if ( rem == 0 and turn % 2 == 0 ) : ans . append ( a [ m ] ) continue if ( turn % 2 == 0 ) : cursize = n - rem if ( cursize < m ) : ans . append ( - 1 ) continue ans . append ( a [ m + rem ] ) else : cursize = rem if ( cursize < m ) : ans . append ( - 1 ) continue ans . append ( a [ m ] ) for i in ans : print ( i )

def PerformQueries ( a , vec ) : ans = new Vector < Integer > ( ) for i in range ( q ) : for m in range ( n ) : if ( m > n ) : ans . add ( - 1 ) continue if ( turn > 1 ) : ans . add ( - 1 ) continue if ( rem == 0 and turn % 2 == 0 ) : ans . add ( a [ m ] ) ; continue if ( turn % 2 == 0 ) : ans .

def PerformQueries ( a , vec ) : ans = list ( ) for i in range ( q ) : t = vec [ i ] [ 0 ] m = vec [ i ] [ 1 ] if m > n : ans . add ( - 1 ) continue turn = ( int ) ( t / n ) rem = ( int ) ( t % n ) if rem == 0 and turn % 2 == 1 : ans . add ( - 1 ) continue if rem == 0 and turn % 2 == 0 : ans . add ( a [ m ] ) continue if turn % 2 == 0 : cursize = n - rem if cursize < m : ans . add ( - 1 ) continue ans . add ( a [ m + rem ] ) else : cursize = rem if cursize < m : ans . add ( - 1 ) continue ans . add ( a [ m ] )

24.72
31.03
21.3
42.58
static void countDistinct ( int arr [ ] , int k ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } } System . out . println ( dist_count ) ; for ( int i = k ; i < arr . length ; i ++ ) { if ( hM . get ( arr [ i - k ] ) == 1 ) { hM . remove ( arr [ i - k ] ) ; dist_count -- ; } else { int count = hM . get ( arr [ i - k ] ) ; hM . put ( arr [ i - k ] , count - 1 ) ; } if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } System . out . println ( dist_count ) ; } }

def countDistinct ( arr , k , n ) : mp = defaultdict ( lambda : 0 ) dist_count = 0 for i in range ( k ) : if mp [ arr [ i ] ] == 0 : dist_count += 1 mp [ arr [ i ] ] += 1 print ( dist_count ) for i in range ( k , n ) : if mp [ arr [ i - k ] ] == 1 : dist_count -= 1 mp [ arr [ i - k ] ] -= 1 if mp [ arr [ i ] ] == 0 : dist_count += 1 mp [ arr [ i ] ] += 1 print ( dist_count )

def countDistinct ( arr , k ) : hM = defaultdict ( int ) for i in range ( k ) : if ( hM . get ( arr [ i ] ) == 1 ) : hM . put ( arr [ i ] , 1 ) dist_count += 1 else : int count = hM . get ( arr [ i ] ) hM . put ( arr [ i ] , count - 1 ) if ( hM . get ( arr [ i ] ) == null ) : hM .

def countDistinct ( arr , k ) : hM = list ( ) dist_count = 0 for i in range ( k ) : if ( hM . get ( arr [ i - k ] ) == 1 ) : hM . remove ( arr [ i - k ] ) dist_count -- ; else : int count = hM . get ( arr [ i - k ] ) hM . put ( arr [ i - k ] , count - 1 ) if ( hM . get ( arr [ i ] ) == null ) : hM . put ( arr [ i ] , 1 ) dist_count ++ else : int count = hM . get ( arr [ i ] ) hM . put ( arr [ i ] , count + 1 ) } if ( hM . get ( arr [ i ] ) == None ) : hM . put ( arr [ i ] , 1 ) dist_count ++ else : int count = hM . get ( arr [ i ] ) hM . put ( arr [ i ] , count + 1 )

24.94
21.4
53.44
38.71
static int totalNodes ( Vector < Integer > adjac [ ] , int n , int x , int y ) { Boolean visited [ ] = new Boolean [ n + 1 ] ; Arrays . fill ( visited , false ) ; int p [ ] = new int [ n ] ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( x ) ; visited [ x ] = true ; int m ; while ( ! q . isEmpty ( ) ) { m = q . peek ( ) ; q . poll ( ) ; for ( int i = 0 ; i < adjac [ m ] . size ( ) ; ++ i ) { int h = adjac [ m ] . get ( i ) ; if ( visited [ h ] != true ) { visited [ h ] = true ; p [ h ] = m ; q . add ( h ) ; } } } int count = 0 ; int i = p [ y ] ; while ( i != x ) { count ++ ; i = p [ i ] ; } return count ; }

def totalNodes ( adjac , n , x , y ) : visited = [ 0 ] * ( n + 1 ) p = [ None ] * n q = queue . Queue ( ) q . put ( x ) visited [ x ] = True m = None while ( not q . empty ( ) ) : m = q . get ( ) for i in range ( len ( adjac [ m ] ) ) : h = adjac [ m ] [ i ] if ( not visited [ h ] ) : visited [ h ] = True p [ h ] = m q . put ( h ) count = 0 i = p [ y ] while ( i != x ) : count += 1 i = p [ i ] return count

def totalNodes ( adjac , n , x , y ) : visited = [ false for k in range ( n ) ] p = [ n + 1 ] q = list ( ) for m in range ( n ) : if ( visited [ m ] != true ) : visited [ m ] = true p [ m ] = m q . poll ( ) if ( visited [ x ] != true ) : visited [ x ] = true q . add ( x ) m = q .

def totalNodes ( adjac , n , x , y ) : visited = [ False for k in range ( n ) ] p = [ x for k in range ( n ) ] q . add ( x ) visited [ x ] = True m = q . peek ( ) q . poll ( ) for i in range ( 0 , n ) : if ( visited [ h ] != True ) : visited [ h ] = True p [ h ] = m q . add ( i ) count = 0 i = p [ y ] while ( i != x ) : count ++ i = p [ i ] return count

25.0
40.66
31.62
51.21
static int getOddOccurrence ( int arr [ ] , int n ) { HashMap < Integer , Integer > hmap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hmap . containsKey ( arr [ i ] ) ) { int val = hmap . get ( arr [ i ] ) ; hmap . put ( arr [ i ] , val + 1 ) ; } else hmap . put ( arr [ i ] , 1 ) ; } for ( Integer a : hmap . keySet ( ) ) { if ( hmap . get ( a ) % 2 != 0 ) return a ; } return - 1 ; }

def getOddOccurrence ( arr , size ) : Hash = dict ( ) for i in range ( size ) : Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 for i in Hash : if ( Hash [ i ] % 2 != 0 ) : return i return - 1

def getOddOccurrence ( arr , n ) : hmap = defaultdict ( int ) for i in range ( n ) : if ( hmap . containsKey ( arr [ i ] ) ) : val = hmap [ arr [ i ] ] if ( val + 1 > arr [ i ] ) : hmap . put ( arr [ i ] , val + 1 ) else : hmap [ arr [ i ] ] = 1 } for a in range ( 0 , n ) : if ( hmap . containsKey ( a ) : if ( hmap [ a ] ) : if ( hmap [ a ] % 2 != 0 ) : return a

def getOddOccurrence ( arr , n ) : hmap = list ( ) for i in range ( n ) : if ( hmap . containsKey ( arr [ i ] ) ) : val = hmap [ arr [ i ] ] hmap . put ( arr [ i ] , val + 1 ) else : hmap [ arr [ i ] , 1 ) for a in hmap . keySet ( ) : if hmap [ a ] % 2 != 0 : return a return - 1

25.02
29.7
2.09
7.93
static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( "No Pythagoras " + "Triplet exists" ) ; else if ( n % 2 == 0 ) { int var = 1 * n * n / 4 ; System . out . print ( "Pythagoras Triplets " + "exist i.e. " ) ; System . out . print ( n + " " ) ; System . out . print ( var - 1 + " " ) ; System . out . println ( var + 1 + " " ) ; } else if ( n % 2 != 0 ) { int var = 1 * n * n + 1 ; System . out . print ( "Pythagoras Triplets " + "exist i.e. " ) ; System . out . print ( n + " " ) ; System . out . print ( var / 2 - 1 + " " ) ; System . out . println ( var / 2 + " " ) ; } }

def evaluate ( n ) : if ( n == 1 or n == 2 ) : print ( "NoPythagoras" + "Tripletexists" ) elif ( n % 2 == 0 ) : var = n * n / 4 print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var - 1 ) , "" , int ( var + 1 ) ) elif ( n % 2 != 0 ) : var = n * n + 1 print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , int ( var / 2 ) )

def evaluate ( n ) : if n == 0 : print ( "No Pythagoras Triplet exists" ) elif n == 1 or n == 2 : print ( "Pythagoras Triplet exists" ) elif n % 2 == 1 : print ( "Pythagoras Triplets " + "exist i.e. " ) ; System . out . print ( n + " " ) ; System . out . print ( var - 1 + " " ) ; System . out . println ( var + 1 ) else : print ( "Pythagoras Triplet exists" ) elif n % 2 == 2 : int var = 1 * n * n + 1 ) System . out . print ( var / 2 != 0 ) : print ( "Pythagoras Triplets " + "exist i.e. " ) System . out . print ( n + " " ) System . out . print ( var / 2 - 1 + " " ) System . out . println ( var / 2 + " " )

def evaluate ( n ) : if n == 1 or n == 2 : print ( "No Pythagoras Triplets exists" ) else : print ( "No Pythagoras Triplets exists" )

25.21
22.24
24.91
22.94
private static void findMajority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length / 2 ) { System . out . println ( "Majority found :- " + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( " No Majority element" ) ; }

def findMajority ( arr , size ) : m = { } for i in range ( size ) : if arr [ i ] in m : m [ arr [ i ] ] += 1 else : m [ arr [ i ] ] = 1 count = 0 for key in m : if m [ key ] > size / 2 : count = 1 print ( "Majorityfound:-" , key ) break if ( count == 0 ) : print ( "NoMajorityelement" )

def findMajority ( arr ) : map = new HashMap < Integer , Integer > ( ) for i in range ( arr . length ) : if ( map . containsKey ( arr [ i ] ) ) : count = map . get ( arr [ i ] ) + 1 else : count = 1 map . put ( arr [ i ] , count ) if ( count > arr . length / 2 ) : print ( "Majority found :- " + arr [ i ] ) return

def findMajority ( arr ) : map = new HashMap ( ) for i in range ( len ( arr ) ) : if map . containsKey ( arr [ i ] ) : count = map [ arr [ i ] ] + 1 if count > arr . length / 2 : print ( "Majority found :- " + arr [ i ] ) return else : map . put ( arr [ i ] , count ) else : map . put ( arr [ i ] , 1 )

25.25
27.98
46.18
40.44
static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int char_count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) if ( char_count [ s2 . charAt ( i ) - 'a' ] -- <= 0 ) count ++ ; return count ; }

def countManipulations ( s1 , s2 ) : count = 0 char_count = [ 0 ] * 26 for i in range ( 26 ) : char_count [ i ] = 0 for i in range ( len ( s1 ) ) : char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( s2 ) ) : char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1 if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] < 0 ) : count += 1 return count

def countManipulations ( s1 , s2 ) : char_count = [ 0 for i in range ( len ( s1 ) ) ] for i in range ( len ( s2 ) ) : if ( char_count [ s1 [ i ] - 'a' ] >= 0 ) : count += 1 return count

def countManipulations ( s1 , s2 ) : count = 0 char_count = [ 0 for k in range ( 26 ) ] for i in range ( len ( s1 ) ) : char_count [ s1 [ i ] - 'a' ] += 1 for i in range ( len ( s2 ) ) : if ( char_count [ s2 [ i ] - 'a' ] -- <= 0 ) : count += 1 return count

25.25
39.2
35.73
42.78
static void recursiveReverse ( char [ ] str , int i ) { int n = str . length ; if ( i == n / 2 ) return ; swap ( str , i , n - i - 1 ) ; recursiveReverse ( str , i + 1 ) ; }

def recursiveReverse ( str , i = 0 ) : n = len ( str ) if i == n // 2 : return str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] recursiveReverse ( str , i + 1 )

def recursiveReverse ( str , i ) : n = str . length for i in range ( n ) : recursiveReverse ( str , i + 1 , n - i - 1 ) swap ( str , i , n - i - 1 ) recursiveReverse ( str , i + 1 ) swap ( str , i , n - i - 1 ) recursiveReverse ( str , i + 1 ) swap ( str , i , n - i - 1 ) recursiveReverse ( str , i +

def recursiveReverse ( str , i ) : n = str . length if i == n / 2 : return swap ( str , i , n - i - 1 ) recursiveReverse ( str , i + 1 )

25.42
26.43
51.28
42.64
static void findLIS ( int A [ ] , int n ) { Map < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; int LIS_size = 1 ; int LIS_index = 0 ; hash . put ( A [ 0 ] , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { hash . put ( A [ i ] , hash . get ( A [ i ] - 1 ) == null ? 1 : hash . get ( A [ i ] - 1 ) + 1 ) ; if ( LIS_size < hash . get ( A [ i ] ) ) { LIS_size = hash . get ( A [ i ] ) ; LIS_index = A [ i ] ; } } System . out . println ( "LIS_size = " + LIS_size ) ; System . out . print ( "LIS : " ) ; int start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { System . out . print ( start + " " ) ; start ++ ; } }

def findLIS ( A , n ) : hash = dict ( ) LIS_size , LIS_index = 1 , 0 hash [ A [ 0 ] ] = 1 for i in range ( 1 , n ) : if A [ i ] - 1 not in hash : hash [ A [ i ] - 1 ] = 0 hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 if LIS_size < hash [ A [ i ] ] : LIS_size = hash [ A [ i ] ] LIS_index = A [ i ] print ( "LIS_size=" , LIS_size ) print ( "LIS:" , end = "" ) start = LIS_index - LIS_size + 1 while start <= LIS_index : print ( start , end = "" ) start += 1

def findLIS ( A , n ) : hash . clear ( ) LIS_size = 1 LIS_index = 0 for i in range ( n ) : hash . put ( A [ i ] , 1 ) if ( LIS_size < hash [ A [ i ] ] ) : LIS_size = hash [ A [ i ] ] LIS_index = A [ i ] if ( LIS_index < A [ i ] ) : LIS_index =

def findLIS ( A , n ) : LIS_size = 1 LIS_index = 0 hash . update ( A , 1 ) for i in range ( 1 , n ) : hash [ A [ i ] , hash [ A [ i ] - 1 ] + 1 ) if ( LIS_size < hash [ A [ i ] ] ) : LIS_size = hash [ A [ i ] ] LIS_index = A [ i ] print ( "LIS : " ) start = LIS_index - LIS_size + 1 while start <= LIS_index : print ( start + " " ) start += 1

25.47
34.34
77.39
77.93
static float areacircumscribed ( float a ) { float PI = 3.14159265f ; return ( a * a * ( PI / 2 ) ) ; }

def areacircumscribed ( a ) : return ( a * a * ( PI / 2 ) )

def areacircumscribed ( a ) : return a

def areacircumscribed ( a ) : PI = 3.14159265f return ( a * a * ( PI / 2 ) )

25.47
30.17
100.0
100.0
int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }

def pentagonalNum ( n ) : return ( 3 * n * n - n ) / 2

def pentagonalNum ( n ) : return n

def pentagonalNum ( n ) : return ( 3 * n * n - n ) / 2

25.59
25.61
36.17
36.2
static String arrangeString ( String str ) { int char_count [ ] = new int [ MAX_CHAR ] ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) char_count [ str . charAt ( i ) - 'A' ] ++ ; else sum = sum + ( str . charAt ( i ) - '0' ) ; } String res = "" ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( 'A' + i ) ; while ( char_count [ i ] -- != 0 ) res = res + ch ; } if ( sum > 0 ) res = res + sum ; return res ; }

def arrangeString ( string ) : char_count = [ 0 ] * MAX_CHAR s = 0 for i in range ( len ( string ) ) : if string [ i ] >= "A" and string [ i ] <= "Z" : char_count [ ord ( string [ i ] ) - ord ( "A" ) ] += 1 else : s += ord ( string [ i ] ) - ord ( "0" ) res = "" for i in range ( MAX_CHAR ) : ch = chr ( ord ( "A" ) + i ) while char_count [ i ] : res += ch char_count [ i ] -= 1 if s > 0 : res += str ( s ) return res

def arrangeString ( str ) : char_count = [ 0 for i in range ( len ( str ) ) ] for i in range ( len ( str ) ) : if ( Character . isUpperCase ( str [ i ] ) ) : char_count [ i ] = 1 else : sum = 0 for i in range ( len ( str ) ) : char_count [ i ] = 1 res = res + ch if ( sum > 0 ) : res = res + sum return res

def arrangeString ( str ) : char_count = [ 0 for i in range ( MAX_CHAR ) ] sum = 0 for i in range ( 0 , MAX_CHAR ) : if ( Character isUpperCase ( str [ i ] ) ) : char_count [ str [ i ] - 'A' ] ++ else : sum = sum + ( str [ i ] - '0' ) res = "" for i in range ( 0 , MAX_CHAR ) : ch = ( char ) ( 'A' + i ) while char_count [ i ] -- : res = res + ch if sum > 0 : res = res + sum return res

25.79
23.82
38.06
32.49
static void minMaxLengthWords ( String input ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int min_length = len , min_start_index = 0 , max_length = 0 , max_start_index = 0 ; while ( ei <= len ) { if ( ei < len && input . charAt ( ei ) != ' ' ) { ei ++ ; } else { int curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } if ( curr_length > max_length ) { max_length = curr_length ; max_start_index = si ; } ei ++ ; si = ei ; } } minWord = input . substring ( min_start_index , min_start_index + min_length ) ; maxWord = input . substring ( max_start_index , max_length ) ; }

def minMaxLengthWords ( inp ) : length = len ( inp ) si = ei = 0 min_length = length min_start_index = max_length = max_start_index = 0 while ei <= length : if ( ei < length ) and ( inp [ ei ] != "" ) : ei += 1 else : curr_length = ei - si if curr_length < min_length : min_length = curr_length min_start_index = si if curr_length > max_length : max_length = curr_length max_start_index = si ei += 1 si = ei minWord = inp [ min_start_index : min_start_index + min_length ] maxWord = inp [ max_start_index : max_length ] print ( "Minimumlengthword:" , minWord ) print ( "Maximumlengthword:" , maxWord )

def minMaxLengthWords ( input ) : si = 0 ei = 0 for ei <= len : min_length = len min_start_index = 0 max_length = len while ei <= len : min_start_index = ei + 1 max_start_index = ei if ( input [ ei ] != ' ' ) : ei += 1 else : curr_length = len if ( curr_length < min_length ) { min_length = curr_length min_start_index = si if ( curr_length > max_length = curr_length max_length = curr_length min_start_index = ei - 1 max_start_index = ei + 1 if ( curr_length > max_length ) : max_length = curr_length min_start_index = si if ( curr_length > max_length ) : max_length = curr_length min_length = curr_length max_length = curr_length min_start_index = si if ( curr_length > max_start_index > max_length ) : max_length = curr_length max_start_index = si if ( curr_length > max_start_index ) : max_start_index

def minMaxLengthWords ( input ) : si = 0 ei = 0 min_length = len min_start_index = 0 max_length = 0 max_start_index = 0 si = 0 while ei <= len : if ei < len and input [ ei ] != ' ' : ei ++ : if ( curr_length < min_length ) : min_length = curr_length min_start_index = si if ( curr_length > min_length ) : max_length = curr_length max_start_index = si si = ei break minWord = input [ min_start_index : min_start_index + min_length ] maxWord = input [ max_start_index : max_length ] return minWord , maxWord

25.8
42.61
80.21
69.56
static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }

def sumOfSeries ( n ) : return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n )

def sumOfSeries ( n ) : return 0.6172 * n - 0.55 * n

def sumOfSeries ( n ) : return ( 0.6172 * ( math . pow ( 10 , n ) - 1 ) - 0.55 * n )

25.81
28.71
43.3
42.78
static int maxLower ( String str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ ] = new int [ MAX_CHAR ] ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; Arrays . fill ( count , 0 ) ; } if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { count [ str . charAt ( i ) - 'a' ] ++ ; } } return maxCount ; }

def maxLower ( str ) : n = len ( str ) i = 0 for i in range ( n ) : if str [ i ] >= 'A' and str [ i ] <= 'Z' : i += 1 break maxCount = 0 count = [ ] for j in range ( MAX_CHAR ) : count . append ( 0 ) for j in range ( i , n ) : if str [ j ] >= 'A' and str [ j ] <= 'Z' : currCount = 0 for k in range ( MAX_CHAR ) : if count [ k ] > 0 : currCount += 1 maxCount = max ( maxCount , currCount ) for y in count : y = 0 if str [ j ] >= 'a' and str [ j ] <= 'z' : count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1 return maxCount

def maxLower ( str ) : n = len ( str ) for i in range ( n ) : if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) : i += 1 else : maxCount = 0 count = [ 0 for i in range ( n ) ] for j in range ( 0 , MAX_CHAR ) : if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) : count [

def maxLower ( str ) : n = str . length ( ) for i in range ( n ) : if str [ i ] >= 'A' and str [ i ] <= 'Z' : i ++ break maxCount = 0 count = [ MAX_CHAR ] for i in range ( n ) : if ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) : currCount = 0 for j in range ( 0 , MAX_CHAR ) : if ( count [ j ] > 0 ) : currCount += 1 maxCount = max ( maxCount , currCount ) Arrays . fill ( count , 0 ) return maxCount

26.04
33.77
26.02
42.42
static String constructPalin ( char [ ] str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) { str [ i ] = 'a' ; str [ j ] = 'a' ; continue ; } else if ( str [ i ] == '*' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == '*' ) { str [ j ] = str [ i ] ; continue ; } System . out . println ( "Not Possible" ) ; return "" ; } return String . valueOf ( str ) ; }

def constructPalin ( string , l ) : string = list ( string ) i = - 1 j = l while i < j : i += 1 j -= 1 if ( string [ i ] == string [ j ] and string [ i ] != '*' ) : continue elif ( string [ i ] == string [ j ] and string [ i ] == '*' ) : string [ i ] = 'a' string [ j ] = 'a' continue elif string [ i ] == '*' : string [ i ] = string [ j ] continue elif string [ j ] == '*' : string [ j ] = string [ i ] continue print ( "NotPossible" ) return "" return '' . join ( string )

def constructPalin ( str , len ) : i = 0 j = len - 1 for i in range ( len ) : if ( str [ i ] == str [ j ] and str [ i ] == '*' ) : str [ i ] = 'a' str [ j ] = 'a' continue if ( str [ i ] == str [ j ] ) : str [ i ] = 'a' str [ j ] = 'a' continue if ( str [ i ] == '*' ) : str [ i ] = str [ i ] = 'a' str [ j ] = 'a' continue if ( str [ i ] == '*' ) : str [ j ] = str [ i ] continue if ( str [ j ] == '*' ) : str [ i ] = 'a' continue if ( str [ i ] == '*' ) : str [ j ] = 'a' str [ i ] = 'a' continue : return ""

def constructPalin ( str , len ) : i = 0 j = len - 1 for i in range ( len ) : if ( str [ i ] == str [ j ] and str [ i ] != '*' ) : continue if ( str [ i ] == str [ j ] and str [ i ] == '*' ) : str [ i ] = 'a' str [ j ] = 'a' continue if ( str [ i ] == '*' ) : str [ i ] = str [ j ] continue if ( str [ i ] == '*' ) : str [ i ] = str [ j ] continue if ( str [ i ] == '*' ) : str [ i ] = str [ j ] continue if ( str [ j ] == '*' ) : str [ j ] = str [ i ] continue if ( str [ i ] == '*' ) : str [ j ] = str [ i ] continue if ( str [ j ] == '*' ) : str [ i ] = str [ i ] continue return ""

26.1
30.39
34.11
30.44
static boolean isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }

def isLucky ( n ) : next_position = n if isLucky . counter > n : return 1 if n % isLucky . counter == 0 : return 0 next_position = next_position - next_position / isLucky . counter isLucky . counter = isLucky . counter + 1 return isLucky ( next_position )

def isLucky ( n ) : next_position = n counter = 1 while next_position > n : next_position -= next_position / counter : counter += 1 if ( n % counter == 0 ) : return false

def isLucky ( n ) : counter = n if counter > n : return True if n % counter == 0 : return False next_position -= next_position // counter counter ++ return isLucky ( next_position )

26.1
22.65
32.41
32.61
static void find_max ( int [ ] A , int N , int K ) { HashMap < Integer , Integer > Count = new HashMap < > ( ) ; for ( int i = 0 ; i < K - 1 ; i ++ ) if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ; else Count . put ( A [ i ] , 1 ) ; TreeSet < Integer > Myset = new TreeSet < Integer > ( ) ; for ( Map . Entry x : Count . entrySet ( ) ) { if ( Integer . parseInt ( String . valueOf ( x . getValue ( ) ) ) == 1 ) Myset . add ( Integer . parseInt ( String . valueOf ( x . getKey ( ) ) ) ) ; } for ( int i = K - 1 ; i < N ; i ++ ) { if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ; else Count . put ( A [ i ] , 1 ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( A [ i ] ) ) ) == 1 ) Myset . add ( A [ i ] ) ; else Myset . remove ( A [ i ] ) ; if ( Myset . size ( ) == 0 ) System . out . println ( "Nothing" ) ; else System . out . println ( Myset . last ( ) ) ; int x = A [ i - K + 1 ] ; Count . put ( x , Count . get ( x ) - 1 ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 1 ) Myset . add ( x ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 0 ) Myset . remove ( x ) ; } }

def find_max ( A , N , K ) : Count = dict ( ) for i in range ( K - 1 ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 Myset = dict ( ) for x in Count : if ( Count [ x ] == 1 ) : Myset [ x ] = 1 for i in range ( K - 1 , N ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 if ( Count [ A [ i ] ] == 1 ) : Myset [ A [ i ] ] = 1 else : del Myset [ A [ i ] ] if ( len ( Myset ) == 0 ) : print ( "Nothing" ) else : maxm = - 10 ** 9 for i in Myset : maxm = max ( i , maxm ) print ( maxm ) x = A [ i - K + 1 ] if x in Count . keys ( ) : Count [ x ] -= 1 if ( Count [ x ] == 1 ) : Myset [ x ] = 1 if ( Count [ x ] == 0 ) : del Myset [ x ]

def find_max ( A , N , K ) : Count = new HashMap < Integer , Integer > ( ) for i in range ( N , K ) : if ( Count . containsKey ( A [ i ] ) ) : Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) else Count . put ( A [ i ] , 1 ) if ( Integer . parseInt ( String . valueOf ( Count [ A [ i ] ) ) == 1 ) : Myset . add ( A [ i ] ) else : Myset . add ( A [ i ] ) if ( Integer . parseInt ( String . valueOf ( Count [ i ] ) ) == 1 ) : Myset . add ( A [ i ] ) else : Myset . remove ( A [ i ] ) return

def find_max ( A , N , K ) : Count = new HashMap ( ) for i in range ( K ) : if Count . containsKey ( A [ i ] ) : Count [ A [ i ] ] = 1 + Count [ A [ i ] ] else : Count [ A [ i ] ] = 1 if Count . containsKey ( A [ i ] ) : Count [ A [ i ] ] = 1 + Count [ A [ i ] ] else : Count [ A [ i ] ] = 1 if Count . get ( A [ i ] ) == 1 : Myset . add ( A [ i ] ) else : Myset . remove ( A [ i ] ) if Myset . size ( ) == 0 : System . out . println ( "Nothing" ) else : Myset . last ( )

26.1
19.62
27.04
24.48
static boolean checkCorrectOrNot ( String s ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - 'a' ] ++ ; count2 [ s . charAt ( j ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }

def checkCorrectOrNot ( s ) : global MAX_CHAR count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR n = len ( s ) if n == 1 : return true i = 0 j = n - 1 while ( i < j ) : count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 i += 1 j -= 1 for i in range ( MAX_CHAR ) : if count1 [ i ] != count2 [ i ] : return False return True

def checkCorrectOrNot ( s ) : count1 = [ 0 for k in range ( n ) ] count2 = [ 0 for k in range ( n ) ] for i in range ( n - 1 , - 1 , - 1 ) : count1 [ s [ i ] - 'a' ] += 1 if ( count1 [ i ] != count2 [ i ] ) : return false return true

def checkCorrectOrNot ( s ) : count1 = [ 0 for i in range ( MAX_CHAR ) ] count2 = [ 0 for i in range ( MAX_CHAR ) ] n = s . length ( ) if ( n == 1 ) : return True for i in range ( n ) : if ( count1 [ i ] != count2 [ i ] ) : return False return True

26.13
20.32
29.24
21.46
static String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != 'z' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = 'a' ; } return null ; }

def lexNext ( s , n ) : for i in range ( n - 1 , - 1 , - 1 ) : if s [ i ] != 'z' : k = ord ( s [ i ] ) s [ i ] = chr ( k + 1 ) return '' . join ( s ) s [ i ] = 'a'

def lexNext ( str , n ) : s = str . toCharArray ( ) for i in range ( n ) : if ( s [ i ] != 'z' ) : s [ i ] += 1 return null

def lexNext ( str , n ) : s = str . toCharArray ( ) for i in range ( n ) : if ( s [ i ] != 'z' ) : s [ i ] += 1 return String . valueOf ( s )

26.19
33.43
37.92
34.97
static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . min ( ans , bad ) ; } return ans ; }

def minSwap ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : if ( arr [ i ] <= k ) : count = count + 1 bad = 0 for i in range ( 0 , count ) : if ( arr [ i ] > k ) : bad = bad + 1 ans = bad j = count for i in range ( 0 , n ) : if ( j == n ) : break if ( arr [ i ] > k ) : bad = bad - 1 if ( arr [ j ] > k ) : bad = bad + 1 ans = min ( ans , bad ) j = j + 1 return ans

def minSwap ( arr , n , k ) : count = 0 bad = 0 for i in range ( 0 , n ) : if ( arr [ i ] <= k ) : count = 1 if ( arr [ i ] > k ) : bad = min ( bad , arr [ i ] ) return ans

def minSwap ( arr , n , k ) : count = 0 for i in range ( n ) : if arr [ i ] <= k : ++ count if arr [ i ] > k : -- bad if arr [ i ] > k : ++ bad ans = bad for i in range ( i , n ) : if arr [ i ] > k : -- bad if arr [ j ] > k : ++ bad ans = min ( ans , bad ) return ans

26.21
28.18
35.25
29.75
static int findCommon ( int mat [ ] [ ] ) { HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) { cnt . put ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ 0 ] , 1 ) ; } for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) if ( cnt . containsKey ( mat [ i ] [ j ] ) ) { cnt . put ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ j ] , 1 ) ; } } } for ( Map . Entry < Integer , Integer > ele : cnt . entrySet ( ) ) { if ( ele . getValue ( ) == M ) return ele . getKey ( ) ; } return - 1 ; }

def findCommon ( mat ) : global M global N cnt = dict ( ) cnt = defaultdict ( lambda : 0 , cnt ) i = 0 j = 0 while ( i < M ) : cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 j = 1 while ( j < N ) : if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : cnt [ mat [ i ] [ j ] ] = cnt [ mat [ i ] [ j ] ] + 1 j = j + 1 i = i + 1 for ele in cnt : if ( cnt [ ele ] == M ) : return ele return - 1

def findCommon ( mat ) : cnt = new HashMap < Integer , Integer > ( ) for i in range ( M , N ) : if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) : cnt . put ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) else : cnt . put ( mat [ i ] [ 0 ] , 1 ) for j in range ( 1 , N ) : if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : if ( cnt . containsKey ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) ) : cnt . put ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) else : cnt . put ( mat [ i ] [ j ] , 1 ) for j in range ( 1 , N ) : if ( cnt [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : if ( cnt [ i ] [ j ] != mat [ i ] [ j ] ) ) : cnt . put ( mat [ i ] [ j ] ) return - 1

def findCommon ( mat [ ] [ ] ) : cnt = new HashMap < Integer , Integer > ( ) for i in range ( M ) : if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) : cnt . put ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) else : cnt . put ( mat [ i ] [ 0 ] , 1 ) for j in range ( 1 , N ) : if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : if ( cnt . containsKey ( mat [ i ] [ j ] ) ) : cnt . put ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) else : cnt . put ( mat [ i ] [ j ] , 1 ) return - 1

26.24
37.01
60.08
57.24
static boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) return false ; if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ; if ( first . length ( ) > 0 && first . charAt ( 0 ) == '*' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ; return false ; }

def match ( first , second ) : if len ( first ) == 0 and len ( second ) == 0 : return True if len ( first ) > 1 and first [ 0 ] == '*' and len ( second ) == 0 : return False if ( len ( first ) > 1 and first [ 0 ] == '?' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) : return match ( first [ 1 : ] , second [ 1 : ] ) ; if len ( first ) != 0 and first [ 0 ] == '*' : return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) return False

def match ( first , second ) : if first == second : return true if second == null : return false if first . length ( ) == 0 and first [ 0 ] == '*' : return match ( first , second ) : return match ( first , second ) if ( first . length ( ) > 1 and first [ 0 ] == '?' : return match ( first , second ) : return match ( first , second )

def match ( first , second ) : if first . length ( ) == 0 and second . length ( ) == 0 : return True if first . length ( ) == 0 and second . length ( ) == 0 : return False if first . length ( ) > 1 and first . charAt ( 0 ) == '?' : or ( first . length ( ) != 0 and second [ 0 ] == second [ 0 ] ) : return match ( first [ 1 : ] , second [ 1 : ] ) if second . length ( ) > 0 and first [ 0 ] == '*' : return match ( first [ 1 : ] , second [ 1 : ] ) or match ( first , second [ 1 : ] ) return False

26.29
29.47
58.41
46.64
static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { System . out . print ( "k pairs don't exist" ) ; return ; } int index2 [ ] = new int [ n1 ] ; while ( k > 0 ) { int min_sum = Integer . MAX_VALUE ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } System . out . print ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) ; index2 [ min_index ] ++ ; k -- ; } }

def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : if ( k > n1 * n2 ) : print ( "kpairsdon'texist" ) return index2 = [ 0 for i in range ( n1 ) ] while ( k > 0 ) : min_sum = sys . maxsize min_index = 0 for i1 in range ( 0 , n1 , 1 ) : if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : min_index = i1 min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] print ( "(" , arr1 [ min_index ] , "," , arr2 [ index2 [ min_index ] ] , ")" , end = "" ) index2 [ min_index ] += 1 k -= 1

def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : if ( k < n1 * n2 ) : print ( "k pairs don't exist" ) return ; } index2 = [ 0 for k in range ( n1 * n2 ) ] for i1 in range ( 0 , n1 ) : if ( index2 [ i1 ] < n2 ) : min_index = i1 min_sum = arr

def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : min_sum = float ( 'inf' ) min_index = 0 for i1 in range ( n1 ) : if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : min_index = i1 min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] if ( arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : min_index = i1 min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] print ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) index2 [ min_index ] ++ k --

26.33
48.75
24.92
29.84
static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( " Diagonal one : " ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " ) ; } System . out . println ( ) ; System . out . print ( " Diagonal two : " ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " ) ; } }

def diagonalsquare ( mat , row , column ) : print ( "Diagonalone:" , end = "" ) for i in range ( 0 , row ) : print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = "" ) print ( "\n\nDiagonaltwo:" , end = "" ) for i in range ( 0 , row ) : print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = "" )

def diagonalsquare ( mat , row , column ) : System . out . print ( " Diagonal one : " ) for i in range ( row , column ) : print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " ) print ( " Diagonal two : " ) for i in range ( row , column ) : print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] [ row - i - 1 ] [ row - i - 1 ] ) print ( " Diagonal three : " ) print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " ) print ( ) print ( " Diagonal three : " ) print ( mat [ i ] [ row - i - 1 ] [ row - i - 1 ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] [ row - i - 1 ] [ row - i - 1 ] ) print ( " Diagonal three : " ) print ( mat [ i ] [ row - i - 1 ] [ row - i - 1 ] [ row - i -

def diagonalsquare ( mat , row , column ) : mat . sort ( reverse = True ) for i in range ( row , column ) : print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " )

26.46
46.22
96.23
88.75
public static double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }

def hexagonArea ( s ) : return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 )

def hexagonArea ( s ) : return ( s * s )

def hexagonArea ( s ) : return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2

26.46
38.41
87.4
79.59
static double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }

def vol_of_octahedron ( side ) : return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) )

def vol_of_octahedron ( side ) : return ( side * side )

def vol_of_octahedron ( side ) : return ( ( side * side * side ) * ( math . sqrt ( 2 ) ) )

26.53
28.8
39.09
22.88
static int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }

def kPrimeFactor ( n , k ) : while ( n % 2 == 0 ) : k = k - 1 n = n / 2 if ( k == 0 ) : return 2 i = 3 while i <= math . sqrt ( n ) : while ( n % i == 0 ) : if ( k == 1 ) : return i k = k - 1 n = n / i i = i + 2 if ( n > 2 and k == 1 ) : return n return - 1

def kPrimeFactor ( n , k ) : while ( n % 2 == 0 ) : if ( k == 1 ) : return n k -= 1 n = n / 2 if ( k == 0 ) : return - 1

def kPrimeFactor ( n , k ) : n = n // 2 if k == 0 : return 2 for i in range ( 3 , 3 + 2 ) : while ( n % i == 0 ) : if ( k == 1 ) : return i , k -- n = n / i if k == 1 : return n return - 1

26.55
31.4
28.06
30.4
static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( "No such window exists" ) ; return "" ; } int hash_pat [ ] = new int [ no_of_chars ] ; int hash_str [ ] = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) ] ++ ; if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . charAt ( start ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { System . out . println ( "No such window exists" ) ; return "" ; } return str . substring ( start_index , start_index + min_len ) ; }

def findSubString ( string , pat ) : len1 = len ( string ) len2 = len ( pat ) if len1 < len2 : print ( "Nosuchwindowexists" ) return "" hash_pat = [ 0 ] * no_of_chars hash_str = [ 0 ] * no_of_chars for i in range ( 0 , len2 ) : hash_pat [ ord ( pat [ i ] ) ] += 1 start , start_index , min_len = 0 , - 1 , float ( 'inf' ) count = 0 for j in range ( 0 , len1 ) : hash_str [ ord ( string [ j ] ) ] += 1 if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : count += 1 if count == len2 : while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : hash_str [ ord ( string [ start ] ) ] -= 1 start += 1 len_window = j - start + 1 if min_len > len_window : min_len = len_window start_index = start if start_index == - 1 : print ( "Nosuchwindowexists" ) return "" return string [ start_index : start_index + min_len ]

def findSubString ( str , pat ) : len1 = len2 = len1 + 1 hash_pat = [ 0 for i in range ( len2 ) ] hash_str = [ 0 for i in range ( len1 ) ] for j in range ( len1 ) : if ( hash_pat [ str . charAt ( j ) ] != 0 ) : hash_str [ str . charAt ( j ) ] += 1 if ( hash_str [ str . charAt ( j ) ] > hash_pat [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] : count += 1 if ( count == len2 ) : break if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] == 0 ) : hash_str [ str . charAt ( start ) ] -= 1 start += 1 elif ( hash_str [ str . charAt ( start ) ] == 0 ) : hash_str [ str . charAt ( start ) ] = 0 else : if ( hash_pat [ str . charAt ( start ) ] == 0 ) : break if ( count == len1 ) : break if ( hash_str [ str [ start ] >

def findSubString ( str , pat ) : len1 = len2 len2 = pat . length ( ) for j in range ( len1 , len2 ) : hash_pat [ pat [ j ] ] += 1 if ( hash_pat [ str [ j ] ] != 0 and hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) : count += 1 if count == len2 : while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] or hash_pat [ str [ start ] ] == 0 ) : if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) : hash_str [ str [ start ] ] -- start ++ if count == len2 : while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] or hash_pat [ str [ start ] ] == 0 ) : if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) : hash_str [ str [ start ] ] -- start ++ if count == len2 : while ( hash_str [ str [ start ] ] >

26.62
26.71
47.13
39.02
static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . add ( x ) ; else { if ( Q . peek ( ) < x ) { Q . poll ( ) ; Q . add ( x ) ; } } } } return Q . poll ( ) ; }

def kthLargestSum ( arr , n , k ) : sum = [ ] sum . append ( 0 ) sum . append ( arr [ 0 ] ) for i in range ( 2 , n + 1 ) : sum . append ( sum [ i - 1 ] + arr [ i - 1 ] ) Q = [ ] heapq . heapify ( Q ) for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : x = sum [ j ] - sum [ i - 1 ] if len ( Q ) < k : heapq . heappush ( Q , x ) else : if Q [ 0 ] < x : heapq . heappop ( Q ) heapq . heappush ( Q , x ) return Q [ 0 ]

def kthLargestSum ( arr , n , k ) : sum = [ 0 for k in range ( n ) ] for i in range ( 2 , n ) : sum [ i ] = sum [ i ] + arr [ i - 1 ] Q = new PriorityQueue < Integer > ( ) for j in range ( i + 1 , n ) : if ( Q . size ( ) < k ) : Q . add ( x ) else : Q . poll ( )

def kthLargestSum ( arr , n , k ) : sum = [ 0 for k in range ( n ) ] sum [ 1 ] = arr [ 0 ] for i in range ( 2 , n ) : sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] for j in range ( i , n ) : x = sum [ j ] - sum [ i - 1 ] if ( Q . size ( ) < k ) : Q . add ( x ) else : if ( Q . peek ( ) < x ) : Q . poll ( ) Q . add ( x ) return Q . poll ( )

26.68
29.93
64.07
50.11
static int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = Integer . MAX_VALUE ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) { min_diff = diff ; first = i ; last = i + m - 1 ; } } return ( arr [ last ] - arr [ first ] ) ; }

def findMinDiff ( arr , n , m ) : if ( m == 0 or n == 0 ) : return 0 arr . sort ( ) if ( n < m ) : return - 1 min_diff = sys . maxsize first = 0 last = 0 i = 0 while ( i + m - 1 < n ) : diff = arr [ i + m - 1 ] - arr [ i ] if ( diff < min_diff ) : min_diff = diff first = i last = i + m - 1 i += 1 return ( arr [ last ] - arr [ first ] )

def findMinDiff ( arr , n , m ) : if ( m == 0 ) : return 0 for i in range ( 0 , n ) : if ( i + m - 1 < n ) : min_diff = diff return ( arr [ last ] - arr [ first ] )

def findMinDiff ( arr , n , m ) : if m == 0 or n == 0 : return - 1 min_diff = float ( 'inf' ) first = 0 last = 0 for i in range ( 0 , n , m ) : diff = arr [ i + m - 1 ] - arr [ i ] if ( diff < min_diff ) : min_diff = diff first = i last = i + m - 1 return ( arr [ last ] - arr [ first ] )

26.79
35.12
33.36
36.47
static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }

def countRotationsDivBy8 ( n ) : l = len ( n ) count = 0 if ( l == 1 ) : oneDigit = int ( n [ 0 ] ) if ( oneDigit % 8 == 0 ) : return 1 return 0 if ( l == 2 ) : first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) if ( first % 8 == 0 ) : count += 1 if ( second % 8 == 0 ) : count += 1 return count threeDigit = 0 for i in range ( 0 , ( l - 2 ) ) : threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 return count

def countRotationsDivBy8 ( n ) : len = len . split ( ' ' ) count = 0 for k in range ( len ) : oneDigit = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) if ( oneDigit % 8 == 0 ) : count ++ if ( second % 8 == 0 ) : count ++ return count if ( len == 3 ) : first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] ) if ( first % 8 == 0 ) : second = ( n [ 1 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) if ( second % 8 == 0 ) : count ++ threeDigit = ( n [ len - 2 ] - '0' ) return count

def countRotationsDivBy8 ( n ) : count = 0 threeDigit = ( n . charAt ( 0 ) - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) if threeDigit % 8 == 0 : count += 1 threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) if threeDigit % 8 == 0 : count += 1 threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) if threeDigit % 8 == 0 : count += 1 threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) if threeDigit % 8 == 0 : count += 1 threeDigit = ( n [ len - 2 ] - '0' ) * 100 + (

26.89
23.31
38.99
31.45
public static void findFibSubset ( Integer [ ] x ) { Integer max = Collections . max ( Arrays . asList ( x ) ) ; List < Integer > fib = new ArrayList < Integer > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; Integer a = 0 ; Integer b = 1 ; while ( b < max ) { Integer c = a + b ; a = b ; b = c ; fib . add ( c ) ; } for ( Integer i = 0 ; i < x . length ; i ++ ) { if ( fib . contains ( x [ i ] ) ) { result . add ( x [ i ] ) ; } } System . out . println ( result ) ; }

def findFibSubset ( arr , n ) : m = max ( arr ) a = 0 b = 1 hash = [ ] hash . append ( a ) hash . append ( b ) while ( b < m ) : c = a + b a = b b = c hash . append ( b ) for i in range ( n ) : if arr [ i ] in hash : print ( arr [ i ] , end = "" )

def findFibSubset ( x ) : max = max ( x ) fib = list ( ) for b in range ( 1 , max ) : c = a + b fib . add ( c ) a = b b = c result = list ( ) for i in range ( 0 , x . length ) : if ( fib . contains ( x [ i ] ) ) : result . add ( x [ i ] ) : fib . remove ( x [ i ] )

def findFibSubset ( x ) : max = max ( list ( x ) ) fib = list ( ) result = list ( ) a = 0 b = 1 while ( b < max ) : c = a + b a = b b = c fib . add ( c ) for i in range ( 0 , x . length ) : if fib [ i ] == x [ i ] : result . add ( x [ i ] )

27.07
38.38
34.01
34.9
static int binaryMedian ( int m [ ] [ ] , int r , int c ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ; } int desired = ( r * c + 1 ) / 2 ; while ( min < max ) { int mid = min + ( max - min ) / 2 ; int place = 0 ; int get = 0 ; for ( int i = 0 ; i < r ; ++ i ) { get = Arrays . binarySearch ( m [ i ] , mid ) ; if ( get < 0 ) get = Math . abs ( get ) - 1 ; else { while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ; } place = place + get ; } if ( place < desired ) min = mid + 1 ; else max = mid ; } return min ; }

def binaryMedian ( m , r , d ) : mi = m [ 0 ] [ 0 ] mx = 0 for i in range ( r ) : if m [ i ] [ 0 ] < mi : mi = m [ i ] [ 0 ] if m [ i ] [ d - 1 ] > mx : mx = m [ i ] [ d - 1 ] desired = ( r * d + 1 ) // 2 while ( mi < mx ) : mid = mi + ( mx - mi ) // 2 place = [ 0 ] for i in range ( r ) : j = upper_bound ( m [ i ] , mid ) place [ 0 ] = place [ 0 ] + j if place [ 0 ] < desired : mi = mid + 1 else : mx = mid print ( "Medianis" , mi ) return

def binaryMedian ( m , r , c ) : min = float ( 'inf' ) for i in range ( r ) : if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] max = m [ i ] [ c - 1 ] desired = ( r * c + 1 ) // 2 while ( min < max ) : min = mid + 1 else : get = 0 if ( get < 0 ) : get = Math .

def binaryMedian ( m , r , c ) : max = INT_MAX for i in range ( r ) : if ( m [ i ] [ 0 ] < min ) : min = m [ i ] [ 0 ] if ( m [ i ] [ c - 1 ] > max ) : max = m [ i ] [ c - 1 ] while ( min < max ) : mid = min + ( max - min ) / 2 place = 0 for i in range ( 0 , r ) : get = 0 for i in range ( 0 , r ) : get = 0 for i in range ( 0 , r ) : get = Arrays . binarySearch ( m [ i ] , mid ) if ( get < 0 ) : get = Math . abs ( get ) - 1 else : while ( get < m [ i ] . length and m [ i ] [ get ] == mid ) : get += 1 place = place + get if place < desired : min = mid + 1 else : max = mid return min

27.08
34.21
29.45
36.02
static boolean isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }

def isPerfectSquare ( n ) : i = 1 the_sum = 0 while the_sum < n : the_sum += i if the_sum == n : return True i += 2 return False

def isPerfectSquare ( n ) : sum = 0 for i in range ( 2 , n ) : sum += i if ( sum == n ) : return true

def isPerfectSquare ( n ) : sum = 0 for i in range ( 1 , n ) : sum += i if ( sum == n ) : return True return False

27.1
35.96
38.13
36.37
static void printDistinct ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ! set . contains ( arr [ i ] ) ) { set . add ( arr [ i ] ) ; System . out . print ( arr [ i ] + " " ) ; } } }

def printDistinct ( arr , n ) : s = dict ( ) for i in range ( n ) : if ( arr [ i ] not in s . keys ( ) ) : s [ arr [ i ] ] = arr [ i ] print ( arr [ i ] , end = "" )

def printDistinct ( arr ) : set = new HashSet < Integer > ( ) for i in range ( arr . length ) : if ( set . contains ( arr [ i ] ) ) : print ( arr [ i ] ) set . add ( arr [ i ] ) print ( " " ) } for i in range ( 0 , arr . length ) : if ( set . contains ( arr [ i ] ) : print ( arr [ i ] ) print ( " " )

def printDistinct ( arr ) : set = list ( ) for i in range ( len ( arr ) ) : if not set . contains ( arr [ i ] ) : set . add ( arr [ i ] ) print ( arr [ i ] + " " )

27.15
31.75
38.92
38.35
static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }

def isPalindrome ( string ) : l = 0 h = len ( string ) - 1 while h > l : l += 1 h -= 1 if string [ l - 1 ] != string [ h + 1 ] : return False return True

def isPalindrome ( str ) : l = 0 h = str . length ( ) - 1 while ( l < h ) : if ( str [ l ] != str [ h ] ) : return false return true

def isPalindrome ( str ) : l = 0 h = str . length - 1 while h > l : if ( str [ l ] != str [ l -- ] ) : return False return True

27.16
34.9
20.22
31.01
static void printMat ( int degseq [ ] , int n ) { int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -- ; degseq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } } System . out . print ( "\n" + setw ( 3 ) + " " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( setw ( 3 ) + "(" + i + ")" ) ; System . out . print ( "\n\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( setw ( 4 ) + "(" + i + ")" ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j ] ) ; System . out . print ( "\n" ) ; } }

def printMat ( degseq , n ) : mat = [ [ 0 ] * n for i in range ( n ) ] for i in range ( n ) : for j in range ( i + 1 , n ) : if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) : degseq [ i ] -= 1 degseq [ j ] -= 1 mat [ i ] [ j ] = 1 mat [ j ] [ i ] = 1 print ( "" , end = "" ) for i in range ( n ) : print ( "" , "(" , i , ")" , end = "" ) print ( ) print ( ) for i in range ( n ) : print ( "" , "(" , i , ")" , end = "" ) for j in range ( n ) : print ( "" , mat [ i ] [ j ] , end = "" ) print ( )

def printMat ( degseq , n ) : mat = [ INT_MAX for i in range ( n ) ] for j in range ( i + 1 , n ) : if ( degseq [ i ] > 0 ) : degseq [ i ] -- degseq [ j ] -- mat [ i ] [ j ] = 1 else : print ( "\n" + setw ( 3 ) + "(" + i + ")" ) for i in range ( 0 , n ) : print ( set

def printMat ( degseq , n ) : mat = [ 0 for i in range ( n ) ] for i in range ( n ) : if degseq [ i ] > 0 and degseq [ j ] > 0 : degseq [ i ] -- degseq [ j ] = 1 mat [ i ] [ j ] = 1 mat [ j ] [ i ] = 1

27.48
29.92
39.32
35.47
static void firstNonRepeating ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; Queue < Character > q = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; q . add ( ch ) ; charCount [ ch - 'a' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( charCount [ q . peek ( ) - 'a' ] > 1 ) q . remove ( ) ; else { System . out . print ( q . peek ( ) + " " ) ; break ; } } if ( q . isEmpty ( ) ) System . out . print ( - 1 + " " ) ; } System . out . println ( ) ; }

def firstnonrepeating ( Str ) : global MAX_CHAR q = Queue ( ) charCount = [ 0 ] * MAX_CHAR for i in range ( len ( Str ) ) : q . put ( Str [ i ] ) charCount [ ord ( Str [ i ] ) - ord ( 'a' ) ] += 1 while ( not q . empty ( ) ) : if ( charCount [ ord ( q . queue [ 0 ] ) - ord ( 'a' ) ] > 1 ) : q . get ( ) else : print ( q . queue [ 0 ] , end = "" ) break if ( q . empty ( ) ) : print ( - 1 , end = "" ) print ( )

def firstNonRepeating ( str ) : charCount = [ 0 for i in range ( len ( str ) ) ] for i in range ( len ( str ) ) : ch = str [ i ] if ( ch == 'a' ) : q . append ( ch ) else : print ( ch + " " ) break if ( q . isEmpty ( ) ) : print ( - 1 + " " ) break if ( charCount [ ch - 'a' ] > 1 ) : q .

def firstNonRepeating ( str ) : charCount = [ MAX_CHAR for i in range ( len ( str ) ) ] q = list ( ) for ch in range ( 0 , MAX_CHAR ) : if ( ch in str ) : q . append ( ch ) charCount [ ch - 'a' ] += 1 while ( not q . isEmpty ( ) ) : if ( charCount [ q . peek ( ) - 'a' ] > 1 ) : q . remove ( ) else : print ( q . peek ( ) ) if ( q . isEmpty ( ) ) : print ( - 1 + " " )

27.52
20.51
43.76
43.57
static int SieveOfSundaram ( int n ) { int nNew = ( n - 2 ) / 2 ; boolean marked [ ] = new boolean [ nNew + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + " " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + " " ) ; return - 1 ; }

def SieveOfSundaram ( n ) : nNew = int ( ( n - 2 ) / 2 ) marked = [ 0 ] * ( nNew + 1 ) for i in range ( 1 , nNew + 1 ) : j = i while ( ( i + j + 2 * i * j ) <= nNew ) : marked [ i + j + 2 * i * j ] = 1 j += 1 if ( n > 2 ) : print ( 2 , end = "" ) for i in range ( 1 , nNew + 1 ) : if ( marked [ i ] == 0 ) : print ( ( 2 * i + 1 ) , end = "" )

def SieveOfSundaram ( n ) : nNew = ( n - 2 ) // 2 if ( n > 2 ) print ( 2 + " " ) for i in range ( 1 , nNew ) : if ( marked [ i ] == false ) print ( 2 * i + 1 + " " ) return - 1 else : print ( 2 * i + 1 + " " ) return - 1

def SieveOfSundaram ( n ) : marked = [ False for i in range ( n ) ] for i in range ( 1 , nNew + 1 ) : marked [ i ] = False for j in range ( i + 1 , nNew ) : marked [ i + j + 2 * i * j ] = True if n > 2 : print ( 2 + " " ) for i in range ( 1 , nNew ) : if marked [ i ] == false : print ( 2 * i + 1 + " " ) return - 1

27.63
35.35
18.04
19.95
public static void subArraySum ( int [ ] arr , int n , int sum ) { int cur_sum = 0 ; int start = 0 ; int end = - 1 ; HashMap < Integer , Integer > hashMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cur_sum = cur_sum + arr [ i ] ; if ( cur_sum - sum == 0 ) { start = 0 ; end = i ; break ; } if ( hashMap . containsKey ( cur_sum - sum ) ) { start = hashMap . get ( cur_sum - sum ) + 1 ; end = i ; break ; } hashMap . put ( cur_sum , i ) ; } if ( end == - 1 ) { System . out . println ( "No subarray with given sum exists" ) ; } else { System . out . println ( "Sum found between indexes " + start + " to " + end ) ; } }

def subArraySum ( arr , n , Sum ) : Map = { } curr_sum = 0 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if curr_sum == Sum : print ( "Sumfoundbetweenindexes0to" , i ) return if ( curr_sum - Sum ) in Map : print ( "Sumfoundbetweenindexes" , \ Map [ curr_sum - Sum ] + 1 , "to" , i ) return Map [ curr_sum ] = i print ( "Nosubarraywithgivensumexists" )

def subArraySum ( arr , n , sum ) : cur_sum = 0 for i in range ( n ) : cur_sum = cur_sum + arr [ i ] if ( cur_sum - sum == 0 ) : start = 0 end = i break if ( hashMap . containsKey ( cur_sum - sum ) ) : start = hashMap [ cur_sum - sum ] + 1 end = i break if ( start == - 1 ) : print ( "

def subArraySum ( arr , n , sum ) : cur_sum = 0 start = 0 end = - 1 hashMap = list ( ) for i in range ( n ) : cur_sum = cur_sum + arr [ i ] if ( cur_sum - sum == 0 ) : start = 0 end = i break if ( hashMap . containsKey ( cur_sum - sum ) ) : start = hashMap . get ( cur_sum - sum ) + 1 end = i break if ( end == - 1 ) : print ( "No subarray with given sum exists" ) else : print ( "Sum found between indexes " + start + " to " + end )

27.64
24.1
29.31
25.06
int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; int start_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_index = i ; } if ( hM . containsKey ( sum + n ) ) { if ( max_len < i - hM . get ( sum + n ) ) { max_len = i - hM . get ( sum + n ) ; ending_index = i ; } } else hM . put ( sum + n , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; } int end = ending_index - max_len + 1 ; System . out . println ( end + " to " + ending_index ) ; return max_len ; }

def maxLen ( arr , n ) : hash_map = { } curr_sum = 0 max_len = 0 ending_index = - 1 for i in range ( 0 , n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 else : arr [ i ] = 1 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if ( curr_sum == 0 ) : max_len = i + 1 ending_index = i if ( curr_sum + n ) in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum + n ] ) else : hash_map [ curr_sum ] = i for i in range ( 0 , n ) : if ( arr [ i ] == - 1 ) : arr [ i ] = 0 else : arr [ i ] = 1 print ( ending_index - max_len + 1 , end = "" ) print ( "to" , end = "" ) print ( ending_index ) return max_len

def maxLen ( arr , n ) : hM = defaultdict ( int ) for i in range ( n ) : sum = 0 max_len = 0 ending_index = - 1 start_index = 0 for i in range ( n ) : sum += arr [ i ] if ( sum == 0 ) : max_len = i + 1 ending_index = i if ( max_len < i - hM [ sum + n ] ) : max_len = i - hM [ sum + n ] else : max_len = i - hM [ sum + n ] if ( max_len < i - hM [ sum + n ] : max_len = i - hM [ sum + n ] if ( max_len < i - hM [ sum + n ] ) : max_len = i + 1 ending_index = i if ( max_len < i - hM [ sum + n ] ) : max_len = i - hM [ sum + n ] else : max_len = i - hM [ sum + n ] if ( max_len < i - hM [ sum + n ] : max_len = i - hM [ sum + n ] if (

def maxLen ( arr , n ) : sum = 0 max_len = 0 ending_index = - 1 start_index = 0 for i in range ( 0 , n ) : sum += arr [ i ] if ( sum == 0 ) : max_len = i + 1 ending_index = i if ( hM . containsKey ( sum + n ) ) : if ( max_len < i - hM [ sum + n ] ) : max_len = i - hM [ sum + n ] ending_index = i if ( hM . containsKey ( sum + n ) ) : if ( max_len < i - hM [ sum + n ] ) : max_len = i - hM [ sum + n ] ending_index = i if ( hM . containsKey ( sum + n ) ) : if ( max_len < i - hM [ sum + n ] ) : max_len = i - hM [ sum + n ] ending_index = i if ( hM . get ( sum + n ) ) : if ( max_len < i - hM [ sum + n ] ) : max_len = i - hM [ sum + n ] ending_index = i

27.68
20.85
14.33
16.83
static boolean checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( j ) - 'a' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }

def checkCorrectOrNot ( s ) : global MAX_CHAR count = [ 0 ] * MAX_CHAR n = len ( s ) if n == 1 : return true i = 0 j = n - 1 while i < j : count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1 i += 1 j -= 1 for i in range ( MAX_CHAR ) : if count [ i ] != 0 : return False return True

def checkCorrectOrNot ( s ) : count = [ 0 for i in range ( n ) ] for j in range ( n - 1 , - 1 , - 1 ) : count [ s [ i ] - 'a' ] += 1 count [ s [ j ] - 'a' ] -= 1 if ( count [ i ] != 0 ) : return false return true

def checkCorrectOrNot ( s ) : count = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( 0 , MAX_CHAR ) : if ( count [ i ] != 0 ) : return False return True

27.68
21.55
33.42
27.99
static int countZeroes ( int mat [ ] [ ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }

def countZeroes ( mat ) : N = 5 ; row = N - 1 ; col = 0 ; count = 0 ; while ( col < N ) : while ( mat [ row ] [ col ] ) : if ( row < 0 ) : return count ; row = row - 1 ; count = count + ( row + 1 ) ; col = col + 1 ; return count ;

def countZeroes ( mat , N ) : row = N - 2 col = 0 while ( row < N ) : if ( -- row < 0 ) : return count count += ( row + 1 ) col += 1 if ( col >= N ) : return count

def countZeroes ( mat ) : row = N - 1 col = 0 count = 0 while col < N : while mat [ row ] [ col ] > 0 : if -- row < 0 : return count count += ( row + 1 ) col += ( row + 1 ) col += 1 return count

27.94
21.66
61.69
39.92
static int computeLastDigit ( long A , long B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }

def computeLastDigit ( A , B ) : variable = 1 if ( A == B ) : return 1 elif ( ( B - A ) >= 5 ) : return 0 else : for i in range ( A + 1 , B + 1 ) : variable = ( variable * ( i % 10 ) ) % 10 return variable % 10

def computeLastDigit ( A , B ) : variable = 1 for i in range ( A , B ) : variable = ( int ) ( variable * i ) return variable % 10

def computeLastDigit ( A , B ) : variable = 1 if A == B : return 1 else : for i in range ( A + 1 , B + 1 ) : variable = ( int ( variable * ( i // 10 ) ) % 10 ) return variable % 10

27.95
22.58
33.66
23.89
static int maxDP ( int n ) { int res [ ] = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }

def maxDP ( n ) : res = list ( ) res . append ( 0 ) res . append ( 1 ) i = 2 while i < n + 1 : res . append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ) i = i + 1 return res [ n ]

def maxDP ( n ) : res = [ 0 for i in range ( n ) ] for i in range ( 2 , n ) : res [ i ] = max ( i , res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) return res [ n ]

def maxDP ( n ) : res = [ 0 for i in range ( n ) ] res [ 0 ] = 0 res [ 1 ] = 1 for i in range ( 2 , n ) : res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) return res [ n ]

27.96
37.33
52.97
42.63
static int costToBalance ( String s ) { if ( s . length ( ) == 0 ) System . out . println ( 0 ) ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' ) o ++ ; if ( s . charAt ( i ) == ')' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == '(' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; }

def costToBalance ( s ) : if ( len ( s ) == 0 ) : print ( 0 ) ans = 0 o = 0 c = 0 for i in range ( len ( s ) ) : if ( s [ i ] == '(' ) : o += 1 if ( s [ i ] == ')' ) : c += 1 if ( o != c ) : return - 1 a = [ 0 for i in range ( len ( s ) ) ] if ( s [ 0 ] == '(' ) : a [ 0 ] = 1 else : a [ 0 ] = - 1 if ( a [ 0 ] < 0 ) : ans += abs ( a [ 0 ] ) for i in range ( 1 , len ( s ) ) : if ( s [ i ] == '(' ) : a [ i ] = a [ i - 1 ] + 1 else : a [ i ] = a [ i - 1 ] - 1 if ( a [ i ] < 0 ) : ans += abs ( a [ i ] ) return ans

def costToBalance ( s ) : ans = 0 o = 0 c = 0 for i in range ( len ( s ) ) : if ( s [ i ] == '(' ) o += 1 if ( s [ i ] == ')' ) c += 1 if ( s [ i ] == '(' ) a [ 0 ] = 1 else : a [ 0 ] = - 1 if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) return ans

def costToBalance ( s ) : ans = 0 o = 0 c = 0 for i in range ( 1 , len ( s ) ) : if s [ i ] == '(' : a [ i ] = 1 else : a [ i ] = - 1 if ( a [ i ] < 0 ) : ans += abs ( a [ i ] ) for i in range ( 1 , len ( s ) ) : if s [ i ] == '(' : a [ i ] = a [ i - 1 ] + 1 else : a [ i ] = a [ i - 1 ] - 1 if ( a [ i ] < 0 ) : ans += abs ( a [ i ] ) return ans

27.99
33.91
42.28
34.81
void sortInWave ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; }

def sortInWave ( arr , n ) : arr . sort ( ) for i in range ( 0 , n - 1 , 2 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]

def sortInWave ( arr , n ) : arr . sort ( reverse = True ) for i in range ( 0 , n ) : swap ( arr , i , i + 1 ) swap ( arr , i , i + 1 ) swap ( arr , i , i + 1 ) swap ( arr , i , i + 1 ) swap ( arr , i , i + 1 ) swap ( arr , i , i + 1 )

def sortInWave ( arr , n ) : arr . sort ( reverse = True ) for i in range ( n - 1 , - 1 , - 1 ) : swap ( arr , i , i + 1 )

28.04
31.82
28.02
29.34
public static int smallestKFreq ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ; else m . put ( a [ i ] , 1 ) ; int res = Integer . MAX_VALUE ; Set < Integer > s = m . keySet ( ) ; for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ; return ( res != Integer . MAX_VALUE ) ? res : - 1 ; }

def smallestKFreq ( arr , n , k ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 res = sys . maxsize res1 = sys . maxsize for key , values in mp . items ( ) : if values == k : res = min ( res , key ) return res if res != res1 else - 1

def smallestKFreq ( a , n , k ) : m = defaultdict ( int ) for i in range ( n ) : if ( m . containsKey ( a [ i ] ) ) : m . put ( a [ i ] , 1 ) else : m . put ( a [ i ] , 1 ) res = Integer . MAX_VALUE for temp in s ) if ( m . get ( temp ) == k ) : res = min ( res , temp ) return ( res != Integer .

def smallestKFreq ( a , n , k ) : m = new HashMap ( ) for i in range ( n ) : if m . containsKey ( a [ i ] ) : m [ a [ i ] ] = m [ a [ i ] ] + 1 else : m [ a [ i ] ] = 1 res = float ( 'inf' ) s = m . keySet ( ) for temp in s : if m [ temp ] == k : res = min ( res , temp ) return ( res != float ( 'inf' ) )

28.07
37.74
56.32
44.93
static void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " -- " + next ) ; } }

def printNGE ( arr ) : for i in range ( 0 , len ( arr ) , 1 ) : next = - 1 for j in range ( i + 1 , len ( arr ) , 1 ) : if arr [ i ] < arr [ j ] : next = arr [ j ] break print ( str ( arr [ i ] ) + "--" + str ( next ) )

def printNGE ( arr , n ) : next = - 1 for i in range ( 0 , n ) : if ( arr [ i ] < arr [ j ] ) : next = arr [ j ] if ( arr [ i ] > arr [ j ] ) : next = arr [ j ] i = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] < arr [ j ] ) : next = arr [ j ] break if ( arr [ i ] > arr [ j ] : next = arr [ j ] if ( arr [ i ] < arr [ j ] ) : next = arr [ j ] break if ( arr [ i ] < arr [ j ] ) : next = arr [ j ] print ( arr [ i ] + " -- " + next )

def printNGE ( arr , n ) : next = - 1 for i in range ( n ) : next = - 1 for j in range ( i + 1 , n ) : if ( arr [ i ] < arr [ j ] ) : next = arr [ j ] break print ( arr [ i ] + " -- " + next )

28.16
32.69
34.21
32.88
static int maxArea ( int mat [ ] [ ] ) { int hist [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ; for ( int i = 0 ; i < C ; i ++ ) { hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < R ; j ++ ) { hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 ; } } for ( int i = 0 ; i < R ; i ++ ) { int count [ ] = new int [ R + 1 ] ; for ( int j = 0 ; j < C ; j ++ ) { count [ hist [ i ] [ j ] ] ++ ; } int col_no = 0 ; for ( int j = R ; j >= 0 ; j -- ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { hist [ i ] [ col_no ] = j ; col_no ++ ; } } } } int curr_area , max_area = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { curr_area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_area > max_area ) { max_area = curr_area ; } } } return max_area ; }

def maxArea ( mat ) : hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] for i in range ( 0 , C , 1 ) : hist [ 0 ] [ i ] = mat [ 0 ] [ i ] for j in range ( 1 , R , 1 ) : if ( ( mat [ j ] [ i ] == 0 ) ) : hist [ j ] [ i ] = 0 else : hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 for i in range ( 0 , R , 1 ) : count = [ 0 for i in range ( R + 1 ) ] for j in range ( 0 , C , 1 ) : count [ hist [ i ] [ j ] ] += 1 col_no = 0 j = R while ( j >= 0 ) : if ( count [ j ] > 0 ) : for k in range ( 0 , count [ j ] , 1 ) : hist [ i ] [ col_no ] = j col_no += 1 j -= 1 max_area = 0 for i in range ( 0 , R , 1 ) : for j in range ( 0 , C , 1 ) : curr_area = ( j + 1 ) * hist [ i ] [ j ] if ( curr_area > max_area ) : max_area = curr_area return max_area

def maxArea ( mat , R , C ) : hist = [ 0 for i in range ( R , C ) ] for i in range ( R , C ) : hist [ 0 ] [ i ] = mat [ 0 ] [ i ] for j in range ( R , C ) : count [ hist [ i ] [ j ] ] = 1 col_no = 0 for j in range ( R , j >= 0 ) : if ( count [ j ] > 0 ) : hist [ i ] [ col_no ] = j if ( count [ j ] > 0 ) : max_area = curr_area = ( j + 1 ) * hist [ i ] [ j ] return max_area

def maxArea ( mat ) : hist [ 0 ] [ i ] = mat [ 0 ] [ i ] for j in range ( 1 , R , - 1 ) : hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 for j in range ( R , - 1 , - 1 ) : count [ hist [ i ] [ j ] ] += 1 col_no = 0 for j in R : if ( j >= 0 ) : if ( count [ j ] > 0 ) : for k in range ( count [ j ] ) : hist [ i ] [ col_no ] = j col_no += 1 return max_area

28.25
34.14
43.81
47.4
public static void countCurrency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 }; int [ ] noteCounter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } System . out . println ( "Currency Count ->" ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { System . out . println ( notes [ i ] + " : " + noteCounter [ i ] ) ; } } }

def countCurrency ( amount ) : notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] print ( "CurrencyCount->" ) for i , j in zip ( notes , noteCounter ) : if amount >= i : j = amount // i amount = amount - j * i print ( i , ":" , j )

def countCurrency ( amount ) : notes = [ 2000 , 1000 , 1000 , 100 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } noteCounter = [ 0 for i in range ( 9 ) ] for i in range ( 0 , 9 ) : if ( amount >= notes [ i ] ) : noteCounter [ i ] = amount - notes [ i ] * notes [ i ] amount = amount - noteCounter [ i ] * notes [ i ] noteCounter [ i ] = 0 if ( noteCounter [ i ] != 0 ) : print ( notes [ i ] + " : " + noteCounter [ i ] ) return

def countCurrency ( amount ) : notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] noteCounter = [ 0 for i in range ( 9 ) ] for i in range ( 0 , 9 ) : if amount >= notes [ i ] : noteCounter [ i ] = amount / notes [ i ] amount = amount - noteCounter [ i ] * notes [ i ] print ( notes [ i ] + " : " + noteCounter [ i ] )

28.28
42.77
24.4
34.61
static boolean isLucky ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }

def isLucky ( n ) : ar = [ 0 ] * 10 while ( n > 0 ) : digit = math . floor ( n % 10 ) if ( ar [ digit ] ) : return 0 ar [ digit ] = 1 n = n / 10 return 1

def isLucky ( n ) : arr = [ false for i in range ( 10 ) ] for i in range ( 10 ) : if ( arr [ i ] ) : return false arr [ i ] = true n = n / 10 while n > 0 : digit = n % 10 if ( arr [ digit ] ) : return false arr [ digit ] = true n = n / 10 return true

def isLucky ( n ) : arr = [ False for i in range ( 10 ) ] for i in range ( 10 ) : arr [ i ] = False while n > 0 : digit = n % 10 if arr [ digit ] : return False ; arr [ digit ] = True n = n // 10 return True

28.33
30.29
31.24
30.66
static void printSuperSeq ( String a , String b ) { int m = a . length ( ) , n = b . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } String res = "" ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) { res = a . charAt ( i - 1 ) + res ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res = a . charAt ( i - 1 ) + res ; i -- ; } else { res = b . charAt ( j - 1 ) + res ; j -- ; } } while ( i > 0 ) { res = a . charAt ( i - 1 ) + res ; i -- ; } while ( j > 0 ) { res = b . charAt ( j - 1 ) + res ; j -- ; } System . out . println ( res ) ; }

def printSuperSeq ( a , b ) : m = len ( a ) n = len ( b ) dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( 0 , m + 1 ) : for j in range ( 0 , n + 1 ) : if not i : dp [ i ] [ j ] = j elif not j : dp [ i ] [ j ] = i elif ( a [ i - 1 ] == b [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] res = [ "" ] * ( index ) i = m j = n while ( i > 0 and j > 0 ) : if ( a [ i - 1 ] == b [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 j -= 1 index -= 1 elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 else : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 while ( i > 0 ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 while ( j > 0 ) : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 print ( "" . join ( res ) )

def printSuperSeq ( a , b ) : m = len ( a ) n = len ( b ) for i in range ( m + 1 , n + 1 ) : for j in range ( n ) : if ( a [ i ] == b [ j ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] if ( j == 0 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : res = a [ i - 1 ] [ j ] return res

def printSuperSeq ( a , b ) : dp = [ 0 for k in range ( m ) ] for i in range ( m ) : dp [ i ] [ j ] = j if i == 0 : dp [ i ] [ j ] = i elif j == 0 : dp [ i ] [ j ] = i elif a [ i - 1 ] == b [ j - 1 ] : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] elif b [ i - 1 ] == j - 1 : dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) else : dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) i -= 1 j -= 1 res += b [ j - 1 ] + res return res

28.34
44.62
100.0
100.0
static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }

def transpose ( A , B ) : for i in range ( N ) : for j in range ( N ) : B [ i ] [ j ] = A [ j ] [ i ]

def transpose ( A , B , N ) : B . sort ( reverse = True ) for i in range ( 0 , N ) : B [ i ] [ j ] = A [ j ] [ i ] if ( i == j ) : B [ i ] [ j ] = A [ i ] [ j ] if ( j == N ) : B [ i ] [ j ] = A [ j ] [ i ] if ( A [ i ] [ j ] ) :

def transpose ( A , B ) : for i in range ( N ) : for j in range ( N ) : B [ i ] [ j ] = A [ j ] [ i ]

28.38
34.74
37.56
40.63
static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n ; if ( sum == s ) return n ; } return - 1 ; }

def findS ( s ) : _sum = 0 n = 1 while ( _sum < s ) : _sum += n * n n += 1 n -= 1 if _sum == s : return n return - 1

def findS ( s ) : sum = 0 for n in range ( 1 , s ) : sum += n * n if ( sum == s ) : return n

def findS ( s ) : sum = 0 for n in range ( 1 , len ( s ) ) : sum += n * n if ( sum == s ) : return n return - 1

28.48
37.03
70.74
53.79
public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int count [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; }

def findMaxGCD ( arr , n ) : high = 0 for i in range ( 0 , n ) : high = max ( high , arr [ i ] ) count = [ 0 ] * ( high + 1 ) for i in range ( 0 , n ) : count [ arr [ i ] ] += 1 counter = 0 for i in range ( high , 0 , - 1 ) : j = i while ( j <= high ) : if ( count [ j ] > 0 ) : counter += count [ j ] j += i if ( counter == 2 ) : return i counter = 0

def findMaxGCD ( arr , n ) : high = 0 for i in range ( n ) : high = max ( high , arr [ i ] ) for i in range ( n ) : if ( arr [ i ] >= 1 ) : counter += count [ arr [ i ] ] return 1

def findMaxGCD ( arr , n ) : high = 0 for i in range ( n ) : high = max ( high , arr [ i ] ) count [ arr [ i ] ] += 1 counter = 0 for i in high : if ( count [ i ] > 0 ) : counter += count [ i ] j = i while ( j <= high ) : if ( count [ j ] > 0 ) : counter += count [ j ] j += i if ( counter == 2 ) : return i counter = 0 return 1

28.49
41.89
48.78
42.35
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int lps [ ] = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }

def longestPrefixSuffix ( s ) : n = len ( s ) lps = [ 0 ] * n l = 0 i = 1 while ( i < n ) : if ( s [ i ] == s [ l ] ) : l = l + 1 lps [ i ] = l i = i + 1 else : if ( l != 0 ) : l = lps [ l - 1 ] else : lps [ i ] = 0 i = i + 1 res = lps [ n - 1 ] if ( res > n / 2 ) : return n // 2 else : return res

def longestPrefixSuffix ( s ) : lps = [ 0 for k in range ( n ) ] len = 0 for i in range ( n ) : if ( s [ i ] == s [ len ] ) : len = lps [ len - 1 ] i += 1 elif ( s [ i ] == s [ len ] ) : len = lps [ len - 1 ] if ( len != 0 ) : lps [ i ] = len - 1 i += 1 elif ( s [ i ] == s [ len ] : if ( len != 0 ) : len = lps [ len - 1 ] if ( len != 0 ) : len = lps [ len - 1 ] if ( len != 0 ) : lps [ i ] = len - 1 ] i += 1 else : return res

def longestPrefixSuffix ( s ) : lps = [ 0 for k in range ( n ) ] len = 0 i = 1 while i < n : if ( s [ i ] == s [ len ] ) : len ++ lps [ i ] = len i ++ else : if ( len != 0 ) : len = lps [ len - 1 ] else : lps [ i ] = 0 i ++ res = lps [ n - 1 ] return ( res > n / 2 ) ? n / 2 : res

28.63
36.03
32.92
38.61
public static int minOperation ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; else hash . put ( arr [ i ] , 1 ) ; int max_count = 0 ; Set < Integer > s = hash . keySet ( ) ; for ( int i : s ) if ( max_count < hash . get ( i ) ) max_count = hash . get ( i ) ; return ( n - max_count ) ; }

def minOperation ( arr , n ) : Hash = defaultdict ( lambda : 0 ) for i in range ( 0 , n ) : Hash [ arr [ i ] ] += 1 max_count = 0 for i in Hash : if max_count < Hash [ i ] : max_count = Hash [ i ] return n - max_count

def minOperation ( arr , n ) : hash = new HashMap < Integer , Integer > ( ) for i in range ( n ) : if ( hash [ arr [ i ] ] != 1 ) : hash . put ( arr [ i ] , 1 ) else : max_count = hash [ arr [ i ] ] for i in range ( n ) : if ( max_count < hash [ i ] ) : max_count = hash [ i ] return ( n - max_

def minOperation ( arr , n ) : hash = new HashMap ( ) for i in range ( n ) : if hash . containsKey ( arr [ i ] ) : hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 else : hash [ arr [ i ] ] = 1 max_count = 0 s = hash . keySet ( ) for i in s : if max_count < hash [ i ] : max_count = hash [ i ] return ( n - max_count )

28.73
36.43
28.89
32.44
static void printStringAlternate ( String str ) { int [ ] occ = new int [ 122 ] ; String s = str . toLowerCase ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = s . charAt ( i ) ; occ [ temp ] ++ ; if ( occ [ temp ] % 2 != 0 ) System . out . print ( str . charAt ( i ) ) ; } System . out . println ( ) ; }

def printStringAlternate ( string ) : occ = { } for i in range ( 0 , len ( string ) ) : temp = string [ i ] . lower ( ) occ [ temp ] = occ . get ( temp , 0 ) + 1 if occ [ temp ] & 1 : print ( string [ i ] , end = "" ) print ( )

def printStringAlternate ( str ) : occ = [ 0 for i in range ( len ( str ) ) ] for i in range ( len ( s ) ) : temp = s [ i ] if ( occ [ temp ] % 2 != 0 ) : print ( str [ i ] ) occ [ temp ] = 0 if ( occ [ temp ] % 2 != 0 ) : print ( str [ i ] )

def printStringAlternate ( str ) : occ = [ 122 for i in range ( len ( str ) ) ] s = str . toLowerCase ( ) for i in range ( 0 , len ( str ) ) : occ [ i ] = float ( s [ i ] ) if occ [ i ] % 2 != 0 : print ( str [ i ] )

28.8
29.37
60.49
45.72
static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++ ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; }

def countDivisbleby4 ( s ) : n = len ( s ) count = 0 for i in range ( 0 , n , 1 ) : if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : count += 1 for i in range ( 0 , n - 1 , 1 ) : h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) if ( h % 4 == 0 ) : count = count + i + 1 return count

def countDivisbleby4 ( s ) : n = len ( s ) for i in range ( n ) : if ( s [ i ] == '4' || s [ i ] == '8' ) : count += i break if ( s [ i ] == '0' ) : count = count + i + 1 return count

def countDivisbleby4 ( s ) : count = 0 for i in range ( n ) : if s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' : count += 1 for i in range ( n - 1 ) : h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) if ( h % 4 == 0 ) : count = count + i + 1 return count

28.87
43.63
58.45
60.18
static int cassini ( int n ) { return ( n & 1 ) != 0 ? - 1 : 1 ; }

def cassini ( n ) : return - 1 if ( n & 1 ) else 1

def cassini ( n ) : return n

def cassini ( n ) : return ( n & 1 ) != 0

28.89
48.75
42.56
40.92
static void generate ( Set < String > st , String s ) { if ( s . length ( ) == 0 ) { return ; } if ( ! st . contains ( s ) ) { st . add ( s ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String t = s ; t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; generate ( st , t ) ; } } return ; }

def generate ( st , s ) : if len ( s ) == 0 : return if s not in st : st . add ( s ) for i in range ( len ( s ) ) : t = list ( s ) . copy ( ) t . remove ( s [ i ] ) t = '' . join ( t ) generate ( st , t ) return

def generate ( st , s ) : if ( s == null ) : return for i in range ( len ( s ) ) : t = s s = t [ 0 : i + 1 ] generate ( st , s ) return for i in range ( len ( s ) ) : t = s [ i : i + 1 ] generate ( st , t ) return for i in range ( len ( s ) ) : t = s [ 0 : i + 1 ] generate ( st , t ) : if ( t ) : t = t [ 0 : i + 1 ] generate ( st , t ) return

def generate ( st , s ) : if not st . contains ( s ) : st . add ( s ) for i in range ( 0 , len ( s ) , - 1 ) : String t = s [ 0 : i ] t = t [ 0 : i ] + t [ i + 1 : ] generate ( st , t )

28.91
29.56
21.28
23.29
static void convertOpposite ( StringBuffer str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { Character c = str . charAt ( i ) ; if ( Character . isLowerCase ( c ) ) str . replace ( i , i + 1 , Character . toUpperCase ( c ) + "" ) ; else str . replace ( i , i + 1 , Character . toLowerCase ( c ) + "" ) ; } }

def convertOpposite ( str ) : ln = len ( str ) for i in range ( ln ) : if str [ i ] >= 'a' and str [ i ] <= 'z' : str [ i ] = chr ( ord ( str [ i ] ) - 32 ) elif str [ i ] >= 'A' and str [ i ] <= 'Z' : str [ i ] = chr ( ord ( str [ i ] ) + 32 )

def convertOpposite ( str ) : ln = str . length ( ) for i in range ( ln ) : c = str [ i ] if ( Character . isUpperCase ( c ) ) : str . replace ( i , i + 1 , Character . toUpperCase ( c ) + "" ) else : str [ i ] = c return str

def convertOpposite ( str ) : ln = str . length ( ) for i in range ( ln ) : c = str . charAt ( i ) if isLowerCase ( c ) : str . replace ( i , i + 1 , c ) else : str . replace ( i , i + 1 , c )

28.96
48.49
70.73
67.72
static void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }

def query ( s , i , j ) : n = len ( s ) i %= n j %= n print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" )

def query ( s , i , j ) : n = len ( s ) for i in range ( n ) : if ( s [ i ] == s [ j ] ) : System . out . println ( "Yes" ) elif ( s [ i ] == s [ j ] ) : System . out . println ( "No" ) return n = len ( s ) if ( s [ i ] == s [ j ] ) : System . out . println ( "Yes

def query ( s , i , j ) : n = s . length i %= n j %= n if s [ i ] == s [ j ] : print ( "Yes" ) else : print ( "No" )

29.0
33.91
25.89
18.54
public static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }

def countDigits ( a , b ) : if ( a == 0 or b == 0 ) : return 1 return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1

def countDigits ( a , b ) : if ( a == 0 ) : return 1 return countDigits ( a , b )

def countDigits ( a , b ) : if a == 0 or b == 0 : return 1 return float ( 'inf' )

29.11
37.12
49.7
44.84
static int maxLen ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; Integer prev_i = hM . get ( sum ) ; if ( prev_i != null ) max_len = Math . max ( max_len , i - prev_i ) ; else hM . put ( sum , i ) ; } return max_len ; }

def maxLen ( arr ) : hash_map = { } max_len = 0 curr_sum = 0 for i in range ( len ( arr ) ) : curr_sum += arr [ i ] if arr [ i ] is 0 and max_len is 0 : max_len = 1 if curr_sum is 0 : max_len = i + 1 if curr_sum in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum ] ) else : hash_map [ curr_sum ] = i return max_len

def maxLen ( arr ) : hM = defaultdict ( int ) for i in range ( arr . length ) : sum = 0 max_len = 0 for i in range ( arr . length ) : sum += arr [ i ] if ( arr [ i ] == 0 and max_len == 0 ) : max_len = 1 if ( sum == 0 ) : max_len = 1 if ( sum == 0 ) : max_len = 1 if ( sum == 0 ) : max_len = i + 1 else : hM [ sum ] = i + 1 else : prev_i = hM [ sum ] if ( prev_i != null ) : max_len = max ( max_len , i - prev_i ) else : hM . put ( sum , i ) return max_len

def maxLen ( arr ) : sum = 0 max_len = 0 for i in range ( len ( arr ) ) : sum += arr [ i ] if arr [ i ] == 0 and max_len == 0 : max_len = 1 if sum == 0 : max_len = 1 if sum == 0 : max_len = i + 1 prev_i = hM . get ( sum ) if prev_i != None : max_len = max ( max_len , i - prev_i ) else : hM . put ( sum , i ) return max_len

29.17
38.68
43.16
49.12
static boolean canFormPalindrome ( String str ) { List < Character > list = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( list . contains ( str . charAt ( i ) ) ) list . remove ( ( Character ) str . charAt ( i ) ) ; else list . add ( str . charAt ( i ) ) ; } if ( str . length ( ) % 2 == 0 && list . isEmpty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true ; else return false ; }

def canFormPalindrome ( strr ) : listt = [ ] for i in range ( len ( strr ) ) : if ( strr [ i ] in listt ) : listt . remove ( strr [ i ] ) else : listt . append ( strr [ i ] ) if ( len ( strr ) % 2 == 0 and len ( listt ) == 0 or \ ( len ( strr ) % 2 == 1 and len ( listt ) == 1 ) ) : return True else : return False

def canFormPalindrome ( str ) : list = list ( str ) for i in range ( len ( str ) ) : if ( list [ i ] == ( Character ) str [ i ] ) : list . remove ( ( Character ) str [ i ] ) else : list . add ( ( Character ) str [ i ] ) if ( list [ 0 ] == ( Character ) str [ i ] ) : return true else : return false

def canFormPalindrome ( str ) : list = list ( ) for i in range ( len ( str ) ) : if ( list . contains ( str [ i ] ) ) : list . remove ( ( Character ) str [ i ] ) else : list . add ( str [ i ] ) if ( str . length ( ) % 2 == 0 and list . isEmpty ( ) or ( str . length ( ) % 2 == 1 and list . size ( ) == 1 ) ) : return True else : return False

29.18
32.01
77.96
63.62
static boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }

def modularSum ( arr , n , m ) : if ( n > m ) : return True DP = [ False for i in range ( m ) ] for i in range ( n ) : if ( DP [ 0 ] ) : return True temp = [ False for i in range ( m ) ] for j in range ( m ) : if ( DP [ j ] == True ) : if ( DP [ ( j + arr [ i ] ) % m ] == False ) : temp [ ( j + arr [ i ] ) % m ] = True for j in range ( m ) : if ( temp [ j ] ) : DP [ j ] = True DP [ arr [ i ] % m ] = True return DP [ 0 ]

def modularSum ( arr , n , m ) : DP = [ false for i in range ( n ) ] temp = [ false for i in range ( n ) ] for j in range ( 0 , m ) : if ( DP [ j ] ) : DP [ j ] = true temp [ ( j + arr [ i ] ) % m ] = true return DP [ 0 ]

def modularSum ( arr , n , m ) : if n > m : return True DP [ ] = [ False for i in range ( n ) ] for i in range ( n ) : if ( DP [ 0 ] ) : return True DP [ 0 ] = True temp = [ ] for j in range ( 0 , m ) : if ( DP [ j ] == True ) : if ( DP [ ( j + arr [ i ] ) % m ] == false ) : temp [ ( j + arr [ i ] ) % m ] = True if ( temp [ j ] ) : DP [ j ] = True DP [ arr [ i ] % m ] = True return DP [ 0 ]

29.23
31.1
26.24
24.79
static void generateSquare ( int n ) { int [ ] [ ] magicSquare = new int [ n ] [ n ] ; int i = n / 2 ; int j = n - 1 ; for ( int num = 1 ; num <= n * n ; ) { if ( i == - 1 && j == n ) { j = n - 2 ; i = 0 ; } else { if ( j == n ) j = 0 ; if ( i < 0 ) i = n - 1 ; } if ( magicSquare [ i ] [ j ] != 0 ) { j -= 2 ; i ++ ; continue ; } else magicSquare [ i ] [ j ] = num ++ ; j ++ ; i -- ; } System . out . println ( "The Magic Square for " + n + ":" ) ; System . out . println ( "Sum of each row or column " + n * ( n * n + 1 ) / 2 + ":" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) System . out . print ( magicSquare [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

def generateSquare ( n ) : magicSquare = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] i = n / 2 j = n - 1 num = 1 while num <= ( n * n ) : if i == - 1 and j == n : j = n - 2 i = 0 else : if j == n : j = 0 if i < 0 : i = n - 1 if magicSquare [ int ( i ) ] [ int ( j ) ] : j = j - 2 i = i + 1 continue else : magicSquare [ int ( i ) ] [ int ( j ) ] = num num = num + 1 j = j + 1 i = i - 1 print ( "MagicSqureforn=" , n ) print ( "Sumofeachroworcolumn" , n * ( n * n + 1 ) / 2 , "\n" ) for i in range ( 0 , n ) : for j in range ( 0 , n ) : print ( '%2d' % ( magicSquare [ i ] [ j ] ) , end = '' ) if j == n - 1 : print ( )

def generateSquare ( n ) : magicSquare = [ 0 for k in range ( n ) ] for k in range ( n ) : for num in range ( 1 , n ) : if ( i == - 1 and j == n ) : i = 0 j = n - 2 elif ( num == n * n + 1 ) : j = n - 1 i = 0 continue if ( magicSquare [ i ] [ j ] != 0 ) : j -= 2 i += 1 continue if ( magicSquare [ i ] [ j ] = num continue if ( magicSquare [ i ] [ j ] != 0 ) : j -= 1 print ( magicSquare [ i ] [ j ] = num continue if ( magicSquare [ i ] [ j ] != 0 ) : i += 1 print ( magicSquare [ i ] [ j ]

def generateSquare ( n ) : magicSquare = [ 0 for i in range ( n ) ] for num in range ( 1 , n ) : if ( i == - 1 and j == n ) : j = n if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = n - 1 if ( i < 0 ) : i = n - 1 if ( j == n ) : j = 0

29.41
32.61
32.41
28.49
static void manipulated_seive ( int N ) { isprime . set ( 0 , false ) ; isprime . set ( 1 , false ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( isprime . get ( i ) ) { prime . add ( i ) ; SPF . set ( i , i ) ; } for ( int j = 0 ; j < prime . size ( ) && i * prime . get ( j ) < N && prime . get ( j ) <= SPF . get ( i ) ; j ++ ) { isprime . set ( i * prime . get ( j ) , false ) ; SPF . set ( i * prime . get ( j ) , prime . get ( j ) ) ; } } }

def manipulated_seive ( N ) : isprime [ 0 ] = isprime [ 1 ] = False for i in range ( 2 , N ) : if isprime [ i ] == True : prime . append ( i ) SPF [ i ] = i j = 0 while ( j < len ( prime ) and i * prime [ j ] < N and prime [ j ] <= SPF [ i ] ) : isprime [ i * prime [ j ] ] = False SPF [ i * prime [ j ] ] = prime [ j ] j += 1

def manipulated_seive ( N ) : isprime . clear ( ) SPF . set ( 0 , false ) prime . clear ( ) SPF . set ( 1 , false ) for i in range ( 2 , N ) : if ( isprime . get ( i ) ) : isprime . set ( i , true ) SPF . set ( i , prime [ i ] ) j = 0 for j in range ( 0 , N ) : isprime . set ( i * prime [ j ] = prime [ j ] if ( i * prime [ j ] <= SPF . get ( i ) : isprime . set ( i * prime [ j ] , prime [ j ] ) for j in range ( 2 , N ) : isprime . set ( i * prime [ j ] = true ) SPF . set ( i , prime [ j ] ) return isprime [ i ]

def manipulated_seive ( N ) : isprime . set ( 0 , False ) for i in range ( 2 , N ) : if isprime . get ( i ) : prime . add ( i ) SPF . set ( i , i ) for j in range ( 0 , prime . size ( ) ) : isprime . set ( i * prime [ j ] , False ) SPF . set ( i * prime [ j ] , prime [ j ] )

29.41
28.31
22.14
17.68
static StringBuilder findLeft ( StringBuilder str ) { int n = str . length ( ) ; while ( n > 0 ) { n -- ; if ( str . charAt ( n ) == 'd' ) { str . setCharAt ( n , 'c' ) ; break ; } if ( str . charAt ( n ) == 'b' ) { str . setCharAt ( n , 'a' ) ; break ; } if ( str . charAt ( n ) == 'a' ) str . setCharAt ( n , 'b' ) ; else if ( str . charAt ( n ) == 'c' ) str . setCharAt ( n , 'd' ) ; } return str ; }

def findLeft ( str ) : n = len ( str ) - 1 while ( n > 0 ) : if ( str [ n ] == 'd' ) : str = str [ 0 : n ] + 'c' + str [ n + 1 : ] break if ( str [ n ] == 'b' ) : str = str [ 0 : n ] + 'a' + str [ n + 1 : ] break if ( str [ n ] == 'a' ) : str = str [ 0 : n ] + 'b' + str [ n + 1 : ] elif ( str [ n ] == 'c' ) : str = str [ 0 : n ] + 'd' + str [ n + 1 : ] n -= 1 return str

def findLeft ( str ) : n = len ( str ) while n > 0 : if ( str [ n ] == 'c' ) : str . setCharAt ( n , 'd' ) break if ( str [ n ] == 'a' ) : str . setCharAt ( n , 'b' ) else : str [ n ] = 'c' break if ( str [ n ] == 'b' ) : str . setCharAt ( n ,

def findLeft ( str ) : n = str . length ( ) while n > 0 : if ( str . charAt ( n ) == 'd' ) : str . setCharAt ( n , 'c' ) break if ( str . charAt ( n ) == 'b' ) : str . setCharAt ( n , 'a' ) elif ( str . charAt ( n ) == 'a' ) : str . setCharAt ( n , 'b' ) else : if ( str . charAt ( n ) == 'c' ) : str . setCharAt ( n , 'd' ) return str

29.46
28.6
100.0
100.0
public static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }

def nthTerm ( n ) : return ( n * n ) + ( n * n * n )

def nthTerm ( n ) : return ( n

def nthTerm ( n ) : return ( n * n ) + ( n * n * n )

29.69
21.27
76.27
79.78
static int maxProd ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }

def maxProd ( n ) : if ( n == 2 or n == 3 ) : return ( n - 1 ) res = 1 while ( n > 4 ) : n -= 3 res *= 3 return ( n * res )

def maxProd ( n ) : if ( n == 1 || n == 2 ) : return ( n - 1 )

def maxProd ( n ) : if n == 2 or n == 3 : return ( n - 1 ) res = 1 while n > 4 : n -= 3 res *= 3 return ( n * res )

29.84
42.63
59.22
51.32
static void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " " ) ; }

def findLarger ( arr , n ) : x = sorted ( arr ) for i in range ( n / 2 , n ) : print ( x [ i ] ) ,

def findLarger ( arr , n ) : arr . sort ( reverse = True ) for i in range ( n ) : print ( arr [ i ] , end = "" ) for i in range ( n - 1 , - 1 , - 1 ) : print ( arr [ i ] , end = "" ) return

def findLarger ( arr , n ) : sort ( arr ) for i in range ( n ) : print ( arr [ i ] )

29.87
37.49
77.88
56.61
static void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + " " ) ; } System . out . println ( ) ; } }

def printSumSimple ( mat , k ) : if ( k > n ) : return for i in range ( n - k + 1 ) : for j in range ( n - k + 1 ) : sum = 0 for p in range ( i , k + i ) : for q in range ( j , k + j ) : sum += mat [ p ] [ q ] print ( sum , end = "" ) print ( )

def printSumSimple ( mat , n , k ) : if ( k < 0 || k >= n - 1 ) : return for i in range ( 0 , n - k + 1 , - 1 ) : sum = mat [ i ] [ j ] if ( sum == 0 ) : print ( sum + " " ) return for j in range ( 0 , n - k + 1 , - 1 ) : print ( sum + " " ) if ( sum == 0 ) : print ( mat [ p ] [ q ] ) : print ( ) return for i in range ( 0 , n - k + 1 ) : print ( sum + " " ) return for j in range ( 0 , n - k + 1 ) : print ( mat [ i ] [ j ] )

def printSumSimple ( mat , k ) : if k > n : return for i in range ( n ) : for j in range ( n - k + 1 , k ) : sum = 0 for p in range ( i , k + i ) : for q in range ( j , k + j ) : sum += mat [ p ] [ q ] print ( sum + " " )

30.13
29.41
40.07
31.94
static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }

def exactPrimeFactorCount ( n ) : count = 0 if ( n % 2 == 0 ) : count = count + 1 while ( n % 2 == 0 ) : n = int ( n / 2 ) i = 3 while ( i <= int ( math . sqrt ( n ) ) ) : if ( n % i == 0 ) : count = count + 1 while ( n % i == 0 ) : n = int ( n / i ) i = i + 2 if ( n > 2 ) : count = count + 1 return count

def exactPrimeFactorCount ( n ) : count = 0 for i in range ( 3 , Math . sqrt ( n ) ) : if ( n % 2 == 0 ) : count ++ while ( n % 2 == 0 ) n = n / 2 if ( n > 2 ) : count ++ return count

def exactPrimeFactorCount ( n ) : count = 0 if n % 2 == 0 : count += 1 for i in range ( 3 , sqrt ( n ) ) : if ( n % i == 0 ) : count += 1 while ( n % i == 0 ) : n = n / i if ( n > 2 ) : count += 1 return count

30.15
32.13
39.13
40.19
static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = "" ; String anticlock_rot = "" ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ; return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ; }

def isRotated ( str1 , str2 ) : if ( len ( str1 ) != len ( str2 ) ) : return False clock_rot = "" anticlock_rot = "" l = len ( str2 ) anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] return ( str1 == clock_rot or str1 == anticlock_rot )

def isRotated ( str1 , str2 ) : len = str1 . length ( ) clock_rot = "" anticlock_rot = "" str2 = str2 [ len - 2 : len - 2 ] str2 = str2 [ 0 : len - 2 ] if ( str1 . equals ( clock_rot ) ) : return ( str1 . equals ( anticlock_rot ) ) : return ( str1 . equals ( anticlock_rot )

def isRotated ( str1 , str2 ) : clock_rot = "" anticlock_rot = "" len = str2 . length ( ) str2 = str2 [ len - 2 : len ] + str2 [ 0 : len - 2 ] + str2 [ len - 2 : ] clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : len - 2 ] anticlock_rot = anticlock_rot + str2 [ 2 : ] + str2 [ 0 : len - 2 ] clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] return ( str1 . equals ( clock_rot ) or str1 . equals ( anticlock_rot ) )

30.18
24.14
54.48
44.31
static int leonardo ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; }

def leonardo ( n ) : dp = [ ] dp . append ( 1 ) dp . append ( 1 ) for i in range ( 2 , n + 1 ) : dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) return dp [ n ]

def leonardo ( n ) : dp = [ 0 for i in range ( n ) ] dp [ 0 ] = dp [ 1 ] = dp [ n + 1 ] = 1 return dp [ n ]

def leonardo ( n ) : dp = [ INT_MAX for i in range ( n ) ] dp [ 0 ] = dp [ 1 ] = 1 for i in range ( 2 , n ) : dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 return dp [ n ]

30.18
32.02
34.07
30.3
static void printGrouped ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str . charAt ( i ) - 'a' ] != 0 ) { System . out . print ( str . charAt ( i ) ) ; count [ str . charAt ( i ) - 'a' ] -- ; } count [ str . charAt ( i ) - 'a' ] = 0 ; } }

def printGrouped ( string ) : n = len ( string ) count = [ 0 ] * MAX_CHAR for i in range ( n ) : count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1 for i in range ( n ) : while count [ ord ( string [ i ] ) - ord ( "a" ) ] : print ( string [ i ] , end = "" ) count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1 count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0

def printGrouped ( str ) : n = len ( str ) count = [ 0 for i in range ( n ) ] for i in range ( 0 , n ) : if ( count [ str [ i ] - 'a' ] != 0 ) : print ( str [ i ] ) count [ str [ i ] - 'a' ] = 0 print ( str [ i ] ) count [ str [ i ] - 'a' ] = 0 print ( str [ i ] )

def printGrouped ( str ) : count = [ 0 for i in range ( n ) ] for i in range ( n ) : while count [ str [ i ] - 'a' ] != 0 : print ( str [ i ] ) count [ str [ i ] - 'a' ] -- for i in range ( n ) : if count [ str [ i ] - 'a' ] != 0 : print ( str [ i ] ) count [ str [ i ] - 'a' ] -= 1 count [ str [ i ] - 'a' ] = 0

30.19
53.38
30.19
53.38
static int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }

def cost ( a , n ) : return ( ( n - 1 ) * min ( a ) )

def cost ( a , n ) : min = a [ 0 ] for i in range ( 1 , n ) : if ( a [ i ] < min ) : min = a [ i ] return ( n - 1 ) * min

def cost ( a , n ) : min = a [ 0 ] for i in range ( 1 , n ) : if ( a [ i ] < min ) : min = a [ i ] return ( n - 1 ) * min

30.2
35.94
43.16
38.57
static int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }

def countPair ( a , b ) : s = str ( b ) i = 0 while i < ( len ( s ) ) : if ( s [ i ] != '9' ) : break i += 1 result = 0 if ( i == len ( s ) ) : result = a * len ( s ) else : result = a * ( len ( s ) - 1 ) return result

def countPair ( a , b ) : s = String . valueOf ( a ) for i in range ( len ( s ) ) : if ( s [ i ] != '9' ) : break return countPair ( a , b )

def countPair ( a , b ) : s = str ( b ) for i in range ( len ( s ) ) : if i == s [ - 1 ] : result = a * s [ - 1 ] else : result = a * ( s [ - 1 ] - 1 ) return result

30.21
33.69
21.7
30.5
static boolean checkCount ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , 0 ) ; hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; } for ( Map . Entry x : hash . entrySet ( ) ) if ( ( int ) x . getValue ( ) > 2 * k ) return false ; return true ; }

def checkCount ( arr , n , k ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 for key , values in mp . items ( ) : if values > 2 * k : return False return True

def checkCount ( arr , n , k ) : hash . clear ( ) for i in range ( n ) : if ( ! hash . containsKey ( arr [ i ] ) ) : hash . put ( arr [ i ] , 0 ) hash . put ( arr [ i ] , 1 ) for x in hash . entrySet ( ) : if ( ( int ) x . getValue ( ) > 2 * k ) : return false return true

def checkCount ( arr , n , k ) : hash = { } for i in range ( n ) : if not hash . containsKey ( arr [ i ] ) : hash [ arr [ i ] ] = 0 if not hash [ arr [ i ] ] : hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 if not hash [ arr [ i ] ] : hash [ arr [ i ] ] = 0 hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 return True

30.22
37.51
18.7
37.92
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }

def equilibrium ( arr ) : total_sum = sum ( arr ) leftsum = 0 for i , num in enumerate ( arr ) : total_sum -= num if leftsum == total_sum : return i leftsum += num return - 1

def equilibrium ( arr , n ) : sum = 0 leftsum = 0 for i in range ( n ) : sum -= arr [ i ] if ( leftsum == sum ) : return i leftsum += arr [ i ] return - 1

def equilibrium ( arr , n ) : sum = 0 leftsum = 0 for i in range ( n ) : sum += arr [ i ] for i in range ( n ) : sum -= arr [ i ] for i in range ( n ) : sum -= arr [ i ] if ( leftsum == sum ) : return i leftsum += arr [ i ] return - 1

30.24
49.27
30.59
49.6
static boolean checkSentence ( char [ ] str ) { int len = str . length ; if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false ; if ( str [ len - 1 ] != '.' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . length ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ; else if ( str [ index ] == ' ' ) curr_state = 1 ; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ; else if ( str [ index ] == '.' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ; index ++ ; prev_state = curr_state ; } return false ; }

def checkSentence ( string ) : length = len ( string ) if string [ 0 ] < 'A' or string [ 0 ] > 'Z' : return False if string [ length - 1 ] != '.' : return False prev_state = 0 curr_state = 0 index = 1 while ( string [ index ] ) : if string [ index ] >= 'A' and string [ index ] <= 'Z' : curr_state = 0 elif string [ index ] == '' : curr_state = 1 elif string [ index ] >= 'a' and string [ index ] <= 'z' : curr_state = 2 elif string [ index ] == '.' : curr_state = 3 if prev_state == curr_state and curr_state != 2 : return False if prev_state == 2 and curr_state == 0 : return False if curr_state == 3 and prev_state != 1 : return True index += 1 prev_state = curr_state return False

def checkSentence ( str ) : len = len1 ( str ) if ( len <= 1 || str [ len - 1 ] < 'A' or str [ len - 1 ] > 'Z' ) : return false prev_state = 0 curr_state = 0 for index in range ( len ) : if ( str [ index ] >= 'A' and str [ index ] <= 'Z' ) : curr_state = 1 else : curr_state = 2 if ( str [ index ] == '.' ) : curr_state = 3 if ( str [ index ] >= 'a' and str [ index ] <= 'z' ) : curr_state = 3 if ( str [ index ] == '.' ) : return ( prev_state == curr_state ) : return ( index + 1 == str . length )

def checkSentence ( str ) : len = str . length prev_state = 0 curr_state = 0 index = 1 while index <= str . length : if ( str [ index ] < 'A' or str [ index ] <= 'Z' ) : curr_state = 0 else : if ( str [ index ] == ' ' ) : curr_state = 1 else : if ( str [ index ] == ' ' ) : curr_state = 2 else : if ( str [ index ] == 'a' ) : curr_state = 3 if prev_state == curr_state and curr_state != 2 : return false ; if ( prev_state == curr_state and curr_state != 0 ) : return false ; if ( curr_state == 2 and prev_state != 1 ) : return ( index + 1 == str . length ) : prev_state = curr_state prev_state = curr_state state = 1 index += 1 while index <= str . length : if ( str [ index ] >= 'A' and str [ index ] <= 'Z' ) : curr_state = 0 else : if ( str [ index ] == ' ' ) : curr_state = 1 else : if ( str [

30.28
26.83
55.9
40.35
static int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }

def countOfBinaryNumberLessThanN ( N ) : q = deque ( ) q . append ( 1 ) cnt = 0 while ( q ) : t = q . popleft ( ) if ( t <= N ) : cnt = cnt + 1 q . append ( t * 10 ) q . append ( t * 10 + 1 ) return cnt

def countOfBinaryNumberLessThanN ( N ) : q = list ( ) for t in range ( 1 , 10 ) : if ( t <= N ) : cnt += 1 q . add ( t * 10 ) return cnt

def countOfBinaryNumberLessThanN ( N ) : q . append ( 1 ) cnt = 0 for k in range ( len ( q ) ) : t = q [ k ] q . remove ( ) if t <= N : cnt ++ q . add ( t * 10 ) q . add ( t * 10 + 1 ) return cnt

30.29
34.95
64.59
60.92
static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }

def countNonEmptySubstr ( str ) : n = len ( str ) return int ( n * ( n + 1 ) / 2 )

def countNonEmptySubstr ( str ) : n = str . length ( ) return n

def countNonEmptySubstr ( str ) : n = str . length ( ) return n * ( n + 1 ) / 2

30.31
57.59
28.06
36.26
static void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }

def stoogesort ( arr , l , h ) : if l >= h : return if arr [ l ] > arr [ h ] : t = arr [ l ] arr [ l ] = arr [ h ] arr [ h ] = t if h - l + 1 > 2 : t = ( int ) ( ( h - l + 1 ) / 3 ) stoogesort ( arr , l , ( h - t ) ) stoogesort ( arr , l + t , ( h ) ) stoogesort ( arr , l , ( h - t ) )

def stoogesort ( arr , l , h ) : if ( l >= h ) : return if ( arr [ l ] == arr [ h ] ) : arr [ l ] = arr [ h ] stoogesort ( arr , l , h - t ) stoogesort ( arr , l + t , h ) if ( h - l + 1 > 2 ) : stoogesort ( arr , l , h - t ) stoogesort ( arr , l + t , h ) if ( h - l + 1 > 3 ) : stoogesort ( arr , l , h - t ) stoogesort ( arr , l , h - t ) stoogesort ( arr , l + t , h ) stoogesort ( arr , l , h - t ) stoogesort ( arr , l + t , h ) stoogesort ( arr , l , h - t ) stoogesort ( arr , l + t , h ) stoogesort ( arr , l , h - t ) stoogesort ( arr , l , h - t ) stoogesort ( arr , l , h - t ) stoogesort ( arr ,

def stoogesort ( arr , l , h ) : if l >= h : return if arr [ l ] > arr [ h ] : t = arr [ l ] arr [ l ] = arr [ h ] arr [ h ] = t

30.4
36.35
63.03
63.86
static int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - '0' ) c ++ ; if ( j != s . charAt ( 1 ) - '0' ) c ++ ; if ( k != s . charAt ( 2 ) - '0' ) c ++ ; if ( l != s . charAt ( 3 ) - '0' ) c ++ ; if ( m != s . charAt ( 4 ) - '0' ) c ++ ; if ( n != s . charAt ( 5 ) - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }

def calculate ( s ) : ans = 6 for i in range ( 10 ) : for j in range ( 10 ) : for k in range ( 10 ) : for l in range ( 10 ) : for m in range ( 10 ) : for n in range ( 10 ) : if ( i + j + k == l + m + n ) : c = 0 if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : c += 1 if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : c += 1 if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : c += 1 if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : c += 1 if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : c += 1 if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : c += 1 if ( c < ans ) : ans = c return ans

def calculate ( s ) : ans = 6 for i in range ( 0 , 10 ) : for j in range ( 0 , 10 ) : for k in range ( 0 , 10 ) : for l in range ( 0 , 10 ) : if ( j + k == l + m + n ) : if ( m != s [ charAt ( 1 ) - '0' ) : c += 1 if ( n != s [ 5 ] - '0' ) : c += 1 if ( n != s [ 7 ] ) : ans = c if ( c < ans ) : ans = c return ans

def calculate ( s ) : ans = 6 for i in range ( 10 ) : for j in range ( 10 ) : for k in range ( 0 , 10 ) : for l in range ( 0 , 10 ) : for m in range ( 0 , 10 ) : if ( i + j + k == l + m + n ) : c = 0 if ( i != s [ 0 ] - '0' ) : c += 1 if ( j != s [ 1 ] - '0' ) : c += 1 if ( k != s [ 2 ] - '0' ) : c += 1 if ( l != s [ 3 ] - '0' ) : c += 1 if ( m != s [ 4 ] - '0' ) : c += 1 if ( n != s [ 5 ] - '0' ) : c += 1 if ( c < ans ) : ans = c return ans

30.48
42.89
85.25
88.4
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; }

def binarySearch ( arr , l , r , x ) : if ( r >= l ) : mid = int ( l + ( r - l ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > l and arr [ mid - 1 ] == x ) : return ( mid - 1 ) if ( mid < r and arr [ mid + 1 ] == x ) : return ( mid + 1 ) if ( arr [ mid ] > x ) : return binarySearch ( arr , l , mid - 2 , x ) return binarySearch ( arr , mid + 2 , r , x ) return - 1

def binarySearch ( arr , l , r , x ) : if ( arr [ l ] == x ) : return mid if ( arr [ l ] > x ) : return binarySearch ( arr , l , mid - 1 , x ) return binarySearch ( arr , mid + 1 , r , x ) return - 1

def binarySearch ( arr , l , r , x ) : if r >= l : mid = l + ( r - l ) / 2 if arr [ mid ] == x : return mid if ( mid > l and arr [ mid - 1 ] == x ) : return ( mid - 1 ) if ( mid < r and arr [ mid + 1 ] == x ) : return ( mid + 1 ) if ( arr [ mid ] > x ) : return binarySearch ( arr , l , mid - 2 , x ) return binarySearch ( arr , mid + 2 , r , x )

30.49
30.19
53.08
42.95
static void printCommonElements ( int mat [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( mat [ i ] [ j ] ) == i ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " " ) ; } } } }

def printCommonElements ( mat ) : mp = dict ( ) for j in range ( N ) : mp [ mat [ 0 ] [ j ] ] = 1 for i in range ( 1 , M ) : for j in range ( N ) : if ( mat [ i ] [ j ] in mp . keys ( ) and mp [ mat [ i ] [ j ] ] == i ) : mp [ mat [ i ] [ j ] ] = i + 1 if i == M - 1 : print ( mat [ i ] [ j ] , end = "" )

def printCommonElements ( mat , N , M ) : mp = new HashMap < Integer , Integer > ( ) for j in range ( 0 , N , M ) : if ( mp . get ( mat [ i ] [ j ] ) == i ) : mp . put ( mat [ i ] [ j ] , i + 1 ) if ( i == M - 1 ) : print ( mat [ i ] [ j ] + " " ) else : print ( mat [ i ] [ j ] ) if ( i == M - 1 ) : print ( mat [ i ] [ j ] ) mp . remove ( mat [ i ] [ j ] ) if ( i == M - 1 ) : print ( mat [ i ] [ j ] ) : mp . put ( mat [ i ] [ j ] , i + 1 ) if ( i == M - 1 ) : print ( mat [ i ] [ j ] + " " )

def printCommonElements ( mat ) : mp = list ( ) for j in range ( N ) : for i in range ( 1 , M ) : if mp . get ( mat [ i ] [ j ] ) != None and mp . get ( mat [ i ] [ j ] ) == i : mp . put ( mat [ i ] [ j ] , i + 1 ) if ( i == M - 1 ) : print ( mat [ i ] [ j ] + " " )

30.51
40.67
78.25
80.94
static int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }

def getTotalNumberOfSequences ( m , n ) : if m < n : return 0 if n == 0 : return 1 res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) return res

def getTotalNumberOfSequences ( m , n ) : if ( m == n ) : return 0 return getTotalNumberOfSequences ( m - 1 , n )

def getTotalNumberOfSequences ( m , n ) : if m < n : return 0 if n == 0 : return 1 return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 )

30.52
55.88
74.23
54.05
static void swapDiagonal ( int matrix [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { int temp = matrix [ i ] [ i ] ; matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ; matrix [ i ] [ N - i - 1 ] = temp ; } }

def swapDiagonal ( matrix ) : for i in range ( N ) : matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \ matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ]

def swapDiagonal ( matrix , N ) : matrix . sort ( reverse = True ) matrix . sort ( reverse = True ) for i in range ( N ) : temp = matrix [ i ] [ i ] matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] = temp matrix [ i ] [ N - i - 1 ] = temp matrix [ i ] [ N - i - 1 ] = temp for i in range ( 0 , N ) : if ( i < N ) : matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ N - i - 1 ] return matrix

def swapDiagonal ( matrix , [ ] ) : for i in range ( N ) : temp = matrix [ i ] [ i ] matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] matrix [ i ] [ N - i - 1 ] = temp

30.54
35.87
60.26
52.3
static int minSumPath ( ) { int [ ] memo = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }

def minSumPath ( A ) : memo = [ None ] * len ( A ) n = len ( A ) - 1 for i in range ( len ( A [ n ] ) ) : memo [ i ] = A [ n ] [ i ] for i in range ( len ( A ) - 2 , - 1 , - 1 ) : for j in range ( len ( A [ i ] ) ) : memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ]

def minSumPath ( A ) : memo = [ 0 for i in range ( A . length ) ] for i in range ( n ) : memo [ i ] = A [ n ] [ i ] + ( int ) min ( memo [ i ] , memo [ j + 1 ] ) return memo [ 0 ]

def minSumPath ( A ) : memo = [ INT_MAX for i in range ( A . length ) ] for n in A [ - 1 : ] : memo [ i ] = A [ n ] [ i ] for i in range ( A . length - 2 ) : for j in range ( A [ i ] . length ) : memo [ j ] = A [ i ] [ j ] + ( int ) min ( memo [ j ] , memo [ j + 1 ] ) return memo [ 0 ]

30.58
37.53
35.83
40.37
static long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; }

def exponentiation ( bas , exp ) : t = 1 while ( exp > 0 ) : if ( exp % 2 != 0 ) : t = ( t * bas ) % N bas = ( bas * bas ) % N exp = int ( exp / 2 ) return t % N

def exponentiation ( base , exp ) : t = 1L base = 1L while exp > 0 : if exp % 2 != 0 : t = ( t * base ) % N base = ( base * base ) % N exp /= 2 while exp > 0 : t = ( t * base ) % N base = ( base * base ) % N return t

def exponentiation ( base , exp ) : t = 1L while exp > 0 : if exp % 2 != 0 : t = ( t * base ) % N base = ( base * base ) % N exp /= 2 return t

30.66
34.39
42.33
53.31
static boolean checkStackPermutation ( int ip [ ] , int op [ ] , int n ) { Queue < Integer > input = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { input . add ( ip [ i ] ) ; } Queue < Integer > output = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { output . add ( op [ i ] ) ; } Stack < Integer > tempStack = new Stack < > ( ) ; while ( ! input . isEmpty ( ) ) { int ele = input . poll ( ) ; if ( ele == output . peek ( ) ) { output . poll ( ) ; while ( ! tempStack . isEmpty ( ) ) { if ( tempStack . peek ( ) == output . peek ( ) ) { tempStack . pop ( ) ; output . poll ( ) ; } else break ; } } else { tempStack . push ( ele ) ; } } return ( input . isEmpty ( ) && tempStack . isEmpty ( ) ) ; }

def checkStackPermutation ( ip , op , n ) : Input = Queue ( ) for i in range ( n ) : Input . put ( ip [ i ] ) output = Queue ( ) for i in range ( n ) : output . put ( op [ i ] ) tempStack = [ ] while ( not Input . empty ( ) ) : ele = Input . queue [ 0 ] Input . get ( ) if ( ele == output . queue [ 0 ] ) : output . get ( ) while ( len ( tempStack ) != 0 ) : if ( tempStack [ - 1 ] == output . queue [ 0 ] ) : tempStack . pop ( ) output . get ( ) else : break else : tempStack . append ( ele ) return ( Input . empty ( ) and len ( tempStack ) == 0 )

def checkStackPermutation ( ip , op , n ) : input = list ( ) output = list ( ) for i in range ( n ) : input . add ( ip [ i ] ) output . add ( op [ i ] ) tempStack = list ( ) while ( ! input . isEmpty ( ) ) : if ( ele == output . peek ( ) ) : output . poll ( ) else : tempStack . append ( ele ) return ( input . isEmpty ( ) && tempStack .

def checkStackPermutation ( ip , op , n ) : input = list ( ) for i in range ( n ) : input . append ( ip [ i ] ) output . append ( op [ i ] ) tempStack . append ( ele ) while not input . empty ( ) : ele = input . poll ( ) if ele == output . peek ( ) : output . poll ( ) while not tempStack . isEmpty ( ) : if ( tempStack . peek ( ) == output . peek ( ) ) : tempStack . pop ( ) output . poll ( ) else : break tempStack . append ( ele ) return ( input . isEmpty ( ) and tempStack . isEmpty ( ) )

30.69
25.14
63.86
50.01
static boolean findWinner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }

def findWinner ( x , y , n ) : dp = [ 0 for i in range ( n + 1 ) ] dp [ 0 ] = False dp [ 1 ] = True for i in range ( 2 , n + 1 ) : if ( i - 1 >= 0 and not dp [ i - 1 ] ) : dp [ i ] = True elif ( i - x >= 0 and not dp [ i - x ] ) : dp [ i ] = True elif ( i - y >= 0 and not dp [ i - y ] ) : dp [ i ] = True else : dp [ i ] = False return dp [ n ]

def findWinner ( x , y , n ) : dp = [ false for i in range ( 2 , n ) ] for i in range ( 2 , n ) : if ( i - 1 >= 0 and dp [ i - 1 ] == false ) : dp [ i ] = true else : dp [ i ] = false return dp [ 0 ]

def findWinner ( x , y , n ) : dp = [ False for k in range ( n ) ] dp [ 0 ] = False dp [ 1 ] = True for i in range ( 2 , n ) : if ( i - 1 >= 0 and dp [ i - 1 ] == false ) : dp [ i ] = True else : if ( i - x >= 0 and dp [ i - x ] == false ) : dp [ i ] = True else : dp [ i ] = False return dp [ n ]

30.82
33.02
36.77
34.93
static int waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; Vector < Integer > [ ] position = new Vector [ M ] ; for ( int i = 0 ; i < M ; i ++ ) position [ i ] = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) position [ str2 . charAt ( i - 1 ) - 'a' ] . add ( i ) ; int [ ] [ ] lcsl = new int [ m + 2 ] [ n + 2 ] ; int [ ] [ ] lcsr = new int [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = Math . max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = Math . max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( char d = 0 ; d < 26 ; d ++ ) { for ( int j = 0 ; j < position [ d ] . size ( ) ; j ++ ) { int p = position [ d ] . elementAt ( j ) ; if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) ways ++ ; } } } return ways ; }

def waysToIncreaseLCSBy1 ( str1 , str2 ) : m = len ( str1 ) n = len ( str2 ) position = [ [ ] for i in range ( M ) ] for i in range ( 1 , n + 1 , 1 ) : position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i ) lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] lcsr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] for i in range ( 1 , m + 1 , 1 ) : for j in range ( 1 , n + 1 , 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] else : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) for i in range ( m , 0 , - 1 ) : for j in range ( n , 0 , - 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] else : lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ways = 0 for i in range ( 0 , m + 1 , 1 ) : for C in range ( 0 , 26 , 1 ) : for j in range ( 0 , len ( position [ C ] ) , 1 ) : p = position [ C ] [ j ] if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : ways += 1 return ways

def waysToIncreaseLCSBy1 ( str1 , str2 ) : M = len ( str1 ) for i in range ( M ) : position [ i ] = new Vector < Integer > ( ) for j in range ( 1 , n ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j ] else : lcsl [ i ] [ j ] = max ( lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] = max ( lcsl [ i ] [ j ] , lcsl [ i - 1 ] [ j - 1 ] ) for i in range ( 1 , n ) : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] = max ( lcsl [ i - 1 ] [ j ] ) else : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i - 1 ] [ j ] ) lcsr [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ]

def waysToIncreaseLCSBy1 ( str1 , str2 ) : m = str1 . length n = str2 . length m = m + 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] else : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) lcsr [ i ] [ j ] = 0 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] else : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) lcsr [ i ] [ j ] = 0 for i

30.82
33.28
44.51
40.37
static void printFirstRepeating ( int arr [ ] ) { int min = - 1 ; HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { if ( set . contains ( arr [ i ] ) ) min = i ; else set . add ( arr [ i ] ) ; } if ( min != - 1 ) System . out . println ( "The first repeating element is " + arr [ min ] ) ; else System . out . println ( "There are no repeating elements" ) ; }

def printFirstRepeating ( arr , n ) : Min = - 1 myset = dict ( ) for i in range ( n - 1 , - 1 , - 1 ) : if arr [ i ] in myset . keys ( ) : Min = i else : myset [ arr [ i ] ] = 1 if ( Min != - 1 ) : print ( "Thefirstrepeatingelementis" , arr [ Min ] ) else : print ( "Therearenorepeatingelements" )

def printFirstRepeating ( arr ) : min = - 1 for i in range ( arr . length ) : if ( set . contains ( arr [ i ] ) ) : min = i elif ( set . contains ( arr [ i ] ) ) : min = i else : set . add ( arr [ i ] ) if ( min != - 1 ) : print ( "The first repeating element is " + arr [ min ] ) else : print ( "There are no repeating

def printFirstRepeating ( arr ) : min = - 1 set = list ( ) for i in range ( arr . length - 1 , - 1 , - 1 ) : if ( set [ i ] == arr [ i ] ) : min = i break if ( min != - 1 ) : print ( "The first repeating element is " + arr [ min ] ) else : print ( "There are no repeating elements" )

30.84
28.03
45.86
44.4
static void printDistance ( int mat [ ] [ ] ) { int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

def printDistance ( mat ) : global N , M ans = [ [ None ] * M for i in range ( N ) ] for i in range ( N ) : for j in range ( M ) : ans [ i ] [ j ] = 999999999999 for i in range ( N ) : for j in range ( M ) : for k in range ( N ) : for l in range ( M ) : if ( mat [ k ] [ l ] == 1 ) : ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) for i in range ( N ) : for j in range ( M ) : print ( ans [ i ] [ j ] , end = "" ) print ( )

def printDistance ( mat , N , M ) : ans = [ INT_MAX for i in range ( N , M ) ] for j in range ( 0 , N , M ) : if ( mat [ i ] [ j ] == 1 ) : ans [ i ] [ j ] = min ( ans [ i ] [ j ] , float ( 'inf' ) ) elif ( mat [ i ] [ j ] == 1 ) : ans [ i ] [ j ] = min

def printDistance ( mat ) : ans [ ] [ ] = [ INT_MAX for i in range ( N ) ] for j in range ( M ) : ans [ i ] [ j ] = float ( 'inf' ) for k in range ( N ) : for l in range ( M ) : if mat [ k ] [ l ] == 1 : ans [ i ] [ j ] = min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) )

30.89
32.49
55.06
44.17
static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }

def discreteLogarithm ( a , b , m ) : n = int ( math . sqrt ( m ) + 1 ) an = 1 for i in range ( n ) : an = ( an * a ) % m value = [ 0 ] * m cur = an for i in range ( 1 , n + 1 ) : if ( value [ cur ] == 0 ) : value [ cur ] = i cur = ( cur * an ) % m cur = b for i in range ( n + 1 ) : if ( value [ cur ] > 0 ) : ans = value [ cur ] * n - i if ( ans < m ) : return ans cur = ( cur * a ) % m return - 1

def discreteLogarithm ( a , b , m ) : n = ( int ) ( sqrt ( m + 1 ) + 1 ) for i in range ( 1 , n ) : if ( value [ cur ] == 0 ) : value [ cur ] = i an = ( an * a ) % m cur = ( cur * an ) % m return - 1

def discreteLogarithm ( a , b , m ) : an = 1 for i in range ( m ) : if value [ cur ] == 0 : value [ cur ] = i cur = ( cur * an ) % m return - 1 for i in range ( 1 , n ) : if ( value [ cur ] > 0 ) : int ans = value [ cur ] * n - i if ( ans < m ) : return ans cur = ( cur * a ) % m return - 1

30.98
22.63
35.03
26.87
static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }

def seriesSum ( n ) : i = 1 res = 0.0 sign = True while ( n > 0 ) : n = n - 1 if ( sign ) : sign = False res = res + ( i + 1 ) / ( i + 2 ) i = i + 2 else : sign = True res = res - ( i + 1 ) / ( i + 2 ) i = i + 2 return res

def seriesSum ( n ) : i = 1 sign = true res = 0.0 for n in range ( n ) : sign = ! sign res = res + ( double ) ++ i / ++ i if ( sign ) : sign = ! sign res = res - ( double ) ++ i / ++ i return res

def seriesSum ( n ) : i = 1 res = 0.0 sign = True while n > 0 : n -- if sign : sign = not sign res = res + ( float ) ++ i / ++ i else : sign = not sign res = res - ( float ) ++ i / ++ i return res

31.05
28.63
82.07
60.52
static int countWays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }

def countWays ( n ) : A = [ 0 ] * ( n + 1 ) B = [ 0 ] * ( n + 1 ) A [ 0 ] = 1 A [ 1 ] = 0 B [ 0 ] = 0 B [ 1 ] = 1 for i in range ( 2 , n + 1 ) : A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] B [ i ] = A [ i - 1 ] + B [ i - 2 ] return A [ n ]

def countWays ( n ) : A = [ 1 , 1 ] B = [ 1 , 1 ] for i in range ( 2 , n ) : A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] return A [ n ]

def countWays ( n ) : A = [ 1 for k in range ( n ) ] B = [ 0 for k in range ( n ) ] A [ 0 ] = 1 A [ 1 ] = 0 B [ 0 ] = 0 B [ 1 ] = 1 for i in range ( 2 , n ) : A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] B [ i ] = A [ i - 1 ] + B [ i - 2 ] return A [ n ]

31.12
30.84
42.59
33.07
static int firstElement ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > count_map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = 0 ; if ( count_map . get ( arr [ i ] ) != null ) { a = count_map . get ( arr [ i ] ) ; } count_map . put ( arr [ i ] , a + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . get ( arr [ i ] ) == k ) { return arr [ i ] ; } } return - 1 ; }

def firstElement ( arr , n , k ) : count_map = { } for i in range ( 0 , n ) : if ( arr [ i ] in count_map . keys ( ) ) : count_map [ arr [ i ] ] += 1 else : count_map [ arr [ i ] ] = 1 i += 1 for i in range ( 0 , n ) : if ( count_map [ arr [ i ] ] == k ) : return arr [ i ] i += 1 return - 1

def firstElement ( arr , n , k ) : count_map = new HashMap < Integer , Integer > ( ) for i in range ( 0 , n , k ) : if ( count_map [ arr [ i ] ] == k ) : return arr [ i ]

def firstElement ( arr , n , k ) : count_map = list ( ) for i in range ( n ) : if ( count_map . get ( arr [ i ] ) != None ) : a = 0 if ( count_map . get ( arr [ i ] ) != None ) : a = count_map . get ( arr [ i ] ) count_map [ arr [ i ] ] = a + 1 return arr [ i ]

31.16
28.14
34.59
38.97
public static int playGame ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i : arr ) set . add ( i ) ; return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ; }

def playGame ( arr , n ) : s = set ( ) for i in range ( n ) : s . add ( arr [ i ] ) return 1 if len ( s ) % 2 == 0 else 2

def playGame ( arr ) : set = new HashSet < Integer > ( ) for i in arr : set . add ( i ) return ( set . size ( ) % 2 == 0 ) ? 1 : 2

def playGame ( arr ) : set = set ( ) for i in arr : set . add ( i ) return ( set . size ( ) % 2 == 0 )

31.25
26.55
50.93
35.6
static void carveCross ( String str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { System . out . print ( "Not possible. Please enter " + "odd length string.\n" ) ; } else { char arr [ ] [ ] = new char [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = 'X' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " " ) ; } System . out . print ( "\n" ) ; } } }

def carveCross ( str ) : n = len ( str ) if ( n % 2 == 0 ) : print ( "Notpossible.Pleaseenter" , "oddlengthstring.\n" ) else : arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] m = n // 2 for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = 'X' for i in range ( n ) : arr [ i ] [ m ] = str [ i ] for i in range ( n ) : arr [ m ] [ i ] = str [ i ] for i in range ( n ) : for j in range ( n ) : print ( arr [ i ] [ j ] , end = "" ) print ( )

def carveCross ( str ) : n = len ( str ) max = len ( str ) for i in range ( n ) : arr = [ 'A' , 'Z' ] for j in range ( 0 , n ) : arr [ i ] [ j ] = 'X' if ( j == 0 ) : print ( arr [ i ] [ j ] + " " ) else : print ( arr [ i ] [ j ] + " " ) print ( "\n" )

def carveCross ( str ) : n = str . length ( ) for i in range ( n ) : arr [ i ] [ m ] = str [ i ] for i in range ( 0 , n ) : arr [ i ] [ m ] = str [ i ] for i in range ( 0 , n ) : arr [ m ] [ i ] = str [ i ] for i in range ( 0 , n ) : arr [ m ] [ i ] = str [ i ] for i in range ( 0 , n ) : arr [ m ] [ i ] = str [ i ] for i in range ( 0 , n ) : arr [ m ] [ i ] = str [ i ] for i in range ( 0 , n ) : for j in range ( 0 , n ) : print ( arr [ i ] [ j ] )

31.4
30.96
36.36
28.7
public static int minProduct ( int [ ] arr , int n , int k ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) pq . add ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( pq . isEmpty ( ) == false && count < k ) { ans = ans * pq . element ( ) ; pq . remove ( ) ; count ++ ; } return ans ; }

def minProduct ( arr , n , k ) : heapq . heapify ( arr ) count = 0 ans = 1 while ( arr ) and count < k : x = heapq . heappop ( arr ) ans = ans * x count = count + 1 return ans

def minProduct ( arr , n , k ) : pq = new PriorityQueue < Integer > ( ) for i in range ( 0 , n , k ) : pq . add ( arr [ i ] ) count = 0 ans = 1 while pq . isEmpty ( ) == false and count < k : ans = ans * pq . element ( ) pq . remove ( ) count ++ return ans

def minProduct ( arr , n , k ) : pq = list ( ) count = 0 for k in range ( n ) : ans = 1 while pq . isEmpty ( ) == False and count < k : ans = ans * pq . element ( ) pq . remove ( ) count ++ return ans

31.43
28.77
30.13
26.5
static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }

def findTrailingZeros ( n ) : count = 0 i = 5 while ( n / i >= 1 ) : count += int ( n / i ) i *= 5 return int ( count )

def findTrailingZeros ( n ) : count = 0 for i in range ( 5 , n ) : count += n / i

def findTrailingZeros ( n ) : count = 0 for i in range ( 5 ) : count += n [ i ] return count

31.45
39.07
56.74
62.65
static void printLevels ( Vector < Vector < Integer >> graph , int V , int x ) { int level [ ] = new int [ V ] ; boolean marked [ ] = new boolean [ V ] ; Queue < Integer > que = new LinkedList < Integer > ( ) ; que . add ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( que . size ( ) > 0 ) { x = que . peek ( ) ; que . remove ( ) ; for ( int i = 0 ; i < graph . get ( x ) . size ( ) ; i ++ ) { int b = graph . get ( x ) . get ( i ) ; if ( ! marked [ b ] ) { que . add ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } System . out . println ( "Nodes" + " " + "Level" ) ; for ( int i = 0 ; i < V ; i ++ ) System . out . println ( " " + i + " --> " + level [ i ] ) ; }

def printLevels ( graph , V , x ) : level = [ None ] * V marked = [ False ] * V que = queue . Queue ( ) que . put ( x ) level [ x ] = 0 marked [ x ] = True while ( not que . empty ( ) ) : x = que . get ( ) for i in range ( len ( graph [ x ] ) ) : b = graph [ x ] [ i ] if ( not marked [ b ] ) : que . put ( b ) level [ b ] = level [ x ] + 1 marked [ b ] = True print ( "Nodes" , "" , "Level" ) for i in range ( V ) : print ( "" , i , "-->" , level [ i ] )

def printLevels ( graph , V , x ) : level = [ 0 for x in range ( V ) ] marked = set ( ) for x in range ( V ) : if ( marked [ x ] ) : que . add ( x ) level [ x ] = level [ x ] + 1 marked [ x ] = true printLevels ( graph , V , x ) que . clear ( ) x = que . peek ( ) if ( marked [ x ] ) : que .

def printLevels ( graph , V , x ) : level = [ 0 for k in range ( V ) ] marked = [ False for k in range ( V ) ] que = list ( ) for x in range ( V ) : que . add ( x ) level [ x ] = level [ x ] + 1 marked [ x ] = True for i in range ( 0 , V ) : b = graph [ x ] [ i ] if not marked [ b ] : que . add ( b ) level [ b ] = level [ x ] + 1 marked [ b ] = True print ( "Nodes" + " " + "Level" ) for i in range ( 0 , V ) : print ( " " + i + " --> " + level [ i ] )

31.51
42.08
39.38
42.67
static Boolean subArrayExists ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 || sum == 0 || hM . get ( sum ) != null ) return true ; hM . put ( sum , i ) ; } return false ; }

def subArrayExists ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : sum += arr [ i ] if sum == 0 or sum in s : return True s . add ( sum ) return False

def subArrayExists ( arr ) : hM = defaultdict ( int ) for i in range ( arr . length ) : sum = 0 for i in range ( 0 , arr . length ) : sum += arr [ i ] if ( sum == 0 || hM . get ( sum ) != null ) : return true hM . put ( sum , i ) return false

def subArrayExists ( arr ) : hM = { } sum = 0 for i in range ( len ( arr ) ) : sum += arr [ i ] if ( arr [ i ] == 0 or sum == 0 or hM . get ( sum ) != null ) : return True hM . put ( sum , i ) return False

31.63
38.49
47.81
46.35
static void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } }

def Print ( n , k ) : rem = 1 for i in range ( 0 , k ) : print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = "" ) rem = ( 10 * rem ) % n

def print ( n , k ) : rem = 1 for i in range ( k ) : print ( rem / n ) rem = ( 10 * rem ) % n print ( rem ) rem = ( 10 * rem ) % n print ( rem ) k = 0 for i in range ( k ) : print ( n , k ) rem = ( 10 * rem ) % n print ( rem ) rem = ( 10 * rem ) % n print ( rem ) k = 1 for i in range

def print ( n , k ) : rem = 1 for i in range ( k ) : print ( n , k ) rem = ( 10 * rem ) % n

31.86
55.94
38.11
44.09
static void constructTree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { System . out . println ( "1 2" ) ; return ; } System . out . println ( "-1" ) ; return ; } if ( d > 2 * h ) { System . out . println ( "-1" ) ; return ; } for ( int i = 1 ; i <= h ; i ++ ) System . out . println ( i + " " + ( i + 1 ) ) ; if ( d > h ) { System . out . println ( "1" + " " + ( h + 2 ) ) ; for ( int i = h + 2 ; i <= d ; i ++ ) { System . out . println ( i + " " + ( i + 1 ) ) ; } } for ( int i = d + 1 ; i < n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; System . out . println ( k + " " + ( i + 1 ) ) ; } }

def constructTree ( n , d , h ) : if d == 1 : if n == 2 and h == 1 : print ( "12" ) return 0 print ( "-1" ) return 0 if d > 2 * h : print ( "-1" ) return 0 for i in range ( 1 , h + 1 ) : print ( i , "" , i + 1 ) if d > h : print ( 1 , "" , h + 2 ) for i in range ( h + 2 , d + 1 ) : print ( i , "" , i + 1 ) for i in range ( d + 1 , n ) : k = 1 if d == h : k = 2 print ( k , "" , i + 1 )

def constructTree ( n , d , h ) : if ( n == 2 && h == 1 ) : print ( "1 2" ) return if ( d == 1 ) : print ( "1 2" ) return if ( d > 2 * h ) : print ( "1" + " " + ( h + 1 ) ) return for i in range ( 1 , n , h ) : print ( i + " " + ( i + 1 ) ) if ( d == h ) : k = 2 if ( d == h ) : print ( k + " " + ( i + 1 ) ) return if ( d == h ) : print ( k + " " + ( i + 1 ) ) return if ( d == h ) : print ( "1" + " " + ( h + 2 ) ) return for i in range ( d + 1 , n ) : print ( i + " " + ( i + 1 ) ) return if ( d == h ) : k = 3 if ( d == h ) : print ( k + " " + ( i + 1 ) ) return

def constructTree ( n , d , h ) : if d == 2 and h == 1 : print ( "1 2" ) return if d > 2 * h : print ( "-1" ) return if d > 2 * h : print ( "-1" ) return if d > h : print ( "1" + " " + ( h + 2 ) ) for i in range ( h + 2 , d ) : print ( i + " " + ( i + 1 ) )

31.86
30.7
65.56
70.49
static int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }

def count ( a , b , m , n ) : if ( ( m == 0 and n == 0 ) or n == 0 ) : return 1 if ( m == 0 ) : return 0 if ( a [ m - 1 ] == b [ n - 1 ] ) : return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) else : return count ( a , b , m - 1 , n )

def count ( a , b , m , n ) : if m == 0 : return 1 if n == 0 : return count ( a , b , m - 1 , n ) else : return count ( a , b , m - 1 , n )

def count ( a , b , m , n ) : if m == 0 : return 1 if n == 0 : return 0 if a [ m - 1 ] == b [ n - 1 ] : return count ( a , b , m - 1 , n ) + count ( a , b , m - 1 , n ) else : return count ( a , b , m - 1 , n )

31.88
25.52
64.02
50.58
static void maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } System . out . println ( "Maximum contiguous sum is " + max_so_far ) ; System . out . println ( "Starting index " + start ) ; System . out . println ( "Ending index " + end ) ; }

def maxSubArraySum ( a , size ) : max_so_far = - maxsize - 1 max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( 0 , size ) : max_ending_here += a [ i ] if max_so_far < max_ending_here : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 print ( "Maximumcontiguoussumis%d" % ( max_so_far ) ) print ( "StartingIndex%d" % ( start ) ) print ( "EndingIndex%d" % ( end ) )

def maxSubArraySum ( a , size ) : max_so_far = float ( 'inf' ) for i in range ( size ) : max_ending_here = float ( 'inf' ) for i in range ( size ) : max_so_far = max_ending_here + a [ i ] if ( max_so_far < 0 ) : max_ending_here = 0 s = i + 1 if ( max_ending_here <

def maxSubArraySum ( a , size ) : max_so_far = float ( 'inf' ) max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( size ) : max_ending_here += a [ i ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 print ( "Maximum contiguous sum is " + max_so_far )

31.91
39.63
74.48
67.1
static int findSum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }

def findSum ( n ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = abs ( i - j ) sum = 0 for i in range ( n ) : for j in range ( n ) : sum += arr [ i ] [ j ] return sum

def findSum ( n ) : arr = [ 0 for i in range ( n ) ] for j in range ( 0 , n ) : arr [ i ] [ j ] = abs ( i - j ) return sum

def findSum ( n ) : arr = [ 0 for i in range ( n ) ] for j in range ( n ) : arr [ i ] [ j ] = abs ( i - j ) sum = 0 for i in range ( 0 , n ) : for j in range ( n ) : sum += arr [ i ] [ j ] return sum

31.97
21.23
78.52
71.86
static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }

def isPrime ( n , i = 2 ) : if ( n <= 2 ) : return True if ( n == 2 ) else False if ( n % i == 0 ) : return False if ( i * i > n ) : return true return isPrime ( n , i + 1 )

def isPrime ( n , i ) : if ( n == 2 ) : return ( n == 2 ) : return ( n == 2 ) : return ( n == 2 ) : return ( n == 2 )

def isPrime ( n , i ) : if ( n <= 2 ) : return ( n == 2 ) ? True : false if ( n % i == 0 ) : return False if ( i * i > n ) : return True return isPrime ( n , i + 1 )

31.97
31.83
61.31
52.93
static int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }

def findLargestd ( S , n ) : found = False S . sort ( ) for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( 0 , n ) : if ( i == j ) : continue for k in range ( j + 1 , n ) : if ( i == k ) : continue for l in range ( k + 1 , n ) : if ( i == l ) : continue if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = True return S [ i ] if ( found == False ) : return - 1

def findLargestd ( S , n ) : found = false for i in range ( n ) : for j in range ( 0 , n - 1 , - 1 ) : if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = true return S [ i ]

def findLargestd ( S , n ) : found = False for i in range ( n ) : for j in range ( 0 , n , - 1 ) : if ( i == j ) : continue for k in range ( j + 1 , n ) : if ( i == k ) : continue if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = True return S [ i ]

32.0
43.85
51.4
47.51
static int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == ' ' || str . charAt ( i ) == '\n' || str . charAt ( i ) == '\t' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }

def countWords ( string ) : state = OUT wc = 0 for i in range ( len ( string ) ) : if ( string [ i ] == '' or string [ i ] == '\n' or string [ i ] == '\t' ) : state = OUT elif state == OUT : state = IN wc += 1 return wc

def countWords ( str ) : state = OUT wc = 0 for i in range ( len ( str ) ) : if ( str [ i ] == ' ' ) : state = IN else : state = OUT wc += 1 i = 0 while i < len ( str ) : if ( state == IN ) : state = OUT else : state = IN wc = 0 for i in range ( i + 1 , len ( str ) ) : if ( state == OUT ) : state =

def countWords ( str ) : state = OUT wc = 0 i = 0 while i < str . length ( ) : if ( str [ i ] == ' ' or str [ i ] == '\n' or str [ i ] == '\t' ) : state = OUT elif ( state == IN ) : state = IN wc += 1 i += 1 return wc

32.09
32.49
48.71
40.52
static void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }

def printRotatedString ( string ) : n = len ( string ) temp = string + string for i in range ( n ) : for j in range ( n ) : print ( temp [ i + j ] , end = "" ) print ( )

def printRotatedString ( str ) : n = str . length ( ) for i in range ( 0 , n ) : print ( sb [ i ] ) for j in range ( 0 , n ) : print ( sb [ i + j ] ) print ( ) if ( j != n ) : print ( sb [ i + j ] )

def printRotatedString ( str ) : n = str . length sb = new StringBuffer ( str ) for i in range ( n ) : for j in range ( 0 , n ) : print ( sb [ i + j ] )

32.27
41.12
51.62
61.83
static double minHeight ( double base , double area ) { double d = ( 2 * area ) / base ; return Math . ceil ( d ) ; }

def minHeight ( area , base ) : return math . ceil ( ( 2 * area ) / base )

def minHeight ( base , area ) : d = ( base * area ) / base return d

def minHeight ( base , area ) : d = ( 2 * area ) / base return math . ceil ( d )

32.38
32.36
49.92
39.3
static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + " " ) ; } }

def printEqualModNumbers ( arr , n ) : arr . sort ( ) d = arr [ n - 1 ] - arr [ 0 ] v = [ ] i = 1 while ( i * i <= d ) : if ( d % i == 0 ) : v . append ( i ) if ( i != d / i ) : v . append ( d / i ) i += 1 for i in range ( len ( v ) ) : temp = arr [ 0 ] % v [ i ] j = 1 while ( j < n ) : if ( arr [ j ] % v [ i ] != temp ) : break j += 1 if ( j == n ) : print ( v [ i ] , end = "" )

def printEqualModNumbers ( arr , n ) : arr . sort ( reverse = True ) v = list ( ) for i in range ( 1 , n ) : if ( arr [ i ] % v . get ( i ) == 0 ) : v . add ( i ) if ( i != d / i ) : v . add ( d / i ) if ( i != d / i ) : v . add ( i ) if ( j != n ) : print (

def printEqualModNumbers ( arr , n ) : d = arr [ n - 1 ] - arr [ 0 ] v = list ( ) for i in range ( 1 , n ) : if ( d % i == 0 ) : v . add ( i ) if ( i != d // i ) : v . add ( d // i ) for j in range ( 1 , n ) : if ( arr [ j ] % v [ i ] != temp ) : break if ( j == n ) : print ( v . get ( i ) )

32.41
37.46
82.2
67.74
public static int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }

def maxCost ( mat , N ) : dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] for i in range ( 1 , N ) : for j in range ( 1 , min ( i + 1 , N ) ) : dp [ i ] [ j ] = mat [ i ] [ j ] + \ max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) result = 0 for i in range ( N ) : if ( result < dp [ N - 1 ] [ i ] ) : result = dp [ N - 1 ] [ i ] return result

def maxCost ( mat , N ) : dp = [ 0 for k in range ( N ) ] dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] dp [ 0 ] [ 1 ] = mat [ 0 ] [ 0 ] for i in range ( 1 , N ) : if ( dp [ i ] [ 0 ] < dp [ N - 1 ] [ i ] ) : result = dp [ N - 1 ] [ i ] return result

def maxCost ( mat , N ) : dp = [ 0 for i in range ( N ) ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = mat [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] for i in range ( 1 , i + 1 ) : dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) result = 0 for i in range ( 0 , N ) : if result < dp [ N - 1 ] [ i ] : result = dp [ N - 1 ] [ i ] return result

32.44
50.57
13.22
42.15
static boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }

def checkJumbled ( num ) : if ( num // 10 == 0 ) : return True while ( num != 0 ) : if ( num // 10 == 0 ) : return True digit1 = num % 10 digit2 = ( num // 10 ) % 10 if ( abs ( digit2 - digit1 ) > 1 ) : return False num = num // 10 return True

def checkJumbled ( num ) : if ( num == 0 ) : return true num = num / 10 while num != 0 : if ( num / 10 == 0 ) : return true num = num / 10 while num != 0 : if ( num / 10 == 0 ) : return true num = num / 10 while num != 0 : if ( num / 10 == 0 ) : return true num = num / 10

def checkJumbled ( num ) : if num == 0 : return True while num != 0 : if num / 10 == 0 : return True if num / 10 == 0 : return True if num / 10 == 0 : return True if num / 10 == 0 : return True if num / 10 == 0 : return True if num / 10 == 0 : return True while num != 0 : if num / 10 == 0 : if num / 10 == 0 : return True if num / 10 == 0 : return True if num / 10 == 0 : return True if num / 10 == 0 : return True return False

32.5
29.51
31.41
32.87
static int longestCommonSum ( int n ) { int maxLen = 0 ; int preSum1 = 0 , preSum2 = 0 ; int diff [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < diff . length ; i ++ ) { diff [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { preSum1 += arr1 [ i ] ; preSum2 += arr2 [ i ] ; int curr_diff = preSum1 - preSum2 ; int diffIndex = n + curr_diff ; if ( curr_diff == 0 ) maxLen = i + 1 ; else if ( diff [ diffIndex ] == - 1 ) diff [ diffIndex ] = i ; else { int len = i - diff [ diffIndex ] ; if ( len > maxLen ) maxLen = len ; } } return maxLen ; }

def longestCommonSum ( arr1 , arr2 , n ) : maxLen = 0 presum1 = presum2 = 0 diff = { } for i in range ( n ) : presum1 += arr1 [ i ] presum2 += arr2 [ i ] curr_diff = presum1 - presum2 if curr_diff == 0 : maxLen = i + 1 elif curr_diff not in diff : diff [ curr_diff ] = i else : length = i - diff [ curr_diff ] maxLen = max ( maxLen , length ) return maxLen

def longestCommonSum ( n ) : maxLen = 0 preSum1 = 0 preSum2 = 0 diff = [ 0 for i in range ( 2 * n + 1 ) ] for i in range ( n ) : preSum1 += arr1 [ i ] preSum2 += arr2 [ i ] diff [ i ] = - 1 if ( curr_diff == 0 ) : maxLen = i + 1 else : diff [ diffIndex ] = i if ( diff [ diffIndex ] == - 1 ) : diff [ diffIndex ] = len > maxLen ) : maxLen = len return maxLen

def longestCommonSum ( n ) : maxLen = 0 preSum1 = 0 preSum2 = 0 diff = [ - 1 for i in range ( 2 * n + 1 ) ] for i in range ( n ) : diff [ i ] = - 1 for i in range ( n ) : preSum1 += arr1 [ i ] preSum2 += arr2 [ i ] curr_diff = preSum1 - preSum2 diffIndex = n + curr_diff if ( curr_diff == 0 ) : maxLen = i + 1 else : if ( diff [ diffIndex ] == - 1 ) : diff [ diffIndex ] = i else : len = i - diff [ diffIndex ] if len > maxLen : maxLen = len return maxLen

32.56
36.88
41.04
42.31
static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }

def findS ( s ) : _sum = 0 n = 1 while ( _sum < s ) : _sum += n * n * n n += 1 n -= 1 if _sum == s : return n return - 1

def findS ( s ) : sum = 0 for n in range ( 1 , s ) : sum += n * n * n if ( sum == s ) : return n

def findS ( s ) : sum = 0 for n in range ( 1 , len ( s ) ) : sum += n * n * n if ( sum == s ) : return n return - 1

32.58
41.29
34.35
37.74
static int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - 'a' ] ++ ; } if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }

def stringReduction ( str ) : n = len ( str ) count = [ 0 ] * 3 for i in range ( n ) : count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : return n if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : return 2 return 1

def stringReduction ( str ) : n = len ( str ) count = [ 0 for i in range ( n ) ] for i in range ( n ) : count [ str [ i ] - 'a' ] += 1 if ( count [ 0 ] == n || count [ 1 ] == n ) : return n

def stringReduction ( str ) : n = str . length count = [ 0 for k in range ( 3 ) ] for i in range ( n ) : count [ str [ i ] - 'a' ] += 1 if count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n : return n return 1

32.66
30.57
49.23
38.42
public static void longestSubsequence ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; int [ ] dp = new int [ n ] ; int maximum = Integer . MIN_VALUE ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] - 1 ) != null ) { int lastIndex = mp . get ( a [ i ] - 1 ) - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else dp [ i ] = 1 ; mp . put ( a [ i ] , i + 1 ) ; if ( maximum < dp [ i ] ) { maximum = dp [ i ] ; index = i ; } } for ( int curr = a [ index ] - maximum + 1 ; curr <= a [ index ] ; curr ++ ) System . out . print ( curr + " " ) ; }

def longestSubsequence ( a , n ) : mp = { i : 0 for i in range ( 13 ) } dp = [ 0 for i in range ( n ) ] maximum = - sys . maxsize - 1 index = - 1 for i in range ( n ) : if ( ( a [ i ] - 1 ) in mp ) : lastIndex = mp [ a [ i ] - 1 ] - 1 dp [ i ] = 1 + dp [ lastIndex ] else : dp [ i ] = 1 mp [ a [ i ] ] = i + 1 if ( maximum < dp [ i ] ) : maximum = dp [ i ] index = i for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) : print ( curr , end = "" )

def longestSubsequence ( a , n ) : mp = new HashMap < Integer , Integer > ( ) dp = [ INT_MAX for i in range ( n ) ] for i in range ( 0 , n ) : if ( mp . get ( a [ i ] - 1 ) != null ) : dp [ i ] = 1 + dp [ lastIndex ] index = i elif ( maximum < dp [ i ] ) : maximum = dp [ i ] index = i else : for curr in

def longestSubsequence ( a , n ) : mp = [ INT_MAX for i in range ( n ) ] dp = [ INT_MAX for i in range ( n ) ] maximum = INT_MAX for i in range ( n ) : if mp . get ( a [ i ] - 1 ) != None : lastIndex = mp . get ( a [ i ] - 1 ) - 1 dp [ i ] = 1 + dp [ lastIndex ] else : dp [ i ] = 1 mp . put ( a [ i ] , i + 1 ) if maximum < dp [ i ] : maximum = dp [ i ] index = i

32.71
37.51
100.0
100.0
static double areaOfInscribedCircle ( float a ) { return ( PI / 4 ) * a * a ; }

def areaOfInscribedCircle ( a ) : return ( PI / 4 ) * a * a

def areaOfInscribedCircle ( a ) : return a

def areaOfInscribedCircle ( a ) : return ( PI / 4 ) * a * a

32.81
39.05
53.4
33.99
static void shufleArray ( int a [ ] , int f , int l ) { if ( l > f ) return ; if ( l - f == 1 ) return ; int mid = ( f + l ) / 2 ; int temp = mid + 1 ; int mmid = ( f + mid ) / 2 ; for ( int i = mmid + 1 ; i <= mid ; i ++ ) { int temp1 = a [ i ] ; a [ i ] = a [ temp ] ; a [ temp ++ ] = temp1 ; } shufleArray ( a , f , mid ) ; shufleArray ( a , mid + 1 , l ) ; }

def shufleArray ( a , f , l ) : if ( l > f ) : return if ( l - f == 1 ) : return mid = int ( ( f + l ) / 2 ) temp = mid + 1 mmid = int ( ( f + mid ) / 2 ) for i in range ( mmid + 1 , mid + 1 ) : ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) temp += 1 shufleArray ( a , f , mid ) shufleArray ( a , mid + 1 , l )

def shufleArray ( a , f , l ) : if ( l <= f ) : return shufleArray ( a , f , mid ) : shufleArray ( a , mid + 1 , l ) : shufleArray ( a , f , mid + 1 ) : shufleArray ( a , mid + 1 , l ) : shufleArray ( a , mmid + 1 , l ) : shufleArray ( a , f

def shufleArray ( a , f , l ) : if l > f : return mid = ( f + l ) / 2 temp = mid + 1 mmid = ( f + mid ) // 2 for i in range ( mmid + 1 , mid ) : temp1 = a [ i ] a [ i ] = a [ temp ] a [ temp ++ ] = temp1 shufleArray ( a , f , mid ) shufleArray ( a , mid + 1 , l )

32.81
25.85
39.23
29.23
static void printSpiral ( int [ ] [ ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) System . out . print ( mat [ low_row ] [ i ] + " " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) System . out . print ( mat [ i ] [ high_column ] + " " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) System . out . print ( mat [ high_row ] [ i ] + " " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) System . out . print ( mat [ i ] [ low_column ] + " " ) ; low_column -= 1 ; } System . out . println ( ) ; }

def printSpiral ( mat , r , c ) : a = 0 b = 2 low_row = 0 if ( 0 > a ) else a low_column = 0 if ( 0 > b ) else b - 1 high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 while ( ( low_row > 0 - r and low_column > 0 - c ) ) : i = low_column + 1 while ( i <= high_column and i < c and low_row >= 0 ) : print ( mat [ low_row ] [ i ] , end = "" ) i += 1 low_row -= 1 i = low_row + 2 while ( i <= high_row and i < r and high_column < c ) : print ( mat [ i ] [ high_column ] , end = "" ) i += 1 high_column += 1 i = high_column - 2 while ( i >= low_column and i >= 0 and high_row < r ) : print ( mat [ high_row ] [ i ] , end = "" ) i -= 1 high_row += 1 i = high_row - 2 while ( i > low_row and i >= 0 and low_column >= 0 ) : print ( mat [ i ] [ low_column ] , end = "" ) i -= 1 low_column -= 1 print ( )

def printSpiral ( mat , r , c ) : a = 2 b = 0 low_row = 0 low_column = 0 high_row = 0 high_column = 0 while ( low_row > 0 - r and low_column > 0 - c ) : for i in range ( low_row > 0 - r , high_column > 0 - c ) : print ( mat [ low_row ] [ i ] + " " ) low_row -= 1 for i in range ( low_row += 1 , high_column = 2 while i <= high_row and i < r and high_column >= 0 : print ( mat [ low_row ] [ i ] + " " ) high_column -= 1 for i in range ( low_row + 1 , high_row + 2 , range ( low_row + 1 , high_column ) : print ( mat [ i ] [ high_column ] + " " ) high_row += 1 for i in range ( high_row - 2 ) : print ( mat [ high_row - 2 ) : print ( mat [ high_row ] [ i ] [ high_column ] [ i ] + " " ) high_row += 1

def printSpiral ( mat , r , c ) : low_row = 0 low_column = 0 high_row = ( ( a + 1 ) >= r ) ? 0 : b - 1 low_column = ( ( a + 1 ) >= c ) ? r - 1 : a + 1 high_row = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 while ( low_row > 0 - r and low_column > 0 - c ) : for i in range ( low_column + 1 , high_column + 1 ) : print ( mat [ low_row ] [ i ] ) low_row -= 1 for i in range ( low_column + 1 , high_column + 1 ) : print ( mat [ i ] [ high_column ] ) high_column += 1 for i in range ( high_column - 2 , i >= low_column and i >= 0 and high_row < r ; -- i ) : print ( mat [ high_row ] [ i ] ) high_row += 1 for i in range ( high_column - 2 , i

32.87
47.48
49.47
48.53
static int getPairsCount ( int n , int sum ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , 0 ) ; hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; } int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . get ( sum - arr [ i ] ) != null ) twice_count += hm . get ( sum - arr [ i ] ) ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; }

def getPairsCount ( arr , n , sum ) : m = [ 0 ] * 1000 for i in range ( 0 , n ) : m [ arr [ i ] ] m [ arr [ i ] ] += 1 twice_count = 0 for i in range ( 0 , n ) : twice_count += m [ sum - arr [ i ] ] if ( sum - arr [ i ] == arr [ i ] ) : twice_count -= 1 return int ( twice_count / 2 )

def getPairsCount ( n , arr ) : hm = defaultdict ( int ) for i in range ( n ) : if ( hm . containsKey ( arr [ i ] ) ) : hm . put ( arr [ i ] , 0 ) hm . put ( arr [ i ] , 1 ) for i in range ( n ) : if ( hm [ sum - arr [ i ] ] != null ) : twice_count += hm [ sum - arr [ i ] ] if ( sum - arr [ i ] == arr [ i ] ) twice_count += 1 else : twice_count += 1 if ( sum - arr [ i ] == arr [ i ] ) : twice_count -= 1 if ( sum - arr [ i ] == arr [ i ] ) : twice_count -= 1 return twice_count

def getPairsCount ( n , sum ) : hm = list ( ) for i in range ( n ) : if not hm . containsKey ( arr [ i ] ) : hm [ arr [ i ] ] = 0 hm [ arr [ i ] ] += 1 hm [ arr [ i ] ] += 1 twice_count = 0 for i in range ( n ) : if hm [ sum - arr [ i ] ] != None : twice_count += hm [ sum - arr [ i ] ] if ( sum - arr [ i ] == arr [ i ] ) twice_count -- return twice_count

32.9
35.08
14.91
24.73
static int findGreatest ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ; } } Arrays . sort ( arr ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m . get ( result ) == null || m . get ( result ) > 0 ) { return arr [ i ] ; } else if ( result == arr [ j ] && m . get ( result ) > 1 ) { return arr [ i ] ; } } } } return - 1 ; }

def findGreatest ( arr , n ) : m = dict ( ) for i in arr : m [ i ] = m . get ( i , 0 ) + 1 arr = sorted ( arr ) for i in range ( n - 1 , 0 , - 1 ) : j = 0 while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : if ( arr [ i ] % arr [ j ] == 0 ) : result = arr [ i ] // arr [ j ] if ( result != arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 0 ) : return arr [ i ] elif ( result == arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 1 ) : return arr [ i ] j += 1 return - 1

def findGreatest ( arr , n ) : m = defaultdict ( int ) for i in range ( n ) : if ( arr [ i ] in m ) : return arr [ i ] if ( m [ arr [ i ] ] != 1 ) : return arr [ i ] if ( arr [ i ] % arr [ j ] == 0 ) : return arr [ i ] if ( result != arr [ j ] and m . get ( result ) == null : return arr [ i ] else : return arr [ i ]

def findGreatest ( arr , n ) : m = new HashMap ( ) for i in range ( n ) : if ( m . containsKey ( arr [ i ] ) ) : m [ arr [ i ] ] = m [ arr [ i ] ] + 1 else : m [ arr [ i ] ] = m [ arr [ i ] ] return arr [ i ]

32.96
34.39
44.51
43.44
public static void amendSentence ( String sstr ) { char [ ] str = sstr . toCharArray ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) System . out . print ( " " ) ; System . out . print ( str [ i ] ) ; } else System . out . print ( str [ i ] ) ; } }

def amendSentence ( string ) : string = list ( string ) for i in range ( len ( string ) ) : if string [ i ] >= 'A' and string [ i ] <= 'Z' : string [ i ] = chr ( ord ( string [ i ] ) + 32 ) if i != 0 : print ( "" , end = "" ) print ( string [ i ] , end = "" ) else : print ( string [ i ] , end = "" )

def amendSentence ( sstr ) : str = [ sstr for i in range ( len ( sstr ) ) ] for i in range ( len ( str ) ) : if ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) : str [ i ] = ( char ) ( str [ i ] - 32 ) else : str [ i ] = ( char ) ( str [ i ] + 32 ) if ( i != 0 ) : print ( str [ i ] )

def amendSentence ( sstr ) : str = sstr . toCharArray ( ) for i in range ( len ( str ) ) : if str [ i ] >= 'A' and str [ i ] <= 'Z' : str [ i ] = ( char ) ( str [ i ] + 32 ) if i != 0 : print ( " " ) print ( str [ i ] ) else : print ( str [ i ] )

32.97
34.08
47.25
35.22
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( "Sum found between indexes " + i + " and " + p ) ; return 1 ; } if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( "No subarray found" ) ; return 0 ; }

def subArraySum ( arr , n , sum ) : for i in range ( n ) : curr_sum = arr [ i ] j = i + 1 while j <= n : if curr_sum == sum : print ( "Sumfoundbetween" ) print ( "indexes%dand%d" % ( i , j - 1 ) ) return 1 if curr_sum > sum or j == n : break curr_sum = curr_sum + arr [ j ] j += 1 print ( "Nosubarrayfound" ) return 0

def subArraySum ( arr , n , sum ) : curr_sum = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( curr_sum == sum ) : p = j - 1 curr_sum = curr_sum + arr [ j ] if ( curr_sum > sum || j == n ) : break curr_sum = curr_sum + arr [ j ] if ( curr_sum < sum ) : break curr_sum = curr_sum if ( curr_sum > sum ) : break curr_sum = curr_sum + arr [ j ] if ( curr_sum > sum || j == n ) : break return 1

def subArraySum ( arr , n , sum ) : curr_sum = arr [ i ] for j in range ( i + 1 , n ) : if ( curr_sum == sum ) : p = j - 1 if ( curr_sum > sum or j == n ) : break curr_sum = curr_sum + arr [ j ] if ( curr_sum > sum or j == n ) : break curr_sum = curr_sum + arr [ j ] return 1

33.1
36.35
85.03
69.97
static int maxProfit ( int price [ ] , int n ) { int profit [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) profit [ i ] = 0 ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; return result ; }

def maxProfit ( price , n ) : profit = [ 0 ] * n max_price = price [ n - 1 ] for i in range ( n - 2 , 0 , - 1 ) : if price [ i ] > max_price : max_price = price [ i ] profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) min_price = price [ 0 ] for i in range ( 1 , n ) : if price [ i ] < min_price : min_price = price [ i ] profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) result = profit [ n - 1 ] return result

def maxProfit ( price , n ) : profit = [ 0 for i in range ( n ) ] for i in range ( n ) : if ( price [ i ] > max_price ) max_price = price [ i ] profit [ i ] = max ( profit [ i + 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) return result

def maxProfit ( price , n ) : profit = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( price [ i ] > max_price ) : max_price = price [ i ] profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) min_price = price [ 0 ] for i in range ( 1 , n ) : if ( price [ i ] < min_price ) : min_price = price [ i ] profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) result = profit [ n - 1 ] return result

33.15
33.7
32.36
42.72
static int mostFrequent ( int arr [ ] , int n ) { Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . containsKey ( key ) ) { int freq = hp . get ( key ) ; freq ++ ; hp . put ( key , freq ) ; } else { hp . put ( key , 1 ) ; } } int max_count = 0 , res = - 1 ; for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) { if ( max_count < val . getValue ( ) ) { res = val . getKey ( ) ; max_count = val . getValue ( ) ; } } return res ; }

def mostFrequent ( arr , n ) : Hash = dict ( ) for i in range ( n ) : if arr [ i ] in Hash . keys ( ) : Hash [ arr [ i ] ] += 1 else : Hash [ arr [ i ] ] = 1 max_count = 0 res = - 1 for i in Hash : if ( max_count < Hash [ i ] ) : res = i max_count = Hash [ i ] return res

def mostFrequent ( arr , n ) : hp = defaultdict ( int ) for i in range ( n ) : key = arr [ i ] if ( hp . containsKey ( key ) ) : freq = hp [ key ] if ( freq < 1 ) : hp . put ( key , freq ) else : hp [ key ] = 1 res = - 1 max_count = 0 for val in hp . entrySet ( ) : if ( max_count < val . getValue ( ) ) : res = val .

def mostFrequent ( arr , n ) : hp = list ( ) for i in range ( n ) : key = arr [ i ] if hp . containsKey ( key ) : freq = hp [ key ] freq += 1 hp . put ( key , freq ) else : hp . put ( key , 1 ) max_count = 0 res = - 1 for entry in hp . entrySet ( ) : if max_count < val . getValue ( ) : res = val . getKey ( ) max_count = val . getValue ( ) return res

33.18
28.97
22.79
25.77
static String nextGreater ( String num ) { int l = num . length ( ) ; int i ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '0' ) { num = num . substring ( 0 , i ) + '1' + num . substring ( i + 1 ) ; break ; } else { num = num . substring ( 0 , i ) + '0' + num . substring ( i + 1 ) ; } } if ( i < 0 ) { num = "1" + num ; } return num ; }

def nextGreater ( num1 ) : l = len ( num1 ) num = list ( num1 ) i = l - 1 while ( i >= 0 ) : if ( num [ i ] == '0' ) : num [ i ] = '1' break else : num [ i ] = '0' i -= 1 num1 = '' . join ( num ) if ( i < 0 ) : num1 = '1' + num1 return num1

def nextGreater ( num ) : l = num . length ( ) for i in range ( l - 2 , - 1 , - 1 ) : if ( num [ i ] == '1' ) : num = "1" + num break if ( num [ i ] == '0' ) : num = "0" + num break if ( num [ i ] == '1' ) : num = "1" + num break return num

def nextGreater ( num ) : l = num . length ( ) for i in range ( l ) : if num [ i ] == '0' : num = num [ 0 : i ] + '1' + num [ i + 1 ] break else : num = num [ 0 : i ] + '0' + num [ i + 1 ] return num

33.21
54.68
80.44
67.7
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }

def binarySearch ( arr , l , r , x ) : if r >= l : mid = l + ( r - l ) // 2 if arr [ mid ] == x : return mid elif arr [ mid ] > x : return binarySearch ( arr , l , mid - 1 , x ) else : return binarySearch ( arr , mid + 1 , r , x ) else : return - 1

def binarySearch ( arr , l , r , x ) : if ( r >= l ) : mid = l + ( r - l ) // 2 if arr [ mid ] == x : return mid

def binarySearch ( arr , l , r , x ) : if r >= l : mid = l + ( r - l ) / 2 if arr [ mid ] == x : return mid if ( arr [ mid ] > x ) : return binarySearch ( arr , l , mid - 1 , x ) return binarySearch ( arr , mid + 1 , r , x )

33.26
32.31
36.38
36.81
static boolean canMakeStr2 ( String str1 , String str2 ) { int [ ] count = new int [ MAX ] ; char [ ] str3 = str1 . toCharArray ( ) ; for ( int i = 0 ; i < str3 . length ; i ++ ) count [ str3 [ i ] ] ++ ; char [ ] str4 = str2 . toCharArray ( ) ; for ( int i = 0 ; i < str4 . length ; i ++ ) { if ( count [ str4 [ i ] ] == 0 ) return false ; count [ str4 [ i ] ] -- ; } return true ; }

def canMakeStr2 ( s1 , s2 ) : count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } for i in range ( len ( s1 ) ) : count [ s1 [ i ] ] += 1 for i in range ( len ( s2 ) ) : if count [ s2 [ i ] ] == 0 : return False count [ s2 [ i ] ] -= 1 return True

def canMakeStr2 ( str1 , str2 ) : count = [ 0 for i in range ( MAX ) ] for i in range ( 0 , str3 . length ) : if ( count [ str3 [ i ] ] == 0 ) : return false count [ str3 [ i ] ] ++ str4 = str2 . toCharArray ( ) for i in range ( 0 , str4 . length ) : if ( count [ str4 [ i ] ] == 0 ) : return false

def canMakeStr2 ( str1 , str2 ) : count = [ MAX for k in range ( MAX ) ] str3 = str1 . toCharArray ( ) for i in range ( 0 , MAX ) : count [ str3 [ i ] ] += 1 str4 = str2 . toCharArray ( ) for i in range ( 0 , str4 . length ) : if ( count [ str4 [ i ] ] == 0 ) : return False count [ str4 [ i ] ] -- return True

33.27
24.89
39.07
27.57
static int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }

def snoob ( x ) : next = 0 if ( x ) : rightOne = x & - ( x ) nextHigherOneBit = x + int ( rightOne ) rightOnesPattern = x ^ int ( nextHigherOneBit ) rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) rightOnesPattern = int ( rightOnesPattern ) >> 2 next = nextHigherOneBit | rightOnesPattern return next

def snoob ( x ) : rightOne = 0 nextHigherOneBit = 0 rightOnesPattern = 0 for x in range ( 2 , 32 ) : nextHigherOneBit = x + rightOne nextHigherOneBit = x ^ nextHigherOneBit rightOnesPattern = ( rightOnesPattern ) // rightOne >>= 2 next = nextHigherOneBit | rightOnesPattern next = nextHigherOneBit | rightOnesPattern next = nextHigherOneBit if ( x > 0 ) : next = nextHigherOneBit | rightOnesPattern next = nextHigherOneBit | rightOnesPattern return next

def snoob ( x ) : rightOne = x & - x nextHigherOneBit = x + rightOne nextHigherOneBit = x + rightOne rightOnesPattern = x ^ nextHigherOneBit rightOnesPattern = ( rightOnesPattern ) / rightOne rightOnesPattern >>= 2 next = nextHigherOneBit | rightOnesPattern next = nextHigherOneBit | rightOnesPattern return next

33.31
32.41
49.81
54.12
static boolean checkSorted ( int n ) { Stack < Integer > st = new Stack < Integer > ( ) ; int expected = 1 ; int fnt ; while ( q . size ( ) != 0 ) { fnt = q . peek ( ) ; q . poll ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . size ( ) == 0 ) { st . push ( fnt ) ; } else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) { return false ; } else st . push ( fnt ) ; } while ( st . size ( ) != 0 && st . peek ( ) == expected ) { st . pop ( ) ; expected ++ ; } } if ( expected - 1 == n && st . size ( ) == 0 ) return true ; return false ; }

def checkSorted ( n , q ) : st = [ ] expected = 1 fnt = None while ( not q . empty ( ) ) : fnt = q . queue [ 0 ] q . get ( ) if ( fnt == expected ) : expected += 1 else : if ( len ( st ) == 0 ) : st . append ( fnt ) elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) : return False else : st . append ( fnt ) while ( len ( st ) != 0 and st [ - 1 ] == expected ) : st . pop ( ) expected += 1 if ( expected - 1 == n and len ( st ) == 0 ) : return True return False

def checkSorted ( q , n ) : st = list ( ) for fnt in range ( n ) : if ( fnt == expected ) : expected ++ else : if ( st . size ( ) == 0 ) : st . append ( fnt ) else : if ( st . size ( ) != 0 and st . peek ( ) < fnt ) : return false else : st . pop ( ) } if ( expected - 1 == n and st . size ( ) == 0 ) : return true

def checkSorted ( n ) : st = list ( ) expected = 1 fnt = q . pop ( ) if fnt == expected : expected += 1 else : if ( st . size ( ) == 0 ) : st . append ( fnt ) elif ( st . size ( ) != 0 and st . peek ( ) < fnt ) : return False else : st . push ( fnt ) while st . size ( ) != 0 and st . peek ( ) == expected : st . pop ( ) expected ++ if ( expected - 1 == n and st . size ( ) == 0 ) : return True return False

33.34
39.11
34.02
40.0
static int countWords ( String str [ ] , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( str [ i ] ) ) { int get = m . get ( str [ i ] ) ; m . put ( str [ i ] , get + 1 ) ; } else { m . put ( str [ i ] , 1 ) ; } } int res = 0 ; for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) { if ( it . getValue ( ) == 2 ) res ++ ; } return res ; }

def countWords ( stri , n ) : m = dict ( ) for i in range ( n ) : m [ stri [ i ] ] = m . get ( stri [ i ] , 0 ) + 1 res = 0 for i in m . values ( ) : if i == 2 : res += 1 return res

def countWords ( str , n ) : m = defaultdict ( int ) for i in range ( n ) : if ( m . containsKey ( str [ i ] ) ) : get = 1 m . put ( str [ i ] , get + 1 ) else : m . put ( str [ i ] , 1 ) } res = 0 for it in m . entrySet ( ) : if ( it . getValue ( ) == 2 ) : res += 1 return res

def countWords ( str , n ) : m = new HashMap ( ) for i in range ( n ) : if ( m . containsKey ( str [ i ] ) ) : int get = m . get ( str [ i ] ) m . put ( str [ i ] , get + 1 ) else : m . put ( str [ i ] , 1 ) res = 0 for map_entry in m . entrySet ( ) : if ( map_entry . getValue ( ) == 2 ) : res += 1 return res

33.35
34.45
61.47
46.54
static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " " ) ; } }

def findElements ( arr , n ) : for i in range ( n ) : count = 0 for j in range ( 0 , n ) : if arr [ j ] > arr [ i ] : count = count + 1 if count >= 2 : print ( arr [ i ] , end = "" )

def findElements ( arr , n ) : count = 0 for i in range ( n ) : if ( arr [ i ] > arr [ j ] ) : count += 1 if ( count >= 2 ) print ( arr [ i ] + " " ) return if ( count >= 2 ) print ( arr [ i ] + " " ) return if ( count >= 2 ) print ( arr [ i ] + " " ) return if ( count >= 2 ) print ( arr [ i ] )

def findElements ( arr , n ) : count = 0 for i in range ( n ) : if arr [ i ] > arr [ j ] : count += 1 if count >= 2 : print ( arr [ i ] + " " )

33.52
37.74
100.0
100.0
static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }

def maxSumWO3Consec ( arr , n ) : sum = [ 0 for k in range ( n ) ] if n >= 1 : sum [ 0 ] = arr [ 0 ] if n >= 2 : sum [ 1 ] = arr [ 0 ] + arr [ 1 ] if n > 2 : sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) for i in range ( 3 , n ) : sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) return sum [ n - 1 ]

def maxSumWO3Consec ( arr , n ) : sum = [ 0 for k in range ( n ) ] if ( n >= 1 and n >= 2 and n >= 3 : sum [ 0 ] = arr [ 0 ] + arr [ 1 ] if n > 2 : sum [ 1 ] = max ( sum [ 0 ] , arr [ 1 ] + arr [ 2 ] ) return sum [ n - 1 ]

def maxSumWO3Consec ( arr , n ) : sum = [ 0 for k in range ( n ) ] if n >= 1 : sum [ 0 ] = arr [ 0 ] if n >= 2 : sum [ 1 ] = arr [ 0 ] + arr [ 1 ] if n > 2 : sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) for i in range ( 3 , n ) : sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) return sum [ n - 1 ]

33.6
22.88
53.05
51.79
static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }

def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

def factorial ( n ) : if ( n == 1 ) : return 1

def factorial ( n ) : if n == 0 : return 1 return n * factorial ( n - 1 )

33.6
22.88
53.05
51.79
static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }

def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

def factorial ( n ) : if ( n == 1 ) : return 1

def factorial ( n ) : if n == 0 : return 1 return n * factorial ( n - 1 )

33.61
35.83
82.39
77.75
static int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }

def minproduct ( a , b , n , k ) : diff = 0 res = 0 for i in range ( n ) : pro = a [ i ] * b [ i ] res = res + pro if ( pro < 0 and b [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] elif ( pro < 0 and a [ i ] < 0 ) : temp = ( a [ i ] - 2 * k ) * b [ i ] elif ( pro > 0 and a [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] elif ( pro > 0 and a [ i ] > 0 ) : temp = ( a [ i ] - 2 * k ) * b [ i ] d = abs ( pro - temp ) if ( d > diff ) : diff = d return res - diff

def minproduct ( a , b , n , k ) : diff = 0 for i in range ( n ) : pro = a [ i ] * b [ i ] res = res + pro if ( pro > 0 and a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] else : temp = ( a [ i ] + 2 * k ) * b [ i ] diff = d return res

def minproduct ( a , b , n , k ) : diff = 0 res = 0 for i in range ( n ) : pro = a [ i ] * b [ i ] res = res + pro if ( pro < 0 and b [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] else : temp = ( a [ i ] - 2 * k ) * b [ i ] if ( pro < 0 and a [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] else : temp = ( a [ i ] - 2 * k ) * b [ i ] d = abs ( pro - temp ) if ( d > diff ) : diff = d return res - diff

33.62
32.31
67.29
49.87
static void midPoint ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dy - ( dx / 2 ) ; int x = X1 , y = Y1 ; System . out . print ( x + "," + y + "\n" ) ; while ( x < X2 ) { x ++ ; if ( d < 0 ) d = d + dy ; else { d += ( dy - dx ) ; y ++ ; } System . out . print ( x + "," + y + "\n" ) ; } }

def midPoint ( X1 , Y1 , X2 , Y2 ) : dx = X2 - X1 dy = Y2 - Y1 d = dy - ( dx / 2 ) x = X1 y = Y1 print ( x , "," , y , "\n" ) while ( x < X2 ) : x = x + 1 if ( d < 0 ) : d = d + dy else : d = d + ( dy - dx ) y = y + 1 print ( x , "," , y , "\n" )

def midPoint ( X1 , Y1 , X2 , Y2 ) : dx = X2 - X1 dy = Y2 - Y1 d = dx - ( dy / 2 ) y = Y1 while x < X2 : d = d + dy x += 1 y += 1 print ( x + "," + y )

def midPoint ( X1 , Y1 , X2 , Y2 ) : dx = X2 - X1 dy = Y2 - Y1 d = dy - ( dx / 2 ) x = X1 , y = Y1 print ( x + "," + y + "\n" ) while ( x < X2 ) : x += ( d < 0 ) d = d + dy else : d += ( dy - dx ) y += ( dy - dy ) print ( x + "," + y + "\n" )

33.64
23.29
80.86
79.04
static long doublefactorial ( long n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; }

def doublefactorial ( n ) : if ( n == 0 or n == 1 ) : return 1 return n * doublefactorial ( n - 2 )

def doublefactorial ( n ) : if ( n == 2 ) : return n

def doublefactorial ( n ) : if n == 0 or n == 1 : return 1 return n * doublefactorial ( n - 2 )

33.65
37.62
86.56
76.31
static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }

def getRemainder ( num , divisor ) : return ( num - divisor * ( num // divisor ) )

def getRemainder ( num , divisor ) : return num

def getRemainder ( num , divisor ) : return ( num - divisor * ( num / divisor ) )

33.79
30.09
84.48
66.23
static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end ; curr_sum = 0 ; } curr_sum += arr [ end ++ ] ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }

def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : if ( curr_sum <= 0 and x > 0 ) : start = end curr_sum = 0 curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len

def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 for end in range ( 0 , n ) : if ( curr_sum >= x && end < n ) : min_len = end - start curr_sum += arr [ end ++ ] if ( curr_sum > x ) : min_len = end - start if ( min_len < 1 ) : min_len = end - start return min_len

def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while end < n : while ( curr_sum <= x and end < n ) : if ( curr_sum <= 0 and x > 0 ) : start = end curr_sum = 0 curr_sum += arr [ end ++ ] curr_sum -= arr [ start ++ ] while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ++ ] return min_len

33.79
31.94
27.25
30.59
public static int minSwaps ( int [ ] arr ) { int n = arr . length ; ArrayList < Pair < Integer , Integer >> arrpos = new ArrayList < Pair < Integer , Integer >> ( ) ; for ( int i = 0 ; i < n ; i ++ ) arrpos . add ( new Pair < Integer , Integer > ( arr [ i ] , i ) ) ; arrpos . sort ( new Comparator < Pair < Integer , Integer >> ( ) { @ Override public int compare ( Pair < Integer , Integer > o1 , Pair < Integer , Integer > o2 ) { if ( o1 . getKey ( ) > o2 . getKey ( ) ) return - 1 ; else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) ) ) return 0 ; else return 1 ; } } ) ; Boolean [ ] vis = new Boolean [ n ] ; Arrays . fill ( vis , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos . get ( i ) . getValue ( ) == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos . get ( j ) . getValue ( ) ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; }

def minSwaps ( arr ) : n = len ( arr ) arrpos = [ * enumerate ( arr ) ] arrpos . sort ( key = lambda it : it [ 1 ] ) vis = { k : False for k in range ( n ) } ans = 0 for i in range ( n ) : if vis [ i ] or arrpos [ i ] [ 0 ] == i : continue cycle_size = 0 j = i while not vis [ j ] : vis [ j ] = True j = arrpos [ j ] [ 0 ] cycle_size += 1 if cycle_size > 0 : ans += ( cycle_size - 1 ) return ans

def minSwaps ( arr ) : arrpos = new ArrayList < Pair < Integer , Integer > > ( ) for i in range ( n ) : arrpos . add ( new Pair < Integer , Integer > ( arr [ i ] , i ) ) sort ( reverse = True ) ans = 0 for i in range ( 0 , n ) : if ( o1 [ 0 ] > o2 [ 0 ] ) : return - 1 else : ans += ( cycle_size - 1 ) return ans for j in range ( i ) : if ( vis [ i ] ) : vis [ j ] = true j = arrpos [ i ] if ( vis [ j ] ) : ans += ( cycle_size - 1 ) else : return ans

def minSwaps ( arr ) : n = arr . length arrpos = list ( ) for i in range ( n ) : if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : continue if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : continue if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : continue if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : continue if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : continue if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : continue if ( not vis [ j ] ) : vis [ j ] = True j = arrpos [ j ] . getValue ( ) cycle_size = 0 while not vis [ j ] : vis [ j ] = True j = arrpos [ j ] . getValue ( ) cycle_size ++ } if ( cycle_size > 0 ) : ans += ( cycle_size - 1 ) return ans

33.8
32.41
51.03
39.83
static int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . max ( maxHam , currHam ) ; } return maxHam ; }

def maxHamming ( arr , n ) : brr = [ 0 ] * ( 2 * n + 1 ) for i in range ( n ) : brr [ i ] = arr [ i ] for i in range ( n ) : brr [ n + i ] = arr [ i ] maxHam = 0 for i in range ( 1 , n ) : currHam = 0 k = 0 for j in range ( i , i + n ) : if brr [ j ] != arr [ k ] : currHam += 1 k = k + 1 if currHam == n : return n maxHam = max ( maxHam , currHam ) return maxHam

def maxHamming ( arr , n ) : brr = [ 0 for i in range ( n ) ] n += 1 for i in range ( 1 , n ) : if ( brr [ i ] != arr [ i ] ) : currHam = 0 if ( currHam == n ) : return n maxHam = max ( maxHam , currHam ) return maxHam

def maxHamming ( arr , n ) : brr = [ 0 for i in range ( 2 * n + 1 ) ] for i in range ( 1 , n ) : currHam = 0 for j in range ( 1 , n ) : if ( brr [ j ] != arr [ k ] ) : currHam += ( brr [ j ] - arr [ k ] ) if ( currHam == n ) : return n maxHam = max ( maxHam , currHam ) return maxHam

33.85
37.5
56.68
43.12
static boolean negCyclefloydWarshall ( int graph [ ] [ ] ) { int dist [ ] [ ] = new int [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( i = 0 ; i < V ; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; }

def negCyclefloydWarshall ( graph ) : dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ] for i in range ( V ) : for j in range ( V ) : dist [ i ] [ j ] = graph [ i ] [ j ] for k in range ( V ) : for i in range ( V ) : for j in range ( V ) : if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] for i in range ( V ) : if ( dist [ i ] [ i ] < 0 ) : return True return False

def negCyclefloydWarshall ( graph , V ) : dist = [ 0 for i in range ( V ) ] for j in range ( 0 , V ) : if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] return true

def negCyclefloydWarshall ( graph ) : dist [ ] [ ] = [ 0 for k in range ( V ) ] for i in range ( 0 , V , - 1 ) : if ( dist [ i ] [ j ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] if ( dist [ i ] [ j ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] return False

33.85
36.66
33.51
29.73
static int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; }

def findLargestPlus ( mat ) : left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] top = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] bottom = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] for i in range ( N ) : top [ 0 ] [ i ] = mat [ 0 ] [ i ] bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] left [ i ] [ 0 ] = mat [ i ] [ 0 ] right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] for i in range ( N ) : for j in range ( 1 , N ) : if ( mat [ i ] [ j ] == 1 ) : left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 else : left [ i ] [ j ] = 0 if ( mat [ j ] [ i ] == 1 ) : top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 else : top [ j ] [ i ] = 0 j = N - 1 - j if ( mat [ j ] [ i ] == 1 ) : bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 else : bottom [ j ] [ i ] = 0 if ( mat [ i ] [ j ] == 1 ) : right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 else : right [ i ] [ j ] = 0 j = N - 1 - j n = 0 for i in range ( N ) : for j in range ( N ) : l = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) if ( l > n ) : n = l if ( n ) : return 4 * ( n - 1 ) + 1 return 0

def findLargestPlus ( mat , N ) : left = [ ] right = [ ] top = [ ] bottom = [ ] for i in range ( N ) : left [ i ] [ j ] = mat [ i ] [ j - 1 ] + 1 right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] i = 0 if ( mat [ i ] [ j ] == 1 ) : top [ i ] [ j ] = top [ j ] [ i ] = 0 if ( mat [ j ] [ i ] == 1 ) : bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] = 0 if ( mat [ j ] [ i ] == 1 ) : bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] = 0 i = N - 1 - j if ( mat [ j ] [ i ] == 1 ) : bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] = 0 if ( mat [ j ] [ i ] == 1 ) : bottom [ j ] [ i ] = 0 if ( mat [ j ] [ i ] == 1 ) : bottom [ j ] [ i ] = bottom [

def findLargestPlus ( mat ) : left [ i ] = mat [ 0 ] [ i ] bottom [ N - 1 ] [ i ] = mat [ 0 ] [ i ] left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 else : left [ i ] [ j ] = 0 j = 1 - j if mat [ j ] [ i ] == 1 : top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 else top [ j ] [ i ] = 0 j = N - 1 - j if mat [ j ] [ i ] == 1 : bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 else bottom [ j ] [ i ] = 0 j = N - 1 - j if mat [ j ] [ i ] == 1 : top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 else top [ j ] [ i ] = 0 j = N - 1 - j if mat [ j ] [ i ] == 1 : bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 else bottom [ j ] [ i ] = 0

33.88
34.24
28.83
29.98
static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }

def check ( num ) : digitSum = 0 while num > 0 : rem = num % 10 digitSum = digitSum + rem num = num // 10 return ( digitSum % 3 == 0 )

def check ( str ) : digitSum = 0 for i in range ( n ) : digitSum += ( str [ i ] - '0' ) return ( digitSum % 3 == 0 )

def check ( str ) : n = str . length digitSum = 0 for i in range ( n ) : digitSum += ( str [ i ] - '0' ) return ( digitSum % 3 == 0 )

33.92
28.17
77.83
60.26
static void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } System . out . print ( maxOfMin + " " ) ; } }

def printMaxOfMin ( arr , n ) : for k in range ( 1 , n + 1 ) : maxOfMin = INT_MIN for i in range ( n - k + 1 ) : min = arr [ i ] for j in range ( k ) : if ( arr [ i + j ] < min ) : min = arr [ i + j ] if ( min > maxOfMin ) : maxOfMin = min print ( maxOfMin , end = "" )

def printMaxOfMin ( n , arr ) : maxOfMin = float ( 'inf' ) for k in range ( 1 , n ) : if ( arr [ i ] < maxOfMin ) : min = arr [ i ] maxOfMin = min if ( maxOfMin > maxOfMin ) maxOfMin = max ( arr [ i ] , min )

def printMaxOfMin ( n ) : for k in range ( 1 , n ) : maxOfMin = float ( 'inf' ) for i in range ( 1 , n - k ) : min = arr [ i ] for j in range ( 1 , k ) : if ( arr [ i + j ] < min ) : min = arr [ i + j ] if ( min > maxOfMin ) : maxOfMin = min print ( maxOfMin + " " )

33.93
26.52
50.56
33.62
static int minimumSquare ( int a , int b ) { int result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; rem = a % b ; a = b ; b = rem ; } return result ; }

def minimumSquare ( a , b ) : result = 0 rem = 0 if ( a < b ) : a , b = b , a while ( b > 0 ) : result += int ( a / b ) rem = int ( a % b ) a = b b = rem return result

def minimumSquare ( a , b ) : result = 0 rem = 0 for a in range ( a , b ) : result += a / b b = rem return result

def minimumSquare ( a , b ) : result = 0 rem = 0 if a < b : swap ( a , b ) while b > 0 : result += a / b rem = a % b a = b b = rem return result

33.94
33.01
60.59
50.62
static void worstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( wstIdx == - 1 ) wstIdx = j ; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j ; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( "Not Allocated" ) ; System . out . println ( ) ; } }

def worstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : wstIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if wstIdx == - 1 : wstIdx = j elif blockSize [ wstIdx ] < blockSize [ j ] : wstIdx = j if wstIdx != - 1 : allocation [ i ] = wstIdx blockSize [ wstIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )

def worstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 for i in range ( n ) ] for i in range ( 0 , n ) : if ( blockSize [ j ] >= processSize [ i ] ) : wstIdx = j elif ( blockSize [ j ] < processSize [ i ] ) : wstIdx = j if ( wstIdx != - 1 ) : allocation [ i ] = wstIdx else : print ( "Not

def worstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 for k in range ( n ) ] for i in range ( n ) : allocation [ i ] = - 1 for j in range ( m ) : if ( blockSize [ j ] >= processSize [ i ] ) : if ( blockSize [ wstIdx ] < blockSize [ j ] ) : wstIdx = j if ( blockSize [ wstIdx ] > blockSize [ j ] ) : wstIdx = j if ( wstIdx != - 1 ) : allocation [ i ] = wstIdx blockSize [ wstIdx ] -= processSize [ i ] if wstIdx != - 1 : allocation [ i ] = wstIdx blockSize [ wstIdx ] -= processSize [ i ]

33.95
38.3
60.84
59.41
static int findIndex ( int n ) { float fibo = 2.078087F * ( float ) Math . log ( n ) + 1.672276F ; return Math . round ( fibo ) ; }

def findIndex ( n ) : fibo = 2.078087 * math . log ( n ) + 1.672276 return round ( fibo )

def findIndex ( n ) : fibo = 2.078087F * n + 1.672276F return - 1

def findIndex ( n ) : fibo = 2.078087F * ( float ) log ( n ) + 1.672276F return round ( fibo )

34.04
37.92
71.3
58.74
static int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }

def countWords ( str , l ) : count = 1 ; if ( l == 1 ) : return count if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : count *= 2 for j in range ( 1 , l - 1 ) : if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : count *= 1 elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : count *= 2 else : count *= 3 if ( str [ l - 1 ] == str [ l - 2 ] ) : count *= 1 else : count *= 2 return count

def countWords ( str , len ) : count = 1 if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : if ( str [ 0 ] == str [ 1 ] ) : count *= 2

def countWords ( str , len ) : count = 1 if len == 1 : count *= 1 else : count *= 2 for j in range ( 1 , len - 1 , - 1 ) : if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : count *= 1 elif ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : count *= 1 else : if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : count *= 1 else : count *= 2 else : count *= 3 return count

34.13
33.22
34.45
28.94
static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int [ ] sum = new int [ n ] ; int curr_rem ; int maxSum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sum [ i ] % k ; if ( curr_rem == 0 ) { if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ; } else if ( ! um . containsKey ( curr_rem ) ) um . put ( curr_rem , i ) ; else if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_rem ) ] ) ) maxSum = sum [ i ] - sum [ um . get ( curr_rem ) ] ; } return ( maxSum / k ) ; }

def maxNumOfChocolates ( arr , n , k ) : um , curr_rem , maxSum = { } , 0 , 0 sm = [ 0 ] * n sm [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : sm [ i ] = sm [ i - 1 ] + arr [ i ] for i in range ( n ) : curr_rem = sm [ i ] % k if ( not curr_rem and maxSum < sm [ i ] ) : maxSum = sm [ i ] elif ( not curr_rem in um ) : um [ curr_rem ] = i elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) : maxSum = sm [ i ] - sm [ um [ curr_rem ] ] return maxSum // k

def maxNumOfChocolates ( arr , n , k ) : um = { } sum = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : curr_rem = sum [ i ] % k if ( curr_rem == 0 ) : if ( maxSum < sum [ i ] ) : maxSum = sum [ i ] if ( ! um . containsKey ( curr_rem ) ) : um . put ( curr_rem , i ) else : if ( maxSum < sum [ i ] - sum [ um . get ( curr_rem ) : maxSum = sum [ i ] - sum [ um . get ( curr_rem ) : if ( maxSum < sum [ i ] ) : maxSum = sum [ i ] - sum [ um . get ( curr_rem ] ) : maxSum = sum [ i ] if ( ! um . containsKey ( curr_rem ) ) : um . put ( curr_rem , i ) return ( maxSum / k )

def maxNumOfChocolates ( arr , n , k ) : um = { } sum = list ( ) for i in range ( n ) : curr_rem = sum [ i ] % k if ( curr_rem == 0 ) : if ( maxSum < sum [ i ] ) : maxSum = sum [ i ] elif ( not um . containsKey ( curr_rem ) ) : um . put ( curr_rem , i ) else : if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_rem ) ] ) ) : maxSum = sum [ i ] - sum [ um . get ( curr_rem ) ] return ( maxSum / k )

34.15
25.41
76.66
61.7
static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }

def power ( x , y ) : if ( y == 0 ) : return 1 temp = power ( x , int ( y / 2 ) ) if ( y % 2 == 0 ) : return temp * temp else : if ( y > 0 ) : return x * temp * temp else : return ( temp * temp ) / x

def power ( x , y ) : temp = power ( x , y ) if ( y % 2 == 0 ) : return temp * temp else : return x * temp

def power ( x , y ) : if y == 0 : return 1 temp = power ( x , y / 2 ) if y % 2 == 0 : return temp * temp else : if ( y > 0 ) : return x * temp * temp else : return ( temp * temp ) / x

34.17
26.96
50.95
47.24
static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }

def isDivisible ( n ) : while ( int ( n / 100 ) ) : last_digit = int ( n % 10 ) n = int ( n / 10 ) n += last_digit * 3 return ( n % 29 == 0 )

def isDivisible ( n ) : n /= 100 while ( n > 0 ) : last_digit = ( int ) n % 10 n /= 10 n += last_digit * 3 return false

def isDivisible ( n ) : while n / 100 > 0 : last_digit = ( int ) n % 10 n /= 10 n += last_digit * 3 return ( n % 29 == 0 )

34.24
31.9
62.39
57.42
static int sumNodes ( int l ) { int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ; Vector < Vector < Integer >> vec = new Vector < Vector < Integer >> ( ) ; for ( int i = 1 ; i <= l ; i ++ ) vec . add ( new Vector < Integer > ( ) ) ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec . get ( l - 1 ) . add ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) { vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) + vec . get ( i + 1 ) . get ( k + 1 ) ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec . get ( i ) . size ( ) ; j ++ ) sum += vec . get ( i ) . get ( j ) ; } return sum ; }

def SumNodes ( l ) : leafNodeCount = pow ( 2 , l - 1 ) vec = [ [ ] for i in range ( l ) ] for i in range ( 1 , leafNodeCount + 1 ) : vec [ l - 1 ] . append ( i ) for i in range ( l - 2 , - 1 , - 1 ) : k = 0 while ( k < len ( vec [ i + 1 ] ) - 1 ) : vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) k += 2 Sum = 0 for i in range ( l ) : for j in range ( len ( vec [ i ] ) ) : Sum += vec [ i ] [ j ] return Sum

def sumNodes ( l ) : leafNodeCount = ( int ) pow ( 2 , l - 1 ) for i in range ( 1 , leafNodeCount ) : vec . add ( new Vector < Integer > ( ) ) for i in range ( l - 1 , leafNodeCount ) : vec . add ( new Vector < Integer > ( ) ) for i in range ( l - 2 , - 1 , - 1 ) : if ( k < vec . get ( i + 1 ) . size ( ) ) : vec . get ( i ) . get ( k ) ) : sum += vec [ i ] . get ( k ) return sum

def sumNodes ( l ) : vec = [ [ 0 for k in range ( l ) ] for i in range ( l ) ] for i in range ( l - 2 , - 1 , - 1 ) : vec [ i ] . add ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) for i in range ( l - 2 , i >= 0 ) : k = 0 while ( k < vec [ i + 1 ] . size ( ) - 1 ) : vec [ i ] . add ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) k += 2 sum = 0 for i in range ( 0 , l ) : for j in range ( 0 , vec [ i ] . size ( ) ) : sum += vec [ i ] [ j ] return sum

34.27
31.84
53.08
41.54
public static void maxOverlap ( int [ ] start , int [ ] end , int n ) { int maxa = Arrays . stream ( start ) . max ( ) . getAsInt ( ) ; int maxb = Arrays . stream ( end ) . max ( ) . getAsInt ( ) ; int maxc = Math . max ( maxa , maxb ) ; int [ ] x = new int [ maxc + 2 ] ; Arrays . fill ( x , 0 ) ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = Integer . MIN_VALUE ; for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } System . out . println ( "Maximum value is:" + maxy + " at position: " + idx + "" ) ; }

def maxOverlap ( start , end ) : n = len ( start ) maxa = max ( start ) maxb = max ( end ) maxc = max ( maxa , maxb ) x = ( maxc + 2 ) * [ 0 ] cur = 0 idx = 0 for i in range ( 0 , n ) : x [ start [ i ] ] += 1 x [ end [ i ] + 1 ] -= 1 maxy = - 1 for i in range ( 0 , maxc + 1 ) : cur += x [ i ] if maxy < cur : maxy = cur idx = i print ( "Maximumvalueis:{0:d}" . format ( maxy ) , "atposition:{0:d}" . format ( idx ) )

def maxOverlap ( start , end , n ) : maxa , maxb = max ( start , end , n ) maxc = max ( maxa , maxb ) x = [ 0 for i in range ( n ) ] idx = 0 for i in range ( maxc ) : cur += x [ i ] if ( maxy < cur ) : maxy = cur idx = i if ( maxy < cur ) : maxy = cur if ( maxy <

def maxOverlap ( start , end , n ) : maxa = max ( start , end ) maxb = max ( maxa , maxb ) x = [ maxc + 2 ] cur = 0 , idx = 0 for i in range ( n ) : ++ x [ start [ i ] ] -- x [ end [ i ] + 1 ] maxy = float ( 'inf' ) for i in range ( n ) : cur += x [ i ] if maxy < cur : maxy = cur idx = i if i <= maxc : cur += x [ i ] if maxy < cur : maxy = cur idx = i

34.31
48.09
65.77
57.09
static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }

def concatenate ( a , b , c , n1 , n2 ) : i = - 1 for i in range ( n1 ) : c [ i ] = a [ i ] for j in range ( n2 ) : c [ i ] = b [ j ] i += 1

def concatenate ( a , b , c , n1 , n2 ) : c . sort ( reverse = True ) for i in range ( 0 , n1 , n2 ) : c [ i ] = a [ i ] for j in range ( 0 , n2 ) : c [ i ] = b [ j ] if ( j < n1 ) : c [ i ++ ] = c [ i ++ ] = b [ j ] if ( j < n2 ) : c [ i ++ ] = b [ j ] if ( c [ i ] != a [ i ] ) : c [ i ++ ] = c [ i ] return c

def concatenate ( a , b , c , n1 , n2 ) : c . append ( a [ i ] ) for i in range ( n1 , n2 ) : c [ i ] = b [ i ] for j in range ( 0 , n2 ) : c [ i ++ ] = b [ j ]

34.32
39.1
31.34
31.51
static int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == '(' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ')' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ')' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }

def findIndex ( str ) : l = len ( str ) open = [ None ] * ( l + 1 ) close = [ None ] * ( l + 1 ) index = - 1 open [ 0 ] = 0 close [ l ] = 0 if ( str [ 0 ] == '(' ) : open [ 1 ] = 1 if ( str [ l - 1 ] == ')' ) : close [ l - 1 ] = 1 for i in range ( 1 , l ) : if ( str [ i ] == '(' ) : open [ i + 1 ] = open [ i ] + 1 else : open [ i + 1 ] = open [ i ] for i in range ( l - 2 , - 1 , - 1 ) : if ( str [ i ] == ')' ) : close [ i ] = close [ i + 1 ] + 1 else : close [ i ] = close [ i + 1 ] if ( open [ l ] == 0 ) : return len if ( close [ 0 ] == 0 ) : return 0 for i in range ( l + 1 ) : if ( open [ i ] == close [ i ] ) : index = i return index

def findIndex ( str ) : open = [ 0 for k in range ( len ) ] close = [ 0 for k in range ( len ) ] for i in range ( len ) : if ( str [ i ] == '(' ) open [ 1 ] = 1 else : open [ 1 ] = 1 close [ len - 1 ] = 1 i = len - 2 while i >= 0 : if ( str [ i ] == ')' ) : close [ i ] = close [ i + 1 ] = open [ i ] if ( i <= len : if ( open [ i ] == close [ i ] ) : index = i return index if ( close [ len ] == 0 ) : return len

def findIndex ( str ) : open = [ 0 for k in range ( len ) ] close = [ 0 for k in range ( len ) ] if ( str [ 0 ] == '(' ) : open [ 1 ] = 1 if ( str [ 0 ] == ')' ) : open [ 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ 1 ] = 1 if ( str [ len - 1 ] == '(' ) : close [ 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len - 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len - 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len - 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len - 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len - 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len - 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len - 1 ] = 1 if ( str [ len - 1 ] == ')' ) : close [ len

34.36
36.12
38.62
36.31
static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; int result [ ] = new int [ len1 + len2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 . charAt ( i ) - '0' ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 . charAt ( j ) - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = "" ; while ( i >= 0 ) s += ( result [ i -- ] ) ; return s ; }

def multiply ( num1 , num2 ) : len1 = len ( num1 ) len2 = len ( num2 ) if len1 == 0 or len2 == 0 : return "0" result = [ 0 ] * ( len1 + len2 ) i_n1 = 0 i_n2 = 0 for i in range ( len1 - 1 , - 1 , - 1 ) : carry = 0 n1 = ord ( num1 [ i ] ) - 48 i_n2 = 0 for j in range ( len2 - 1 , - 1 , - 1 ) : n2 = ord ( num2 [ j ] ) - 48 summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry carry = summ // 10 result [ i_n1 + i_n2 ] = summ % 10 i_n2 += 1 if ( carry > 0 ) : result [ i_n1 + i_n2 ] += carry i_n1 += 1 i = len ( result ) - 1 while ( i >= 0 and result [ i ] == 0 ) : i -= 1 if ( i == - 1 ) : return "0" s = "" while ( i >= 0 ) : s += chr ( result [ i ] + 48 ) i -= 1 return s

def multiply ( num1 , num2 ) : len1 = len1 + len2 = 0 result = [ 0 for i in range ( len1 , len2 ) ] i_n1 = 0 i_n2 = 0 for j in range ( len2 ) : n1 = num1 [ i ] n2 = num2 [ j ] carry = 0 for i in range ( len1 - 1 , len2 - 1 ) : sum = n1 * n2 + result [ i_n1 + i_n2 += carry = 0 if ( carry > 0 ) : result [ i_n1 + i_n2 ] = sum % 10 i_n1 += carry i_n2 += 1 if ( carry > 0 ) : result [ i_n1 + i_n2 ] = carry carry = sum % 10 s += ( result [ i_n1 + i_n2 ] ) return s

def multiply ( num1 , num2 ) : len1 = len1 len2 = len2 for i in range ( len1 , len2 ) : carry = 0 n1 = num1 [ i ] - '0' i_n2 = 0 for j in range ( len2 ) : n2 = num2 [ j ] - '0' sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry carry = sum / 10 result [ i_n1 + i_n2 ] = sum % 10 i_n2 ++ if carry > 0 : result [ i_n1 + i_n2 ] += carry i_n1 ++ i = result . length - 1 while i >= 0 and result [ i ] == 0 : i -- if i == - 1 : return "0" s = "" while i >= 0 : s += ( result [ i -- ] ) return s

34.36
28.21
81.43
63.5
public static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; }

def findNth ( n ) : nthElement = 19 + ( n - 1 ) * 9 outliersCount = int ( math . log10 ( nthElement ) ) - 1 nthElement += 9 * outliersCount return nthElement

def findNth ( n ) : nthElement = 19 + n * 9 nthElement += 9 * outliersCount return nthElement

def findNth ( n ) : nthElement = 19 + ( n - 1 ) * 9 outliersCount = ( int ) log10 ( nthElement ) - 1 nthElement += 9 * outliersCount return nthElement

34.37
44.1
61.82
61.2
static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + ", " + ( float ) ( y1 + y2 ) / 2 ) ; }

def center ( x1 , x2 , y1 , y2 ) : print ( int ( ( x1 + x2 ) / 2 ) , end = "" ) print ( "," , int ( ( y1 + y2 ) / 2 ) )

def center ( x1 , x2 , y1 , y2 ) : print ( x1 + x2 + ", " + y1 + y2 )

def center ( x1 , x2 , y1 , y2 ) : print ( ( float ( x1 + x2 ) / 2 , " " + ( float ( y1 + y2 ) / 2 ) )

34.45
30.83
45.89
40.49
static int MaxSumDifference ( Integer [ ] a , int n ) { List < Integer > finalSequence = new ArrayList < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return MaximumSum ; }

def MaxSumDifference ( a , n ) : np . sort ( a ) j = 0 finalSequence = [ 0 for x in range ( n ) ] for i in range ( 0 , int ( n / 2 ) ) : finalSequence [ j ] = a [ i ] finalSequence [ j + 1 ] = a [ n - i - 1 ] j = j + 2 MaximumSum = 0 for i in range ( 0 , n - 1 ) : MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) print ( MaximumSum )

def MaxSumDifference ( a , n ) : finalSequence = list ( ) for i in range ( 0 , n ) : finalSequence . add ( a [ i ] ) for i in range ( 0 , n / 2 ) : finalSequence . add ( a [ i ] ) for i in range ( 0 , n - 1 ) : MaximumSum = MaximumSum + Math . abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) return MaximumSum

def MaxSumDifference ( a , n ) : finalSequence = list ( ) for i in range ( n ) : finalSequence . append ( a [ i ] ) finalSequence . append ( a [ n - i - 1 ] ) maximumSum = 0 for i in range ( 0 , n ) : MaximumSum = MaximumSum + Math . abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) MaximumSum = MaximumSum + Math . abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) return MaximumSum

34.46
23.78
25.41
40.17
static void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( "-1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( "b = " + b + ", c = " + c ) ; } } else { if ( n == 2 ) System . out . println ( "-1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( "b = " + b + ", c = " + c ) ; } } }

def printOtherSides ( n ) : if ( n & 1 ) : if ( n == 1 ) : print ( - 1 ) else : b = ( n * n - 1 ) // 2 c = ( n * n + 1 ) // 2 print ( "b=" , b , ",c=" , c ) else : if ( n == 2 ) : print ( - 1 ) else : b = n * n // 4 - 1 c = n * n // 4 + 1 print ( "b=" , b ",c=" , c )

def printOtherSides ( n ) : if n % 2 == 0 : print ( n ) elif n % 2 == 1 : print ( "-1" ) else : print ( n ) if n == 2 : print ( "-1" ) else : int b = n * n - 1 int c = n * n + 1 print ( "b = " + b + ", c = " + c ) } else : print ( n == 1 ) : print ( "-1" )

def printOtherSides ( n ) : if n % 2 != 0 : if n == 1 : print ( "-1" ) else : int b = ( n * n - 1 ) / 2 c = ( n * n + 1 ) / 2 print ( "b = " + b + ", c = " + c )

34.46
44.52
46.06
72.93
static int findRepeating ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum - ( ( ( n - 1 ) * n ) / 2 ) ; }

def findRepeating ( arr , n ) : return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 )

def findRepeating ( arr , n ) : sum = 0 for i in range ( n ) : sum += arr [ i ] return sum

def findRepeating ( arr , n ) : sum = 0 for i in range ( n ) : sum += arr [ i ] return sum - ( ( ( n - 1 ) * n ) / 2 )

34.54
34.63
47.88
68.12
static int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }

def largestPower ( n , p ) : x = 0 while n : n /= p x += n return x

def Largestpower ( n , p ) : ans = 0 n /= p while ( n > 0 ) : ans += n

def Largestpower ( n , p ) : ans = 0 while n > 0 : n /= p ans += n return ans

34.6
31.5
42.15
49.3
public static int minRemove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; else countA . put ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; else countB . put ( b [ i ] , 1 ) ; } int res = 0 ; Set < Integer > s = countA . keySet ( ) ; for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ; return res ; }

def minRemove ( a , b , n , m ) : countA = dict ( ) countB = dict ( ) for i in range ( n ) : countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 for i in range ( n ) : countB [ b [ i ] ] = countB . get ( b [ i ] , 0 ) + 1 res = 0 for x in countA : if x in countB . keys ( ) : res += min ( countA [ x ] , countB [ x ] ) return res

def minRemove ( a , b , n , m ) : countA = new HashMap < Integer , Integer > ( ) countB = new HashMap < Integer , Integer > ( ) for i in range ( n , m ) : if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA [ get ( a [ i ] ) + 1 ) else countA . put ( a [ i ] , 1 ) countB .

def minRemove ( a , b , n , m ) : countA = list ( ) countB = list ( ) for i in range ( n ) : if countA . containsKey ( a [ i ] ) : countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) else : countA . put ( a [ i ] , 1 ) for i in range ( m ) : if countB . containsKey ( b [ i ] ) : countB . put ( b [ i ] , 1 ) res = 0 s = countA . keySet ( ) for x in s : if countB . containsKey ( x ) : res += min ( countB . get ( x ) , countA . get ( x ) ) return res

34.61
35.27
51.25
54.2
static char findExtraCharcter ( String strA , String strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA . charAt ( i ) ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB . charAt ( i ) ; } return ( ( char ) ( res ) ) ; }

def findExtraCharcter ( strA , strB ) : res = 0 for i in range ( 0 , len ( strA ) ) : res = res ^ ( ord ) ( strA [ i ] ) for i in range ( 0 , len ( strB ) ) : res = res ^ ( ord ) ( strB [ i ] ) return ( ( chr ) ( res ) ) ;

def findExtraCharcter ( strA , strB ) : res = 0 for i in range ( len ( strA ) ) : res ^= strA [ i ] if ( res == 0 ) : return ( ( char ) ( res ) )

def findExtraCharcter ( strA , strB ) : res = 0 for i in range ( len ( strA ) ) : res ^= strA [ i ] for i in range ( len ( strB ) ) : res ^= strB [ i ] return ( ( char ) ( res ) )

34.62
44.53
69.71
63.56
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }

def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

def factorial ( n ) : n * factorial ( n - 1 )

def factorial ( n ) : if n == 1 or n == 0 : return 1 return n * factorial ( n - 1 )

34.62
44.53
69.71
63.56
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }

def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

def factorial ( n ) : n * factorial ( n - 1 )

def factorial ( n ) : if n == 1 or n == 0 : return 1 return n * factorial ( n - 1 )

34.67
36.94
28.58
37.27
static void lineFromPoints ( Pair P , Pair Q ) { int a = Q . second - P . second ; int b = P . first - Q . first ; int c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { System . out . println ( "The line passing through points P and Q is: " + a + "x " + b + "y = " + c ) ; } else { System . out . println ( "The line passing through points P and Q is: " + a + "x + " + b + "y = " + c ) ; } }

def lineFromPoints ( P , Q ) : a = Q [ 1 ] - P [ 1 ] b = P [ 0 ] - Q [ 0 ] c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) if ( b < 0 ) : print ( "ThelinepassingthroughpointsPandQis:" , a , "x" , b , "y=" , c , "\n" ) else : print ( "ThelinepassingthroughpointsPandQis:" , a , "x+" , b , "y=" , c , "\n" )

def lineFromPoints ( P , Q ) : a = P . first - Q . first b = Q . second - P . second a = b * P . first + c = a * ( P . second ) + c * ( P . first ) if ( b < 0 ) : print ( "The line passing through points P and Q is: " + a + "x " + b + "y = " + c ) else : print ( "The line passing

def lineFromPoints ( P , Q ) : a = Q . second - P . second b = P . first - Q . first c = a * ( P . first ) + b * ( P . second ) if b < 0 : print ( "The line passing through points P and Q is: " + a + "x " + b + "y = " + c ) else : print ( "The line passing through points P and Q is: " + a + "x " + b + "y = " + c )

34.74
33.87
41.62
39.55
static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }

def kth ( arr1 , arr2 , m , n , k ) : sorted1 = [ 0 ] * ( m + n ) i = 0 j = 0 d = 0 while ( i < m and j < n ) : if ( arr1 [ i ] < arr2 [ j ] ) : sorted1 [ d ] = arr1 [ i ] i += 1 else : sorted1 [ d ] = arr2 [ j ] j += 1 d += 1 while ( i < m ) : sorted1 [ d ] = arr1 [ i ] d += 1 i += 1 while ( j < n ) : sorted1 [ d ] = arr2 [ j ] d += 1 j += 1 return sorted1 [ k - 1 ]

def kth ( arr1 , arr2 , m , n , k ) : sorted1 = [ 0 for i in range ( m , n ) ] j = 0 for i in range ( m , n ) : if ( arr1 [ i ] < arr2 [ j ] ) : sorted1 [ d ++ ] = arr1 [ i ++ ] else : sorted1 [ d ++ ] = arr2 [ j ++ ] return sorted1 [ k - 1 ]

def kth ( arr1 , arr2 , m , n , k ) : sorted1 = [ 0 for k in range ( m + n ) ] while i < m and j < n : if ( arr1 [ i ] < arr2 [ j ] ) : sorted1 [ d ++ ] = arr1 [ i ++ ] else : sorted1 [ d ++ ] = arr2 [ j ++ ] i += 1 j += 1 return sorted1 [ k - 1 ]

34.75
34.4
94.28
68.08
static int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ; }

def unitnumber ( x , y ) : x = x % 10 if y != 0 : y = y % 4 + 4 return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 )

def unitnumber ( x , y ) : x = x % 10 y = y % 4 + 4 return ( x

def unitnumber ( x , y ) : x = x % 10 if y != 0 : y = y % 4 + 4 return ( ( ( int ( math . pow ( x , y ) ) ) % 10 )

34.85
31.82
65.25
55.86
static void makePermutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . put ( next_missing , 1 ) ; } } }

def makePermutation ( a , n ) : count = dict ( ) for i in range ( n ) : if count . get ( a [ i ] ) : count [ a [ i ] ] += 1 else : count [ a [ i ] ] = 1 next_missing = 1 for i in range ( n ) : if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : count [ a [ i ] ] -= 1 while count . get ( next_missing ) : next_missing += 1 a [ i ] = next_missing count [ next_missing ] = 1

def makePermutation ( a , n ) : count = new HashMap < Integer , Integer > ( ) for i in range ( 0 , n ) : if ( count . containsKey ( a [ i ] ) ) : count . put ( a [ i ] , 1 ) else : a [ i ] = 1 next_missing = 1 while ( count . containsKey ( next_missing ) ) next_missing += 1 a [ i ] = next_missing count . put ( next_

def makePermutation ( a , n ) : count = { } for i in range ( n ) : if count . containsKey ( a [ i ] ) : count [ a [ i ] ] += 1 else : count [ a [ i ] ] = 1 next_missing = 1 for i in range ( n ) : if count . containsKey ( a [ i ] ) and count [ a [ i ] ] != 1 or a [ i ] > n || a [ i ] < 1 : count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) while ( count . containsKey ( next_missing ) ) : next_missing ++ a [ i ] = next_missing count . put ( next_missing , 1 )

34.85
42.02
50.82
41.0
static int subset ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; }

def subset ( arr , n ) : mp = { i : 0 for i in range ( 10 ) } for i in range ( n ) : mp [ arr [ i ] ] += 1 res = 0 for key , value in mp . items ( ) : res = max ( res , value ) return res

def subset ( arr , n ) : mp = new HashMap < Integer , Integer > ( ) for i in range ( n ) : mp . put ( arr [ i ] , 1 ) for i in range ( n ) : mp . put ( arr [ i ] , 1 ) for i in range ( n ) : mp . put ( arr [ i ] , 1 ) res = max ( res , entry . getValue ( ) ) return res

def subset ( arr , n ) : mp = new HashMap ( ) for i in range ( n ) : mp . put ( arr [ i ] , mp [ i ] == None ? 1 : mp [ arr [ i ] ] + 1 ) res = 0 for entry in mp . entrySet ( ) : res = max ( res , entry . value ) return res

34.9
38.97
45.99
39.93
int countTriangle ( int graph [ ] [ ] , boolean isDirected ) { int count_Triangle = 0 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 && graph [ k ] [ i ] == 1 ) count_Triangle ++ ; } } } if ( isDirected == true ) { count_Triangle /= 3 ; } else { count_Triangle /= 6 ; } return count_Triangle ; }

def countTriangle ( g , isDirected ) : nodes = len ( g ) count_Triangle = 0 for i in range ( nodes ) : for j in range ( nodes ) : for k in range ( nodes ) : if ( i != j and i != k and j != k and g [ i ] [ j ] and g [ j ] [ k ] and g [ k ] [ i ] ) : count_Triangle += 1 return count_Triangle / 3 if isDirected else count_Triangle / 6

def countTriangle ( graph , V , isDirected ) : count_Triangle = 0 for i in range ( len ( graph ) ) : for j in range ( 0 , V ) : if ( graph [ i ] [ j ] == 1 and graph [ k ] [ i ] == 1 ) : count_Triangle += 1 if ( isDirected == true ) : count_Triangle /= 3 return count_Triangle

def countTriangle ( graph , isDirected ) : count_Triangle = 0 for i in range ( V ) : for j in range ( 0 , V ) : for k in range ( 0 , V ) : if ( graph [ i ] [ j ] == 1 and graph [ j ] [ k ] == 1 and graph [ k ] [ i ] == 1 ) : count_Triangle += 1 if isDirected == True : count_Triangle /= 3 else : count_Triangle /= 6 return count_Triangle

34.9
25.47
15.87
21.12
static String to_upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) { if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) { in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) ; } } return String . valueOf ( in ) ; }

def to_upper ( string ) : for i in range ( len ( string ) ) : if ( 'a' <= string [ i ] <= 'z' ) : string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] ) return string

def to_upper ( in ) : in . sort ( reverse = True ) i = 0 for i in range ( len ( in ) ) : if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) : in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) return String . valueOf ( in )

def to_upper ( in ) : in = [ '' for i in in if 'a' <= in [ i ] & in [ i ] <= 'z' ] in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) return string ( in )

34.92
47.02
68.64
71.29
static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }

def sortedCount ( mat , r , c ) : result = 0 for i in range ( r ) : j = 0 for j in range ( c - 1 ) : if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : break if j == c - 2 : result += 1 for i in range ( 0 , r ) : j = 0 for j in range ( c - 1 , 0 , - 1 ) : if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : break if c > 1 and j == 1 : result += 1 return result

def sortedCount ( mat , r , c ) : result = 0 for i in range ( 0 , r , c ) : if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) : break if ( c > 1 and j == 0 ) : result ++ if ( j == c - 1 ) : result ++ return result

def sortedCount ( mat , r , c ) : result = 0 for i in range ( r ) : for j in range ( 0 , c - 1 , - 1 ) : if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) : break if ( j == c - 1 ) : result += 1 for i in range ( 0 , r ) : if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) : break if ( j == c - 1 ) : result += 1 return result

34.94
32.9
65.92
56.6
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }

def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) count = [ 0 ] * MAX_CHAR for i in range ( n ) : count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR ) : result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) return result

def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) for i in range ( n ) : count [ s [ i ] - 'a' ] += 1 result += count [ 'a' ] * count [ 'b' ] return result

def countSubstringWithEqualEnds ( s ) : result = 0 n = s . length ( ) count = [ MAX_CHAR for i in range ( 0 , n ) ] for i in range ( 0 , n ) : count [ s [ i ] - 'a' ] += 1 for i in range ( 0 , MAX_CHAR ) : result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) return result

34.96
33.65
25.16
22.12
static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " " ) ; } }

def substringConversions ( s , k , b ) : l = len ( s ) for i in range ( l ) : if ( ( i + k ) < l + 1 ) : sub = s [ i : i + k ] sum , counter = 0 , 0 for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) counter += 1 print ( sum , end = "" )

def substringConversions ( str , k , b ) : for i in range ( 0 , len ( str ) , k ) : sub = str [ i : i + k ] sum = 0 counter = 0 for j in range ( i + k , len ( str ) ) : sum = ( int ) ( sum + ( sub [ j ] - '0' ) * Math . pow ( b , counter ) ) print ( sum + " " ) counter = 0 for j in

def substringConversions ( str , k , b ) : sub = str . substring ( i , i + k ) sum = 0 counter = 0 for j in sub : sum = ( int ( sum + ( ( sub [ j ] - '0' ) * Math . pow ( b , counter ) ) ) counter += 1 print ( sum + " " )

34.98
22.25
39.22
22.69
static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }

def smallest ( x , y , z ) : c = 0 while ( x and y and z ) : x = x - 1 y = y - 1 z = z - 1 c = c + 1 return c

def smallest ( x , y , z ) : c = 0 while ( x != 0 && y != 0 && z != 0 ) : x -- ; y -- z c ++ while ( x != 0 && y != 0 ) : y -- z -- c ++ return c

def smallest ( x , y , z ) : c = 0 while x != 0 and y != 0 and z != 0 : x -- y -- z -- c += 1 return c

35.03
28.89
39.28
30.86
static int minStringValue ( String str , int k ) { int l = str . length ( ) ; if ( k >= l ) return 0 ; int [ ] frequency = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) frequency [ str . charAt ( i ) - 'a' ] ++ ; Comparator < Integer > c = new IntCompare ( ) ; PriorityQueue < Integer > q = new PriorityQueue < > ( c ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( frequency [ i ] != 0 ) q . add ( frequency [ i ] ) ; } while ( k != 0 ) { int temp = q . peek ( ) ; q . poll ( ) ; temp = temp - 1 ; q . add ( temp ) ; k -- ; } int result = 0 ; while ( ! q . isEmpty ( ) ) { int temp = q . peek ( ) ; result += temp * temp ; q . poll ( ) ; } return result ; }

def minStringValue ( str , k ) : l = len ( str ) if ( k >= l ) : return 0 frequency = [ 0 ] * MAX_CHAR for i in range ( 0 , l ) : frequency [ ord ( str [ i ] ) - 97 ] += 1 q = PriorityQueue ( ) for i in range ( 0 , MAX_CHAR ) : q . put ( - frequency [ i ] ) while ( k > 0 ) : temp = q . get ( ) temp = temp + 1 q . put ( temp , temp ) k = k - 1 result = 0 ; while not q . empty ( ) : temp = q . get ( ) temp = temp * ( - 1 ) result += temp * temp return result

def minStringValue ( str , k ) : l = len ( str ) for i in range ( l ) : frequency [ str [ i ] - 'a' ] += 1 q = PriorityQueue < Integer > ( c ) for i in range ( MAX_CHAR ) : if ( frequency [ i ] != 0 ) : q . add ( frequency [ i ] ) k -= 1 while ( k != 0 ) : temp = q . peek ( ) q . poll ( ) result += temp * temp return result

def minStringValue ( str , k ) : l = str . length ( k ) frequency = [ 0 for k in range ( l ) ] c = new IntCompare ( ) for i in range ( l ) : if ( frequency [ i ] != 0 ) : q . add ( frequency [ i ] ) for i in range ( MAX_CHAR ) : if ( frequency [ i ] != 0 ) : q . add ( frequency [ i ] ) k -= 1 if k != 0 : int temp = q . peek ( ) q . poll ( ) temp = temp - 1 q . add ( temp ) k -= 1 result = 0 while not q . isEmpty ( ) : temp = q . peek ( ) result += temp * temp q . poll ( ) return result

35.09
31.64
52.78
41.4
static void sortUsingHash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int hash [ ] = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] != 0 ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { System . out . print ( i + " " ) ; } } } }

def sortUsingHash ( a , n ) : Max = max ( a ) Hash = [ 0 ] * ( Max + 1 ) for i in range ( 0 , n ) : Hash [ a [ i ] ] += 1 for i in range ( 0 , Max + 1 ) : if Hash [ i ] != 0 : for j in range ( 0 , Hash [ i ] ) : print ( i , end = "" )

def sortUsingHash ( a , n ) : max = maxOf ( a , n ) hash = [ 0 for i in range ( max , n ) ] for i in range ( 0 , max + 1 , - 1 ) : if ( hash [ i ] != 0 ) : print ( i + " " ) if ( hash [ i ] != 1 ) : print ( j + " " ) if ( hash [ i ] != 0 ) : print ( i + " " )

def sortUsingHash ( a , n ) : max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) for i in range ( n ) : hash [ a [ i ] ] += 1 for i in range ( 0 , max ) : if ( hash [ i ] != 0 ) : for j in range ( hash [ i ] ) : print ( i + " " + j )

35.14
46.95
58.04
51.29
static void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }

def translate ( st ) : for i in range ( 1 , len ( st ) ) : if ( st [ i - 1 ] == 'A' and st [ i ] == 'B' ) : st [ i - 1 ] = 'C' for j in range ( i , len ( st ) - 1 ) : st [ j ] = st [ j + 1 ] st [ len ( st ) - 1 ] = '' return

def translate ( str ) : str . sort ( reverse = True ) i = 1 for i in range ( 1 , len ( str ) ) : if ( str [ i - 1 ] == 'A' and str [ i ] == 'B' ) : str [ i - 1 ] = 'C' str [ i - 1 ] = 'D' j = i for j in range ( i + 1 , len ( str ) - 1 ) : str [ j ] = str [ j + 1 ] if ( j <= str . length - 1 ) : str [ j ] = str [ j + 1 ] else : str [ j ] = str [ j + 1 ] return str [ i - 1 ]

def translate ( str ) : str . sort ( reverse = True ) for i in range ( 1 , len ( str ) ) : if ( str [ i - 1 ] == 'A' and str [ i ] == 'B' ) : str [ i - 1 ] = 'C' for j in range ( i , len ( str ) - 1 ) : str [ j ] = str [ j + 1 ] str [ j ] = ' '

35.16
37.48
39.29
33.77
static void printSubsequences ( int n ) { int opsize = ( int ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) System . out . print ( arr [ j ] + " " ) ; } System . out . println ( ) ; } }

def printSubsequences ( arr , n ) : opsize = math . pow ( 2 , n ) for counter in range ( 1 , ( int ) ( opsize ) ) : for j in range ( 0 , n ) : if ( counter & ( 1 << j ) ) : print ( arr [ j ] , end = "" ) print ( )

def printSubsequences ( n ) : arr = range ( n ) for counter in range ( 1 , opsize ) : for j in range ( n ) : if ( arr [ j ] . testBit ( j ) ) : print ( arr [ j ] + " " ) if ( counter == 1 ) : print ( arr [ j ] + " " ) if ( arr [ j ] . testBit ( j ) ) : print ( arr [ j ] + " " )

def printSubsequences ( n ) : opsize = ( 1 , n ) for counter in opsize : for j in range ( 1 , n ) : if BigInteger . valueOf ( counter ) . testBit ( j ) : print ( arr [ j ] )

35.24
32.78
35.36
36.29
static int longestNull ( String str ) { ArrayList < Pair > arr = new ArrayList < > ( ) ; arr . add ( new Pair ( '@' , - 1 ) ) ; int maxlen = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { arr . add ( new Pair ( str . charAt ( i ) , i ) ) ; while ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) - 3 ) . first == '1' && arr . get ( arr . size ( ) - 2 ) . first == '0' && arr . get ( arr . size ( ) - 1 ) . first == '0' ) { arr . remove ( arr . size ( ) - 3 ) ; arr . remove ( arr . size ( ) - 2 ) ; arr . remove ( arr . size ( ) - 1 ) ; } int tmp = arr . get ( arr . size ( ) - 1 ) . second ; maxlen = Math . max ( maxlen , i - tmp ) ; } return maxlen ; }

def longestNull ( S ) : arr = [ ] arr . append ( [ '@' , - 1 ] ) maxlen = 0 for i in range ( len ( S ) ) : arr . append ( [ S [ i ] , i ] ) while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] [ 0 ] == '1' and arr [ len ( arr ) - 2 ] [ 0 ] == '0' and arr [ len ( arr ) - 1 ] [ 0 ] == '0' ) : arr . pop ( ) arr . pop ( ) arr . pop ( ) tmp = arr [ - 1 ] maxlen = max ( maxlen , i - tmp [ 1 ] ) return maxlen

def longestNull ( str ) : arr = list ( ) for i in range ( len ( str ) ) : arr . add ( new Pair ( str [ i ] , i ) ) maxlen = max ( maxlen , i ) for i in range ( len ( str ) ) : arr . add ( new Pair ( str [ i ] , i ) ) if ( arr [ size ( ) >= 3 and arr [ size ( ) - 3 ] . first == '1' and arr [ arr . get ( ) - 1 ] . first == '0' ) : arr . remove ( arr . size ( ) - 2 ) : arr . remove ( arr . size ( ) - 1 ) maxlen = max ( maxlen , i - tmp ) return maxlen

def longestNull ( str ) : arr = [ ] maxlen = 0 for i in range ( len ( str ) ) : arr . add ( new Pair ( '@' , - 1 ) ) while arr . size ( ) >= 3 and arr . get ( arr . size ( ) - 3 ) . first == '1' and arr . get ( arr . size ( ) - 2 ) . first == '0' and arr . get ( arr . size ( ) - 1 ) . first == '0' : arr . remove ( arr . size ( ) - 3 ) arr . remove ( arr . size ( ) - 2 ) arr . remove ( arr . size ( ) - 1 ) maxlen = max ( maxlen , i - tmp ) return maxlen

35.25
30.19
57.91
40.58
static int count9s ( char number [ ] ) { int n = number . length ; int d [ ] = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( number [ i ] - '0' ) == 0 ) { continuous_zero ++ ; } else { continuous_zero = 0 ; } mod_sum += ( number [ i ] - '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; }

def count9s ( number ) : n = len ( number ) d = [ 0 for i in range ( 9 ) ] d [ 0 ] = 1 result = 0 mod_sum = 0 continuous_zero = 0 for i in range ( n ) : if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : continuous_zero += 1 else : continuous_zero = 0 mod_sum += ord ( number [ i ] ) - ord ( '0' ) mod_sum %= 9 result += d [ mod_sum ] d [ mod_sum ] += 1 result -= continuous_zero return result

def count9s ( number ) : d = [ 0 for k in range ( n ) ] mod_sum = 0 continuous_zero = 0 for i in range ( n ) : mod_sum += ( number [ i ] - '0' ) == 0 : continuous_zero = 0 result += d [ mod_sum ] d [ mod_sum ] ++ result -= continuous_zero return result

def count9s ( number ) : d = [ 1 for i in range ( n ) ] result = 0 mod_sum = 0 continuous_zero = 0 for i in range ( n ) : if ( ( number [ i ] - '0' ) == 0 ) : continuous_zero ++ else : continuous_zero = 0 mod_sum += ( number [ i ] - '0' ) mod_sum %= 9 result += d [ mod_sum ] d [ mod_sum ] ++ result -= continuous_zero return result

35.25
30.36
55.43
41.9
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }

def gcd ( a , b ) : if ( a == 0 ) : return b if ( b == 0 ) : return a k = 0 while ( ( ( a | b ) & 1 ) == 0 ) : a = a >> 1 b = b >> 1 k = k + 1 while ( ( a & 1 ) == 0 ) : a = a >> 1 while ( b != 0 ) : while ( ( b & 1 ) == 0 ) : b = b >> 1 if ( a > b ) : temp = a a = b b = temp b = ( b - a ) return ( a << k )

def gcd ( a , b ) : if ( a == 0 ) : return b k = 0 for k in range ( len ( a ) ) : while ( a & 1 ) == 0 : a >>= 1 b >>= 1 do { if ( b > a ) : b = a a = b b = ( b - a ) } while ( b != 0 ) : return a << k

def gcd ( a , b ) : a = a b = b k = 0 for k in range ( len ( a ) ) : a >>= 1 b >>= 1 while ( ( a & 1 ) == 0 ) : a >>= 1 if ( b & 1 ) == 0 : b >>= 1 do { while ( ( b & 1 ) == 0 ) : b >>= 1 : if ( a > b ) : a = b b = temp temp = a a = b b = temp temp = b b = b b = temp } b = ( b - a ) while ( b != 0 ) : a = ( a - a ) return a << k

35.27
36.09
42.43
34.08
static boolean checkStar ( int mat [ ] [ ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }

def checkStar ( mat ) : global size vertexD1 = 0 vertexDn_1 = 0 if ( size == 1 ) : return ( mat [ 0 ] [ 0 ] == 0 ) if ( size == 2 ) : return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) for i in range ( 0 , size ) : degreeI = 0 for j in range ( 0 , size ) : if ( mat [ i ] [ j ] ) : degreeI = degreeI + 1 if ( degreeI == 1 ) : vertexD1 = vertexD1 + 1 elif ( degreeI == size - 1 ) : vertexDn_1 = vertexDn_1 + 1 return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 )

def checkStar ( size , mat ) : vertexD1 = 0 vertexDn_1 = 0 if ( size == 1 ) : return ( mat [ 0 ] [ 0 ] == 1 and mat [ 0 ] [ 1 ] == 1 ) else : degreeI = 0 for j in range ( 0 , size ) : if ( mat [ i ] [ j ] == 1 ) : vertexD1 += 1 elif ( degreeI == size - 1 ) : vertexDn_1 +=

def checkStar ( mat ) : vertexD1 = 0 vertexDn_1 = 0 for i in range ( size ) : degreeI = 0 for j in range ( 0 , size ) : if ( mat [ i ] [ j ] == 1 ) : degreeI ++ if ( mat [ i ] [ j ] == 1 ) : degreeI += if ( degreeI == 1 ) vertexD1 += else if ( degreeI == size - 1 ) vertexDn_1 ++ : return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 ) return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 )

35.33
36.78
66.54
53.26
public static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " " + v . get ( i ) ) ; }

def printPairs ( arr , n ) : v = [ ] for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : v . append ( abs ( arr [ i ] ) ) if ( len ( v ) == 0 ) : return ; v . sort ( ) for i in range ( len ( v ) ) : print ( - v [ i ] , "" , v [ i ] , end = "" )

def printPairs ( arr , n ) : v = new Vector < Integer > ( ) for i in range ( 0 , n ) : if ( arr [ i ] == arr [ j ] ) : v . add ( i ) elif ( arr [ i ] == arr [ j ] ) : v . add ( j ) if ( v [ 0 ] == 0 ) : return printPairs ( arr , n )

def printPairs ( arr , n ) : v = list ( ) for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : v . add ( abs ( arr [ i ] ) ) if ( v . size ( ) == 0 ) : return print ( - v [ i ] + " " + v [ i ] )

35.53
20.01
100.0
100.0
static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }

def power ( n ) : if n == 1 : return 2 return 2 * power ( n - 1 )

def power ( n ) : if ( n == 0 ) : return 1

def power ( n ) : if n == 1 : return 2 return 2 * power ( n - 1 )

35.55
40.44
65.0
57.6
static void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence . get ( i ) ; int precedent = BrocotSequence . get ( i - 1 ) ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( BrocotSequence . get ( i ) + " " ) ; }

def SternSequenceFunc ( BrocotSequence , n ) : for i in range ( 1 , n ) : considered_element = BrocotSequence [ i ] precedent = BrocotSequence [ i - 1 ] BrocotSequence . append ( considered_element + precedent ) BrocotSequence . append ( considered_element ) for i in range ( 0 , 15 ) : print ( BrocotSequence [ i ] , end = "" )

def SternSequenceFunc ( BrocotSequence , n ) : BrocotSequence . clear ( ) for i in range ( 1 , n ) : if ( BrocotSequence [ i ] == 0 ) : BrocotSequence . add ( considered_element + precedent ) else : BrocotSequence [ i ] = considered_element + precedent BrocotSequence [ i ] = considered_element + precedent BrocotSequence [ i ] = considered_element BrocotSequence [ i ] = considered_element + precedent BrocotSequence . add ( considered_element ) print ( BrocotSequence [ i ] ) print ( BrocotSequence [ i ]

def SternSequenceFunc ( BrocotSequence , n ) : BrocotSequence . sort ( reverse = True ) for i in range ( 1 , n ) : considered_element = BrocotSequence [ i ] precedent = BrocotSequence [ i - 1 ] BrocotSequence . add ( considered_element + precedent ) BrocotSequence . add ( considered_element ) BrocotSequence . append ( considered_element )

35.55
32.53
42.96
43.52
boolean findPairs ( int arr [ ] ) { HashMap < Integer , pair > map = new HashMap < Integer , pair > ( ) ; int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( ! map . containsKey ( sum ) ) map . put ( sum , new pair ( i , j ) ) ; else { pair p = map . get ( sum ) ; System . out . println ( "(" + arr [ p . first ] + ", " + arr [ p . second ] + ") and (" + arr [ i ] + ", " + arr [ j ] + ")" ) ; return true ; } } } return false ; }

def findPairs ( arr , n ) : Hash = { } for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum = arr [ i ] + arr [ j ] if sum in Hash . keys ( ) : prev = Hash . get ( sum ) print ( str ( prev ) + "and(%d,%d)" % ( arr [ i ] , arr [ j ] ) ) return True else : Hash [ sum ] = ( arr [ i ] , arr [ j ] )

def findPairs ( arr ) : map = defaultdict ( pair ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( map . containsKey ( sum ) ) : map . put ( sum , new pair ( i , j ) ) else : p = map . get ( sum ) if ( p != null ) : print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" ) return true

def findPairs ( arr ) : map = new HashMap ( ) for i in range ( n ) : for j in range ( i + 1 , n ) : sum = arr [ i ] + arr [ j ] if not map . containsKey ( sum ) : map . put ( sum , new pair ( i , j ) ) else : pair p = map . get ( sum ) print ( "(" + arr [ p . first ] + ", " + arr [ p . second ] + ") and (" + arr [ i ] + ", " + arr [ j ] + ")" ) return True

35.58
50.99
57.83
60.72
static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + " " ) ; if ( n >= 1 ) System . out . print ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { System . out . print ( a + b + " " ) ; b = a + b ; a = b - a ; } }

def fib ( n ) : a = 0 b = 1 if ( n >= 0 ) : print ( a , end = '' ) if ( n >= 1 ) : print ( b , end = '' ) for i in range ( 2 , n + 1 ) : print ( a + b , end = '' ) b = a + b a = b - a

def fib ( n ) : a = 0 b = 1 for i in range ( 2 , n ) : a = a + b b = a - b if ( n >= 2 ) : print ( a + b + " " ) b = a + b if ( n >= 1 ) : print ( b + " " ) ; n = 2 while i <= n : a = a + b " " ) b = b - a if ( n >= 2 ) : print ( a ) if ( n >= 1 ) : print ( a ) if ( n >= 2 ) : print ( a + b + " " ) b = a - b return a

def fib ( n ) : a = 0 b = 1 if n >= 0 : print ( a + " " ) if n >= 1 : print ( b + " " ) for i in range ( 2 , n ) : print ( a + b + " " ) b = a + b a = b - a

35.66
36.82
38.41
42.79
static void rotatematrix ( int m , int n , int mat [ ] [ ] ) { int row = 0 , col = 0 ; int prev , curr ; while ( row < m && col < n ) { if ( row + 1 == m || col + 1 == n ) break ; prev = mat [ row + 1 ] [ col ] ; for ( int i = col ; i < n ; i ++ ) { curr = mat [ row ] [ i ] ; mat [ row ] [ i ] = prev ; prev = curr ; } row ++ ; for ( int i = row ; i < m ; i ++ ) { curr = mat [ i ] [ n - 1 ] ; mat [ i ] [ n - 1 ] = prev ; prev = curr ; } n -- ; if ( row < m ) { for ( int i = n - 1 ; i >= col ; i -- ) { curr = mat [ m - 1 ] [ i ] ; mat [ m - 1 ] [ i ] = prev ; prev = curr ; } } m -- ; if ( col < n ) { for ( int i = m - 1 ; i >= row ; i -- ) { curr = mat [ i ] [ col ] ; mat [ i ] [ col ] = prev ; prev = curr ; } } col ++ ; } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( mat [ i ] [ j ] + " " ) ; System . out . print ( "\n" ) ; } }

def rotateMatrix ( mat ) : if not len ( mat ) : return top = 0 bottom = len ( mat ) - 1 left = 0 right = len ( mat [ 0 ] ) - 1 while left < right and top < bottom : prev = mat [ top + 1 ] [ left ] for i in range ( left , right + 1 ) : curr = mat [ top ] [ i ] mat [ top ] [ i ] = prev prev = curr top += 1 for i in range ( top , bottom + 1 ) : curr = mat [ i ] [ right ] mat [ i ] [ right ] = prev prev = curr right -= 1 for i in range ( right , left - 1 , - 1 ) : curr = mat [ bottom ] [ i ] mat [ bottom ] [ i ] = prev prev = curr bottom -= 1 for i in range ( bottom , top - 1 , - 1 ) : curr = mat [ i ] [ left ] mat [ i ] [ left ] = prev prev = curr left += 1 return mat

def rotatematrix ( m , n , mat ) : row = 0 col = 0 prev = mat [ row + 1 ] [ col ] for i in range ( col , m ) : curr = mat [ row ] [ i ] mat [ row ] [ i ] = prev prev = curr if ( row < m ) : for i in range ( n - 1 , row + 1 ) : curr = mat [ i ] [ n - 1 ] = prev mat [ i ] [ n - 1 ] = curr if ( col < n ) : curr = mat [ i ] [ n - 1 ] = prev prev = curr if ( col < n ) : curr = mat [ i ] [ n - 1 ] = prev prev = curr if ( row < m ) : curr = mat [ i ] [ i ] = prev prev = curr if ( col < n - 1 ) : curr = mat [ i ] [ n - 1 ] = prev prev = curr if ( i >= row ) : curr = mat [ m - 1 ] [ i ] = curr if ( col < n ) : curr = mat [ i ] [ n - 1 ] = curr if ( col < n ) : curr = mat [ m - 1 ] [ i ]

def rotatematrix ( m , n , mat ) : row = 0 col = 0 prev = mat [ row + 1 ] [ col ] for i in range ( row + 1 , m , n ) : curr = mat [ row ] [ i ] mat [ row ] [ i ] = prev prev = curr row += 1 for i in range ( row + 1 , m ) : curr = mat [ i ] [ n - 1 ] mat [ i ] [ n - 1 ] = prev prev = curr row += 1 for i in range ( row + 1 , m ) : curr = mat [ i ] [ n - 1 ] mat [ i ] [ n - 1 ] = prev prev = curr row += 1 for i in range ( row + 1 , m , n ) : curr = mat [ i ] [ n - 1 ] mat [ i ] [ n - 1 ] = prev prev = curr row += 1 for i in range ( row + 1 , m , n ) : curr = mat [ i ] [ n - 1 ] mat [ i ] [ n - 1 ] = prev prev = curr row += 1 for i in range ( row + 1 , m , n ) : curr = mat [ i ] [ col ] mat

35.72
50.12
100.0
100.0
static double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }

def maxArea ( a , b , c , d ) : semiperimeter = ( a + b + c + d ) / 2 return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )

def maxArea ( a , b , c , d ) : semiperimeter = ( a + b + c + d ) / 2 return semiperimeter

def maxArea ( a , b , c , d ) : semiperimeter = ( a + b + c + d ) / 2 return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )

35.78
45.94
56.36
45.32
static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) System . out . print ( arr [ k ] + " " ) ; }

def arrayEvenAndOdd ( arr , n ) : i = - 1 j = 0 while ( j != n ) : if ( arr [ j ] % 2 == 0 ) : i = i + 1 arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] j = j + 1 for i in arr : print ( str ( i ) + "" , end = '' )

def arrayEvenAndOdd ( arr , n ) : i = - 1 j = 0 while ( j != n ) : if ( arr [ j ] % 2 == 0 ) : i += 1 arr [ j ] = arr [ i ] arr [ i ] = arr [ j ] j = 0 if ( arr [ j ] % 2 == 0 ) : arr [ j ] = temp i += 1 arr [ j ] = temp for k in range ( 0 , n ) : if ( k != 0 ) : arr [ k ] = arr [ k ] % 2 == 0 : print ( arr [ k ] + " " ) if ( arr [ k ] % 2 == 0 ) : print ( arr [ k ] + " " )

def arrayEvenAndOdd ( arr , n ) : i = - 1 j = 0 while j != n : if ( arr [ j ] % 2 == 0 ) : i ++ , temp = arr [ i ] arr [ i ] = arr [ j ] arr [ j ] = temp j ++ for k in range ( 0 , n ) : print ( arr [ k ] + " " )

35.86
35.62
50.22
41.61
static Boolean areElementsContiguous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ( ) ) ) ; }

def areElementsContiguous ( arr ) : us = set ( ) for i in arr : us . add ( i ) count = 1 curr_ele = arr [ 0 ] - 1 while curr_ele in us : count += 1 curr_ele -= 1 curr_ele = arr [ 0 ] + 1 while curr_ele in us : count += 1 curr_ele += 1 return ( count == len ( us ) )

def areElementsContiguous ( arr , n ) : us = new HashSet < Integer > ( ) for i in range ( n ) : us . add ( arr [ i ] ) count = 1 curr_ele = arr [ 0 ] while ( us . contains ( curr_ele ) == true ) : count ++ curr_ele -= 1 while ( us . contains ( curr_ele ) == true ) : count ++ curr_ele = arr [ 0 ] + 1 while ( us . contains ( curr_ele ) : us .

def areElementsContiguous ( arr , n ) : us = list ( ) count = 1 curr_ele = arr [ 0 ] - 1 while us . contains ( curr_ele ) == True : count += 1 curr_ele -= 1 curr_ele += 1 us = arr [ 0 ] + 1 while us . contains ( curr_ele ) == True : count += 1 curr_ele += arr [ 0 ] + 1 return ( count == ( us . size ( ) ) )

36.05
31.98
47.11
39.52
static int minInitialPoints ( int points [ ] [ ] , int R , int C ) { int dp [ ] [ ] = new int [ R ] [ C ] ; int m = R , n = C ; dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ; for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = Math . max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }

def minInitialPoints ( points ) : dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] m , n = R , C if points [ m - 1 ] [ n - 1 ] > 0 : dp [ m - 1 ] [ n - 1 ] = 1 else : dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 for i in range ( m - 2 , - 1 , - 1 ) : dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) for i in range ( 2 , - 1 , - 1 ) : dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) for i in range ( m - 2 , - 1 , - 1 ) : for j in range ( n - 2 , - 1 , - 1 ) : min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) return dp [ 0 ] [ 0 ]

def minInitialPoints ( points , R , C ) : dp = [ [ 0 for k in range ( R , C ) ] for k in range ( R , C ) : dp [ m - 1 ] [ n - 1 ] = float ( 'inf' ) for i in range ( m - 2 , n - 1 ) : dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) : dp [ i ] [ n - 1 ] = max ( dp [ m - 1 ] [ n - 1 ] - points [ m - 1 ] [ j ] = max ( min_points_on_exit , points [ i ] [ j ] ) return dp [ 0 ] [ 0 ]

def minInitialPoints ( points , R , C ) : dp [ ] = [ 1 for k in range ( m ) ] n = C dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : abs ( points [ m - 1 ] [ n - 1 ] ) + 1 for i in range ( m ) : dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) for j in range ( n ) : min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) return dp [ 0 ] [ 0 ]

36.11
33.96
48.75
42.37
static int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }

def FirstRepeated ( string ) : checker = 0 pos = 0 for i in string : val = ord ( i ) - ord ( 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) : return pos checker |= ( 1 << val ) pos += 1 return - 1

def FirstRepeated ( str ) : checker = 0 for i in range ( len ( str ) ) : val = ( str [ i ] - 'a' ) if ( checker & ( 1 << val ) ) > 0 : return i

def FirstRepeated ( str ) : checker = 0 for i in range ( len ( str ) ) : val = ( str [ i ] - 'a' ) if ( checker & ( 1 << val ) ) > 0 : return i checker |= ( 1 << val ) return - 1

36.16
33.78
36.97
28.84
static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( "" ) ; }

def nthPalindrome ( n , k ) : if ( k & 1 ) : temp = k // 2 else : temp = k // 2 - 1 palindrome = 10 ** temp palindrome = palindrome + n - 1 print ( palindrome , end = "" ) if ( k & 1 ) : palindrome = palindrome // 10 while ( palindrome ) : print ( palindrome % 10 , end = "" ) palindrome = palindrome // 10

def nthPalindrome ( n , k ) : temp = ( k & 1 ) != 0 ? k : k - 1 palindrome = ( int ) Math . pow ( 10 , temp ) palindrome += n - 1 while ( palindrome > 0 ) : palindrome /= 10 print ( palindrome ) palindrome -= n - 1 if ( k & 1 ) > 0 : palindrome /= 10 print ( "" ) palindrome = (

def nthPalindrome ( n , k ) : temp = ( k & 1 ) != 0 ? ( k / 2 - 1 ) : ( k / 2 - 1 ) palindrome = ( int ) Math . pow ( 10 , temp ) palindrome += n - 1 System . out . print ( palindrome ) if ( k & 1 ) > 0 : palindrome /= 10 while palindrome > 0 : print ( palindrome % 10 ) palindrome /= 10

36.18
51.97
36.18
51.97
static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; }

def largest ( arr , n ) : return max ( arr )

def largest ( arr , n ) : arr . sort ( reverse = True ) return arr [ n - 1 ]

def largest ( arr , n ) : arr . sort ( reverse = True ) return arr [ n - 1 ]

36.23
50.23
72.84
58.43
static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }

def findMaximum ( arr , low , high ) : max = arr [ low ] i = low for i in range ( high + 1 ) : if arr [ i ] > max : max = arr [ i ] return max

def findMaximum ( arr , low , high ) : max = arr [ low ] for i in range ( low , high ) : if ( arr [ i ] > max ) max = arr [ i ] if ( arr [ i ] > max ) : max = arr [ i ] if ( arr [ i ] > max ) : max = arr [ i ] if ( arr [ i ] > max ) : max = arr [ i ] return max

def findMaximum ( arr , low , high ) : max = arr [ low ] for i in range ( low , high ) : if ( arr [ i ] > max ) : max = arr [ i ] return max

36.25
38.77
17.8
20.17
static boolean isPossible ( int n , int index , int sum , int M , int arr [ ] , int dp [ ] [ ] ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } else if ( sum < 0 || sum >= MAX ) return false ; if ( dp [ index ] [ sum ] != - 1 ) { if ( dp [ index ] [ sum ] == 0 ) return false ; return true ; } boolean placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , M , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) ; boolean res = ( placeAdd || placeMinus ) ; dp [ index ] [ sum ] = ( res ) ? 1 : 0 ; return res ; }

def isPossible ( n , index , Sum , M , arr , dp ) : global MAX if index == n : if ( Sum % M ) == 0 : return True return False if dp [ index ] [ Sum ] != - 1 : return dp [ index ] [ Sum ] placeAdd = isPossible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp ) res = placeAdd or placeMinus dp [ index ] [ Sum ] = res return res

def isPossible ( n , index , sum , M , arr , dp ) : if ( sum % M == 0 ) : return true else : if ( index == n + 1 , sum + arr [ index ] , M , arr , dp ) : return isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) : return res

def isPossible ( n , index , sum , M , arr , dp ) : if sum < 0 or sum >= MAX : return False if dp [ index ] [ sum ] != - 1 : if ( dp [ index ] [ sum ] == 0 ) : return false return True

36.38
34.98
27.76
32.59
static boolean checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }

def checkplusperfect ( x ) : temp = x n = 0 while ( x != 0 ) : x = x // 10 n = n + 1 x = temp sm = 0 while ( x != 0 ) : sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) x = x // 10 return ( sm == temp )

def checkplusperfect ( x ) : temp = x n = 0 while ( x != 0 ) : sum += x % 10 n += 1 x = temp sum = 0 for x in range ( 1 , 20 ) : sum += x % 10 n += 1 return ( sum == temp )

def checkplusperfect ( x ) : temp = x n = 0 while x != 0 : sum += math . pow ( x % 10 , n ) x /= 10 return ( sum == temp )

36.44
37.66
46.63
47.49
static int evaluateBoolExpr ( StringBuffer s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s . charAt ( i + 1 ) == 'A' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == 'B' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . setCharAt ( i + 2 , '1' ) ; else s . setCharAt ( i + 2 , '0' ) ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } } } return s . charAt ( n - 1 ) - '0' ; }

def evaluateBoolExpr ( s ) : n = len ( s ) for i in range ( 0 , n - 2 , 2 ) : if ( s [ i + 1 ] == "A" ) : if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) : s [ i + 2 ] = "0" else : s [ i + 2 ] = "1" elif ( s [ i + 1 ] == "B" ) : if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) : s [ i + 2 ] = "1" else : s [ i + 2 ] = "0" else : if ( s [ i + 2 ] == s [ i ] ) : s [ i + 2 ] = "0" else : s [ i + 2 ] = "1" return ord ( s [ n - 1 ] ) - ord ( "0" )

def evaluateBoolExpr ( s ) : n = len ( s ) for i in range ( 0 , n ) : if ( s [ i ] == 'A' ) : if ( s [ i ] == '1' ) : s . setCharAt ( i + 2 , '1' ) else : s . setCharAt ( i + 2 , '0' ) if ( s [ i ] == 'B' ) : if ( s [ i ] == '0' ) : s . setCharAt ( i + 2 , '1' ) : s . setCharAt ( i + 2 , '1' ) : s . setCharAt ( i + 2 , '0' ) else : s . setCharAt ( i + 2 , '1' ) return s [ n - 1 ]

def evaluateBoolExpr ( s ) : n = len ( s ) for i in range ( n ) : if i + 1 < n and i + 2 < n : if ( s [ i + 1 ] == 'A' ) : if ( s [ i + 2 ] == '0' or s [ i ] == 0 ) : s . setCharAt ( i + 2 , '0' ) else : s . setCharAt ( i + 2 , '1' ) elif ( i + 1 ) < n and s [ i + 1 ] == 'B' : if ( s [ i + 2 ] == '1' or s [ i ] == '1' ) : s . setCharAt ( i + 2 , '1' ) else : if ( s [ i + 2 ] == s [ i ] ) : s . setCharAt ( i + 2 , '0' ) else : if ( s [ i + 2 ] == s [ i ] ) : s . setCharAt ( i + 2 , '1' ) else : if ( s [ i + 2 ] == s [ i ] ) : s . setCharAt ( i + 2 , '0' ) else : s .

36.53
31.06
71.72
62.31
static boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }

def ifPossible ( arr , n ) : cp = [ 0 ] * n cp = arr cp . sort ( ) for i in range ( 0 , n ) : if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : return False return True

def ifPossible ( arr , n ) : copy = [ 0 for k in range ( n ) ] for i in range ( 0 , n ) : if ( arr [ i ] == copy [ i ] ) : return false return true

def ifPossible ( arr , n ) : copy = [ INT_MAX for i in range ( n ) ] sort ( copy ) for i in range ( 0 , n ) : if ( not ( arr [ i ] == copy [ i ] ) and not ( arr [ n - 1 - i ] == copy [ i ] ) ) : return False return True

36.54
30.95
33.6
29.64
static void minSpacePreferLarge ( int wall , int m , int n ) { int num_m = 0 , num_n = 0 , min_empty = wall ; int p = 0 , q = 0 , rem ; while ( wall >= n ) { p = wall / m ; rem = wall % m ; if ( rem <= min_empty ) { num_m = p ; num_n = q ; min_empty = rem ; } q += 1 ; wall = wall - n ; } System . out . println ( num_m + " " + num_n + " " + min_empty ) ; }

def minSpacePreferLarge ( w , m , n ) : num_m = 0 num_n = 0 rem = w p = 0 q = 0 r = 0 while ( w >= n ) : p = w / m r = w % m if ( r <= rem ) : num_m = p num_n = q rem = r q += 1 w -= n print ( str ( int ( num_m ) ) + "" + str ( num_n ) + "" + str ( rem ) )

def minSpacePreferLarge ( wall , m , n ) : num_m = 0 num_n = 0 min_empty = wall for wall in range ( m , n ) : p = 0 q = 0 rem = wall % m if ( min_empty <= min_empty ) : num_m = p num_n = q min_empty = wall break if ( wall >= n ) : num_m = p num_n = q wall = wall -

def minSpacePreferLarge ( wall , m , n ) : num_m = 0 num_n = 0 min_empty = wall p = 0 q = 0 rem = 0 while wall >= n : p = wall / m rem = wall % m if ( rem <= min_empty ) : num_m = p num_n = q min_empty = rem while wall >= n : p = wall / m rem = wall % m if ( rem <= min_empty ) : num_m = p num_n = q min_empty = rem wall = wall - n return num_m , num_n , min_empty

36.55
41.58
38.13
34.94
public static void maxelement ( int no_of_rows , int [ ] [ ] arr ) { int i = 0 ; int max = 0 ; int [ ] result = new int [ no_of_rows ] ; while ( i < no_of_rows ) { for ( int j = 0 ; j < arr [ i ] . length ; j ++ ) { if ( arr [ i ] [ j ] > max ) { max = arr [ i ] [ j ] ; } } result [ i ] = max ; max = 0 ; i ++ ; } printArray ( result ) ; }

def maxelement ( arr ) : no_of_rows = len ( arr ) no_of_column = len ( arr [ 0 ] ) for i in range ( no_of_rows ) : max1 = 0 for j in range ( no_of_column ) : if arr [ i ] [ j ] > max1 : max1 = arr [ i ] [ j ] print ( max1 )

def maxelement ( no_of_rows , arr ) : result = [ 0 for i in range ( no_of_rows ) ] for i in range ( no_of_rows ) : for j in range ( i + 1 , no_of_rows ) : if ( arr [ i ] [ j ] > max ) : max = arr [ i ] [ j ] i += 1 if ( max == 0 ) : max = arr [ i ] [ j ] printArray ( result )

def maxelement ( no_of_rows , arr ) : max = 0 result = [ no_of_rows ] while i < no_of_rows : for j in range ( 0 , no_of_rows ) : if ( arr [ i ] [ j ] > max ) : max = arr [ i ] [ j ] print ( result [ i ] = max , max = 0 i ++ ) printArray ( result )

36.61
40.75
43.64
36.46
public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; double r = 6371 ; return ( c * r ) ; }

def distance ( lat1 , lat2 , lon1 , lon2 ) : lon1 = radians ( lon1 ) lon2 = radians ( lon2 ) lat1 = radians ( lat1 ) lat2 = radians ( lat2 ) dlon = lon2 - lon1 dlat = lat2 - lat1 a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 c = 2 * asin ( sqrt ( a ) ) r = 6371 return ( c * r )

def distance ( lat1 , lat2 , lon1 , lon2 ) : lon1 = toRadians ( lon1 ) lat2 = toRadians ( lat2 ) dlon = lon2 - lon1 dlat = lat1 - lat2 a = 2 * Math . pow ( dlat , 2 ) + Math . cos ( lat1 ) * Math . pow ( dlon , 2 ) return ( c * r )

def distance ( lat1 , lat2 , lon1 , lon2 ) : dlon = lon2 - lon1 lat1 = lat2 - lat1 dlat = lat2 - lat1 a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . sin ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) + Math . sin ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) c = 2 * math . asin ( math . sqrt ( a ) ) r = 6371 return ( c * r )

36.74
35.54
55.67
57.51
static long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }

def countNonDecreasing ( n ) : N = 10 count = 1 for i in range ( 1 , n + 1 ) : count = int ( count * ( N + i - 1 ) ) count = int ( count / i ) return count

def countNonDecreasing ( n ) : N = 100 for i in range ( 1 , n ) : count *= N + i - 1 count /= i return count

def countNonDecreasing ( n ) : N = 10 count = 1 for i in range ( 1 , n ) : count *= ( N + i - 1 ) count /= i return count

36.74
34.34
40.4
37.51
static void printRotatedString ( String str ) { int len = str . length ( ) ; StringBuffer sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuffer ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . length ( ) ; k2 ++ ) { sb . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( sb ) ; } }

def printRotatedString ( str ) : lenn = len ( str ) temp = [ 0 ] * ( lenn ) for i in range ( lenn ) : j = i k = 0 while ( j < len ( str ) ) : temp [ k ] = str [ j ] k += 1 j += 1 j = 0 while ( j < i ) : temp [ k ] = str [ j ] j += 1 k += 1 print ( * temp , sep = "" )

def printRotatedString ( str ) : len = len ( str ) for i in range ( len ) : sb = new StringBuffer ( ) for j in range ( i ) : sb . insert ( k , str [ j ] ) k += 1 j = 0 while ( j < i ) : sb . insert ( k , str [ j ] ) j ++ k += 1 if ( k2 < len ) : sb . insert ( k , str [ k2 ] ) : sb .

def printRotatedString ( str ) : len = str . length ( ) sb = list ( ) for i in range ( len ) : sb = list ( ) for j in range ( i ) : sb . append ( str [ j ] ) k = 0 for k2 in j : sb . insert ( k , str [ j ] ) k += 1 j += 1 j = 0 while ( j < i ) : sb . insert ( k , str [ j ] ) j += 1 k += 1 print ( sb )

36.74
39.0
65.14
56.45
static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " " ) ; }

def findMissing ( a , b , n , m ) : s = dict ( ) for i in range ( m ) : s [ b [ i ] ] = 1 for i in range ( n ) : if a [ i ] not in s . keys ( ) : print ( a [ i ] , end = "" )

def findMissing ( a , b , n , m ) : s = new HashSet < Integer > ( ) for i in range ( 0 , n , m ) : if ( ! s . contains ( a [ i ] ) ) : print ( a [ i ] + " " ) else : print ( b [ i ] + " " ) for i in range ( 0 , n , m ) : if ( ! s . contains ( a [ i ] ) ) : print ( a [ i ] + "

def findMissing ( a , b , n , m ) : s = list ( ) for i in range ( m ) : s . add ( b [ i ] ) for i in range ( n ) : if not s . contains ( a [ i ] ) : print ( a [ i ] + " " )

36.75
30.17
43.77
32.96
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; ( i + j ) < n && j <= MAX_CHAR ; j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ; return result ; }

def countPairs ( str1 ) : result = 0 ; n = len ( str1 ) for i in range ( 0 , n ) : for j in range ( 1 , MAX_CHAR + 1 ) : if ( ( i + j ) < n ) : if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : result += 1 ; return result

def countPairs ( str ) : result = 0 for i in range ( 0 , n ) : for j in range ( 1 , n ) : if ( str [ i + j ] == str [ i + j ] ) : result += 1 return result

def countPairs ( str ) : result = 0 n = str . length for i in range ( n ) : for j in range ( 1 , n , MAX_CHAR ) : if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) : result += 1 return result

36.75
30.59
44.22
30.36
static double findArea ( int r ) { return PI * Math . pow ( r , 2 ) ; }

def findArea ( r ) : PI = 3.142 return PI * ( r * r )

def findArea ( r ) : return PI * r

def findArea ( r ) : return PI * math . pow ( r , 2 )

36.75
48.07
31.89
50.28
static long yMod ( long y , long x ) { if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y ; if ( x > 63 ) return y ; return ( y % ( 1 << ( int ) x ) ) ; }

def yMod ( y , x ) : return ( y % pow ( 2 , x ) )

def yMod ( y , x ) : if ( y < 0 ) : return y if ( x > 63 ) : return y

def yMod ( y , x ) : if ( y < 0 ) : return y if x > 63 : return y return ( y % ( 1 << ( int ) x ) )

36.76
31.08
38.07
36.15
static void NFG ( int a [ ] , int n , int freq [ ] ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; int res [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ] && s . size ( ) > 0 ) { res [ s . peek ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( s . size ( ) > 0 ) { res [ s . peek ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " " ) ; } }

def NFG ( a , n ) : if ( n <= 0 ) : print ( "Listempty" ) return [ ] stack = [ 0 ] * n freq = { } for i in a : freq [ a [ i ] ] = 0 for i in a : freq [ a [ i ] ] += 1 res = [ 0 ] * n top = - 1 top += 1 stack [ top ] = 0 for i in range ( 1 , n ) : if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) : top += 1 stack [ top ] = i else : while ( top > - 1 and freq [ a [ stack [ top ] ] ] < freq [ a [ i ] ] ) : res [ stack [ top ] ] = a [ i ] top -= 1 top += 1 stack [ top ] = i while ( top > - 1 ) : res [ stack [ top ] ] = - 1 top -= 1 return res

def NFG ( a , n , freq ) : s = list ( ) for i in range ( n ) : if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) : s . push ( i ) else : while ( freq [ a [ s . peek ( ) ] < freq [ a [ i ] ] ) : res [ i ] = - 1 s . pop ( ) if ( s . size ( ) > 0 ) : res [ i ] = i else : while ( s . size ( ) > 0 ) : res [ i ] = a [ i ] if ( freq [ a [ s . peek ( ) ] > freq [ a [ i ] ) : s . pop ( ) return : while ( s . size ( ) > 0 ) : res [ s . peek ( ) ] = freq [ a [ i ] ] s . pop ( ) return :

def NFG ( a , n , freq ) : s . append ( 0 ) res = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : if freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] : s . append ( i ) else : while freq [ a [ s [ peek ( ) ] ] < freq [ a [ i ] ] and s . size ( ) > 0 : res [ s . peek ( ) ] = a [ i ] s . pop ( ) } for i in range ( 1 , n ) : res [ i ] = 0 for i in range ( 1 , n ) : if freq [ a [ s [ i ] ] ] > freq [ a [ i ] ] : s . append ( i ) else : while freq [ a [ s [ i ] ] ] < freq [ a [ i ] ] and s . size ( ) > 0 : res [ s [ i ] ] = a [ i ] s . pop ( )

36.77
47.11
47.8
35.71
public static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " " ) ; } }

def sequence ( n ) : f = [ 0 , 1 , 1 ] print ( f [ 1 ] , end = "" ) , print ( f [ 2 ] , end = "" ) , for i in range ( 3 , n + 1 ) : f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) print ( f [ i ] , end = "" ) ,

def sequence ( n ) : f = [ 0 for k in range ( n ) ] f [ 0 ] = 1 f [ 1 ] = 1 f [ 2 ] = 1 f [ 3 ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] print ( f [ i ] + " " ) for i in range ( 3 , n ) : f [ i ] = f [ f [ i - 1 ] + f [ i - f [ i - 1 ] if ( i <= n ) : f [ i ] = f [ i - f [ i - 1 ] print ( f [ i ] + " " ) print ( f [ i ] + " " )

def sequence ( n ) : f = [ 0 ] f [ 0 ] = 0 f [ 1 ] = 1 f [ 2 ] = 1 f [ 3 ] = 1 f [ 2 ] = 1 print ( f [ 1 ] + " " + f [ 2 ] + " " ) for i in range ( 3 , n ) : f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] System . out . print ( f [ i ] )

36.78
43.75
27.43
28.17
static int count ( String s , int len ) { int MAX = 1000 ; int cur = 0 , dig = 0 ; int [ ] sum = new int [ MAX ] ; int [ ] [ ] dp = new int [ MAX ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; if ( dig == 8 ) ans ++ ; if ( i - 2 >= 0 ) { dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ; } if ( i - 3 >= 0 ) { dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ; dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) continue ; ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; }

def count ( s , Len ) : global MAX cur = 0 dig = 0 Sum = [ 0 ] * MAX dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , Len + 1 ) : dig = int ( s [ i - 1 ] ) - 48 cur += dig cur %= 3 Sum [ i ] = cur dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] dp [ i ] [ Sum [ i ] ] += 1 ans = 0 dprev = 0 value = 0 dprev2 = 0 for i in range ( 1 , Len + 1 ) : dig = int ( s [ i - 1 ] ) - 48 if dig == 8 : ans += 1 if i - 2 >= 0 : dprev = int ( s [ i - 2 ] ) - 48 value = dprev * 10 + dig if ( value % 8 == 0 ) and ( value % 3 != 0 ) : ans += 1 if i - 3 >= 0 : dprev2 = int ( s [ i - 3 ] ) - 48 dprev = int ( s [ i - 2 ] ) - 48 value = ( dprev2 * 100 + dprev * 10 + dig ) if value % 8 != 0 : continue ans += ( i - 2 ) ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) return ans

def count ( s , len ) : sum = [ 0 for k in range ( len ) ] dp = [ 0 for k in range ( len ) ] cur = 0 dig = 0 sum [ i ] = 0 dp [ i ] [ 0 ] = 1 dp [ i ] [ 1 ] = dp [ i - 1 ] [ 2 ] = 1 cur %= 3 sum [ i ] = cur for i in range ( 1 , len ) : dig = ( int ) ( s [ i - 1 ] ) if ( dig == 8 ) : dprev = ( int ) ( s [ i - 1 ] ) dprev2 = ( int ) ( s [ i - 2 ) : dprev2 = dprev * 10 + dig if ( value % 8 == 0 ) : ans += 1 if ( dprev2 % 3 != 0 ) : ans += 1 if ( i - 3 >= 0 ) : dprev2 = dprev * 10 + dig if ( value % 3 != 0 ) : ans += 1 if ( dprev2 % 8 == 0 ) : dprev2 = ( int ) ( s [ i - 3 ) ) ans += 1 if ( dprev2 % 3 != 0 ) : ans += 1 if ( value %

def count ( s , len ) : dig = 0 sum = [ 0 for k in range ( len ) ] cur = 0 dig = 0 sum [ i ] = cur cur %= 3 sum [ i ] = cur dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] dp [ i ] [ sum [ i ] ] += 1 dp [ i ] [ sum [ i ] ] = cur dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] dp [ i ] [ sum [ i ] ] += 1 return ans

36.79
39.33
100.0
100.0
static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }

def procal ( n ) : return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )

def procal ( n ) : return ( 3.0 * n )

def procal ( n ) : return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )

36.79
40.26
100.0
100.0
int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }

def hexagonalNum ( n ) : return n * ( 2 * n - 1 )

def hexagonalNum ( n ) : return n

def hexagonalNum ( n ) : return n * ( 2 * n - 1 )

36.79
23.38
100.0
100.0
static int addOne ( int x ) { return ( - ( ~ x ) ) ; }

def addOne ( x ) : return ( - ( ~ x ) )

def addOne ( x ) : return

def addOne ( x ) : return ( - ( ~ x ) )

36.84
45.95
43.94
59.92
static double squareRoot ( double n ) { return Math . pow ( 2 , 0.5 * ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }

def squareRoot ( n ) : return pow ( 2 , 0.5 * math . log2 ( n ) )

def squareRoot ( n ) : return 0.5 * ( n )

def squareRoot ( n ) : return math . pow ( 2 , 0.5 * ( math . log ( n ) / math . log ( 2 ) )

36.84
47.88
51.67
46.05
static void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( "The complete array is sorted" ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " The unsorted subarray which" + " makes the given array sorted lies" + " between the indices " + s + " and " + e ) ; return ; }

def printUnsorted ( arr , n ) : e = n - 1 for s in range ( 0 , n - 1 ) : if arr [ s ] > arr [ s + 1 ] : break if s == n - 1 : print ( "Thecompletearrayissorted" ) exit ( ) e = n - 1 while e > 0 : if arr [ e ] < arr [ e - 1 ] : break e -= 1 max = arr [ s ] min = arr [ s ] for i in range ( s + 1 , e + 1 ) : if arr [ i ] > max : max = arr [ i ] if arr [ i ] < min : min = arr [ i ] for i in range ( s ) : if arr [ i ] > min : s = i break i = n - 1 while i >= e + 1 : if arr [ i ] < max : e = i break i -= 1 print ( "Theunsortedsubarraywhichmakesthegivenarray" ) print ( "sortedliesbetweentheindexes%dand%d" % ( s , e ) )

def printUnsorted ( arr , n ) : s = 0 e = n - 1 for s in range ( n ) : if ( arr [ s ] > arr [ s + 1 ] ) : max = arr [ s ] if ( arr [ s ] < arr [ s - 1 ] ) : min = arr [ s ] if ( arr [ e ] > arr [ e - 1 ] ) : max = arr [ e ] i = s + 1 while i <= e + 1 : if ( arr [ i ] > min ) : min = arr [ i ] if ( arr [ i ] < min ) : min = arr [ i ] if ( arr [ i ] > max ) : max = arr [ i ] if ( arr [ i ] < min ) : min = arr [ i ] s = i break if ( arr [ i ] > max ) : max = arr [ i ] if ( arr [ i ] < min ) : e = i break if ( arr [ i ] > max ) : min = arr [ i ] if ( arr [ i ] < min ) : s = i break if ( arr [ i ] > max ) : max = arr [ i ] if ( arr [ i ] < min )

def printUnsorted ( arr , n ) : s = 0 e = n - 1 for s in range ( n ) : if ( arr [ s ] > arr [ s + 1 ] ) : max = arr [ s ] min = arr [ s ] for i in range ( s + 1 , e ) : if ( arr [ i ] > max ) : max = arr [ i ] if ( arr [ i ] < min ) : min = arr [ i ] for i in range ( s + 1 , e ) : if ( arr [ i ] > min ) : min = arr [ i ] if ( i < n - 1 ) : if ( arr [ i ] < max ) : e = i break print ( " The unsorted subarray which" + " makes the given array sorted lies" + " between the indices " + s + " and " + e ) return

36.85
40.24
32.62
32.91
static int printKDistinct ( int arr [ ] , int n , int k ) { Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ; else h . put ( arr [ i ] , 1 ) ; } if ( h . size ( ) < k ) return - 1 ; int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . get ( arr [ i ] ) == 1 ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }

def printKDistinct ( arr , size , KthIndex ) : dict = { } vect = [ ] for i in range ( size ) : if ( arr [ i ] in dict ) : dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 else : dict [ arr [ i ] ] = 1 for i in range ( size ) : if ( dict [ arr [ i ] ] > 1 ) : continue else : KthIndex = KthIndex - 1 if ( KthIndex == 0 ) : return arr [ i ] return - 1

def printKDistinct ( arr , n , k ) : h = defaultdict ( int ) for i in range ( 0 , n ) : if ( h [ arr [ i ] ] == 1 ) : h . put ( arr [ i ] , 1 ) if ( dist_count == k ) : return arr [ i ] dist_count = 0 for i in range ( 0 , n ) : if ( h [ arr [ i ] ] == 1 ) : dist_count += 1 if ( dist_count == k ) : return arr [ i ] if ( dist_count == k ) : return arr [ i ]

def printKDistinct ( arr , n , k ) : h = { } for i in range ( n ) : if ( h . containsKey ( arr [ i ] ) ) : h [ arr [ i ] ] = h [ arr [ i ] ] + 1 else : h [ arr [ i ] ] = 1 return arr [ i ]

36.93
41.75
39.39
48.98
static void sortString ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . print ( String . valueOf ( arr ) ) ; }

def sortString ( str ) : str = '' . join ( sorted ( str ) ) print ( str )

def sortString ( str ) : arr = str . toCharArray ( ) print ( arr ) print ( "\n" )

def sortString ( str ) : arr = str . toCharArray ( ) arr . sort ( reverse = True ) print ( str )

37.01
39.31
52.71
39.9
static int selectRandom ( int x ) { count ++ ; if ( count == 1 ) res = x ; else { Random r = new Random ( ) ; int i = r . nextInt ( count ) ; if ( i == count - 1 ) res = x ; } return res ; }

def selectRandom ( x ) : res = 0 count = 0 count += 1 if ( count == 1 ) : res = x else : i = random . randrange ( count ) if ( i == count - 1 ) : res = x return res

def selectRandom ( count ) : res = x if ( count == 1 ) : res = x else : count -= 1 r = new Random ( ) for i in range ( count ) : if ( i == count - 1 ) : res = x if ( i == count - 1 ) : res = x else : res = selectRandom ( count ) if ( i == count - 1 ) : res = x

def selectRandom ( x ) : count = 1 res = x for i in range ( count ) : r = random ( ) i = r . nextInt ( count ) if ( i == count - 1 ) : res = x return res

37.04
39.81
78.7
62.84
static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }

def addOne ( x ) : m = 1 while ( x & m ) : x = x ^ m m <<= 1 x = x ^ m return x

def addOne ( x ) : m = 1 x = x ^ m return x

def addOne ( x ) : m = 1 while len ( x ) >= 1 : x = x ^ m m <<= 1 x = x ^ m return x

37.06
47.89
69.34
74.89
static int summingSeries ( long n ) { return ( int ) Math . pow ( n , 2 ) ; }

def summingSeries ( n ) : return math . pow ( n , 2 )

def summingSeries ( n ) : return n

def summingSeries ( n ) : return ( int ( math . pow ( n , 2 ) )

37.11
37.4
64.6
53.06
static int minimumflip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }

def minimumflip ( mat , n ) : transpose = [ [ 0 ] * n ] * n for i in range ( n ) : for j in range ( n ) : transpose [ i ] [ j ] = mat [ j ] [ i ] flip = 0 for i in range ( n ) : for j in range ( n ) : if transpose [ i ] [ j ] != mat [ i ] [ j ] : flip += 1 return int ( flip / 2 )

def minimumflip ( mat , n ) : transpose = [ 0 for i in range ( n ) ] for i in range ( n ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : flip += 1 return flip / 2

def minimumflip ( mat , n ) : transpose [ ] = [ 0 for i in range ( n ) ] for j in range ( 0 , n ) : transpose [ i ] [ j ] = mat [ j ] [ i ] flip = 0 for i in range ( 0 , n ) : if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) : flip ++ return flip / 2

37.12
27.59
30.36
20.32
static void printPath ( String str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { int nextX = ( str . charAt ( i ) - 'A' ) / 5 ; int nextY = ( str . charAt ( i ) - 'B' + 1 ) % 5 ; while ( curX > nextX ) { System . out . println ( "Move Up" ) ; curX -- ; } while ( curY > nextY ) { System . out . println ( "Move Left" ) ; curY -- ; } while ( curX < nextX ) { System . out . println ( "Move Down" ) ; curX ++ ; } while ( curY < nextY ) { System . out . println ( "Move Right" ) ; curY ++ ; } System . out . println ( "Press OK" ) ; i ++ ; } }

def printPath ( str ) : i = 0 curX = 0 curY = 0 while ( i < len ( str ) ) : nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 ) nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5 while ( curX > nextX ) : print ( "MoveUp" ) curX -= 1 while ( curY > nextY ) : print ( "MoveLeft" ) curY -= 1 while ( curX < nextX ) : print ( "MoveDown" ) curX += 1 while ( curY < nextY ) : print ( "MoveRight" ) curY += 1 print ( "PressOK" ) i += 1

def printPath ( str ) : i = 0 curX = 0 curY = 0 while ( i < len ( str ) ) : nextX = ( str [ i ] - 'A' + 1 ) // 5 nextY = ( str [ i ] - 'B' + 1 ) // 5 while ( curX > nextX ) : System . out . println ( "Move Up" ) curX -= 1 while ( curY > nextY ) : System . out .

def printPath ( str ) : curX = 0 curY = 0 for i in range ( len ( str ) ) : nextX = ( str [ i ] - 'A' ) // 5 nextY = ( str [ i ] - 'B' + 1 ) % 5 while curX > nextX : print ( "Move Up" ) curX -- if curY > nextY : print ( "Move Left" ) curY -- if curX < nextX : print ( "Move Down" ) curX ++ if curY < nextY : print ( "Move Right" ) curY ++

37.14
35.33
53.8
45.41
static int maximumNumberDistinctPrimeRange ( int m , int n ) { long factorCount [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; }

def maximumNumberDistinctPrimeRange ( m , n ) : factorCount = [ 0 ] * ( n + 1 ) prime = [ False ] * ( n + 1 ) for i in range ( n + 1 ) : factorCount [ i ] = 0 prime [ i ] = True for i in range ( 2 , n + 1 ) : if ( prime [ i ] == True ) : factorCount [ i ] = 1 for j in range ( i * 2 , n + 1 , i ) : factorCount [ j ] += 1 prime [ j ] = False max = factorCount [ m ] num = m for i in range ( m , n + 1 ) : if ( factorCount [ i ] > max ) : max = factorCount [ i ] num = i return num

def maximumNumberDistinctPrimeRange ( m , n ) : factorCount = [ 0 for i in range ( n ) ] prime = [ true for i in range ( n ) ] for i in range ( 2 , n ) : factorCount [ i ] = 1 prime [ i ] = true for i in range ( 2 , n ) : if ( prime [ i ] == true ) : factorCount [ i ] = 1 max = ( int ) factorCount [ i ] num = i if ( i <= m ) : max = ( int ) factorCount [ i ] = 1 num = i if ( factorCount [ i ] > max ) : max = ( int ) factorCount [ i ] num = i if ( factorCount [ i ] > max ) : max = ( int ) factorCount [ i ] num = i if ( prime [ i ] == true ) : prime [ i ] = false else : max = ( int ) factorCount [ i ] num = i if ( factorCount [ i ] > max ) : max = ( int ) factorCount [ i ] return num

def maximumNumberDistinctPrimeRange ( m , n ) : factorCount = [ 0 for k in range ( n ) ] prime = [ True for k in range ( 2 , n ) ] for i in range ( 2 , n ) : if ( prime [ i ] == True ) : factorCount [ i ] = 1 for j in range ( i * 2 , n ) : factorCount [ j ] += 1 prime [ j ] = False for i in range ( 2 , n ) : if ( prime [ i ] == True ) : factorCount [ i ] = 1 for j in range ( i * 2 , n ) : factorCount [ j ] += 1 prime [ j ] = False return num

37.19
35.52
74.1
71.03
static int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }

def compute_average ( a , b ) : return floor ( ( a + b ) / 2 )

def compute_average ( a , b ) : return a

def compute_average ( a , b ) : return ( a + b ) / 2

37.21
44.84
87.64
84.26
static boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }

def isScalarMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False for i in range ( 0 , N - 1 ) : if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : return False return True

def isScalarMatrix ( N , mat ) : mat . sort ( reverse = True ) for i in range ( 0 , N ) : if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : return false return true

def isScalarMatrix ( mat ) : for i in range ( N ) : for j in range ( N ) : if ( i != j ) and ( mat [ i ] [ j ] != 0 ) : return False for i in range ( 0 , N - 1 ) : if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : return False return True

37.21
33.71
41.73
32.06
static void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }

def shuffleArray ( a , n ) : i , q , k = 0 , 1 , n while ( i < n ) : j = k while ( j > i + q ) : a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] j -= 1 i += 1 k += 1 q += 1

def shuffleArray ( a , n ) : a . sort ( reverse = True ) k = 1 q = 1 for i in range ( n ) : for j in range ( k , n ) : if ( j > i + q ) : a [ j - 1 ] = a [ j ] a [ j ] = temp temp = a [ j - 1 ] a [ j - 1 ] = a [ j ] a [ j ] = temp temp = a [ j -

def shuffleArray ( a , n ) : q = 1 k = n for i in range ( n ) : for j in range ( k ) : if j > i + q : temp = a [ j - 1 ] a [ j - 1 ] = a [ j ] a [ j ] = temp

37.27
30.3
10.47
12.86
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }

def decToHexa ( n ) : hexaDeciNum = [ '0' ] * 100 i = 0 while ( n != 0 ) : temp = 0 temp = n % 16 if ( temp < 10 ) : hexaDeciNum [ i ] = chr ( temp + 48 ) i = i + 1 else : hexaDeciNum [ i ] = chr ( temp + 55 ) i = i + 1 n = int ( n / 16 ) j = i - 1 while ( j >= 0 ) : print ( ( hexaDeciNum [ j ] ) , end = "" ) j = j - 1

def decToHexa ( n ) : hexaDeciNum = [ '' for n in range ( 100 ) ] i = 0 while n != 0 : temp = 0 hexaDeciNum [ i ] = ( char ) ( temp + 48 ) i ++ if ( temp < 10 ) : hexaDeciNum [ i ] = ( char ) ( temp + 55 ) n = n / 16 i = 0 while n != 0 : hexaDeciNum [ i ] = ( char

def decToHexa ( n ) : hexaDeciNum = [ 0 for k in range ( 100 ) ] for j in range ( i - 1 , - 1 , - 1 ) : print ( hexaDeciNum [ j ] ) n = n // 16

37.27
28.5
100.0
100.0
static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }

def calculateSum ( n ) : sum = 0 sum = 1 << n return ( sum - 1 )

def calculateSum ( n ) : sum = 0 return sum

def calculateSum ( n ) : sum = 0 sum = 1 << n return ( sum - 1 )

37.33
37.74
42.47
40.25
public static void printPascal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( "" ) ; } }

def printPascal ( n : int ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for line in range ( 0 , n ) : for i in range ( 0 , line + 1 ) : if ( i is 0 or i is line ) : arr [ line ] [ i ] = 1 print ( arr [ line ] [ i ] , end = "" ) else : arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) print ( arr [ line ] [ i ] , end = "" ) print ( "\n" , end = "" )

def printPascal ( n ) : arr = [ INT_MAX for line in range ( n ) ] for i in range ( 0 , n ) : if ( line == i || i == 0 ) : arr [ line ] [ i ] = 1 else : arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] return

def printPascal ( n ) : arr = [ 0 for line in range ( n ) ] for line in range ( n ) : for i in range ( line , n ) : if ( line == i || i == 0 ) : arr [ line ] [ i ] = 1 else : arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ]

37.35
43.5
65.39
74.31
static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }

def sumofoddFactors ( n ) : res = 1 while n % 2 == 0 : n = n // 2 for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : count = 0 curr_sum = 1 curr_term = 1 while n % i == 0 : count += 1 n = n // i curr_term *= i curr_sum += curr_term res *= curr_sum if n >= 2 : res *= ( 1 + n ) return res

def sumofoddFactors ( n ) : res = 1 n = n / 2 for i in range ( 3 , 20 ) : curr_sum = 1 curr_term = 1 n = n / i for i in range ( 3 , 20 ) : curr_sum += curr_term if ( n >= 2 ) res *= ( 1 + n ) return res

def sumofoddFactors ( n ) : res = 1 for i in range ( 3 ) : count = 0 curr_sum = 1 curr_term = 1 while n % i == 0 : count += 1 n = n // i curr_term *= i curr_sum += curr_term res *= curr_sum if n >= 2 : res *= ( 1 + n ) return res

37.35
40.68
32.58
33.2
static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return String . valueOf ( arr ) ; }

def replace ( s , c1 , c2 ) : l = len ( s ) for i in range ( l ) : if ( s [ i ] == c1 ) : s = s [ 0 : i ] + c2 + s [ i + 1 : ] elif ( s [ i ] == c2 ) : s = s [ 0 : i ] + c1 + s [ i + 1 : ] return s

def replace ( s , c1 , c2 ) : l = len ( s ) for i in range ( l ) : if ( arr [ i ] == c1 ) : arr [ i ] = c2 else : arr [ i ] = c1 return s

def replace ( s , c1 , c2 ) : arr = s . toCharArray ( ) for i in range ( l ) : if ( arr [ i ] == c1 ) : arr [ i ] = c2 else : arr [ i ] = c1 return string . valueOf ( arr )

37.38
33.2
66.59
49.78
static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }

def MaxTotalRectangleArea ( a , n ) : a . sort ( reverse = True ) sum = 0 flag = False len = 0 i = 0 while ( i < n - 1 ) : if ( i != 0 ) : i = i + 1 if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : flag = True len = a [ i + 1 ] i = i + 1 elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : sum = sum + a [ i + 1 ] * len flag = False i = i + 1 return sum

def MaxTotalRectangleArea ( a , n ) : a . sort ( reverse = True ) sum = 0 len = 0 for i in range ( 0 , n ) : if ( a [ i ] == a [ i + 1 ] ) and ( flag ) : sum = sum + a [ i + 1 ] * len len = a [ i + 1 ] i += 1 elif ( a [ i ] == a [ i + 1 ] ) and ( flag ) : sum =

def MaxTotalRectangleArea ( a , n ) : sum = 0 flag = False len = 0 for i in range ( n ) : if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and not flag ) : flag = True len = a [ i + 1 ] i += 1 elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) ) : sum = sum + a [ i + 1 ] * len flag = False i += 1 return sum

37.43
38.77
32.73
41.44
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = 0 , temp = i ; while ( temp % p == 0 ) { count ++ ; temp = temp / p ; } ans += count ; } return ans ; }

def PowerOFPINnfactorial ( n , p ) : ans = 0 temp = p while ( temp <= n ) : ans += n / temp temp = temp * p return ans

def PowerOFPINnfactorial ( n , p ) : ans = 0 for i in range ( 1 , n ) : count = 0 temp = i while ( temp % p == 0 ) : count ++ temp = temp / p ans += count

def PowerOFPINnfactorial ( n , p ) : ans = 0 for i in range ( 1 , n ) : count = 0 , temp = i while temp % p == 0 : count += 1 temp = temp / p ans += count return ans

37.45
30.4
39.27
34.11
static void rearrange ( int [ ] arr , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } arr = temp . clone ( ) ; }

def rearrange ( arr , n ) : temp = n * [ None ] small , large = 0 , n - 1 flag = True for i in range ( n ) : if flag is True : temp [ i ] = arr [ large ] large -= 1 else : temp [ i ] = arr [ small ] small += 1 flag = bool ( 1 - flag ) for i in range ( n ) : arr [ i ] = temp [ i ] return arr

def rearrange ( arr , n ) : temp = [ 0 for i in range ( n ) ] small = 0 large = n - 1 flag = true for i in range ( n ) : temp [ i ] = arr [ small ++ ] flag = ! flag arr = temp [ n : ] return arr

def rearrange ( arr , n ) : small = 0 large = n - 1 flag = True for i in range ( n ) : if flag : temp [ i ] = arr [ large -- ] else : temp [ i ] = arr [ small ++ ] flag = not flag return arr

37.49
37.6
65.98
54.15
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( "No such subarray" ) ; else System . out . println ( startindex + " to " + endindex ) ; return maxsize ; }

def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 for i in range ( 0 , n - 1 ) : sum = - 1 if ( arr [ i ] == 0 ) else 1 for j in range ( i + 1 , n ) : sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 if ( sum == 0 and maxsize < j - i + 1 ) : maxsize = j - i + 1 startindex = i if ( maxsize == - 1 ) : print ( "Nosuchsubarray" ) else : print ( startindex , "to" , startindex + maxsize - 1 ) return maxsize

def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 startindex = 0 endindex = 0 for i in range ( n ) : sum = ( arr [ i ] == 0 ) : sum += - 1 if ( arr [ i ] == 0 ) : sum += 1 maxsize = j - i + 1 if ( maxsize == - 1 ) : print ( "No such subarray" ) return maxsize

def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 startindex = 0 endindex = 0 for i in range ( n - 1 , - 1 , - 1 ) : sum = ( arr [ i ] == 0 ) ? - 1 : 1 for j in range ( i + 1 , n ) : if ( arr [ j ] == 0 ) : sum += - 1 else : sum += 1 if ( sum == 0 and maxsize < j - i + 1 ) : maxsize = j - i + 1 startindex = i if maxsize == - 1 : print ( "No such subarray" ) else : print ( startindex + " to " + endindex ) return maxsize

37.61
42.1
61.73
56.06
static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return "-1" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == 'I' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ; } } } return new String ( result ) ; }

def getMinNumberForPattern ( seq ) : n = len ( seq ) if ( n >= 9 ) : return "-1" result = [ None ] * ( n + 1 ) count = 1 for i in range ( n + 1 ) : if ( i == n or seq [ i ] == 'I' ) : for j in range ( i - 1 , - 2 , - 1 ) : result [ j + 1 ] = int ( '0' + str ( count ) ) count += 1 if ( j >= 0 and seq [ j ] == 'I' ) : break return result

def getMinNumberForPattern ( seq ) : n = len ( seq ) for i in range ( n ) : if ( i == n || seq [ i ] == 'I' ) : result [ i ] = ( char ) ( ( int ) '0' + count ++ ) if ( j >= 0 and seq [ j ] == 'I' ) : break return "-1"

def getMinNumberForPattern ( seq ) : n = seq . length ( ) count = 1 for i in range ( n ) : if ( i == n or seq [ i ] == 'I' ) : for j in range ( i - 1 , - 1 , - 1 ) : result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) if ( j >= 0 and seq [ j ] == 'I' ) : break return result

37.66
40.75
43.44
41.71
static void printEqualSumSets ( int [ ] arr , int n ) { int i , currSum , sum = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; if ( ( sum & 1 ) == 1 ) { System . out . print ( "-1" ) ; return ; } int k = sum >> 1 ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ; for ( i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ i ] = false ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ; } } List < Integer > set1 = new ArrayList < Integer > ( ) ; List < Integer > set2 = new ArrayList < Integer > ( ) ; if ( ! dp [ n ] [ k ] ) { System . out . print ( "-1\n" ) ; return ; } i = n ; currSum = k ; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i -- ; set2 . add ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) { i -- ; currSum -= arr [ i ] ; set1 . add ( arr [ i ] ) ; } } System . out . print ( "Set 1 elements: " ) ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) System . out . print ( set1 . get ( i ) + " " ) ; System . out . print ( "\nSet 2 elements: " ) ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) System . out . print ( set2 . get ( i ) + " " ) ; }

def printEqualSumSets ( arr , n ) : sum_array = sum ( arr ) if ( sum_array & 1 ) : print ( "-1" ) return k = sum_array >> 1 dp = np . zeros ( ( n + 1 , k + 1 ) ) for i in range ( 1 , k + 1 ) : dp [ 0 ] [ i ] = False for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : for currSum in range ( 1 , k + 1 ) : dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) set1 , set2 = [ ] , [ ] if ( not dp [ n ] [ k ] ) : print ( "-1" ) return i = n currSum = k while ( i > 0 and currSum >= 0 ) : if ( dp [ i - 1 ] [ currSum ] ) : i -= 1 set2 . append ( arr [ i ] ) elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) : i -= 1 currSum -= arr [ i ] set1 . append ( arr [ i ] ) print ( "Set1elements:" , end = "" ) for i in range ( len ( set1 ) ) : print ( set1 [ i ] , end = "" ) print ( "\nSet2elements:" , end = "" ) for i in range ( len ( set2 ) ) : print ( set2 [ i ] , end = "" )

def printEqualSumSets ( arr , n ) : sum = 0 for i in range ( n ) : sum += arr [ i ] currSum = 0 for i in range ( n + 1 , k + 1 ) : currSum = 1 dp = [ false ] [ k + 1 ] for i in range ( 1 , n ) : dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = dp [ i ] [ currSum ] = dp [ i ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = dp [ i ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = dp [ i ] [ currSum ] = dp [ i

def printEqualSumSets ( arr , n ) : dp = [ False for i in range ( n ) ] for i in range ( n ) : dp [ i ] [ currSum ] = False for i in range ( 1 , n ) : dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] i = n ; currSum = k while ( i > 0 ) : dp [ i ] [ currSum ] = False for i in range ( 1 , n ) : dp [ i ] [ currSum ] = True for i in range ( 1 , n ) : for currSum in range ( 1 , k ) : dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] i -= 1

37.66
50.2
17.45
32.38
public static boolean isAnBn ( String s ) { int l = s . length ( ) ; if ( l % 2 == 1 ) { return false ; } int i = 0 ; int j = l - 1 ; while ( i < j ) { if ( s . charAt ( i ) != 'a' || s . charAt ( j ) != 'b' ) { return false ; } i ++ ; j -- ; } return true ; }

def isAnBn ( str ) : n = len ( str ) for i in range ( n ) : if ( str [ i ] != 'a' ) : break if ( i * 2 != n ) : return False for j in range ( i , n ) : if ( str [ j ] != 'b' ) : return False return True

def isAnBn ( s ) : l = len ( s ) for i in range ( l ) : if ( s [ i ] != 'a' || s [ j ] != 'b' ) : return false i = 0 j = l - 1 while ( i < j ) : if ( s [ i ] != 'a' ) : return false j -= 1 return true

def isAnBn ( s ) : l = len ( s ) while i < j : if s [ i ] != 'a' or s [ j ] != 'b' : return False i += 1 j -= 1 return True

37.68
33.64
25.06
25.27
static void sortByPattern ( char [ ] str , char [ ] pat ) { int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ; i ++ ) { count [ str [ i ] - 'a' ] ++ ; } int index = 0 ; for ( int i = 0 ; i < pat . length ; i ++ ) { for ( int j = 0 ; j < count [ pat [ i ] - 'a' ] ; j ++ ) { str [ index ++ ] = pat [ i ] ; } } }

def sortByPattern ( str , pat ) : global MAX_CHAR count = [ 0 ] * MAX_CHAR for i in range ( 0 , len ( str ) ) : count [ ord ( str [ i ] ) - 97 ] += 1 index = 0 str = "" for i in range ( 0 , len ( pat ) ) : j = 0 while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] ) : str += pat [ i ] j = j + 1 index += 1 return str

def sortByPattern ( str , pat ) : count = [ 0 for i in range ( len ( str ) ) ] for i in range ( len ( pat ) ) : count [ pat [ i ] - 'a' ] += 1 str [ index ] = pat [ i ] for j in range ( count [ pat [ i ] - 'a' ] ) : str [ index ++ ] = pat [ i ] if ( j == count [ pat [ i ] - 'a' ] ) : str [ index ++ ] = pat [ i ]

def sortByPattern ( str , pat ) : count = [ 0 for i in range ( MAX_CHAR ) ] index = 0 for i in range ( 0 , pat . length ) : for j in range ( count [ pat [ i ] - 'a' ] ) : str [ index ++ ] = pat [ i ]

37.69
32.76
39.46
38.22
static int numberofways ( String A , String B , int N , int M ) { Vector < Integer > [ ] pos = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) pos [ i ] = new Vector < > ( ) ; for ( int i = 0 ; i < M ; i ++ ) pos [ B . charAt ( i ) ] . add ( i + 1 ) ; int [ ] [ ] dpl = new int [ N + 2 ] [ M + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int [ ] [ ] dpr = new int [ N + 2 ] [ M + 2 ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( int x : pos [ j ] ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }

def numberofways ( A , B , N , M ) : pos = [ [ ] for _ in range ( MAX ) ] for i in range ( M ) : pos [ ord ( B [ i ] ) ] . append ( i + 1 ) dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( 1 , N + 1 ) : for j in range ( 1 , M + 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 else : dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) LCS = dpl [ N ] [ M ] dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( N , 0 , - 1 ) : for j in range ( M , 0 , - 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 else : dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ans = 0 for i in range ( N + 1 ) : for j in range ( MAX ) : for x in pos [ j ] : if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : ans += 1 break return ans

def numberofways ( A , B , N , M ) : pos = [ ] for i in range ( MAX ) : pos [ i ] = new Vector < Integer > ( ) for i in range ( N , M ) : if ( A [ i ] == B [ j - 1 ] ) : dpl [ i ] [ j ] = dpl [ i - 1 ] [ j ] + 1 else : dpl [ i ] [ j ] = max ( dpl [ i ] [ j ] [ j ] = max ( dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] + 1 , dpl [ i ] [ j - 1 ] ) for i in range ( N , M ) : if ( A [ i - 1 ] == B [ j - 1 ] ) : dpr [ i ] [ j ] = max ( dpr [ i ] [ j ] = max ( dpr [ i ] [ j ] , dpr [ i ] [ j - 1 ] [ j - 1 ] ) return LCS

def numberofways ( A , B , N , M ) : dpl = [ 1 for i in range ( N ) ] for i in range ( 1 , N ) : for j in range ( 1 , M ) : if ( A [ i - 1 ] == B [ j - 1 ] ) : dpr [ i ] [ j ] = dpr [ i - 1 ] [ j - 1 ] + 1 else : dpr [ i ] [ j ] = max ( dpr [ i - 1 ] [ j ] , dpr [ i ] [ j - 1 ] ) LCS = dpl [ N ] [ M ] dpr = [ N + 2 ] [ M + 2 ] for i in range ( 1 , N ) : for j in range ( 1 , M ) : if ( A [ i - 1 ] == B [ j - 1 ] ) : dpr [ i ] [ j ] = max ( dpr [ i - 1 ] [ j ] , dpr [ i ] [ j - 1 ] ) return LCS , dpl , dpr

37.71
40.88
57.22
46.29
static int getMinSteps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ;

def getMinSteps ( n ) : table = [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) : table [ i ] = n - i for i in range ( n , 0 , - 1 ) : if ( not ( i % 2 ) ) : table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) if ( not ( i % 3 ) ) : table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) return table [ 1 ]

def getMinSteps ( n ) : table = [ 0 for i in range ( n ) ] for i in range ( n + 1 , - 1 , - 1 ) : if ( ! ( i % 1 > 0 ) ) : table [ i ] = min ( table [ i ] + 1 , table [ i / 2 ] ) return table [ 0 ]

def getMinSteps ( n ) : table = [ 0 for i in range ( n ) ] for i in range ( n ) : if not ( i % 2 > 0 ) : table [ i / 2 ] = min ( table [ i ] + 1 , table [ i / 2 ] ) if not ( i % 3 > 0 ) : table [ i / 3 ] = min ( table [ i ] + 1 , table [ i / 3 ] ) return table [ 1 ]

37.73
27.15
27.66
30.34
static char getMaxOccuringChar ( String str ) { int count [ ] = new int [ ASCII_SIZE ] ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) count [ str . charAt ( i ) ] ++ ; int max = - 1 ; char result = ' ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str . charAt ( i ) ] ) { max = count [ str . charAt ( i ) ] ; result = str . charAt ( i ) ; } } return result ; }

def getMaxOccuringChar ( str ) : count = [ 0 ] * ASCII_SIZE max = - 1 c = '' for i in str : count [ ord ( i ) ] += 1 ; for i in str : if max < count [ ord ( i ) ] : max = count [ ord ( i ) ] c = i return c

def getMaxOccuringChar ( str ) : count = [ 0 for i in range ( ASCII_SIZE ) ] for i in range ( len ) : if ( max < count [ str . charAt ( i ) ] ) : max = count [ str . charAt ( i ) ] result = str [ i ] return result

def getMaxOccuringChar ( str ) : count = [ 0 for i in range ( ASCII_SIZE ) ] len = str . length ( ) for i in range ( 0 , len ) : count [ str [ i ] ] += 1 max = - 1 result = ' ' for i in range ( 0 , len ) : if ( max < count [ str [ i ] ] ) : max = count [ str [ i ] ] result = str [ i ] return result

37.76
35.48
59.39
46.24
static void find ( Vector < String > list1 , Vector < String > list2 ) { Vector < String > res = new Vector < > ( ) ; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 . get ( i ) ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " " ) ; }

def find ( list1 , list2 ) : res = [ ] max_possible_sum = len ( list1 ) + len ( list2 ) - 2 for sum in range ( max_possible_sum + 1 ) : for i in range ( sum + 1 ) : if ( i < len ( list1 ) and ( sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ sum - i ] ) : res . append ( list1 [ i ] ) if ( len ( res ) > 0 ) : break for i in range ( len ( res ) ) : print ( res [ i ] , end = "" )

def find ( list1 , list2 ) : res = list ( ) for sum in range ( 0 , max_possible_sum , 2 ) : if ( list1 [ sum ] == list2 [ sum ] ) : res . add ( list1 [ sum - i ] ) if ( res [ size ( ) > 0 ) : break if ( i < list1 . size ( ) and ( sum - i ) < list2 [ sum - i ] ) : res .

def find ( list1 , list2 ) : res = list ( ) for sum in range ( max_possible_sum ) : for i in range ( 0 , max_possible_sum ) : if ( i < list1 . size ( ) and ( sum - i ) < list2 . size ( ) and list1 [ i ] == list2 [ sum - i ] ) : res . add ( list1 [ i ] ) if ( res . size ( ) > 0 ) : break for i in range ( 0 , res . size ( ) ) : print ( res [ i ] ) if ( res . size ( ) > 0 ) : break return res

37.79
26.39
48.1
39.95
static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }

def getSum ( n ) : sum = 0 while ( n != 0 ) : sum = sum + int ( n % 10 ) n = int ( n / 10 ) return sum

def getSum ( n ) : sum = 0 n = n // 10 while n != 0 : sum = sum + n // 10 while n != 0 : sum = sum + n // 10 return sum

def getSum ( n ) : sum = 0 while n != 0 : sum = sum + n % 10 n = n / 10 return sum

38.11
39.8
30.92
39.83
static String findSubString ( String str ) { int n = str . length ( ) ; int dist_count = 0 ; boolean [ ] visited = new boolean [ MAX_CHARS ] ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str . charAt ( i ) ] == false ) { visited [ str . charAt ( i ) ] = true ; dist_count ++ ; } } int start = 0 , start_index = - 1 ; int min_len = Integer . MAX_VALUE ; int count = 0 ; int [ ] curr_count = new int [ MAX_CHARS ] ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str . charAt ( j ) ] ++ ; if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str . charAt ( start ) ] > 1 ) { if ( curr_count [ str . charAt ( start ) ] > 1 ) curr_count [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } return str . substring ( start_index , start_index + min_len ) ; }

def findSubString ( str ) : n = len ( str ) dist_count = len ( set ( [ x for x in str ] ) ) count , start , start_index , min_len = 0 , 0 , - 1 , 9999999999 curr_count = defaultdict ( lambda : 0 ) for j in range ( n ) : curr_count [ str [ j ] ] += 1 if curr_count [ str [ j ] ] == 1 : count += 1 if count == dist_count : while curr_count [ str [ start ] ] > 1 : if curr_count [ str [ start ] ] > 1 : curr_count [ str [ start ] ] -= 1 start += 1 len_window = j - start + 1 if min_len > len_window : min_len = len_window start_index = start return str [ start_index : start_index + min_len ]

def findSubString ( str ) : dist_count = 0 for i in range ( n ) : visited [ str [ i ] ] = false dist_count += 1 for i in range ( n ) : if ( visited [ str [ i ] ] == false ) : visited [ str [ i ] ] = true dist_count += 1 for j in range ( n ) : if ( curr_count [ str [ j ] ] == 1 ) : count += 1 if ( dist_count == dist_count ) : break if ( curr_count [ str . charAt ( j ) ] == 1 ) : curr_count [ str [ j ] = 1 start += 1 min_len = len ( str [ start ] ) if ( min_len > len_window ) : min_len = len_window start_index = start if ( min_len > len_window ) : start_index = start return str [ start_index , start_index + min_len

def findSubString ( str ) : dist_count = 0 start = 0 start_index = - 1 min_len = float ( 'inf' ) count = 0 curr_count = [ 0 for j in range ( n ) ] for i in range ( n ) : if ( visited [ str [ i ] ] == False ) : visited [ str [ i ] ] = True count += 1 if count == dist_count : while ( curr_count [ str [ j ] ] > 1 ) : if ( curr_count [ str [ j ] ] > 1 ) : curr_count [ str [ j ] ] -- start ++ if count == dist_count : while ( curr_count [ str [ start ] ] > 1 ) : if ( curr_count [ str [ start ] ] > 1 ) : curr_count [ str [ start ] ] -- start ++ if count == dist_count : while ( curr_count [ str [ start ] ] > 1 ) : curr_count [ str [ start ] ] -- start ++ if count == dist_count : while ( curr_count [ str [ start ] ] > 1 ) : curr_count [ str [ start ] ] -- start ++

38.12
41.28
55.87
46.68
static void findMax ( int arr [ ] [ ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( j >= 0 && arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } System . out . print ( "Row number = " + ( row + 1 ) ) ; System . out . print ( ", MaxCount = " + ( N - 1 - j ) ) ; }

def findMax ( arr ) : row = 0 j = N - 1 for i in range ( 0 , N ) : while ( arr [ i ] [ j ] == 1 and j >= 0 ) : row = i j -= 1 print ( "Rownumber=" , row + 1 , ",MaxCount=" , N - 1 - j )

def findMax ( arr , N ) : row = 0 for i in range ( N ) : while ( j >= 0 and arr [ i ] [ j ] == 1 ) : row = i j = N - 1 while ( j >= 0 and arr [ i ] [ j ] == 1 ) : j = N - 1 - j } System . out . print ( "Row number = " + ( row + 1 ) ) print ( ", MaxCount = " + ( N -

def findMax ( arr ) : row = 0 for i in range ( N ) : while j >= 0 and arr [ i ] [ j ] == 1 : row = i j -= 1 print ( "Row number = " + ( row + 1 ) ) print ( ", MaxCount = " + ( N - 1 - j ) )

38.12
45.77
46.36
49.55
static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { LinkedList < Integer > Di = new LinkedList < > ( ) ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) Di . add ( i ) ; for ( ; i < n ; i ++ ) { if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " " ) ; else System . out . print ( "0" + " " ) ; while ( ( ! Di . isEmpty ( ) ) && Di . peek ( ) < ( i - k + 1 ) ) Di . remove ( ) ; if ( arr [ i ] < 0 ) Di . add ( i ) ; } if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " " ) ; else System . out . print ( "0" + " " ) ; }

def printFirstNegativeInteger ( arr , n , k ) : Di = deque ( ) for i in range ( k ) : if ( arr [ i ] < 0 ) : Di . append ( i ) for i in range ( k , n ) : if ( not Di ) : print ( 0 , end = '' ) else : print ( arr [ Di [ 0 ] ] , end = '' ) while Di and Di [ 0 ] <= ( i - k ) : Di . popleft ( ) if ( arr [ i ] < 0 ) : Di . append ( i ) if not Di : print ( 0 ) else : print ( arr [ Di [ 0 ] ] , end = "" )

def printFirstNegativeInteger ( arr , n , k ) : Di = list ( ) for i in range ( 0 , n , k ) : if ( arr [ i ] < 0 ) : Di . add ( i ) if ( arr [ i ] < 0 ) : Di . add ( i ) if ( arr [ i ] < 0 ) : Di . add ( i ) if ( arr [ i ] < 0 ) : Di . add ( i ) if ( arr [ i ] >

def printFirstNegativeInteger ( arr , n , k ) : Di = list ( ) for i in range ( k ) : if arr [ i ] < 0 : Di . add ( i ) if not Di . isEmpty ( ) : print ( arr [ Di . peek ( ) ] + " " ) : print ( "0" + " " ) while ( ( not Di . isEmpty ( ) ) and Di . peek ( ) < ( i - k + 1 ) ) : Di . remove ( ) if ( arr [ i ] < 0 ) : Di . add ( i ) if not Di . isEmpty ( ) : print ( arr [ Di . peek ( ) ] + " " ) : print ( "0" + " " )

38.13
36.85
70.1
56.41
static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { System . out . print ( x + " " ) ; System . out . print ( arr [ l ] + " " ) ; System . out . println ( arr [ r ] + " " ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) System . out . println ( " No Triplet Found" ) ; }

def findTriplets ( arr , n ) : found = False arr . sort ( ) for i in range ( 0 , n - 1 ) : l = i + 1 r = n - 1 x = arr [ i ] while ( l < r ) : if ( x + arr [ l ] + arr [ r ] == 0 ) : print ( x , arr [ l ] , arr [ r ] ) l += 1 r -= 1 found = True elif ( x + arr [ l ] + arr [ r ] < 0 ) : l += 1 else : r -= 1 if ( found == False ) : print ( "NoTripletFound" )

def findTriplets ( arr , n ) : found = false for i in range ( n ) : if ( arr [ i ] == 0 ) : print ( x + " " ) print ( arr [ l ] + " " ) print ( arr [ r ] ) found = true else : if ( x + arr [ l ] + arr [ r ] == 0 ) : print ( x + " " ) print ( arr [ l ] + " " ) print ( arr [ r ] ) found = true if ( x + arr [ r ] < 0 ) : l += 1 r -= 1 if ( x + arr [ l ] + arr [ r ] > 0 ) : print ( arr [ l ] + " " ) print ( arr [ r ] ) found = true else : if ( x + arr [ l ] + arr [ r ] < 0 ) : l += 1 else : print ( arr [ r ] ) print ( arr [ r ] ) found = true

def findTriplets ( arr , n ) : found = False for i in range ( n ) : l = i + 1 r = n - 1 x = arr [ i ] while l < r : if ( x + arr [ l ] + arr [ r ] == 0 ) : print ( x + " " ) print ( arr [ l ] + " " ) print ( arr [ r ] + " " ) l ++ r -- found = True elif ( x + arr [ l ] + arr [ r ] < 0 ) : l += 1 else : r -= 1 if found == False : print ( " No Triplet Found" )

38.17
38.87
58.06
59.33
static boolean checkMarkov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }

def checkMarkov ( m ) : for i in range ( 0 , len ( m ) ) : sm = 0 for j in range ( 0 , len ( m [ i ] ) ) : sm = sm + m [ i ] [ j ] if ( sm != 1 ) : return False return True

def checkMarkov ( m ) : m . sort ( reverse = True ) sum = 0 for i in range ( m . length ) : sum = sum + m [ i ] [ j ] if ( sum != 1 ) : return false

def checkMarkov ( m ) : for i in range ( m . length ) : sum = 0 for j in range ( 0 , m . length ) : sum = sum + m [ i ] [ j ] if ( sum != 1 ) : return False return True

38.2
27.13
43.37
36.31
static boolean pairWiseConsecutive ( Stack < Integer > s ) { Stack < Integer > aux = new Stack < Integer > ( ) ; while ( ! s . isEmpty ( ) ) { aux . push ( s . peek ( ) ) ; s . pop ( ) ; } boolean result = true ; while ( aux . size ( ) > 1 ) { int x = aux . peek ( ) ; aux . pop ( ) ; int y = aux . peek ( ) ; aux . pop ( ) ; if ( Math . abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . peek ( ) ) ; return result ; }

def pairWiseConsecutive ( s ) : aux = [ ] while ( len ( s ) != 0 ) : aux . append ( s [ - 1 ] ) s . pop ( ) result = True while ( len ( aux ) > 1 ) : x = aux [ - 1 ] aux . pop ( ) y = aux [ - 1 ] aux . pop ( ) if ( abs ( x - y ) != 1 ) : result = False s . append ( x ) s . append ( y ) if ( len ( aux ) == 1 ) : s . append ( aux [ - 1 ] ) return result

def pairWiseConsecutive ( s ) : aux = new Stack < Integer > ( ) while ( ! s . isEmpty ( ) ) : aux . append ( s . peek ( ) ) s . pop ( ) result = true while ( aux . size ( ) > 1 ) : x = aux . peek ( ) aux . pop ( ) if ( x - y != 1 ) : result = false s . push ( x ) s . push ( y ) return result

def pairWiseConsecutive ( s ) : aux = [ 0 for k in range ( len ( s ) ) ] result = True while aux . size ( ) > 1 : x = aux [ 0 ] aux . pop ( ) y = aux [ 0 ] aux . pop ( ) if ( abs ( x - y ) != 1 ) : result = False s . push ( x ) s . push ( y ) return result

38.21
34.9
49.58
44.04
public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }

def findNth ( n ) : count = 0 curr = 19 while ( True ) : sum = 0 x = curr while ( x > 0 ) : sum = sum + x % 10 x = int ( x / 10 ) if ( sum == 10 ) : count += 1 if ( count == n ) : return curr curr += 9 return - 1

def findNth ( n ) : count = 0 for curr in range ( 19 , 19 + 9 ) : sum = 0 for x in range ( curr , 19 + 9 ) : sum = sum + x % 10 if ( sum == 10 ) : count ++ return curr

def findNth ( n ) : count = 0 for curr in range ( 19 , 9 ) : sum = 0 for x in range ( curr , 0 , 10 ) : sum = sum + x % 10 if ( sum == 10 ) : count ++ if ( count == n ) : return curr

38.22
43.46
84.76
66.4
static int findMaxPath ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < M ; i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ; for ( int i = 1 ; i < N ; i ++ ) { res = - 1 ; for ( int j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; res = max ( mat [ i ] [ j ] , res ) ; } } return res ; }

def findMaxPath ( mat ) : res = - 1 for i in range ( M ) : res = max ( res , mat [ 0 ] [ i ] ) for i in range ( 1 , N ) : res = - 1 for j in range ( M ) : if ( j > 0 and j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) elif ( j > 0 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) elif ( j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) res = max ( mat [ i ] [ j ] , res ) return res

def findMaxPath ( mat , M , N ) : res = - 1 for i in range ( 1 , N ) : res = max ( res , mat [ 0 ] [ i ] ) for j in range ( 0 , M , N ) : if ( j > 0 and j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) res = max ( mat [ i ] [ j ] [ j + 1 ] ) return res

def findMaxPath ( mat ) : res = - 1 for i in range ( N ) : res = - 1 for j in range ( 1 , M ) : if ( j > 0 and j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j - 1 ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) else : if ( j > 0 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) else : if ( j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) res = max ( mat [ i ] [ j ] , res ) return res

38.22
40.48
41.3
36.63
static int check_duck ( String num ) { int len = num . length ( ) ; int count_zero = 0 ; char ch ; for ( int i = 1 ; i < len ; i ++ ) { ch = num . charAt ( i ) ; if ( ch == '0' ) count_zero ++ ; } return count_zero ; }

def check_duck ( num ) : l = len ( num ) count_zero = 0 i = 1 while i < l : ch = num [ i ] if ( ch == "0" ) : count_zero = count_zero + 1 i = i + 1 return count_zero

def check_duck ( num ) : count_zero = 0 for i in range ( len ) : ch = num [ i ] if ( ch == '0' ) : count_zero ++ return count_zero

def check_duck ( num ) : len = num . length count_zero = 0 for i in range ( 1 , len ) : ch = num [ i ] if ( ch == '0' ) : count_zero += 1 return count_zero

38.23
33.24
49.03
32.31
static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }

def evenFibSum ( limit ) : if ( limit < 2 ) : return 0 ef1 = 0 ef2 = 2 sm = ef1 + ef2 while ( ef2 <= limit ) : ef3 = 4 * ef2 + ef1 if ( ef3 > limit ) : break ef1 = ef2 ef2 = ef3 sm = sm + ef2 return sm

def evenFibSum ( limit ) : ef1 = 0 , ef2 = 2 while ( ef1 <= limit ) : ef2 = ef1 + ef2 ef1 = ef2 ef2 = ef3 if ( ef3 > limit ) : break return ( int ) sum

def evenFibSum ( limit ) : ef1 = 0 ef2 = 2 sum = ef1 + ef2 while ef2 <= limit : ef3 = 4 * ef2 + ef1 if ef3 > limit : break ef1 = ef2 ef2 = ef3 sum += ef2 return ( int ) sum

38.31
37.59
53.97
29.1
static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " " ) ; System . out . println ( ) ; }

def printArray ( a , n ) : for i in a : print ( i , end = "" ) print ( )

def printArray ( a , n ) : for i in range ( n ) : print ( a [ i ] , end = "" ) for i in range ( n ) : print ( a [ i ] , end = "" ) print ( )

def printArray ( a , n ) : for i in range ( n ) : print ( a [ i ] )

38.34
32.77
67.3
47.62
static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }

def getMaxGold ( gold , m , n ) : goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] for col in range ( n - 1 , - 1 , - 1 ) : for row in range ( m ) : if ( col == n - 1 ) : right = 0 else : right = goldTable [ row ] [ col + 1 ] if ( row == 0 or col == n - 1 ) : right_up = 0 else : right_up = goldTable [ row - 1 ] [ col + 1 ] if ( row == m - 1 or col == n - 1 ) : right_down = 0 else : right_down = goldTable [ row + 1 ] [ col + 1 ] goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) res = goldTable [ 0 ] [ 0 ] for i in range ( 1 , m ) : res = max ( res , goldTable [ i ] [ 0 ] ) return res

def getMaxGold ( gold , m , n ) : goldTable = [ 0 for row in range ( m , n ) ] for col in range ( n - 1 , - 1 , - 1 ) : right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] goldTable [ row ] [ col ] = max ( right , max ( right_up , right_down ) ) if ( row == 0 || col == n - 1 ) : goldTable [ row ] [ col ] = gold [ row ] [ col + 1 ] = max ( right , max ( right_up , right_down ) ) return res

def getMaxGold ( gold , m , n ) : goldTable [ ] [ ] = [ 0 for k in range ( m ) ] for row in range ( m , n ) : right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] right_up = ( row == 0 or col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] right_down = ( row == m - 1 or col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) res = goldTable [ 0 ] [ 0 ] for i in range ( 1 , m ) : res = max ( res , goldTable [ i ] [ 0 ] ) return res

38.45
27.81
49.93
45.35
static void arrangeString ( String str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { System . out . print ( "0" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { System . out . print ( "1" ) ; count_1 -- ; } } } }

def arrangeString ( str1 , x , y ) : count_0 = 0 count_1 = 0 n = len ( str1 ) for i in range ( n ) : if str1 [ i ] == '0' : count_0 += 1 else : count_1 += 1 while count_0 > 0 or count_1 > 0 : for i in range ( 0 , x ) : if count_0 > 0 : print ( "0" , end = "" ) count_0 -= 1 for j in range ( 0 , y ) : if count_1 > 0 : print ( "1" , end = "" ) count_1 -= 1

def arrangeString ( str , x , y ) : count_0 = 0 count_1 = 0 for i in range ( len ) : if ( str [ i ] == '0' ) : count_0 += 1 count_1 += 1 for j in range ( 0 , x , y ) : if ( count_0 > 0 ) : print ( "0" ) ; count_0 -- if ( count_1 > 0 ) : print ( "1" )

def arrangeString ( str , x , y ) : count_0 = 0 count_1 = 0 len = str . length ( ) for i in range ( len ) : if ( str [ i ] == '0' ) : count_0 += 1 else : count_1 += 1 if count_0 > 0 or count_1 > 0 : for j in range ( x , y ) : if ( count_0 > 0 ) : print ( "0" ) count_0 -- if ( count_1 > 0 ) : print ( "1" ) count_1 --

38.5
32.34
46.0
33.67
static int maximumZeros ( int arr [ ] , int n , int k ) { int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ; for ( int [ ] row : subset ) { Arrays . fill ( row , - 1 ) ; } subset [ 0 ] [ 0 ] = 0 ; for ( int p = 0 ; p < n ; p ++ ) { int pw2 = 0 , pw5 = 0 ; while ( arr [ p ] % 2 == 0 ) { pw2 ++ ; arr [ p ] /= 2 ; } while ( arr [ p ] % 5 == 0 ) { pw5 ++ ; arr [ p ] /= 5 ; } for ( int i = k - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) { subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) ; } } } } int ans = 0 ; for ( int i = 0 ; i < MAX5 ; i ++ ) { ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ; } return ans ; }

def maximumZeros ( arr , n , k ) : global MAX5 subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1 ) ] subset [ 0 ] [ 0 ] = 0 for p in arr : pw2 , pw5 = 0 , 0 while not p % 2 : pw2 += 1 p //= 2 while not p % 5 : pw5 += 1 p //= 5 for i in range ( k - 1 , - 1 , - 1 ) : for j in range ( MAX5 ) : if subset [ i ] [ j ] != - 1 : subset [ i + 1 ] [ j + pw5 ] = ( max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ) ans = 0 for i in range ( MAX5 ) : ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) return ans

def maximumZeros ( arr , n , k ) : subset = [ [ 0 for k in range ( n , k ) ] for p in range ( n , k ) : if ( arr [ p ] == 0 ) : pw2 = 1 pw5 = 0 for p in range ( n , k ) : if ( arr [ p ] % 2 == 0 ) : pw2 += 1 arr [ p ] /= 2 if ( arr [ p ] % 5 == 0 ) : pw5 += 1 if ( arr [ p ] > 0 ) : subset [ 0 ] [ j ] != - 1 ) : subset [ i ] [ j ] = max ( subset [ i ] [ j ] != - 1 ) : subset [ i + 1 ] [ pw5 ] = max ( subset [ i ] [ j ] + pw2 ) return ans

def maximumZeros ( arr , n , k ) : subset [ ] [ ] = [ 0 for p in range ( n ) ] for p in range ( n ) : pw2 = 0 , pw5 = 0 while arr [ p ] % 2 == 0 : pw2 += arr [ p ] /= 2 if arr [ p ] % 5 == 0 : pw5 += arr [ p ] /= 5 for i in range ( k - 1 , - 1 , - 1 ) : if ( subset [ i ] [ j ] != - 1 ) : subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) return ans

38.5
52.68
52.29
53.95
static int findDiff ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int max_count = 0 , min_count = n ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { max_count = Math . max ( max_count , x . getValue ( ) ) ; min_count = Math . min ( min_count , x . getValue ( ) ) ; } return ( max_count - min_count ) ; }

def findDiff ( arr , n ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 max_count = 0 min_count = n for key , values in mp . items ( ) : max_count = max ( max_count , values ) min_count = min ( min_count , values ) return max_count - min_count

def findDiff ( arr , n ) : mp = defaultdict ( int ) for i in range ( n ) : if ( mp [ arr [ i ] ] != 1 ) : mp . put ( arr [ i ] , 1 ) else : mp . put ( arr [ i ] , 1 ) max_count = 0 min_count = n for x in mp . entrySet ( ) : max_count = max ( max_count , x . getValue ( ) ) min_count = min ( x . getValue ( ) if ( x . getValue ( ) ) : min_count = min ( min_count , x . getValue ( ) ) return ( max_count - min_count )

def findDiff ( arr , n ) : mp = list ( ) for i in range ( n ) : if mp . containsKey ( arr [ i ] ) : mp [ arr [ i ] ] += 1 else : mp [ arr [ i ] ] = 1 max_count = 0 min_count = n for map_entry in mp . entrySet ( ) : max_count = max ( max_count , map_entry . value ) min_count = min ( min_count , map_entry . value ) return ( max_count - min_count )

38.58
33.17
47.97
50.02
static int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; }

def gcdOfFactorial ( m , n ) : return math . factorial ( min ( m , n ) )

def gcdOfFactorial ( m , n ) : min = m n = n

def gcdOfFactorial ( m , n ) : min = m < n return factorial ( min )

38.61
36.94
72.16
56.12
static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }

def minPalPartion ( str ) : n = len ( str ) C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] P = [ [ False for i in range ( n ) ] for i in range ( n ) ] j = 0 k = 0 L = 0 for i in range ( n ) : P [ i ] [ i ] = True C [ i ] [ i ] = 0 for L in range ( 2 , n + 1 ) : for i in range ( n - L + 1 ) : j = i + L - 1 if L == 2 : P [ i ] [ j ] = ( str [ i ] == str [ j ] ) else : P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] ) if P [ i ] [ j ] == True : C [ i ] [ j ] = 0 else : C [ i ] [ j ] = 100000000 for k in range ( i , j ) : C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) return C [ 0 ] [ n - 1 ]

def minPalPartion ( str ) : n = len ( str ) P = [ True for i in range ( n ) ] C = [ True for i in range ( n ) ] for j in range ( n - L + 1 , n ) : if ( str [ i ] == str [ j ] ) : P [ i ] [ j ] = ( str [ i ] == str [ j - 1 ] ) : C [ i ] [ j ] = 1 else : if ( L == 2 ) : P [ i ] [ j ] = min ( P [ i ] [ j ] = min ( C [ i ] [ j ] , C [ k + 1 ] [ j ] + 1 ) return C [ 0 ] [ n - 1 ]

def minPalPartion ( str ) : P = [ True for i in range ( n ) ] C = [ True for i in range ( n ) ] P = [ True for i in range ( n ) ] for L in range ( 2 , n ) : for i in range ( n - L + 1 , n ) : j = i + L - 1 if L == 2 : P [ i ] [ j ] = ( str [ i ] == str [ j ] ) else : P [ i ] [ j ] = ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] if ( P [ i ] [ j ] == True ) : C [ i ] [ j ] = 0 else : C [ i ] [ j ] = float ( 'inf' ) for k in range ( i , j - 1 ) : C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) return C [ 0 ] [ n - 1 ]

38.64
38.59
54.76
43.68
static int countPattern ( String str ) { int len = str . length ( ) ; boolean oneSeen = false ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ; if ( getChar == '1' && oneSeen == true ) { if ( str . charAt ( i - 1 ) == '0' ) count ++ ; } if ( getChar == '1' && oneSeen == false ) oneSeen = true ; if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false ; } return count ; }

def countPattern ( s ) : length = len ( s ) oneSeen = False count = 0 for i in range ( length ) : if ( s [ i ] == '1' and oneSeen ) : if ( s [ i - 1 ] == '0' ) : count += 1 if ( s [ i ] == '1' and oneSeen == 0 ) : oneSeen = True if ( s [ i ] != '0' and s [ i ] != '1' ) : oneSeen = False return count

def countPattern ( str ) : len = len ( str ) for i in range ( len ) : if ( getChar == '1' && oneSeen == true ) : count += 1 if ( getChar == '0' && str [ i - 1 ] == '1' ) : oneSeen = false if ( getChar != '1' and str [ i ] != '1' ) : oneSeen = true count += 1 if ( getChar == '1' and oneSeen ==

def countPattern ( str ) : oneSeen = False count = 0 for i in range ( len ) : char getChar = str . charAt ( i ) if ( getChar == '1' and oneSeen == True ) : if ( str [ i - 1 ] == '0' ) : count += 1 if ( getChar == '1' and oneSeen == False ) : oneSeen = True if ( getChar != '0' and str [ i ] != '1' ) : oneSeen = false return count

38.67
37.11
43.87
42.48
static int minimumBox ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }

def minimumBox ( arr , n ) : q = collections . deque ( [ ] ) arr . sort ( ) q . append ( arr [ 0 ] ) for i in range ( 1 , n ) : now = q [ 0 ] if ( arr [ i ] >= 2 * now ) : q . popleft ( ) q . append ( arr [ i ] ) return len ( q )

def minimumBox ( arr , n ) : q = Queue < Integer > ( ) for i in range ( 1 , n ) : if ( arr [ i ] >= 2 * now ) : q . remove ( ) return q . size ( )

def minimumBox ( arr , n ) : q = list ( ) for i in range ( n ) : now = q . element ( ) if arr [ i ] >= 2 * now : q . remove ( ) q . add ( arr [ i ] ) return q . size ( )

38.72
46.72
15.33
39.31
static int findSum ( String str ) { String temp = "" ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . isDigit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = "0" ; } } return sum + Integer . parseInt ( temp ) ; }

def findSum ( str1 ) : temp = "" Sum = 0 for ch in str1 : if ( ch . isdigit ( ) ) : temp += ch else : Sum += int ( temp ) temp = "0" return Sum + int ( temp )

def findSum ( str ) : temp = "" sum = 0 for i in range ( len ( str ) ) : temp += ch if ( Character . isDigit ( ch ) ) : sum += int . parseInt ( temp ) temp = "0" return sum

def findSum ( str ) : temp = "" sum = 0 for i in range ( len ( str ) ) : ch = str [ i ] if isinstance ( ch , int ) : sum += ch elif isinstance ( ch , float ) : sum += float ( ch ) elif isinstance ( ch , float ) : sum += float ( ch ) elif isinstance ( ch , float ) : sum += float ( ch ) temp = "0" return sum + float ( temp )

38.73
27.71
33.79
24.52
static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }

def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if ( B [ i ] == 1 ) : j = i while ( B [ j ] == 1 ) : j = j + 1 A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] i = j for i in range ( 0 , n ) : if ( A [ i ] != i + 1 ) : return False return True

def sortedAfterSwap ( A , B , n ) : i = 0 for i in range ( 0 , n - 1 ) : if ( B [ i ] ) : j = i while ( B [ j ] ) : i ++ if ( A [ i ] != i + 1 ) : return false return true

def sortedAfterSwap ( A , B , n ) : B . sort ( reverse = True ) for i in range ( n - 1 , - 1 , - 1 ) : if ( B [ i ] ) : j = i while ( B [ j ] ) : j += 1 A [ i ] = i + 1 i = j return True

38.77
33.86
39.51
45.65
static int getSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; }

def getSum ( n ) : sum = 0 while ( n > 0 ) : sum += int ( n % 10 ) n = int ( n / 10 ) return sum

def getSum ( n ) : sum = 0 for n in range ( 100 ) : sum += n % 10 , n /= 10 return sum

def getSum ( n ) : sum = 0 for n in range ( n ) : sum += n % 10 n /= 10 return sum

38.77
33.49
60.18
43.63
static int findMaxValue ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( "The array should have" + " atleast 4 elements" ) ; } int table1 [ ] = new int [ n + 1 ] ; int table2 [ ] = new int [ n ] ; int table3 [ ] = new int [ n - 1 ] ; int table4 [ ] = new int [ n - 2 ] ; Arrays . fill ( table1 , Integer . MIN_VALUE ) ; Arrays . fill ( table2 , Integer . MIN_VALUE ) ; Arrays . fill ( table3 , Integer . MIN_VALUE ) ; Arrays . fill ( table4 , Integer . MIN_VALUE ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; for ( int i = n - 4 ; i >= 0 ; i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; return table4 [ 0 ] ; }

def findMaxValue ( arr , n ) : if n < 4 : print ( "Thearrayshouldhaveatlest4elements" ) return MIN table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) for i in range ( n - 1 , - 1 , - 1 ) : table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) for i in range ( n - 2 , - 1 , - 1 ) : table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) for i in range ( n - 3 , - 1 , - 1 ) : table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) for i in range ( n - 4 , - 1 , - 1 ) : table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) return table4 [ 0 ]

def findMaxValue ( arr , n ) : if ( n < 1 ) : exit ( 1 ) ; table1 = [ INT_MAX for k in range ( n ) ] table2 = [ INT_MAX for k in range ( n ) ] table3 = [ INT_MAX for k in range ( n ) ] table4 = [ INT_MAX for k in range ( n ) ] for i in range ( n - 1 , n - 2 ) : table1 [ i ] = max ( table1 [ i + 1 ] = max ( table1 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) if ( i >= 0 ) : table3 [ i ] = max ( table3 [ i + 1 ] + arr [ i ] ) return table1 [ n ]

def findMaxValue ( arr , n ) : table1 = [ 0 for k in range ( n ) ] table2 = [ 0 for k in range ( n ) ] table3 = [ 0 for k in range ( n ) ] table4 = [ 0 for k in range ( n ) ] for i in range ( n ) : table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) for i in range ( n ) : table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) for i in range ( n ) : table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) for i in range ( n - 3 ) : table4 [ i ] = max ( table4 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) return table1 , table2 , table3 , table4

38.78
33.34
67.11
48.99
static int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; }

def minCoins ( coins , m , V ) : table = [ 0 for i in range ( V + 1 ) ] table [ 0 ] = 0 for i in range ( 1 , V + 1 ) : table [ i ] = sys . maxsize for i in range ( 1 , V + 1 ) : for j in range ( m ) : if ( coins [ j ] <= i ) : sub_res = table [ i - coins [ j ] ] if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : table [ i ] = sub_res + 1 return table [ V ]

def minCoins ( coins , m , V ) : table = [ 0 for i in range ( 1 , V ) ] for i in range ( 1 , m , V ) : if ( coins [ j ] <= i ) : table [ i ] = sub_res + 1 else : table [ i ] = sub_res + 1 return table [ V ]

def minCoins ( coins , m , V ) : table = [ 0 for i in range ( V ) ] for i in range ( 1 , V , 1 ) : for j in range ( m ) : if ( coins [ j ] <= i ) : sub_res = table [ i - coins [ j ] ] if ( sub_res != float ( 'inf' ) and sub_res + 1 < table [ i ] ) : table [ i ] = sub_res + 1 return table [ V ]

38.85
40.12
59.54
53.9
static int findSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) ans += ( i / j ) ; return ans ; }

def findSum ( N ) : ans = 0 for i in range ( 1 , N + 1 ) : for j in range ( 1 , N + 1 ) : ans += i // j return ans

def findSum ( n ) : ans = 0 for i in range ( 1 , n ) : ans += ( i / j ) return ans

def findSum ( n ) : ans = 0 for i in range ( 1 , n ) : for j in range ( 1 , n ) : ans += ( i / j ) return ans

38.87
33.17
41.24
37.13
static int getLevenstein ( StringBuilder input ) { StringBuilder revInput = new StringBuilder ( input ) ; revInput = revInput . reverse ( ) ; int n = input . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = Integer . MAX_VALUE ; for ( int i = n , j = 0 ; i >= 0 ; i -- , j ++ ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }

def getLevenstein ( inpt ) : revInput = inpt [ : : - 1 ] n = len ( inpt ) dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ 0 ] [ i ] = i dp [ i ] [ 0 ] = i for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if inpt [ i - 1 ] == revInput [ j - 1 ] : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) res = INT_MAX i , j = n , 0 while i >= 0 : res = min ( res , dp [ i ] [ j ] ) if i < n : res = min ( res , dp [ i + 1 ] [ j ] ) if i > 0 : res = min ( res , dp [ i - 1 ] [ j ] ) i -= 1 j += 1 return res

def getLevenstein ( input ) : input = input . reverse ( ) dp = [ 0 for i in range ( n + 1 , - 1 , - 1 ) ] for i in range ( n + 1 , - 1 ) : if ( input [ i ] == revInput [ j ] ) : dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if ( i > 0 ) : res = min ( res , dp [ i + 1 ] [ j ] ) return res

def getLevenstein ( input ) : revInput = revInput . reverse ( ) dp = [ 0 for i in range ( n + 1 , n + 1 ) ] for i in range ( 1 , n ) : dp [ 0 ] [ i ] = i dp [ i ] [ 0 ] = i for i in range ( 1 , n + 1 ) : if ( input [ i - 1 ] == revInput [ j - 1 ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) return res

38.95
41.1
45.86
49.4
static boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }

def check ( st ) : n = len ( st ) if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : return False digitSum = 0 for i in range ( 0 , n ) : digitSum = digitSum + ( int ) ( st [ i ] ) return ( digitSum % 3 == 0 )

def check ( str ) : n = len ( str ) for i in range ( n ) : digitSum = 0 for i in range ( n - 1 , - 1 , - 1 ) : digitSum += ( str [ i ] - '0' ) return ( digitSum % 3 == 0 )

def check ( str ) : n = str . length ( ) if ( n - 1 ) == 0 : return False digitSum = 0 for i in range ( 0 , n ) : digitSum += ( str [ i ] - '0' ) return ( digitSum % 3 == 0 )

38.95
40.04
31.74
31.84
public static void commonCharacters ( String str [ ] , int n ) { Boolean [ ] prim = new Boolean [ MAX_CHAR ] ; Arrays . fill ( prim , new Boolean ( true ) ) ; for ( int i = 0 ; i < n ; i ++ ) { Boolean [ ] sec = new Boolean [ MAX_CHAR ] ; Arrays . fill ( sec , new Boolean ( false ) ) ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { if ( prim [ str [ i ] . charAt ( j ) - 'a' ] ) sec [ str [ i ] . charAt ( j ) - 'a' ] = true ; } System . arraycopy ( sec , 0 , prim , 0 , MAX_CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) { System . out . print ( Character . toChars ( i + 97 ) ) ; System . out . print ( " " ) ; } }

def commonCharacters ( strings , n ) : prim = [ True ] * MAX_CHAR for i in range ( n ) : sec = [ False ] * MAX_CHAR for j in range ( len ( strings [ i ] ) ) : if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) : sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = True for i in range ( MAX_CHAR ) : prim [ i ] = sec [ i ] for i in range ( 26 ) : if ( prim [ i ] ) : print ( "%c" % ( i + ord ( 'a' ) ) , end = "" )

def commonCharacters ( str , n ) : prim = [ True for i in range ( n ) ] sec = [ True for i in range ( n ) ] for j in range ( 0 , i + 1 , MAX_CHAR ) : if ( prim [ str [ i ] . charAt ( j ) - 'a' ] ) : sec [ str [ i ] . charAt ( j ) - 'a' ] = true prim [ str [ i ] . charAt ( j ) ] = true if ( sec [ i ] ) : sec = [ True for i in range ( 0 , n ) : if ( prim [ i ] ) : print ( Character . toChars ( i + 97 ) ) : print ( " " ) elif ( sec [ prim [ i ] ) : print ( Character . toChars ( i + 97 ) ) : print ( " " ) return

def commonCharacters ( str , n ) : prim = [ True for i in range ( n ) ] sec = [ False for i in range ( n ) ] for j in range ( 0 , n ) : if ( prim [ str [ i ] [ j ] - 'a' ] ) : sec [ str [ i ] [ j ] - 'a' ] = True if ( prim [ str [ i ] [ j ] - 'a' ] ) : sec [ str [ i ] [ j ] - 'a' ] = True if ( prim [ str [ i ] [ j ] - 'a' ] ) : sec [ str [ i ] [ j ] - 'a' ] = True if ( sec [ str [ i ] [ j ] - 'a' ] ) : prim [ str [ i ] [ j ] - 'a' ] = True if ( prim [ i ] ) : System . out . print ( Character . toChars ( i + 97 ) ) else : System . out . print ( " " )

39.02
34.34
42.53
39.89
static void splitString ( String str ) { StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ; else if ( Character . isAlphabetic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ; else special . append ( str . charAt ( i ) ) ; } System . out . println ( alpha ) ; System . out . println ( num ) ; System . out . println ( special ) ; }

def splitString ( str ) : alpha = "" num = "" special = "" for i in range ( len ( str ) ) : if ( str [ i ] . isdigit ( ) ) : num = num + str [ i ] elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( str [ i ] >= 'a' and str [ i ] <= 'z' ) ) : alpha += str [ i ] else : special += str [ i ] print ( alpha ) print ( num ) print ( special )

def splitString ( str ) : alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) for i in range ( len ( str ) ) : if ( Character . isLetter ( str [ i ] ) ) num . append ( str [ i ] ) else special . append ( str [ i ] ) alpha . append ( str [ i ] ) else : num . append ( str [ i ] ) if ( Character . isAlphabetic ( str [ i ] ) : special .

def splitString ( str ) : alpha = "" num = "" special = "" for i in range ( len ( str ) ) : if i < len ( str ) : alpha . append ( str [ i ] ) elif i < len ( str ) : num . append ( str [ i ] ) elif i < len ( str ) : alpha . append ( str [ i ] ) else : special . append ( str [ i ] )

39.02
40.09
76.14
72.12
public static int dealnnoy ( int n , int m ) { if ( m == 0 || n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }

def dealnnoy ( n , m ) : if ( m == 0 or n == 0 ) : return 1 return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 )

def dealnnoy ( n , m ) : if ( m == 0 || n == 0 ) : return 1 else : return dealnnoy ( n , m - 1 )

def dealnnoy ( n , m ) : if m == 0 or n == 0 : return 1 return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n ) + dealnnoy ( m , n )

39.04
37.33
42.83
30.87
static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }

def twoWaySort ( arr , n ) : for i in range ( 0 , n ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1 arr . sort ( ) for i in range ( 0 , n ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1

def twoWaySort ( arr , n ) : if ( arr [ i ] & 1 ) != 0 : arr [ i ] *= - 1 if ( arr [ i ] & 2 ) != 0 : arr [ i ] *= - 1 if ( arr [ i ] & 1 ) != 0 : arr [ i ] *= - 1 if ( arr [ i ] & 1 ) != 0 : arr [ i ] *= - 1 if ( arr [ i ] & 2 ) != 0 : arr [ i ] =

def twoWaySort ( arr , n ) : for i in range ( n ) : if ( arr [ i ] & 1 ) != 0 : arr [ i ] *= - 1 arr [ i ] = None

39.06
34.49
34.42
30.45
static void printSubsequences ( String s ) { char [ ] str = s . toCharArray ( ) ; int n = str . length ; int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " " ) ; } System . out . println ( ) ; } }

def printSubsequences ( str ) : n = len ( str ) opsize = int ( pow ( 2 , n - 1 ) ) for counter in range ( opsize ) : for j in range ( n ) : print ( str [ j ] , end = "" ) if ( counter & ( 1 << j ) ) : print ( "" , end = "" ) print ( "\n" , end = "" )

def printSubsequences ( s ) : n = len ( s ) str = str [ : n ] for counter in range ( 0 , opsize ) : for j in range ( 0 , n ) : if ( counter & ( 1 << j ) ) > 0 : print ( str [ j ] ) if ( counter & ( 1 << j ) ) > 0 : print ( " " ) if ( counter & ( 1 << j ) ) > 0 : print ( " " )

def printSubsequences ( s ) : str = str . encode ( 'utf-8' ) for counter in opsize : for j in range ( 0 , n , - 1 ) : print ( str [ j ] ) if ( ( counter & ( 1 << j ) ) > 0 : print ( " " )

39.06
36.43
31.65
28.67
static void smallestSubsegment ( int a [ ] , int n ) { HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; int mx = 0 ; int mn = - 1 , strindex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count . get ( x ) == null ) { left . put ( x , i ) ; count . put ( x , 1 ) ; } else count . put ( x , count . get ( x ) + 1 ) ; if ( count . get ( x ) > mx ) { mx = count . get ( x ) ; mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) { mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

def smallestSubsegment ( a , n ) : left = dict ( ) count = dict ( ) mx = 0 mn , strindex = 0 , 0 for i in range ( n ) : x = a [ i ] if ( x not in count . keys ( ) ) : left [ x ] = i count [ x ] = 1 else : count [ x ] += 1 if ( count [ x ] > mx ) : mx = count [ x ] mn = i - left [ x ] + 1 strindex = left [ x ] elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) : mn = i - left [ x ] + 1 strindex = left [ x ] for i in range ( strindex , strindex + mn ) : print ( a [ i ] , end = "" )

def smallestSubsegment ( a , n ) : left = defaultdict ( int ) count = defaultdict ( int ) for i in range ( n ) : left . put ( x , i ) count . put ( x , 1 ) if ( count [ x ] == null ) : left [ x , i ) count . put ( x , 1 ) elif ( count [ x ] > mx ) : mx = count [ x ] mn = i - left . get ( x ) + 1 strindex = left [ x ] if ( i - left [ x ] < mn ) : mn = i - left . get ( x ) if ( i - left . get ( x ) + 1 < mn ) : mn = i - left . get ( x ) + 1 strindex = left [ x ] if ( count [ x ] == mx ) : strindex = left [ x ] elif ( count [ x ] > mn ) : mn = i - left . get ( x ) + 1 strindex = left [ x ] if ( i - left [ x ] > mn ) : mn = i - left [ x ] if ( i - left . get ( x ) + 1 < mn ) : mn = i - left . get ( x )

def smallestSubsegment ( a , n ) : left = list ( ) count = list ( ) mx = 0 mn = - 1 strindex = - 1 for i in range ( strindex , strindex + mn ) : x = a [ i ] if ( count . get ( x ) == null ) : left . put ( x , i ) count . put ( x , 1 ) else : count . put ( x , count . get ( x ) + 1 ) if ( count . get ( x ) > mx ) : mx = count . get ( x ) mn = i - left . get ( x ) + 1 strindex = left . get ( x ) else : if ( count . get ( x ) == mx ) and ( i - left . get ( x ) + 1 < mn ) : mn = i - left . get ( x ) + 1 strindex = left . get ( x ) else : if ( count . get ( x ) == mx ) and ( i - left . get ( x ) + 1 < mn ) : mn = i - left . get ( x ) + 1 strindex = left . get ( x )

39.12
36.03
77.85
78.28
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }

def nextPowerOf2 ( n ) : p = 1 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( p < n ) : p <<= 1 return p

def nextPowerOf2 ( n ) : p = 1 while ( p < n ) : p <<= 1 return p

def nextPowerOf2 ( n ) : p = 1 if n > 0 and ( n & ( n - 1 ) ) == 0 : return n while ( p < n ) : p <<= 1 return p

39.12
36.03
77.85
78.28
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }

def nextPowerOf2 ( n ) : p = 1 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( p < n ) : p <<= 1 return p

def nextPowerOf2 ( n ) : p = 1 while ( p < n ) : p <<= 1 return p

def nextPowerOf2 ( n ) : p = 1 if n > 0 and ( n & ( n - 1 ) ) == 0 : return n while ( p < n ) : p <<= 1 return p

39.13
29.86
28.97
26.01
static void longestString ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ str2 . charAt ( i ) - 'a' ] ++ ; } String result = "" ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( 'a' + i ) ; } } System . out . println ( result ) ; }

def longestString ( str1 , str2 ) : count1 = [ 0 ] * 26 count2 = [ 0 ] * 26 for i in range ( len ( str1 ) ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( str2 ) ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 result = "" for i in range ( 26 ) : for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : result = result + chr ( ord ( 'a' ) + i ) print ( result )

def longestString ( str1 , str2 ) : count1 = [ 0 for i in range ( 26 ) ] count2 = [ 0 for i in range ( 26 ) ] for i in range ( 0 , 26 ) : count1 [ i ] += 1 count2 [ i ] += 1 result = "" for i in range ( 0 , 26 ) : if ( j <= min ( count1 [ i ] , count2 [ i ] ) : result += ( char )

def longestString ( str1 , str2 ) : count1 = [ 0 for k in range ( 26 ) ] count2 = [ 0 for k in range ( 26 ) ] result = "" for i in range ( 0 , 26 ) : for j in range ( 1 , count1 [ i ] ) : result += ( char ) ( 'a' + i ) print ( result )

39.14
38.14
100.0
100.0
static int Resources ( int process , int need ) { int minResources = 0 ; minResources = process * ( need - 1 ) + 1 ; return minResources ; }

def Resources ( process , need ) : minResources = 0 minResources = process * ( need - 1 ) + 1 return minResources

def Resources ( process , need ) : minResources = process * need

def Resources ( process , need ) : minResources = 0 minResources = process * ( need - 1 ) + 1 return minResources

39.14
30.3
63.5
73.84
static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }

def isSubSequence ( string1 , string2 , m , n ) : if m == 0 : return True if n == 0 : return False if string1 [ m - 1 ] == string2 [ n - 1 ] : return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) return isSubSequence ( string1 , string2 , m , n - 1 )

def isSubSequence ( str1 , str2 , m , n ) : if ( m == 0 ) : return str1 == str2 ; if ( n == 1 ) : return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) else : return isSubSequence ( str1 , str2 , m - 1 , n - 1 )

def isSubSequence ( str1 , str2 , m , n ) : if m == 0 : return True if n == 0 : return False if str1 [ m - 1 ] == str2 [ n - 1 ] : return isSubSequence ( str1 , str2 , m - 1 , n ) return isSubSequence ( str1 , str2 , m , n )

39.15
40.74
44.34
54.11
static int maxDistance ( int [ ] arr , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }

def maxDistance ( arr , n ) : mp = { } maxDict = 0 for i in range ( n ) : if arr [ i ] not in mp . keys ( ) : mp [ arr [ i ] ] = i else : maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) return maxDict

def maxDistance ( arr , n ) : map = new HashMap < Integer , Integer > ( ) for i in range ( 0 , n ) : if ( ! map . containsKey ( arr [ i ] ) ) : map . put ( arr [ i ] , i ) max_dist = max ( max_dist , i - map [ arr [ i ] ] ) return max_dist

def maxDistance ( arr , n ) : map = { } max_dist = 0 for i in range ( n ) : if not map . containsKey ( arr [ i ] ) : map . put ( arr [ i ] , i ) else : max_dist = max ( max_dist , i - map . get ( arr [ i ] ) ) return max_dist

39.16
36.97
62.47
76.61
static void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; double polarradius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" ) ; else System . out . print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" ) ; }

def checkPoint ( radius , x , y , percent , startAngle ) : endAngle = 360 / percent + startAngle polarradius = math . sqrt ( x * x + y * y ) Angle = math . atan ( y / x ) if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : print ( "Point(" , x , "," , y , ")" "existinthecirclesector" ) else : print ( "Point(" , x , "," , y , ")" "doesnotexistinthecirclesector" )

def checkPoint ( radius , x , y , percent , startAngle ) : endAngle = 360 / percent + startAngle for polarradius in range ( radius ) : if ( Angle >= startAngle && Angle <= endAngle ) : print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" ) else : print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\

def checkPoint ( radius , x , y , percent , startAngle ) : endAngle = 360 / percent + startAngle polarradius = math . sqrt ( x * x + y * y ) Angle = atan ( y / x ) if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" ) else : print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" )

39.18
51.59
30.5
46.18
static void parabola ( float a , float b , float c ) { System . out . println ( "Vertex: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) + ")" ) ; System . out . println ( "Focus: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + ")" ) ; System . out . println ( "Directrix:" + " y=" + ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) ) ; }

def parabola ( a , b , c ) : print ( "Vertex:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) , ")" , sep = "" ) print ( "Focus:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , ")" , sep = "" ) print ( "Directrix:y=" , c - ( ( b * b ) + 1 ) * 4 * a , sep = "" )

def parabola ( a , b , c ) : print ( "Parabola:" + " a=" + ( float ) ( a ) ) print ( "Focus: (" + ( - b / ( 2 * a ) ) , " " + ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ) print ( "Directrix:" + " y=" + ( int ) ( c - ( b * b ) ) )

def parabola ( a , b , c ) : a = float ( a ) b = float ( b ) c = float ( c ) print ( "Vertex: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + ")" )

39.4
39.58
75.16
57.83
static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }

def pairsInSortedRotated ( arr , n , x ) : for i in range ( n ) : if arr [ i ] > arr [ i + 1 ] : break l = ( i + 1 ) % n r = i cnt = 0 while ( l != r ) : if arr [ l ] + arr [ r ] == x : cnt += 1 if l == ( r - 1 + n ) % n : return cnt l = ( l + 1 ) % n r = ( r - 1 + n ) % n elif arr [ l ] + arr [ r ] < x : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return cnt

def pairsInSortedRotated ( arr , n , x ) : for i in range ( n ) : if ( arr [ i ] > arr [ i + 1 ] ) : break if ( arr [ i ] < arr [ i + 1 ] ) : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n cnt += 1 if ( l == r - 1 + n ) : return cnt

def pairsInSortedRotated ( arr , n , x ) : l = ( i + 1 ) % n r = i cnt = 0 while ( l != r ) : if ( arr [ l ] + arr [ r ] == x ) : cnt ++ if ( l == ( r - 1 + n ) % n ) : return cnt l = ( l + 1 ) % n r = ( r - 1 + n ) % n else : if ( arr [ l ] + arr [ r ] < x ) : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return cnt

39.4
39.15
65.62
67.2
static int subsetGraph ( int C [ ] [ ] ) { HashSet < Integer > vertices = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { vertices . add ( i ) ; } while ( ! vertices . isEmpty ( ) ) { if ( vertices . size ( ) == 1 ) { return 1 ; } boolean someone_removed = false ; for ( int x : vertices ) { HashSet < Integer > values = new HashSet < > ( ) ; for ( int y : vertices ) { if ( y != x ) { values . add ( C [ x ] [ y ] ) ; } } if ( values . size ( ) == 1 ) { vertices . remove ( x ) ; someone_removed = true ; break ; } } if ( ! someone_removed ) { break ; } } return ( vertices . size ( ) ) ; }

def subsetGraph ( C ) : global N vertices = set ( ) for i in range ( N ) : vertices . add ( i ) while ( len ( vertices ) != 0 ) : if ( len ( vertices ) == 1 ) : return 1 someone_removed = False for x in vertices : values = set ( ) for y in vertices : if ( y != x ) : values . add ( C [ x ] [ y ] ) if ( len ( values ) == 1 ) : vertices . remove ( x ) someone_removed = True break if ( not someone_removed ) : break return len ( vertices )

def subsetGraph ( N , C ) : vertices = set ( ) for i in range ( N ) : if ( i != 0 ) : values = set ( ) for y in range ( N ) : if ( y != x ) : values . add ( C [ x ] [ y ] ) someone_removed = true break if ( ! someone_removed ) : break return 1

def subsetGraph ( C , [ ] ) : vertices = list ( ) for i in range ( N ) : vertices . add ( i ) while not vertices . isEmpty ( ) : if ( vertices [ - 1 ] == 1 ) : return 1 someone_removed = False for x in vertices : if ( y != x ) : values = list ( ) for y in vertices : if ( y != x ) : values . add ( C [ x ] [ y ] ) if ( values . size ( ) == 1 ) : vertices . remove ( x ) someone_removed = True break if not someone_removed : break return ( vertices . size ( ) )

39.41
37.95
46.82
44.57
private static int minCost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }

def minCost ( cost , m , n ) : tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , m + 1 ) : tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , n + 1 ) : tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return tc [ m ] [ n ]

def minCost ( cost , m , n ) : tc = [ 0 for k in range ( m + 1 , n + 1 ) ] for i in range ( 1 , m + 1 , n ) : tc [ i ] = cost [ i ] [ 0 ] for j in range ( 1 , n ) : tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] ) + cost [ i ] [ j ] return tc [ m ] [ n ]

def minCost ( cost [ ] , m , n ) : tc [ ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , m , n ) : tc [ i ] [ 0 ] = cost [ 0 ] [ 0 ] for j in range ( 1 , n ) : tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return tc [ m ] [ n ]

39.43
33.31
43.88
35.43
static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }

def countSubarrays ( arr , n ) : difference = 0 ans = 0 hash_positive = [ 0 ] * ( n + 1 ) hash_negative = [ 0 ] * ( n + 1 ) hash_positive [ 0 ] = 1 for i in range ( n ) : if ( arr [ i ] & 1 == 1 ) : difference = difference + 1 else : difference = difference - 1 if ( difference < 0 ) : ans += hash_negative [ - difference ] hash_negative [ - difference ] = hash_negative [ - difference ] + 1 else : ans += hash_positive [ difference ] hash_positive [ difference ] = hash_positive [ difference ] + 1 return ans

def countSubarrays ( arr , n ) : difference = 0 hash_positive = [ 0 for k in range ( n ) ] hash_negative = [ 0 for k in range ( n ) ] for i in range ( n ) : if ( arr [ i ] & 1 ) == 1 : difference += 1 if ( difference < 0 ) : ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ return ans

def countSubarrays ( arr , n ) : difference = 0 ans = 0 for i in range ( n ) : if ( arr [ i ] & 1 ) == 1 : difference ++ else : difference -= 1 if ( difference < 0 ) : ans += hash_negative [ - difference ] hash_negative [ - difference ] ++ else : ans += hash_positive [ difference ] hash_positive [ difference ] ++ return ans

39.45
49.64
25.2
26.79
static boolean isDivisible7 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; n = num . length ( ) ; int gSum = 0 , p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; gSum = gSum + group * p ; p = p * - 1 ; } return ( gSum % 7 == 0 ) ; }

def isdivisible7 ( num ) : n = len ( num ) if ( n == 0 and num [ 0 ] == '\n' ) : return 1 if ( n % 3 == 1 ) : num = str ( num ) + "00" n += 2 elif ( n % 3 == 2 ) : num = str ( num ) + "0" n += 1 GSum = 0 p = 1 for i in range ( n - 1 , - 1 , - 1 ) : group = 0 group += ord ( num [ i ] ) - ord ( '0' ) i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 GSum = GSum + group * p p *= ( - 1 ) return ( GSum % 7 == 0 )

def isDivisible7 ( num ) : n = len ( num ) if n == 1 and num [ 0 ] == '0' : return true n = len ( num ) if n % 3 == 0 : num = "00" + num if n % 3 == 2 : num = "0" + num n = len ( num ) for i in range ( n - 1 , - 1 , - 1 ) : group += num [ i ] p += ( num [ i ] - '0' ) if ( i ) : group += ( num [ i ] - '0' ) * 10 group += ( num [ i -- ) * 100 gSum = gSum + group * p return ( gSum % 7 == 0 )

def isDivisible7 ( num ) : n = num . length ( ) gSum = 0 p = 1 for i in range ( n - 1 , - 1 , - 1 ) : group = 0 group += num [ i ] - '0' group += ( num [ i ] - '0' ) * 10 group += ( num [ i ] - '0' ) * 100 gSum = gSum + group * p p = p * - 1 return ( gSum % 7 == 0 )

39.51
22.6
54.52
29.97
public static void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Arrays . sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

def rearrangeArr ( arr , n ) : evenPos = int ( n / 2 ) oddPos = n - evenPos tempArr = np . empty ( n , dtype = object ) for i in range ( 0 , n ) : tempArr [ i ] = arr [ i ] tempArr . sort ( ) j = oddPos - 1 for i in range ( 0 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j - 1 j = oddPos for i in range ( 1 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j + 1 for i in range ( 0 , n ) : print ( arr [ i ] , end = '' )

def rearrangeArr ( arr , n ) : evenPos = n // 2 oddPos = n - evenPos for i in range ( n ) : arr [ i ] = arr [ i ] j = oddPos - 1 for i in range ( 1 , n ) : arr [ i ] = tempArr [ j ] j -= 1 if ( i == 0 ) : print ( arr [ i ] + " " ) else : print ( arr [ i ] + " " )

def rearrangeArr ( arr , n ) : evenPos = n // 2 oddPos = n - evenPos tempArr = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : arr [ i ] = tempArr [ i ] j = oddPos - 1 for i in range ( 1 , n ) : arr [ i ] = tempArr [ j ] j -= 1 j = oddPos for i in range ( 1 , n ) : arr [ i ] = tempArr [ j ] j += 1 for i in range ( 1 , n ) : arr [ i ] = tempArr [ j ] j += 1 for i in range ( 1 , n ) : arr [ i ] = tempArr [ j ] j += 1

39.51
42.41
29.82
21.89
static boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; if ( bin . charAt ( n - 1 ) == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin . charAt ( i ) == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; }

def isDivisibleBy10 ( bin ) : n = len ( bin ) if ( bin [ n - 1 ] == '1' ) : return False sum = 0 i = n - 2 while i >= 0 : if ( bin [ i ] == '1' ) : posFromRight = n - i - 1 if ( posFromRight % 4 == 1 ) : sum = sum + 2 elif ( posFromRight % 4 == 2 ) : sum = sum + 4 elif ( posFromRight % 4 == 3 ) : sum = sum + 8 elif ( posFromRight % 4 == 0 ) : sum = sum + 6 i = i - 1 if ( sum % 10 == 0 ) : return True return False

def isDivisibleBy10 ( bin ) : n = len ( bin ) for i in range ( n ) : if ( bin [ i ] == '1' ) : sum = sum + 1 else : sum = sum + 2 for i in range ( n - 2 , - 1 , - 1 ) : if ( bin [ i ] == '1' ) : sum = sum + 1 else : if ( posFromRight % 4 == 0 ) : sum = sum +

def isDivisibleBy10 ( bin ) : sum = 0 for i in range ( n ) : if bin . charAt ( i ) == '1' : sum = sum + 2 elif bin [ i ] == '1' : sum = sum + 2 elif bin [ i ] == '1' : sum = sum + 4 elif bin [ i ] == '2' : sum = sum + 4 elif bin [ i ] == '3' : sum = sum + 8 elif bin [ i ] == 0 : sum = sum + 6 return isDivisibleBy10 ( bin )

39.52
47.09
70.77
58.28
static int findArea ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }

def findArea ( arr , n ) : s = [ ] first = 0 second = 0 for i in range ( n ) : if arr [ i ] not in s : s . append ( arr [ i ] ) continue if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] return ( first * second )

def findArea ( arr , n ) : s = set ( ) for i in range ( n ) : if ( arr [ i ] < first ) : first = arr [ i ] second = arr [ i ] else : second = arr [ i ] if ( arr [ i ] > second ) : second = first first = arr [ i ] if ( arr [ i ] > first ) : first = arr [ i ] if ( arr [ i ] > second ) : second = arr [ i ] if ( arr [ i ] > second ) : second = arr [ i ] if ( arr [ i ] > second ) : second = arr [ i ] if ( arr [ i ] > second ) : second = arr [ i ] return ( first * second )

def findArea ( arr , n ) : s = list ( ) for i in range ( n ) : if not s . contains ( arr [ i ] ) : s . add ( arr [ i ] ) continue if ( arr [ i ] > first ) : second = first first = arr [ i ] else : if ( arr [ i ] > second ) : second = arr [ i ] else : second = arr [ i ] return ( first * second )

39.52
30.75
73.5
60.74
static void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " " ) ; } }

def printSeries ( n ) : for i in range ( 1 , n + 1 ) : num = i * ( i + 1 ) * ( i + 2 ) // 6 print ( num , end = '' )

def printSeries ( n ) : for i in range ( 1 , n ) : print ( i , end = "" ) print ( end = "" ) for i in range ( 1 , n ) : print ( num , end = "" ) print ( end )

def printSeries ( n ) : for i in range ( 1 , n ) : num = i * ( i + 1 ) * ( i + 2 ) / 6 print ( num )

39.56
29.9
39.6
30.96
static boolean findthepath ( char [ ] S , int v ) { result [ 0 ] = ( char ) ( v + '0' ) ; for ( int i = 1 ; i < ( int ) S . length ; i ++ ) { if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] [ v ] ) { v = S [ i ] - 'A' ; } else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i ] - 'A' + 5 ] [ v ] ) { v = S [ i ] - 'A' + 5 ; } else return false ; result [ i ] = ( char ) ( v + '0' ) ; } return true ; }

def findthepath ( S , v ) : result [ 0 ] = v for i in range ( 1 , len ( S ) ) : if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) ] [ v ] ) : v = ord ( S [ i ] ) - ord ( 'A' ) elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) : v = ord ( S [ i ] ) - ord ( 'A' ) + 5 else : return False result . append ( v ) return True

def findthepath ( S , v ) : result = [ 0 for i in range ( 1 , ( int ) S . length ) ] for i in range ( 1 , ( int ) S . length ) : if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' + 5 ] [ v ] ) : v = S [ i ] - 'A' + 5 ] else : return false result [ i ] = ( char ) ( v + '0' ) if ( adj [ v ] [ S [ i ] - 'A' ] [ S [ i ] - 'A' + 5 ] [ v ] ) : if ( adj [ v ] [ S [ i ] - 'A' ] [ v ] ) : v = S [ i ] - 'A' + 5 ] [ v ] return true

def findthepath ( S , v ) : result [ 0 ] = ( v + '0' ) for i in range ( 1 , S . length ) : if adj [ v ] [ S [ i ] - 'A' ] or adj [ S [ i ] - 'A' ] [ v ] : v = S [ i ] - 'A' elif adj [ v ] [ S [ i ] - 'A' + 5 ] or adj [ S [ i ] - 'A' + 5 ] [ v ] : v = S [ i ] - 'A' + 5 else : return false result [ i ] = ( v + '0' ) return True

39.56
40.9
10.16
19.9
static void factorize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) { System . out . println ( "2" + " " + count ) ; } for ( long i = 3 ; i <= ( long ) Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) { System . out . println ( i + " " + count ) ; } } if ( n > 2 ) { System . out . println ( n + " " + "1" ) ; } }

def factorize ( n ) : count = 0 while ( ( n % 2 > 0 ) == False ) : n >>= 1 count += 1 if ( count > 0 ) : print ( 2 , count ) for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : count = 0 while ( n % i == 0 ) : count += 1 n = int ( n / i ) if ( count > 0 ) : print ( i , count ) i += 2 if ( n > 2 ) : print ( n , 1 )

def factorize ( n ) : count = 0 while ( n > 2 ) : print ( n + " " + count ) if ( n > 2 ) : print ( n + " " + "1" ) ; } for i in range ( 3 , Math . sqrt ( n ) ) : count = 0 while n > 2 : print ( i + " " + count ) if ( n > 1 ) : print ( n + " " + "2" ) ; }

def factorize ( n ) : count = 0 while not ( n % 2 > 0 ) : n >>= 1 count += 1 if count > 0 : print ( "2" + " " + count )

39.64
45.4
57.87
63.91
static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }

def findSum ( n ) : sm = 0 for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : sm = sm + i * j return sm

def findSum ( n ) : sum = 0 for i in range ( 1 , n ) : sum = sum + i * j return sum

def findSum ( n ) : sum = 0 for i in range ( 1 , n ) : for j in range ( 1 , n ) : sum = sum + i * j return sum

39.64
47.25
47.28
59.99
static void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { System . out . println ( "Invalid Input" ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } System . out . println ( " The two elements whose " + "sum is minimum are " + arr [ min_l ] + " and " + arr [ min_r ] ) ; }

def minAbsSumPair ( arr , arr_size ) : inv_count = 0 if arr_size < 2 : print ( "InvalidInput" ) return min_l = 0 min_r = 1 min_sum = arr [ 0 ] + arr [ 1 ] for l in range ( 0 , arr_size - 1 ) : for r in range ( l + 1 , arr_size ) : sum = arr [ l ] + arr [ r ] if abs ( min_sum ) > abs ( sum ) : min_sum = sum min_l = l min_r = r print ( "Thetwoelementswhosesumisminimumare" , arr [ min_l ] , "and" , arr [ min_r ] )

def minAbsSumPair ( arr , arr_size ) : inv_count = 0 for k in range ( arr_size ) : min_sum = arr [ 0 ] + arr [ 1 ] for l in range ( arr_size - 1 , - 1 ) : sum = arr [ l ] + arr [ r ] if ( min_sum > sum ) : min_sum = sum min_l = l min_r = r if ( min_sum > sum ) : min_sum = sum min_sum = sum min_sum = arr [ 0 ] + arr [ 1 ] for r in range ( arr_size - 1 , arr_size - 1 ) : min_sum = sum min_l = l + 1 , arr_size - 1 ) : min_sum = sum print ( "The two elements whose " + "sum is minimum are " + arr [ min_l ] + " and " + arr [ min_r ] ) : inv_count += 1 print ( "The two elements whose " + "sum is maximum are " + arr [ min_r ] ) return inv_count

def minAbsSumPair ( arr , arr_size ) : inv_count = 0 min_l = 0 min_r = 1 min_sum = arr [ 0 ] + arr [ 1 ] for l in range ( arr_size - 1 , arr_size ) : for r in range ( l + 1 , arr_size ) : sum = arr [ l ] + arr [ r ] if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) : min_sum = sum min_l = l min_r = r if l < arr_size - 1 : for r in range ( l + 1 , arr_size ) : sum = arr [ l ] + arr [ r ] if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) : min_sum = sum min_l = l min_r = r print ( "The two elements whose " + "sum is minimum are " + arr [ min_l ] + " and " + arr [ min_r ] )

39.64
42.78
47.03
48.56
void findRoots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( "Invalid" ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( "Roots are real and different \n" ) ; System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + "\n" + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else { System . out . println ( "Roots are complex \n" ) ; System . out . println ( - ( double ) b / ( 2 * a ) + " + i" + sqrt_val + "\n" + - ( double ) b / ( 2 * a ) + " - i" + sqrt_val ) ; } }

def findRoots ( a , b , c ) : if a == 0 : print ( "Invalid" ) return - 1 d = b * b - 4 * a * c sqrt_val = math . sqrt ( abs ( d ) ) if d > 0 : print ( "Rootsarerealanddifferent" ) print ( ( - b + sqrt_val ) / ( 2 * a ) ) print ( ( - b - sqrt_val ) / ( 2 * a ) ) elif d == 0 : print ( "Rootsarerealandsame" ) print ( - b / ( 2 * a ) ) else : print ( "Rootsarecomplex" ) print ( - b / ( 2 * a ) , "+i" , sqrt_val ) print ( - b / ( 2 * a ) , "-i" , sqrt_val )

def findRoots ( a , b , c ) : if ( b == 0 ) : print ( "Invalid" ) return ; a = abs ( a ) b = abs ( b ) c = abs ( c ) d = abs ( d ) if ( d > 0 ) : print ( "Roots are real and different \n" ) print ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + "\n" + ( double ) ( - b - sqrt_val ) ) else : print ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) return ; } findRoots ( a , b , c )

def findRoots ( a , b , c ) : sqrt_val = sqrt ( abs ( d ) ) if d > 0 : print ( "Roots are real and different \n" ) print ( ( - b + sqrt_val ) / ( 2 * a ) + "\n" + ( - b - sqrt_val ) / ( 2 * a ) ) else : print ( "Roots are complex \n" ) print ( - ( double ) b / ( 2 * a ) + " + i" + sqrt_val + "\n" + - ( double ) b / ( 2 * a ) + " - i" + sqrt_val )

39.65
42.71
56.8
44.5
static void assign ( int a [ ] , int n ) { Arrays . sort ( a ) ; int ans [ ] = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ; else ans [ i ] = a [ p ++ ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }

def assign ( a , n ) : a . sort ( ) ans = [ 0 ] * n p = 0 q = n - 1 for i in range ( n ) : if ( i + 1 ) % 2 == 0 : ans [ i ] = a [ q ] q = q - 1 else : ans [ i ] = a [ p ] p = p + 1 for i in range ( n ) : print ( ans [ i ] , end = "" )

def assign ( a , n ) : a . sort ( reverse = True ) p = 0 q = n - 1 ans = [ 0 for i in range ( n ) ] for i in range ( 0 , n ) : if ( i % 2 == 0 ) : ans [ i ] = a [ p ++ ] elif ( i + 1 ) % 2 == 0 : ans [ i ] = a [ q -- ] else : ans [ i ] = a [ p ++ ] if ( i ) : ans [ i ] = a [ i ] if ( i + 1 ) % 2 == 0 : ans [ i ] = a [ p ++ ] else : ans [ i ] = a [ q ] for i in range ( 0 , n ) : print ( ans [ i ] + " " ) print ( ans [ i ] + " " )

def assign ( a , n ) : ans = [ 0 for i in range ( n ) ] p = 0 q = n - 1 for i in range ( 0 , n ) : if ( i + 1 ) % 2 == 0 : ans [ i ] = a [ q -- ] else : ans [ i ] = a [ p ++ ]

39.7
36.04
45.72
40.52
static int numofArray ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > [ ] mu = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new Vector < > ( ) ; mu [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }

def numofArray ( n , m ) : dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] di = [ [ ] for i in range ( MAX ) ] mu = [ [ ] for i in range ( MAX ) ] for i in range ( 1 , m + 1 ) : for j in range ( 2 * i , m + 1 , i ) : di [ j ] . append ( i ) mu [ i ] . append ( j ) di [ i ] . append ( i ) for i in range ( 1 , m + 1 ) : dp [ 1 ] [ i ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 1 , m + 1 ) : dp [ i ] [ j ] = 0 for x in di [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] for x in mu [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ans = 0 for i in range ( 1 , m + 1 ) : ans += dp [ n ] [ i ] di [ i ] . clear ( ) mu [ i ] . clear ( ) return ans

def numofArray ( n , m ) : dp = [ INT_MAX for i in range ( n , m ) ] mu = [ INT_MAX for i in range ( n , m ) ] for j in range ( 1 , MAX ) : di [ i ] = new Vector < int > ( ) mu [ i ] = new Vector < int > ( ) for i in range ( 1 , n , m ) : di [ j ] . add ( i ) : mu [ i ] . add ( j ) : if ( j == 1 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 0 for i in range ( 2 , m ) : if ( x in di [ j ] ) : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] return dp [ i ] [ j ]

def numofArray ( n , m ) : dp = [ 0 for k in range ( MAX ) ] di = [ 0 for k in range ( MAX ) ] mu = [ 0 for k in range ( MAX ) ] for i in range ( MAX ) : dp [ i ] [ j ] = 0 for x in di [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] for x in mu [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] for x in mu [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] for x in di [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] for x in mu [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] for x in mu [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] return dp

39.73
42.0
67.15
54.85
static int [ ] Restore_Tree ( int [ ] S , int [ ] End ) { int [ ] Identity = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Identity [ S [ i ] ] = i ; int [ ] parent = new int [ N ] ; Arrays . fill ( parent , - 1 ) ; int curr_parent = Identity [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) { int child = Identity [ j ] ; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_parent ; curr_parent = child ; } else { parent [ child ] = curr_parent ; while ( parent [ child ] > - 1 && End [ child ] == End [ parent [ child ] ] ) { child = parent [ child ] ; curr_parent = parent [ child ] ; if ( curr_parent == Identity [ 0 ] ) break ; } } } for ( int i = 0 ; i < N ; i ++ ) parent [ i ] += 1 ; return parent ; }

def Restore_Tree ( S , E ) : Identity = N * [ 0 ] for i in range ( N ) : Identity [ Start [ i ] ] = i parent = N * [ - 1 ] curr_parent = Identity [ 0 ] for j in range ( 1 , N ) : child = Identity [ j ] if End [ child ] - j > 1 : parent [ child ] = curr_parent curr_parent = child else : parent [ child ] = curr_parent while End [ child ] == End [ parent [ child ] ] : child = parent [ child ] curr_parent = parent [ child ] if curr_parent == Identity [ 0 ] : break for i in range ( N ) : parent [ i ] += 1 return parent

def Restore_Tree ( S , N ) : Identity = [ 0 for i in range ( N ) ] for i in range ( N ) : Identity [ S [ i ] ] = i curr_parent = Identity [ 0 ] for j in range ( 1 , N ) : if ( End [ child ] - j > 1 ) : parent [ child ] = curr_parent curr_parent = child if ( curr_parent == Identity [ 0 ] ) : break return parent

def Restore_Tree ( S , End ) : Identity = [ 0 for i in range ( N ) ] for i in range ( 0 , N ) : Identity [ S [ i ] ] = i curr_parent = Identity [ 0 ] for j in range ( 1 , N ) : child = Identity [ j ] if ( End [ child ] - j > 1 ) : parent [ child ] = curr_parent curr_parent = child while ( parent [ child ] > - 1 and End [ child ] == End [ parent [ child ] ] ) : child = parent [ child ] curr_parent = parent [ child ] if ( curr_parent == Identity [ 0 ] ) : break return parent

39.76
38.81
57.37
62.61
static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }

def getMinSquares ( n ) : dp = [ 0 , 1 , 2 , 3 ] for i in range ( 4 , n + 1 ) : dp . append ( i ) for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : temp = x * x ; if temp > i : break else : dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) return dp [ n ]

def getMinSquares ( n ) : dp = [ 0 for k in range ( n ) ] dp [ 0 ] = 0 dp [ 1 ] = 1 dp [ 2 ] = 3 for i in range ( 4 , n ) : if ( x <= Math . sqrt ( i ) ) : dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) else : dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) break if ( temp > i ) : break else : dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) return res

def getMinSquares ( n ) : dp = [ 0 , 1 , 2 , 3 ] for i in range ( 4 , n ) : dp [ i ] = i for x in range ( 1 , ceil ( math . sqrt ( i ) ) : if ( x <= n ) : dp [ i ] = i for x in range ( 1 , ceil ( math . sqrt ( i ) ) ) : temp = x * x if ( temp > i ) : break else : dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) res = dp [ n ] return res

39.77
53.23
71.34
52.3
static void bin ( int n ) { if ( n > 1 ) bin ( n / 2 ) ; System . out . print ( n % 2 ) ; }

def bin ( n ) : if n > 1 : bin ( n // 2 ) print ( n % 2 , end = "" )

def bin ( n ) : if ( n > 1 ) bin ( n / 2 ) if ( n > 1 ) bin ( n % 2 )

def bin ( n ) : if n > 1 : bin ( n / 2 ) print ( n % 2 )

39.79
48.22
55.34
61.19
static boolean isMagicSquare ( int mat [ ] [ ] ) { int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( sum != colSum ) return false ; } return true ; }

def isMagicSquare ( mat ) : s = 0 for i in range ( 0 , N ) : s = s + mat [ i ] [ i ] s2 = 0 for i in range ( 0 , N ) : s2 = s2 + mat [ i ] [ N - i - 1 ] if ( s != s2 ) : return False for i in range ( 0 , N ) : rowSum = 0 for j in range ( 0 , N ) : rowSum += mat [ i ] [ j ] if ( rowSum != s ) : return False for i in range ( 0 , N ) : colSum = 0 for j in range ( 0 , N ) : colSum += mat [ j ] [ i ] if ( s != colSum ) : return False return True

def isMagicSquare ( mat , N ) : sum = 0 sum2 = 0 for i in range ( N ) : sum = sum + mat [ i ] [ i ] for i in range ( N ) : sum2 = sum2 + mat [ i ] [ N - 1 - i ] if ( sum != sum2 ) : return false ; i = 0 ; i < N ; i ++ : rowSum = 0 for j in range ( 0 , N ) : colSum += mat [ j ] [ i ] if ( rowSum != sum ) : return false return true

def isMagicSquare ( mat ) : sum = 0 sum2 = 0 for i in range ( N ) : sum = sum + mat [ i ] [ i ] for i in range ( N ) : sum = sum + mat [ i ] [ i ] for i in range ( N ) : sum2 = sum2 + mat [ i ] [ N - 1 - i ] if ( sum != sum2 ) : return False for i in range ( 0 , N ) : rowSum = 0 for j in range ( 0 , N ) : rowSum += mat [ i ] [ j ] if ( rowSum != sum ) : return False return True

39.9
35.96
79.99
80.51
static int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; int temp = 0 ; if ( small > big ) { temp = small ; small = big ; big = temp ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }

def getMinDiff ( arr , n , k ) : if ( n == 1 ) : return 0 arr . sort ( ) ans = arr [ n - 1 ] - arr [ 0 ] small = arr [ 0 ] + k big = arr [ n - 1 ] - k if ( small > big ) : small , big = big , small for i in range ( 1 , n - 1 ) : subtract = arr [ i ] - k add = arr [ i ] + k if ( subtract >= small or add <= big ) : continue if ( big - subtract <= add - small ) : small = subtract else : big = add return min ( ans , big - small )

def getMinDiff ( arr , n , k ) : if ( n == 0 ) : return 0 ans = arr [ 0 ] - arr [ 0 ] for i in range ( 1 , n ) : if ( small > big ) : small = big big = temp if ( small > big ) : temp = small small = big big = temp if ( big - subtract <= add - small ) : big = subtract return min ( ans , small - small )

def getMinDiff ( arr , n , k ) : ans = arr [ n - 1 ] - arr [ 0 ] small = arr [ 0 ] + k big = arr [ n - 1 ] - k temp = 0 if ( small > big ) : temp = small small = big big = temp if ( small > big ) : small = big big = temp for i in range ( 1 , n - 1 ) : subtract = arr [ i ] - k add = arr [ i ] + k if ( subtract >= small || add <= big ) : continue if ( big - subtract <= add - small ) : small = subtract else : big = add return min ( ans , big - small )

39.93
42.15
72.51
70.58
static int isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) { return 1 ; } return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) { return dp [ index ] [ modulo ] ; } int placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; int res = placeAdd ; dp [ index ] [ modulo ] = res ; return res ; }

def isPossible ( n , index , modulo , M , arr , dp ) : modulo = ( ( modulo % M ) + M ) % M if ( index == n ) : if ( modulo == 0 ) : return 1 return 0 if ( dp [ index ] [ modulo ] != - 1 ) : return dp [ index ] [ modulo ] placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) res = bool ( placeAdd or placeMinus ) dp [ index ] [ modulo ] = res return res

def isPossible ( n , index , modulo , M , dp ) : dp . sort ( reverse = True ) index = ( index + 1 ) % M arr . sort ( reverse = True ) placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , dp ) return res

def isPossible ( n , index , modulo , M , arr , dp ) : if index == n : if modulo == 0 : return 1 return 0 dp [ index ] [ modulo ] = 0 if dp [ index ] [ modulo ] != - 1 : return dp [ index ] [ modulo ] placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) res = placeAdd dp [ index ] [ modulo ] = res return res

39.95
38.66
49.44
37.18
static void printDuo ( String str ) { int countChar [ ] = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countChar [ str . charAt ( i ) - 'a' ] ++ ; } String str1 = "" , str2 = "" ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( countChar [ i ] > 1 ) { str2 = str2 + ( char ) ( i + 'a' ) ; } else if ( countChar [ i ] == 1 ) { str1 = str1 + ( char ) ( i + 'a' ) ; } } System . out . print ( "String with characters occurring " + "once:\n" ) ; System . out . print ( str1 + "\n" ) ; System . out . print ( "String with characters occurring " + "multiple times:\n" ) ; System . out . print ( str2 + "\n" ) ; System . out . print ( "" ) ; }

def printDuo ( string ) : countChar = [ 0 for i in range ( MAX_CHAR ) ] n = len ( string ) for i in range ( n ) : countChar [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 str1 = "" str2 = "" for i in range ( MAX_CHAR ) : if ( countChar [ i ] > 1 ) : str2 = str2 + chr ( i + ord ( 'a' ) ) elif ( countChar [ i ] == 1 ) : str1 = str1 + chr ( i + ord ( 'a' ) ) print ( "Stringwithcharactersoccurringonce:" , "\n" , str1 ) print ( "Stringwithcharactersoccurring" , "multipletimes:" , "\n" , str2 )

def printDuo ( str ) : countChar = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( n ) : countChar [ i ] = countChar [ str [ i ] - 'a' ] if ( countChar [ i ] > 1 ) : str1 = str1 + ( char ) ( i + 'a' ) elif ( countChar [ i ] == 1 ) : str2 = str2 + ( char ) ( i + 'a' ) else : countChar [ i ] = 1 str1 = str1 + ( char ) ( i + 'a' ) if ( countChar [ i ] == 1 ) : str1 = str1 + ( char ) ( i + 'a' ) elif ( countChar [ i ] == 1 ) : str2 = str2 + ( char ) ( i + 'a' ) else : print ( "" )

def printDuo ( str ) : countChar = [ 0 for i in range ( MAX_CHAR ) ] str1 = "" str2 = "" for i in range ( 0 , MAX_CHAR ) : if ( countChar [ i ] > 1 ) : str2 = str2 + ( char ) ( i + 'a' ) elif ( countChar [ i ] == 1 ) : str1 = str1 + ( i + 'a' ) else : str1 = str1 + ( i + 'a' ) str2 = str2 + ( char ) ( i + 'a' ) print ( str1 + "\n" ) print ( str2 + "\n" )

39.97
35.9
35.12
29.47
static int minSum ( int [ ] A , int n ) { int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return ( min_val * ( n - 1 ) ) ; }

def minSum ( A ) : min_val = min ( A ) ; return min_val * ( len ( A ) - 1 )

def minSum ( A , n ) : min_val = min ( A , n ) return ( min_val )

def minSum ( A , n ) : min_val = float ( 'inf' ) return ( min_val * ( n - 1 ) )

39.99
41.32
59.94
55.48
static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == - 1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != - 1 ) { allocation [ i ] = bestIdx ; blockSize [ bestIdx ] -= processSize [ i ] ; } } System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( "Not Allocated" ) ; System . out . println ( ) ; } }

def bestFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : bestIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if bestIdx == - 1 : bestIdx = j elif blockSize [ bestIdx ] > blockSize [ j ] : bestIdx = j if bestIdx != - 1 : allocation [ i ] = bestIdx blockSize [ bestIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )

def bestFit ( blockSize , m , processSize , n ) : allocation = [ - 1 for i in range ( n ) ] for i in range ( 0 , n ) : if ( blockSize [ j ] >= processSize [ i ] ) : bestIdx = j if ( blockSize [ j ] > processSize [ i ] ) : bestIdx = j if ( allocation [ i ] != - 1 ) : print ( allocation [ i ] + 1 ) else : print ( "Not

def bestFit ( blockSize , m , processSize , n ) : allocation = [ - 1 for i in range ( n ) ] for i in range ( n ) : bestIdx = - 1 for j in range ( m ) : if ( blockSize [ j ] >= processSize [ i ] ) : if ( bestIdx == - 1 ) : bestIdx = j if ( blockSize [ bestIdx ] > blockSize [ j ] ) : bestIdx = j if ( blockSize [ bestIdx ] > blockSize [ j ] ) : bestIdx = j } if ( bestIdx != - 1 ) : allocation [ i ] = bestIdx blockSize [ bestIdx ] -= processSize [ i ] print ( "\nProcess No.\tProcess Size\tBlock no." ) for i in range ( n ) : print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) if ( allocation [ i ] != - 1 ) : print ( allocation [ i ] + 1 ) else : print ( "Not Allocated" )

40.07
33.13
60.0
47.9
static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }

def findFourElements ( arr , n ) : mp = dict ( ) for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : mp [ arr [ i ] + arr [ j ] ] = ( i , j ) d = - 10 ** 9 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : abs_diff = abs ( arr [ i ] - arr [ j ] ) if abs_diff in mp . keys ( ) : p = mp [ abs_diff ] if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : d = max ( d , max ( arr [ i ] , arr [ j ] ) ) return d

def findFourElements ( arr , n ) : map = new HashMap < Integer , Indexes > ( ) for i in range ( 0 , n - 1 , - 1 ) : map . add ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) d = min ( d , abs ( arr [ i ] , arr [ j ] ) ) if ( map . containsKey ( abs_diff ) ) : d = max ( d , abs ( arr [ i ] ) if ( indexes . getI ( ) != i and indexes . getJ ( ) != j ) : d = max ( d , max ( arr [ i ] , arr [ j ] ) return d

def findFourElements ( arr , n ) : map = list ( ) for i in range ( n ) : for j in range ( i + 1 , n ) : map [ arr [ i ] + arr [ j ] ] = [ ] for i in range ( n ) : for j in range ( i + 1 , n ) : abs_diff = abs ( arr [ i ] - arr [ j ] ) if ( map . containsKey ( abs_diff ) ) : Indexes indexes = map . get ( abs_diff ) if ( indexes . getI ( ) != i and indexes . getI ( ) != j and indexes . getJ ( ) != i ) : d = max ( d , max ( arr [ i ] , arr [ j ] ) ) return d

40.08
46.37
36.78
39.6
static int calculate ( int a [ ] , int n ) { int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int frequency [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }

def calculate ( a ) : maximum = max ( a ) frequency = [ 0 for x in range ( maximum + 1 ) ] for i in a : frequency [ i ] += 1 answer = 0 for i in frequency : answer = answer + i * ( i - 1 ) // 2 return answer

def calculate ( a , n ) : maximum = stream ( a ) . max ( ) . getAsInt ( ) frequency = [ 0 for i in range ( n ) ] for i in range ( maximum + 1 , n ) : frequency [ a [ i ] ] += 1 answer = 0 for i in range ( maximum + 1 , n ) : answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) return answer

def calculate ( a , n ) : maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) frequency = [ maximum + 1 ] for i in range ( n ) : frequency [ a [ i ] ] += 1 answer = 0 for i in range ( 0 , ( maximum ) + 1 ) : answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) return answer

40.21
40.78
50.4
47.14
static void shiftMatrixByK ( int [ ] [ ] mat , int k ) { if ( k > N ) { System . out . print ( "Shifting is" + " not possible" ) ; return ; } int j = 0 ; while ( j < N ) { for ( int i = k ; i < N ; i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ; System . out . println ( ) ; j ++ ; } }

def shiftMatrixByK ( mat , k ) : if ( k > N ) : print ( "shiftingis""notpossible" ) return j = 0 while ( j < N ) : for i in range ( k , N ) : print ( "{}" . format ( mat [ j ] [ i ] ) , end = "" ) for i in range ( 0 , k ) : print ( "{}" . format ( mat [ j ] [ i ] ) , end = "" ) print ( "" ) j = j + 1

def shiftMatrixByK ( mat , N ) : if ( k > N ) : print ( "Shifting is" + " possible" ) return ; } j = 0 for k in range ( N ) : print ( mat [ j ] [ k ] ) for i in range ( 0 , k ) : print ( mat [ j ] [ i ] + " " ) for i in range ( 0 , N ) : print ( mat [ j ] [ i ] + " " ) : if ( i < k ) : print ( mat [ j ] [ i ] + " " ) : print ( mat [ j ] [ i ] + " " ) j += 1 return

def shiftMatrixByK ( mat , k ) : if k > N : print ( "Shifting is" + " not possible" ) return j = 0 while j < N : for i in range ( k ) : print ( mat [ j ] [ i ] ) for i in range ( 0 , k ) : print ( mat [ j ] [ i ] ) j += 1

40.28
36.36
47.02
38.03
static int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = Integer . MIN_VALUE ; int posmin = Integer . MAX_VALUE ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; }

def minProductSubset ( a , n ) : if ( n == 1 ) : return a [ 0 ] max_neg = float ( '-inf' ) min_pos = float ( 'inf' ) count_neg = 0 count_zero = 0 prod = 1 for i in range ( 0 , n ) : if ( a [ i ] == 0 ) : count_zero = count_zero + 1 continue if ( a [ i ] < 0 ) : count_neg = count_neg + 1 max_neg = max ( max_neg , a [ i ] ) if ( a [ i ] > 0 ) : min_pos = min ( min_pos , a [ i ] ) prod = prod * a [ i ] if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : return 0 if ( count_neg == 0 ) : return min_pos if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) : prod = int ( prod / max_neg ) return prod

def minProductSubset ( a , n ) : a . sort ( reverse = True ) count_neg = 0 count_zero = 0 product = 1 for i in range ( n ) : if ( a [ i ] == 0 ) : count_zero += 1 negmax = float ( 'inf' ) posmin = float ( 'inf' ) for i in range ( n ) : if ( a [ i ] > 0 and a [ i ] < negmax ) : negmax = a [ i ] if ( count_neg == 0 ) : product *= a [ i ] if ( count_neg == 0 ) : product = product / negmax if ( count_neg != 0 ) : product = product / posmin if ( count_neg != 0 ) : product = product / negmax return product

def minProductSubset ( a , n ) : negmax = INT_MAX posmin = INT_MIN count_neg = 0 count_zero = 0 product = 1 for i in range ( n ) : if ( a [ i ] == 0 ) : count_zero ++ continue if ( a [ i ] < 0 ) : count_neg += 1 negmax = max ( negmax , a [ i ] ) if ( a [ i ] > 0 and a [ i ] < posmin ) : posmin = a [ i ] product *= a [ i ] } if count_zero == n or ( count_neg == 0 and count_zero > 0 ) : return 0 if count_neg == 0 : return posmin if count_neg % 2 == 0 and count_neg != 0 : product = product / negmax return product

40.3
34.9
38.42
39.59
static int findLength ( String str , int n ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ; int ans = 0 ; for ( int len = 2 ; len <= n ; len += 2 ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ; } } return ans ; }

def findLength ( string , n ) : Sum = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) ) ans = 0 for length in range ( 2 , n + 1 , 2 ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length // 2 ] ) : ans = max ( ans , length ) return ans

def findLength ( str , n ) : sum = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] ) - '0' sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] ) ans = max ( ans , len ) for i in range ( 0 , n - len ) : if ( sum [ i + len ] - sum [ i ] == sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] ) : ans = max ( ans , len ) return ans

def findLength ( str , n ) : sum = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' ) ans = 0 for len in range ( 2 , n ) : for j in range ( i + len ) : if sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] : ans = max ( ans , len ) return ans

40.31
31.74
62.22
53.09
static int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) ; return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( ) ; }

def minSum ( ar , n ) : if ( n <= 4 ) : return min ( ar ) sum = [ 0 for i in range ( n ) ] sum [ 0 ] = ar [ 0 ] sum [ 1 ] = ar [ 1 ] sum [ 2 ] = ar [ 2 ] sum [ 3 ] = ar [ 3 ] for i in range ( 4 , n ) : sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) return min ( sum [ n - 4 : n ] )

def minSum ( ar , n ) : if n <= 4 : return minSum ( ar , n ) else : sum = [ 0 for i in range ( 4 , n ) ] for i in range ( 4 , n ) : sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) return minSum ( sum , n - 4 , n )

def minSum ( ar , n ) : sum = [ 0 for k in range ( n ) ] sum [ 0 ] = ar [ 0 ] sum [ 1 ] = ar [ 1 ] sum [ 2 ] = ar [ 2 ] sum [ 3 ] = ar [ 3 ] for i in range ( 4 , n ) : sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( )

40.34
50.9
100.0
100.0
static void scalarProductMat ( int mat [ ] [ ] , int k ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k ; }

def scalarProductMat ( mat , k ) : for i in range ( N ) : for j in range ( N ) : mat [ i ] [ j ] = mat [ i ] [ j ] * k

def scalarProductMat ( mat , N , k ) : mat . sort ( reverse = True ) for i in range ( 0 , N ) : mat [ i ] [ j ] = mat [ i ] [ j ] * k mat [ i ] = mat [ i ] [ j ] * k mat [ i ] = mat [ i ] [ j ] * k

def scalarProductMat ( mat , k ) : for i in range ( N ) : for j in range ( N ) : mat [ i ] [ j ] = mat [ i ] [ j ] * k

40.35
32.65
62.75
50.17
static int findSDSFunc ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }

def findSDSFunc ( n ) : DP = [ 0 ] * ( n + 1 ) DP [ 0 ] = 0 DP [ 1 ] = 1 for i in range ( 2 , n + 1 ) : if ( int ( i % 2 ) == 0 ) : DP [ i ] = DP [ int ( i / 2 ) ] else : DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) return DP [ n ]

def findSDSFunc ( n ) : DP = [ 0 for k in range ( n ) ] for i in range ( 2 , n ) : if ( i % 2 == 0 ) : DP [ i ] = DP [ i / 2 ] else : DP [ i ] = DP [ i / 2 ] + DP [ i + 1 ] return DP [ n ]

def findSDSFunc ( n ) : DP = [ 0 for i in range ( n ) ] DP [ 0 ] = 0 DP [ 1 ] = 1 for i in range ( 2 , n ) : if ( i % 2 == 0 ) : DP [ i ] = DP [ i / 2 ] else : DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] return DP [ n ]

40.36
37.13
29.88
31.23
static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }

def remAnagram ( str1 , str2 ) : count1 = [ 0 ] * CHARS count2 = [ 0 ] * CHARS i = 0 while i < len ( str1 ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 i += 1 i = 0 while i < len ( str2 ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 i += 1 result = 0 for i in range ( 26 ) : result += abs ( count1 [ i ] - count2 [ i ] ) return result

def remAnagram ( str1 , str2 ) : count1 = [ 0 for i in range ( 26 ) ] count2 = [ 0 for i in range ( 26 ) ] for i in range ( 0 , 26 ) : count1 [ i ] += 1 result = 0 for i in range ( 0 , 26 ) : result += abs ( count1 [ i ] - count2 [ i ] ) return result

def remAnagram ( str1 , str2 ) : count1 = [ 0 for k in range ( 26 ) ] count2 = [ 0 for k in range ( 26 ) ] result = 0 for i in range ( 0 , 26 ) : result += abs ( count1 [ i ] - count2 [ i ] ) return result

40.49
34.64
57.2
40.97
public static boolean containsOdd ( int G [ ] [ ] , int src ) { int colorArr [ ] = new int [ V ] ; for ( int i = 0 ; i < V ; ++ i ) colorArr [ i ] = - 1 ; colorArr [ src ] = 1 ; LinkedList < Integer > q = new LinkedList < Integer > ( ) ; q . add ( src ) ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; q . pop ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] == 1 && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] == 1 && colorArr [ v ] == colorArr [ u ] ) return true ; } } return false ; }

def containsOdd ( G , src ) : global V colorArr = [ - 1 ] * V colorArr [ src ] = 1 q = queue . Queue ( ) q . put ( src ) while ( not q . empty ( ) ) : u = q . get ( ) if ( G [ u ] [ u ] == 1 ) : return True for v in range ( V ) : if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) : colorArr [ v ] = 1 - colorArr [ u ] q . put ( v ) elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) : return True return False

def containsOdd ( G , V , src ) : colorArr = [ 0 for i in range ( V ) ] for i in range ( 0 , V ) : if ( G [ u ] [ u ] == 1 and colorArr [ v ] == 1 ) : colorArr [ v ] = 1 - colorArr [ u ] q . append ( v ) elif ( G [ u ] [ v ] == 1 and colorArr [ v ] == 1 ) : return true

def containsOdd ( G , src ) : colorArr = [ - 1 for k in range ( len ( G ) ) ] colorArr [ src ] = - 1 colorArr [ src ] = 1 q = list ( ) for i in range ( len ( G ) ) : if ( G [ u ] [ v ] == 1 and colorArr [ v ] == - 1 ) : colorArr [ v ] = 1 - colorArr [ u ] q . append ( v ) elif ( G [ u ] [ v ] == 1 and colorArr [ v ] == colorArr [ u ] ) : return True return False

40.52
49.17
61.58
48.63
static void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ] + " " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) System . out . print ( arr1 [ i ] + " " ) ; }

def relativeComplement ( arr1 , arr2 , n , m ) : i = 0 j = 0 while ( i < n and j < m ) : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ] , "" , end = "" ) i += 1 elif ( arr1 [ i ] > arr2 [ j ] ) : j += 1 elif ( arr1 [ i ] == arr2 [ j ] ) : i += 1 j += 1 while ( i < n ) : print ( arr1 [ i ] , "" , end = "" )

def relativeComplement ( arr1 , arr2 , n , m ) : i = 0 j = 0 while ( i < n && j < m ) : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ] + " " ) i += 1 elif ( arr1 [ i ] > arr2 [ j ] ) : j += 1 if ( arr1 [ i ] == arr2 [ j ] ) : i += 1 else : if ( arr1 [ i ] == arr2 [ j ] ) : j += 1 else : print ( arr1 [ i ] == arr2 [ j ] ) : print ( arr1 [ i ] == arr2 [ j ] ) : print ( arr1 [ i ] + " " ) i += 1 elif ( arr1 [ i ] == arr2 [ j ] ) : j += 1 if ( arr1 [ i ] == arr2 [ j ] ) : i += 1 else : print ( arr1 [ i ] == arr2 [ j ] ) : j -= 1 else : print ( arr1 [ i ] == arr2 [ j ] ) : print ( arr1 [ i ]

def relativeComplement ( arr1 , arr2 , n , m ) : i = 0 for i in range ( n ) : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ] + " " ) i += 1 elif ( arr1 [ i ] > arr2 [ j ] ) : j += 1 elif ( arr1 [ i ] == arr2 [ j ] ) : i += 1 j += 1

40.53
34.01
42.16
35.25
static String decimalToBinary ( double num , int k_prec ) { String binary = "" ; int Integral = ( int ) num ; double fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += ( ( char ) ( rem + '0' ) ) ; Integral /= 2 ; } binary = reverse ( binary ) ; binary += ( '.' ) ; while ( k_prec -- > 0 ) { fractional *= 2 ; int fract_bit = ( int ) fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary += ( char ) ( 1 + '0' ) ; } else { binary += ( char ) ( 0 + '0' ) ; } } return binary ; }

def decimalToBinary ( num , k_prec ) : binary = "" Integral = int ( num ) fractional = num - Integral while ( Integral ) : rem = Integral % 2 binary += str ( rem ) Integral //= 2 binary = binary [ : : - 1 ] binary += '.' while ( k_prec ) : fractional *= 2 fract_bit = int ( fractional ) if ( fract_bit == 1 ) : fractional -= fract_bit binary += '1' else : binary += '0' k_prec -= 1 return binary

def decimalToBinary ( num , k_prec ) : binary = "" Integral = float ( num ) fractional = float ( fractional ) while ( Integral > 0 ) : binary += ( char ) ( Integral % 2 + '0' ) fractional /= 2 k_prec -= 1 binary += ( '.' ) while ( k_prec -- > 0 ) : fractional *= 2 binary += ( char ) ( fract_bit + '0' ) if ( fract_bit == 1 ) : fractional -= fract_bit == 1 ) : binary += ( char ) ( 1 + '0' ) return binary

def decimalToBinary ( num , k_prec ) : binary = "" fractional = num - Integral while Integral > 0 : rem = Integral % 2 binary += ( ( char ) ( rem + '0' ) ) Integral /= 2 binary = reverse ( binary ) binary += ( '.' ) while k_prec -- > 0 : fractional *= 2 fract_bit = ( int ) fractional if fract_bit == 1 : fractional -= fract_bit binary += ( char ) ( 1 + '0' ) else : binary += ( 0 + '0' ) return binary

40.61
33.24
53.2
63.99
static int height ( int N ) { return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math . log ( 2 ) ) - 1 ; }

def height ( N ) : return math . ceil ( math . log2 ( N + 1 ) ) - 1

def height ( N ) : return ( int ) Math . ceil ( N / log ( 2 ) )

def height ( N ) : return float ( math . ceil ( log ( N + 1 ) / math . log ( 2 ) ) - 1

40.64
43.3
50.2
39.31
public static void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + " " ) ; }

def longestAlternating ( arr , n ) : count = [ None ] * n count [ n - 1 ] = 1 i = n - 2 while i >= 0 : if ( arr [ i ] * arr [ i + 1 ] < 0 ) : count [ i ] = count [ i + 1 ] + 1 else : count [ i ] = 1 i = i - 1 i = 0 while i < n : print ( count [ i ] , end = "" ) i = i + 1

def longestAlternating ( arr , n ) : count = [ 1 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] * arr [ i + 1 ] < 0 ) : count [ i ] = 1 else : count [ i ] = 1 for i in range ( 0 , n - 2 ) : if ( arr [ i ] * arr [ i + 1 ] < 0 ) : count [ i ] = count [ i + 1 ] = count [ i + 1 ] + 1 else : count [ i ] = 1 print ( count [ i ] ) for i in range ( 0 , n - 1 ) : print ( count [ i ] + " " ) print ( count [ i ]

def longestAlternating ( arr , n ) : count = [ 1 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] * arr [ i + 1 ] < 0 ) : count [ i ] = count [ i + 1 ] + 1 else : count [ i ] = 1

40.64
56.88
72.51
79.33
static boolean isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ) ; if ( num == 0 || num == 7 ) return true ; if ( num < 10 ) return false ; return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ; }

def isDivisibleBy7 ( num ) : if num < 0 : return isDivisibleBy7 ( - num ) if ( num == 0 or num == 7 ) : return True if ( num < 10 ) : return False return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) )

def isDivisibleBy7 ( num ) : if ( num == 0 ) : return isDivisibleBy7 ( - num ) if ( num == 10 ) : return isDivisibleBy7 ( num / 10 ) return isDivisibleBy7 ( num / 10 )

def isDivisibleBy7 ( num ) : if num < 0 : return isDivisibleBy7 ( - num ) if num == 0 or num == 7 : return True if num < 10 : return False return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) )

40.65
48.4
74.96
72.83
static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }

def printMaxSum ( arr , n ) : dp = [ 0 for i in range ( n ) ] for i in range ( n ) : dp [ i ] = arr [ i ] maxi = 0 for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : if ( dp [ j - 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : maxi = dp [ ( i + 1 ) // j - 1 ] dp [ i ] += maxi for i in range ( n ) : print ( dp [ i ] , end = '' )

def printMaxSum ( arr , n ) : dp = [ 0 for i in range ( n ) ] for i in range ( n ) : if ( arr [ i ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ i + 1 ] > maxi && j != 1 ) : maxi = dp [ i + 1 ] if ( dp [ i + 1 ] / j - 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( i + 1 ) != j ) : if ( dp [ j - 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ i + 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ i + 1 ] > maxi ) : maxi = dp [ i + 1 ] if ( dp [ i + 1 ] / j - 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ i + 1 ) != j ) : if ( dp [ j - 1 ] > maxi ) = dp [ j - 1 ] if ( dp [ i + 1 ] > maxi ) : maxi = dp

def printMaxSum ( arr , n ) : dp = [ 0 for i in range ( n ) ] for i in range ( n ) : dp [ i ] = arr [ i ] maxi = 0 for j in range ( 1 , i + 1 ) : if ( ( i + 1 ) % j == 0 ) and ( i + 1 ) != j : if ( dp [ j - 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ ( i + 1 ) / j - 1 ] > maxi and j != 1 ) : maxi = dp [ ( i + 1 ) / j - 1 ] dp [ i ] += maxi

40.76
37.45
52.41
45.39
static boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 . charAt ( i ) - 'a' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 . charAt ( i ) - 'a' ] > 0 ) hash_str1 [ str2 . charAt ( i ) - 'a' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }

def areKAnagrams ( str1 , str2 , k ) : n = len ( str1 ) if ( len ( str2 ) != n ) : return False hash_str1 = [ 0 ] * ( MAX_CHAR ) for i in range ( n ) : hash_str1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 count = 0 for i in range ( n ) : if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] > 0 ) : hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] -= 1 else : count += 1 if ( count > k ) : return False return True

def areKAnagrams ( str1 , str2 , k ) : n = str1 . length ( ) if ( str2 . length ( ) != n ) : return false ; hash_str1 = [ 0 for i in range ( 0 , n ) ] for i in range ( 0 , n ) : if ( hash_str1 [ str1 [ i ] - 'a' ] > 0 ) : hash_str1 [ str1 [ i ] - 'a' ] -= 1 if ( hash_str1 [ str2 [ i ] - 'a' ] > 0 ) : hash_str1 [ str2 [ i ] - 'a' ] -= 1 count = 0 for i in range ( 0 , n ) : if ( hash_str1 [ i ] > 0 ) : hash_str1 [ str2 [ i ] - 'a' ] > 0 ) : hash_str1 [ str2 [ i ] -= 'a' ] -= 1 else : count += 1 if ( count > k ) : return false ; return true

def areKAnagrams ( str1 , str2 , k ) : n = str1 . length ( ) if ( str2 . length ( ) != n ) : return False hash_str1 = [ 0 for i in range ( n ) ] for i in range ( n ) : if ( hash_str1 [ str2 [ i ] - 'a' ] > 0 ) : hash_str1 [ str2 [ i ] - 'a' ] -- else : count = 0 for i in range ( n ) : if ( hash_str1 [ str2 [ i ] - 'a' ] > 0 ) : hash_str1 [ str2 [ i ] - 'a' ] -- else : count += count if count > k : return False return True

40.77
41.53
61.94
48.28
public static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) - '0' ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }

def sumOfSubstrings ( num ) : n = len ( num ) sumofdigit = [ ] sumofdigit . append ( int ( num [ 0 ] ) ) res = sumofdigit [ 0 ] for i in range ( 1 , n ) : numi = int ( num [ i ] ) sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) res += sumofdigit [ i ] return res

def sumOfSubstrings ( num ) : sumofdigit = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : numi = num [ i ] - '0' res += sumofdigit [ 0 ] for i in range ( 1 , n ) : numi = num [ i ] - '0' sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] res += sumofdigit [ i ] if ( numi == '0' ) : sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] return res

def sumOfSubstrings ( num ) : sumofdigit = [ 0 for i in range ( n ) ] sumofdigit [ 0 ] = num [ 0 ] - '0' res = sumofdigit [ 0 ] for i in range ( 1 , n ) : numi = num [ i ] - '0' sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] res += sumofdigit [ i ] return res

40.77
48.08
41.76
54.96
static int findSubarraySum ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . containsKey ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ; Integer count = prevSum . get ( currsum ) ; if ( count == null ) prevSum . put ( currsum , 1 ) ; else prevSum . put ( currsum , count + 1 ) ; } return res ; }

def findSubarraySum ( arr , n , Sum ) : prevSum = defaultdict ( lambda : 0 ) res = 0 currsum = 0 for i in range ( 0 , n ) : currsum += arr [ i ] if currsum == Sum : res += 1 if ( currsum - Sum ) in prevSum : res += prevSum [ currsum - Sum ] prevSum [ currsum ] += 1 return res

def findSubarraySum ( arr , n , sum ) : prevSum = dict ( ) for i in range ( n ) : currsum += arr [ i ] if ( currsum == sum ) : res += 1 if ( prevSum . containsKey ( currsum - sum ) ) : res += prevSum [ currsum - sum ] if ( count == null ) : prevSum . put ( currsum , 1 ) else : prevSum . put ( currsum , count +

def findSubarraySum ( arr , n , sum ) : prevSum = list ( ) res = 0 currsum = 0 for i in range ( n ) : currsum += arr [ i ] if ( currsum == sum ) : res += if ( prevSum . containsKey ( currsum - sum ) ) : res += prevSum [ currsum - sum ] count = prevSum [ currsum ] if ( count == None ) : prevSum . put ( currsum , 1 ) else : prevSum . put ( currsum , count + 1 ) return res

40.78
24.39
55.29
32.2
static boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }

def isMultipleOf10 ( n ) : return ( n % 15 == 0 )

def isMultipleOf10 ( n ) : return true

def isMultipleOf10 ( n ) : if n % 15 == 0 : return True return False

40.91
33.86
73.96
70.14
static boolean isPrime ( int p ) { double checkNumber = Math . pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }

def isPrime ( p ) : checkNumber = 2 ** p - 1 nextval = 4 % checkNumber for i in range ( 1 , p - 1 ) : nextval = ( nextval * nextval - 2 ) % checkNumber if ( nextval == 0 ) : return True else : return False

def isPrime ( p ) : checkNumber = 2 ** p - 1 nextval = ( nextval * nextval - 2 ) % checkNumber return ( nextval == 0 )

def isPrime ( p ) : checkNumber = float ( p ) - 1 nextval = 4 % checkNumber for i in range ( 1 , p - 1 ) : nextval = ( nextval * nextval - 2 ) % checkNumber return ( nextval == 0 )

41.02
72.83
80.59
72.44
static int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }

def binarySearch ( arr , left , right ) : if ( left <= right ) : mid = ( left + right ) // 2 if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : return mid if ( arr [ mid ] < arr [ mid + 1 ] ) : return binarySearch ( arr , mid + 1 , right ) else : return binarySearch ( arr , left , mid - 1 ) return - 1

def binarySearch ( arr , left , right ) : if ( left <= right ) : mid = ( left + right ) // 2 if arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] : return mid

def binarySearch ( arr , left , right ) : if left <= right : mid = ( left + right ) // 2 if arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] : return mid if arr [ mid ] < arr [ mid + 1 ] : return binarySearch ( arr , mid + 1 , right ) else : return binarySearch ( arr , left , mid - 1 )

41.05
39.96
63.72
46.85
static void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ; }

def printClosest ( arr , n , x ) : res_l , res_r = 0 , 0 l , r , diff = 0 , n - 1 , MAX_VAL while r > l : if abs ( arr [ l ] + arr [ r ] - x ) < diff : res_l = l res_r = r diff = abs ( arr [ l ] + arr [ r ] - x ) if arr [ l ] + arr [ r ] > x : r -= 1 else : l += 1 print ( 'Theclosestpairis{}and{}' . format ( arr [ res_l ] , arr [ res_r ] ) )

def printClosest ( arr , n , x ) : res_l = 0 res_r = 0 diff = float ( 'inf' ) for l in range ( n ) : if ( arr [ l ] + arr [ r ] - x ) < diff : res_l = l res_r = r break if ( arr [ l ] + arr [ r ] > x ) : r -= 1 else : diff = float ( 'inf' ) if ( arr [ l ] + arr [ r ] > x ) : res_l = l res_r = r break if ( arr [ l ] + arr [ r ] > x ) : diff = abs ( arr [ l ] + arr [ r ] - x ) < diff : res_l = l res_r = r break if ( arr [ l ] + arr [ r ] > x ) : r -= 1 else : l -= 1 print ( 'inf' )

def printClosest ( arr , n , x ) : res_l = 0 res_r = 0 l = n - 1 diff = float ( 'inf' ) while ( r > l ) : if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : res_l = l res_r = r diff = abs ( arr [ l ] + arr [ r ] - x ) if arr [ l ] + arr [ r ] > x : r -- else l ++ print ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] )

41.1
37.37
100.0
100.0
static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }

def getModulo ( n , d ) : return ( n & ( d - 1 ) )

def getModulo ( n , d ) : return n

def getModulo ( n , d ) : return ( n & ( d - 1 ) )

41.21
33.83
54.1
41.27
static void subarrayDivisibleByK ( int [ ] arr , int n , int k ) { int [ ] mp = new int [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } System . out . print ( "The maximum size is " + ( maxe - maxs + 1 ) + " and the subarray is as follows\n" ) ; for ( int i = maxs ; i <= maxe ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

def subarrayDivisibleByK ( arr , n , k ) : mp = [ 0 ] * 1000 s = 0 e = 0 maxs = 0 maxe = 0 mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 for i in range ( 1 , n ) : mod = arr [ i ] % k while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 s = s + 1 mp [ mod ] = mp [ mod ] + 1 e = e + 1 if ( ( e - s ) > ( maxe - maxs ) ) : maxe = e maxs = s print ( "Themaximumsizeis{}andthe" . format ( ( maxe - maxs + 1 ) ) ) for i in range ( maxs , maxe + 1 ) : print ( "{}" . format ( arr [ i ] ) , end = "" )

def subarrayDivisibleByK ( arr , n , k ) : mp = [ 0 for k in range ( n ) ] s = 0 e = 0 for i in range ( n ) : mod = arr [ i ] % k if ( mp [ k - mod ] != 0 ) : mp [ k - mod ] ++ s += 1 mp [ mod ] ++ if ( e - s ) > ( maxe - maxs + 1 ) : maxe = s if ( ( e - s ) > ( maxe - maxs ) : maxs = e if ( s - s ) > ( maxe - maxs + 1 ) : maxs = e if ( maxe - maxs + 1 ) : maxe = s print ( arr [ i ] + " " ) else : print ( arr [ i ] + " " ) return mp [ maxs ]

def subarrayDivisibleByK ( arr , n , k ) : mp = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : mod = arr [ i ] % k while mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) : mp [ arr [ s ] % k ] -- s ++ mp [ mod ] ++ e += if ( ( e - s ) > ( maxe - maxs ) ) : maxe = e maxs = s e = 0 if ( e - s ) > ( maxe - maxs ) : maxe = e maxs = s e = 0 print ( "The maximum size is " + ( maxe - maxs + 1 ) + " and the subarray is as follows\n" ) for i in range ( maxs , maxe ) : print ( arr [ i ] )

41.27
52.89
54.22
53.57
static int SieveOfAtkin ( int limit ) { if ( limit > 2 ) System . out . print ( 2 + " " ) ; if ( limit > 3 ) System . out . print ( 3 + " " ) ; boolean sieve [ ] = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) System . out . print ( a + " " ) ; return 0 ; }

def SieveOfAtkin ( limit ) : if ( limit > 2 ) : print ( 2 , end = "" ) if ( limit > 3 ) : print ( 3 , end = "" ) sieve = [ False ] * limit for i in range ( 0 , limit ) : sieve [ i ] = False x = 1 while ( x * x < limit ) : y = 1 while ( y * y < limit ) : n = ( 4 * x * x ) + ( y * y ) if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : sieve [ n ] ^= True n = ( 3 * x * x ) + ( y * y ) if ( n <= limit and n % 12 == 7 ) : sieve [ n ] ^= True n = ( 3 * x * x ) - ( y * y ) if ( x > y and n <= limit and n % 12 == 11 ) : sieve [ n ] ^= True y += 1 x += 1 r = 5 while ( r * r < limit ) : if ( sieve [ r ] ) : for i in range ( r * r , limit , r * r ) : sieve [ i ] = False for a in range ( 5 , limit ) : if ( sieve [ a ] ) : print ( a , end = "" )

def SieveOfAtkin ( limit ) : if ( limit > 2 ) print ( 2 , end = "" ) for i in range ( limit ) : sieve [ i ] = true for y in range ( 1 , limit ) : if ( x * y in limit ) : sieve [ n ] ^= true n = ( 4 * x * x ) - ( y * y ) if ( n <= limit && n % 12 == 6 ) : sieve [ n ] ^= true if ( x > y ) : sieve [ n ] ^= true : n = ( 3 * x * x ) + ( y * y ) if ( n % 12 == 1 ) : sieve [ n ] ^= true for x in range ( 1 , limit ) : if ( sieve [ r ] ) : for i in range ( 5 , limit ) : sieve [ i ] = false return i

def SieveOfAtkin ( limit ) : sieve [ a ] = False for x in range ( 1 , limit ) : for y in range ( 1 , limit ) : n = ( 4 * x * x ) + ( y * y ) if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : sieve [ n ] ^= true n = ( 3 * x * x ) + ( y * y ) if ( n <= limit and n % 12 == 7 ) : sieve [ n ] ^= true n = ( 3 * x * x ) - ( y * y ) if ( x > y and n <= limit and n % 12 == 11 ) : sieve [ n ] ^= True n = ( 3 * x * x ) - ( y * y ) if ( x > y and n <= limit and n % 12 == 11 ) : sieve [ n ] ^= True n = ( 3 * x * x ) - ( y * y ) if ( x > y and n <= limit and n % 12 == 11 ) : sieve [ n ] ^= True

41.29
35.5
37.91
45.48
static String minLexRotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }

def minLexRotation ( str_ ) : n = len ( str_ ) arr = [ 0 ] * n concat = str_ + str_ for i in range ( n ) : arr [ i ] = concat [ i : n + i ] arr . sort ( ) return arr [ 0 ]

def minLexRotation ( str ) : n = len ( str ) arr = [ "" for i in range ( n ) ] concat = str + str arr [ 0 ] = concat [ 0 : i + n ] return arr [ 0 ]

def minLexRotation ( str ) : n = str . length arr = [ 0 for k in range ( n ) ] concat = str + str for i in range ( 0 , n ) : arr [ i ] = concat [ i ] for i in range ( 0 , n ) : arr [ i ] = concat [ i : i + n ] sort ( arr ) return arr [ 0 ]

41.37
33.47
54.51
43.46
static int shortestSeq ( char [ ] S , char [ ] T ) { int m = S . length , n = T . length ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; }

def shortestSeq ( S : list , T : list ) : m = len ( S ) n = len ( T ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for i in range ( m + 1 ) : dp [ i ] [ 0 ] = 1 for i in range ( n + 1 ) : dp [ 0 ] [ i ] = MAX for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : ch = S [ i - 1 ] k = j - 1 while k >= 0 : if T [ k ] == ch : break k -= 1 if k == - 1 : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ans = dp [ m ] [ n ] if ans >= MAX : ans = - 1 return ans

def shortestSeq ( S , T ) : dp = [ INT_MAX for i in range ( m + 1 , n + 1 ) ] for i in range ( m + 1 , n + 1 ) : if ( S [ i ] == T [ 0 ] ) : dp [ i ] [ 0 ] = 1 else : k = - 1 dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) if ( k == - 1 ) : dp [ i ] [ j ] = min ( dp [ i - 1 ] [ k ] + 1 ) return ans

def shortestSeq ( S , T ) : m = S . length n = T . length dp = [ 0 for i in range ( m + 1 , n + 1 ) ] for i in range ( 1 , m + 1 , - 1 ) : for j in range ( 1 , n ) : ch = S [ i - 1 ] if ( T [ k ] == ch ) : break if ( k == - 1 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ans = dp [ m ] [ n ] if ( ans >= MAX ) : ans = - 1 return ans

41.38
39.0
73.39
69.23
static int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k ) ; } System . out . println ( "number is " + "not present!" ) ; return - 1 ; }

def search ( arr , n , x , k ) : i = 0 while ( i < n ) : if ( arr [ i ] == x ) : return i i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) print ( "numberisnotpresent!" ) return - 1

def search ( arr , n , x , k ) : i = 0 while ( i < n ) : if ( arr [ i ] == x ) : return i

def search ( arr , n , x , k ) : i = 0 while i < n : if ( arr [ i ] == x ) : return i i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) return i

41.43
41.99
40.61
39.37
static int countSquares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j <= i ; j ++ ) if ( j * j == i ) cnt ++ ; return cnt ; }

def CountSquares ( a , b ) : cnt = 0 for i in range ( a , b + 1 ) : j = 1 ; while j * j <= i : if j * j == i : cnt = cnt + 1 j = j + 1 i = i + 1 return cnt

def countSquares ( a , b ) : cnt = 0 for i in range ( a , b ) : for j in range ( 1 , a + 1 , b ) : if ( j * j == i ) : cnt += 1 return cnt

def countSquares ( a , b ) : cnt = 0 for i in range ( a , b ) : for j in range ( 1 , len ( i ) ) : if ( j * j <= i ) : cnt += 1 return cnt

41.52
45.14
50.67
48.14
static void rearrangeArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int [ ] tempArr = new int [ n ] ; int ArrIndex = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { if ( ArrIndex < n ) { tempArr [ ArrIndex ] = arr [ i ] ; ArrIndex ++ ; } if ( ArrIndex < n ) { tempArr [ ArrIndex ] = arr [ j ] ; ArrIndex ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ i ] ; }

def rearrangeArray ( arr , n ) : arr . sort ( ) tempArr = [ 0 ] * ( n + 1 ) ArrIndex = 0 i = 0 j = n - 1 while ( i <= n // 2 or j > n // 2 ) : tempArr [ ArrIndex ] = arr [ i ] ArrIndex = ArrIndex + 1 tempArr [ ArrIndex ] = arr [ j ] ArrIndex = ArrIndex + 1 i = i + 1 j = j - 1 for i in range ( 0 , n ) : arr [ i ] = tempArr [ i ]

def rearrangeArray ( arr , n ) : arr . sort ( reverse = True ) ArrIndex = 0 for i in range ( 0 , n ) : for j in range ( n - 1 , - 1 , - 1 ) : if ( ArrIndex < n ) : tempArr [ ArrIndex ] = arr [ i ] ArrIndex ++ if ( ArrIndex < n ) : tempArr [ ArrIndex ] = arr [ j ] ArrIndex ++ if ( ArrIndex <

def rerangeArray ( arr , n ) : arr . sort ( arr ) tempArr = [ 0 for i in range ( n ) ] for i in range ( 0 , n , - 1 ) : if ( ArrIndex < n ) : tempArr [ ArrIndex ] = arr [ i ] ArrIndex += 1 if ( ArrIndex < n ) : tempArr [ ArrIndex ] = arr [ j ] ArrIndex += 1 for i in range ( 0 , n ) : arr [ i ] = tempArr [ i ]

41.57
40.9
38.84
40.53
static boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }

def checkReverse ( arr , n ) : temp = [ 0 ] * n for i in range ( n ) : temp [ i ] = arr [ i ] temp . sort ( ) for front in range ( n ) : if temp [ front ] != arr [ front ] : break for back in range ( n - 1 , - 1 , - 1 ) : if temp [ back ] != arr [ back ] : break if front >= back : return True while front != back : front += 1 if arr [ front - 1 ] < arr [ front ] : return False return True

def checkReverse ( arr , n ) : temp = [ 0 for i in range ( n ) ] for i in range ( n ) : temp [ i ] = arr [ i ] for i in range ( n ) : if ( temp [ i ] != arr [ i ] ) : break return true back = n - 1 while back >= 0 : if ( temp [ back ] != arr [ back ] ) : break return true

def checkReverse ( arr , n ) : temp = [ INT_MAX for i in range ( n ) ] for front in range ( 0 , n ) : if ( temp [ front ] != arr [ front ] ) : break if ( front >= back ) : return True ; } do { front ++ if ( arr [ front - 1 ] < arr [ front ] ) : return False } while ( front != back ) : return True

41.62
36.99
52.01
47.05
static void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < Integer > ( ) ; Vector < Integer > oddArr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } Collections . sort ( evenArr ) ; Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr . get ( j ) ; } }

def bitonicGenerator ( arr , n ) : evenArr = [ ] oddArr = [ ] for i in range ( n ) : if ( ( i % 2 ) == 0 ) : evenArr . append ( arr [ i ] ) else : oddArr . append ( arr [ i ] ) evenArr = sorted ( evenArr ) oddArr = sorted ( oddArr ) oddArr = oddArr [ : : - 1 ] i = 0 for j in range ( len ( evenArr ) ) : arr [ i ] = evenArr [ j ] i += 1 for j in range ( len ( oddArr ) ) : arr [ i ] = oddArr [ j ] i += 1

def bitonicGenerator ( arr , n ) : evenArr = new Vector < Integer > ( ) oddArr = new Vector < Integer > ( ) for i in range ( n ) : if ( i % 2 == 1 ) : evenArr . add ( arr [ i ] ) else : oddArr . add ( arr [ i ] ) i = 0 for j in range ( 0 , n ) : arr [ i ++ ] = evenArr [ j ] if ( j % 2 == 0 ) : arr [ i ++ ] = oddArr [ j ] = oddArr [ j ] if ( j % 2 != 1 ) : arr [ i ++ ] = oddArr [ j ] if ( i % 2 == 1 ) : arr [ i ++ ] = evenArr [ j ] else : arr [ i ++ ] = oddArr [ j ] i += 1 return i

def bitonicGenerator ( arr , n ) : evenArr = [ 0 for k in range ( n ) ] oddArr = [ 0 for k in range ( n ) ] arr = [ 0 for k in range ( n ) ] for i in range ( n ) : if ( i % 2 != 1 ) : evenArr . add ( arr [ i ] ) else : oddArr . add ( arr [ i ] ) i = 0 for j in range ( 0 , evenArr . size ( ) ) : arr [ i ++ ] = evenArr [ j ] for j in range ( 0 , oddArr . size ( ) ) : arr [ i ++ ] = oddArr [ j ] return arr

41.66
36.31
78.08
62.76
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; quickSort ( A , 0 , arr_size - 1 ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { System . out . print ( "Triplet is " + A [ i ] + ", " + A [ l ] + ", " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }

def find3Numbers ( A , arr_size , sum ) : A . sort ( ) for i in range ( 0 , arr_size - 2 ) : l = i + 1 r = arr_size - 1 while ( l < r ) : if ( A [ i ] + A [ l ] + A [ r ] == sum ) : print ( "Tripletis" , A [ i ] , ',' , A [ l ] , ',' , A [ r ] ) return True elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : l += 1 else : r -= 1 return False

def find3Numbers ( A , arr_size , sum ) : arr_size = len ( A ) for i in range ( arr_size - 2 , - 1 , - 1 ) : if ( A [ i ] + A [ l ] + A [ r ] == sum ) : print ( "Triplet is " + A [ i ] , ", " + A [ l ] , " and " + A [ r ] ) return true

def find3Numbers ( A , arr_size , sum ) : l = i + 1 r = arr_size - 1 while ( l < r ) : if ( A [ i ] + A [ l ] + A [ r ] == sum ) : print ( "Triplet is " + A [ i ] , " " + A [ l ] + ", " + A [ r ] ) : return True elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : l += 1 else : r -= 1 quickSort ( A , 0 , arr_size - 2 ) return False

41.67
40.93
64.79
66.68
public static int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; else hm . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) { int count = it . getValue ( ) ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }

def countPairs ( arr , n ) : mp = dict ( ) for i in range ( n ) : if arr [ i ] in mp . keys ( ) : mp [ arr [ i ] ] += 1 else : mp [ arr [ i ] ] = 1 ans = 0 for it in mp : count = mp [ it ] ans += ( count * ( count - 1 ) ) // 2 return ans

def countPairs ( arr , n ) : hm = defaultdict ( int ) for i in range ( n ) : hm . add ( arr [ i ] , 1 ) for i in range ( n ) : if ( hm [ arr [ i ] ] != 1 ) : hm . put ( arr [ i ] , 1 ) else : hm . put ( arr [ i ] , 1 ) ans = 0 for it in hm . entrySet ( ) : ans += ( count * ( count - 1 ) ) return ans

def countPairs ( arr , n ) : hm = list ( ) for i in range ( n ) : if hm . containsKey ( arr [ i ] ) : hm [ arr [ i ] ] += 1 else : hm [ arr [ i ] ] = 1 ans = 0 for it in hm . entrySet ( ) : ans += ( count * ( count - 1 ) ) / 2 return ans

41.7
48.53
100.0
100.0
static int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }

def evenbinomialCoeffSum ( n ) : return ( 1 << ( n - 1 ) )

def evenbinomialCoeffSum ( n ) : return 1 << n

def evenbinomialCoeffSum ( n ) : return ( 1 << ( n - 1 ) )

41.73
33.6
53.05
28.9
static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( "-1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } }

def print_sequence ( n , k ) : b = int ( n / ( k * ( k + 1 ) / 2 ) ) if b == 0 : print ( "-1" ) else : r = 1 x = 1 while x ** 2 <= n : if n % x != 0 : continue elif x <= b and x > r : r = x elif n / x <= b and n / x > r : r = n / x x = x + 1 i = 1 while i < k : print ( r * i , end = "" ) i = i + 1 last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) print ( last_term )

def print_sequence ( n , k ) : b = n / ( k + 1 ) / 2 if ( b == 0 ) : print ( "-1" ) else : r = 1 for x in range ( 1 , n , k ) : if ( x <= b and x > r ) : r = x if ( n / x <= b and n / x > r ) : r = n / x if ( n / x <= b and n > r ) : r = n / x : if ( n % x > r ) : r = n / x > r ) : r = n / x <= b and n / x > r : r = n / x

def print_sequence ( n , k ) : b = n // ( k * ( k + 1 ) / 2 ) if b == 0 : print ( "-1" ) else : r = 1 for x in range ( 1 , n , k ) : if ( n % x != 0 ) : continue if ( x <= b and x > r ) : r = x if ( n / x <= b and n / x > r ) : r = n / x if ( n / x <= b and n / x > r ) : r = n / x for i in range ( 1 , k ) : print ( r * i + " " ) res = n - ( r * ( k * ( k - 1 ) / 2 ) ) System . out . println ( res )

41.73
32.24
37.79
34.4
static void deleteElements ( int arr [ ] , int n , int k ) { Stack < Integer > s = new Stack < > ( ) ; s . push ( arr [ 0 ] ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . push ( arr [ i ] ) ; } int m = s . size ( ) ; Integer [ ] v = new Integer [ m ] ; while ( ! s . empty ( ) ) { v [ -- m ] = s . peek ( ) ; s . pop ( ) ; } for ( Integer x : v ) { System . out . print ( x + "" ) ; }; System . out . println ( "" ) ; }

def deleteElements ( arr , n , k ) : st = [ ] st . append ( arr [ 0 ] ) top = 0 count = 0 for i in range ( 1 , n ) : while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) : st . pop ( ) count += 1 top -= 1 st . append ( arr [ i ] ) top += 1 for i in range ( 0 , len ( st ) ) : print ( st [ i ] , "" , end = "" )

def deleteElements ( arr , n , k ) : s = list ( ) for i in range ( n ) : s . append ( arr [ i ] ) count += 1 for i in range ( n ) : s . append ( arr [ i ] ) count += 1 s . push ( arr [ i ] ) s . pop ( ) count = 0 for i in range ( n ) : if ( s [ peek ( ) < arr [ i ] ) : s . pop ( )

def deleteElements ( arr , n , k ) : s . append ( arr [ 0 ] ) count = 0 for i in range ( 1 , n , k ) : while not s . empty ( ) and s [ - 1 ] < arr [ i ] and count < k : s . pop ( ) count += 1 s . append ( arr [ i ] )

41.77
37.16
53.21
38.33
static void leafNode ( int preorder [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { boolean found = false ; if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ) ; else { while ( ! s . isEmpty ( ) ) { if ( preorder [ j ] > s . peek ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) System . out . print ( preorder [ i ] + " " ) ; } System . out . println ( preorder [ n - 1 ] ) ; }

def leafNode ( preorder , n ) : s = [ ] i = 0 for j in range ( 1 , n ) : found = False if preorder [ i ] > preorder [ j ] : s . append ( preorder [ i ] ) else : while len ( s ) != 0 : if preorder [ j ] > s [ - 1 ] : s . pop ( - 1 ) found = True else : break if found : print ( preorder [ i ] , end = "" ) i += 1 print ( preorder [ n - 1 ] )

def leafNode ( preorder , n ) : s = list ( ) for i in range ( n ) : if ( preorder [ i ] > preorder [ j ] ) : s . append ( preorder [ i ] ) found = true else : print ( preorder [ i ] + " " ) if ( found ) : print ( preorder [ j ] + " " ) if ( found ) : print ( preorder [ i ] + " " ) if ( preorder [ j ] > s .

def leafNode ( preorder , n ) : s = list ( ) for i in range ( n ) : found = False if preorder [ i ] > preorder [ j ] : s . append ( preorder [ i ] ) else : while ( not s . isEmpty ( ) ) : if ( preorder [ j ] > s . peek ( ) ) : s . pop ( ) found = True else : break print ( preorder [ i ] + " " )

41.81
42.77
37.53
44.49
public static StringBuffer encrypt ( String text , int s ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( Character . isUpperCase ( text . charAt ( i ) ) ) { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 65 ) % 26 + 65 ) ; result . append ( ch ) ; } else { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 97 ) % 26 + 97 ) ; result . append ( ch ) ; } } return result ; }

def encrypt ( text , s ) : result = "" for i in range ( len ( text ) ) : char = text [ i ] if ( char . isupper ( ) ) : result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) else : result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) return result

def encrypt ( text , s ) : result = new StringBuffer ( ) for i in range ( len ( text ) ) : if ( Character . isUpperCase ( text [ i ] ) ) : ch = ( char ) ( ( ( int ) text [ i ] + s - 65 ) % 26 + 65 ) result . append ( ch ) else : ch = ( char ) ( ( ( int ) text [ i ] + s - 97 ) % 26 + 97 ) result . append ( ch ) if ( Character . isLower ( text [ i ] ) return result

def encrypt ( text , s ) : result = "" for i in range ( len ( text ) ) : if isupper ( text [ i ] ) : ch = ( ( ( int ) text [ i ] + s - 65 ) % 26 , ( ( int ) text [ i ] + s - 97 ) % 26 ) result . append ( ch ) else : ch = ( ( ( int ) text [ i ] + s - 97 ) % 26 , ( ( int ) text [ i ] + s - 65 ) ) result . append ( ch ) return result

41.81
40.59
46.94
38.0
int countkDist ( String str , int k ) { int res = 0 ; int n = str . length ( ) ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Arrays . fill ( cnt , 0 ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) - 'a' ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) - 'a' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }

def countkDist ( str1 , k ) : n = len ( str1 ) res = 0 cnt = [ 0 ] * 27 for i in range ( 0 , n ) : dist_count = 0 cnt = [ 0 ] * 27 for j in range ( i , n ) : if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : dist_count += 1 cnt [ ord ( str1 [ j ] ) - 97 ] += 1 if ( dist_count == k ) : res += 1 if ( dist_count > k ) : break return res

def countkDist ( str , k ) : res = 0 n = len ( str ) for i in range ( 0 , n ) : for j in range ( i , n ) : if ( cnt [ str [ j ] - 'a' ] == 0 ) : dist_count += ( cnt [ str [ j ] - 'a' ] + 1 ) if ( dist_count == k ) : res += 1 return res

def countkDist ( str , k ) : res = 0 n = str . length cnt = [ 0 for i in range ( 0 , 26 ) ] for i in range ( 0 , n ) : dist_count = 0 for j in range ( i , n ) : if ( cnt [ str [ j ] - 'a' ] == 0 ) : dist_count += cnt [ str [ j ] - 'a' ] ++ if ( dist_count == k ) : res += 1 return res

41.81
40.9
63.19
52.87
public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }

def printPascal ( n ) : for line in range ( 1 , n + 1 ) : C = 1 for i in range ( 1 , line + 1 ) : print ( C , end = "" ) C = int ( C * ( line - i ) / i ) print ( "" )

def printPascal ( n ) : for line in range ( 1 , n ) : for i in range ( 1 , n ) : print ( C + " " ) C = 1 for line in range ( 1 , n ) : print ( C + " " ) C = C * line / i : print ( C + " " ) C = C * line - i

def printPascal ( n ) : for line in range ( 1 , n ) : C = 1 for i in range ( 1 , n ) : print ( C + " " ) C = C * ( line - i ) / i print ( C )

41.83
24.56
47.85
36.66
public static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }

def middleOfThree ( a , b , c ) : if ( ( a < b and b < c ) or ( c < b and b < a ) ) : return b if ( ( b < a and a < c ) or ( c < a and a < b ) ) : return a else : return c

def middleOfThree ( a , b , c ) : if ( a < b && b < c ) : return b else : if ( b < a && a < c ) : return a else : return c

def middleOfThree ( a , b , c ) : if ( a < b and b < c ) : return b elif ( b < a and a < c ) : return a else : return c

41.84
36.36
36.6
32.64
static void printTwoElements ( int arr [ ] , int size ) { int i ; System . out . print ( "The repeating element is " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else System . out . println ( abs_val ) ; } System . out . print ( "And the missing element is " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } }

def printTwoElements ( arr , size ) : for i in range ( size ) : if arr [ abs ( arr [ i ] ) - 1 ] > 0 : arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] else : print ( "Therepeatingelementis" , abs ( arr [ i ] ) ) for i in range ( size ) : if arr [ i ] > 0 : print ( "andthemissingelementis" , i + 1 )

def printTwoElements ( arr , size ) : print ( arr [ size ] ) for i in range ( size ) : if ( arr [ i ] > 0 ) : print ( i + 1 ) else : print ( abs_val ) } print ( "The missing element is " ) for i in range ( 0 , size ) : if ( arr [ i ] > 0 ) : print ( i + 1 ) else : print ( abs_val )

def printTwoElements ( arr , size ) : arr . sort ( reverse = True ) for i in range ( size ) : abs_val = abs ( arr [ i ] ) if ( arr [ abs_val - 1 ] > 0 ) : arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] else : print ( abs_val )

41.85
38.06
14.64
17.43
static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( "Diagonal one : " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ; } System . out . println ( ) ; System . out . print ( "Diagonal two : " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i + j == column - 1 ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ; } }

def diagonalsquare ( mat , row , column ) : print ( "Diagonalone:" , end = "" ) for i in range ( 0 , row ) : for j in range ( 0 , column ) : if ( i == j ) : print ( "{}" . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = "" ) print ( "\n\nDiagonaltwo:" , end = "" ) for i in range ( 0 , row ) : for j in range ( 0 , column ) : if ( i + j == column - 1 ) : print ( "{}" . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = "" )

def diagonalsquare ( mat , row , column ) : print ( "Diagonal one : " ) for i in range ( 0 , row , column ) : if ( i == j ) : print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) else : print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) exit ( 1 ) print ( "Diagonal two : " )

def diagonalsquare ( mat , row , column ) : for i in range ( row ) : for j in range ( column ) : if i == j : print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " )

41.85
38.5
48.96
42.44
static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; }

def divSum ( num ) : result = 0 i = 2 while i <= ( math . sqrt ( num ) ) : if ( num % i == 0 ) : if ( i == ( num / i ) ) : result = result + i ; else : result = result + ( i + num / i ) ; i = i + 1 return ( result + 1 ) ;

def divSum ( num ) : result = 0 for i in range ( 2 , math . sqrt ( num ) ) : if ( num % i == 0 ) : result += i else : result += ( num / i ) return ( result + 1 )

def divSum ( num ) : result = 0 for i in range ( 2 , math . sqrt ( num ) ) : if num % i == 0 : if i == ( num / i ) : result += i else : result += ( i + num / i ) return ( result + 1 )

41.85
50.13
93.56
87.78
public static long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }

def rectCount ( n , m ) : return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4

def rectCount ( n , m ) : return ( n * m * n * m )

def rectCount ( n , m ) : return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4

41.86
38.7
43.0
42.86
static int solveQuery ( int start , int end , int arr [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = start ; i <= end ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int count = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) if ( entry . getKey ( ) == entry . getValue ( ) ) count ++ ; return count ; }

def solveQuery ( start , end , arr ) : frequency = dict ( ) for i in range ( start , end + 1 ) : if arr [ i ] in frequency . keys ( ) : frequency [ arr [ i ] ] += 1 else : frequency [ arr [ i ] ] = 1 count = 0 for x in frequency : if x == frequency [ x ] : count += 1 return count

def solveQuery ( start , end , arr ) : mp = defaultdict ( int ) for i in range ( start , end ) : mp . put ( arr [ i ] , 1 ) for i in range ( start , end ) : mp . put ( arr [ i ] , 1 ) if ( mp [ arr [ i ] ] == null ) : count += 1 return count

def solveQuery ( start , end , arr ) : mp = list ( ) for i in range ( start , end ) : mp . append ( arr [ i ] , mp [ arr [ i ] == None ? 1 : mp [ arr [ i ] ] + 1 ) count = 0 for entry in mp . entrySet ( ) : if entry . getKey ( ) == entry . getValue ( ) : count ++ return count

41.88
43.62
60.45
39.55
static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " " ) ; }

def leftRotate ( arr , n , k ) : for i in range ( k , k + n ) : print ( str ( arr [ i % n ] ) , end = "" )

def leftRotate ( arr , n , k ) : for i in range ( k , k + n ) : print ( arr [ i % n ] + " " ) for i in range ( k , k + n ) : print ( arr [ i % n ] + " " ) print ( arr [ i % n ] ) print ( " " ) return

def leftRotate ( arr , n , k ) : for i in range ( k ) : print ( arr [ i % n ] )

41.92
40.54
47.21
41.99
static void generate_derangement ( int N ) { int S [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " " ) ; System . out . println ( ) ; }

def generate_derangement ( N ) : S = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : S [ i ] = i D = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 , 2 ) : if i == N : D [ N ] = S [ N - 1 ] D [ N - 1 ] = S [ N ] else : D [ i ] = i + 1 D [ i + 1 ] = i for i in range ( 1 , N + 1 ) : print ( D [ i ] , end = "" ) print ( )

def generate_derangement ( N ) : S = [ 1 for i in range ( N ) ] D = [ 1 for i in range ( 1 , N ) ] for i in range ( 1 , N ) : D [ i ] = S [ N - 1 ] S [ N - 1 ] = S [ N ] D [ N - 1 ] = S [ N ] i += 2 if ( i == N ) : D [ N ] = S [ N -

def generate_derangement ( N ) : S = [ INT_MAX for i in range ( N ) ] D = [ INT_MAX for i in range ( N ) ] for i in range ( 1 , N ) : if ( i == N ) : D [ N ] = S [ N - 1 ] D [ N - 1 ] = S [ N ] else : D [ i ] = i + 1 D [ i + 1 ] = i

41.98
44.38
61.14
54.77
static void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( "Angle not possible" ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }

def SectorArea ( radius , angle ) : pi = 22 / 7 if angle >= 360 : print ( "Anglenotpossible" ) return else : sector = ( pi * radius ** 2 ) * ( angle / 360 ) print ( sector ) return

def SectorArea ( radius , angle ) : if ( angle >= 360 ) : sector = ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) else : sector = ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) print ( sector )

def SectorArea ( radius , angle ) : if angle >= 360 : print ( "Angle not possible" ) else : sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) print ( sector )

42.0
37.06
47.76
42.62
static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }

def check ( st ) : n = len ( st ) if ( n == 0 ) : return False if ( n == 1 ) : return ( ( st [ 0 ] - '0' ) % 4 == 0 ) last = ( int ) ( st [ n - 1 ] ) second_last = ( int ) ( st [ n - 2 ] ) return ( ( second_last * 10 + last ) % 4 == 0 )

def check ( str ) : n = len ( str ) if ( n == 0 ) : return ( str [ 0 ] - '0' ) % 4 == 0 ) if ( n == 2 : return ( str [ n - 1 ] - '0' ) % 4 == 0 ) : last = str [ n - 1 ] - '0' second_last = str [ n - 2 ] - '0' return ( last * 10 + last ) % 4 == 0 ) if ( second_last == 0 ) : return ( second_last == 0 ) : return ( second_last * 10 + last ) % 4 == 0 )

def check ( str ) : n = str . length ( ) if n == 1 : return ( ( str [ 0 ] - '0' ) % 4 == 0 ) last = str [ n - 1 ] - '0' second_last = str [ n - 2 ] - '0' return ( ( second_last * 10 + last ) % 4 == 0 )

42.0
29.78
62.63
51.96
static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }

def isPrime ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return True if ( n % 2 == 0 or n % 3 == 0 ) : return False i = 5 while ( i * i <= n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return False i = i + 6 return True

def isPrime ( n ) : if ( n <= 2 || n <= 3 ) : return true if n == 2 or n == 3 : return false for i in range ( 5 , 6 ) : if ( n % i == 0 || n % ( i + 2 ) == 0 ) : return false return true

def isPrime ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return True if ( n % 2 == 0 or n % 3 == 0 ) : return False for i in range ( 5 , n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return False for i in range ( i + 6 , n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return False return True

42.02
31.77
16.89
20.45
static void findMin ( int V ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( " " + ans . elementAt ( i ) ) ; } }

def findMin ( V ) : deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] n = len ( deno ) ans = [ ] i = n - 1 while ( i >= 0 ) : while ( V >= deno [ i ] ) : V -= deno [ i ] ans . append ( deno [ i ] ) i -= 1 for i in range ( len ( ans ) ) : print ( ans [ i ] , end = "" )

def findMin ( V ) : ans = new Vector < Integer > ( ) for i in range ( n ) : while ( V >= deno [ i ] ) : V -= deno [ i ] ans . add ( deno [ i ] ) i -= 1 ans . sort ( reverse = True ) for i in range ( 0 , n ) : if ( V >= deno [ i ] ) : V -= deno [ i ] : ans . add ( deno [ i ] )

def findMin ( V ) : ans = list ( ) for i in range ( n ) : while V >= deno [ i ] : V -= deno [ i ] ans . add ( deno [ i ] )

42.09
40.14
61.41
85.35
static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }

def repeat ( s , n ) : s1 = s for i in range ( 1 , n ) : s += s1 return s

def repeat ( s , n ) : s1 = s s = s1 + s return s

def repeat ( s , n ) : s1 = s s1 = s for i in range ( 1 , n ) : s += s1 for i in range ( 1 , n ) : s += s1 return s

42.16
37.95
33.09
31.95
static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }

def checkDivisibility ( num ) : length = len ( num ) if ( length == 1 and num [ 0 ] == '0' ) : return True if ( length % 3 == 1 ) : num = str ( num ) + "00" length += 2 elif ( length % 3 == 2 ) : num = str ( num ) + "0" length += 1 sum = 0 p = 1 for i in range ( length - 1 , - 1 , - 1 ) : group = 0 group += ord ( num [ i ] ) - ord ( '0' ) i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 sum = sum + group * p p *= ( - 1 ) sum = abs ( sum ) return ( sum % 13 == 0 )

def checkDivisibility ( num ) : length = len ( num ) if ( length == 1 and num [ 0 ] == '0' ) : num += "00" length += 2 elif length == 2 and num [ 0 ] == '0' : num += "00" length += 1 else : num += "0" length += 1 p = 1 sum = 0 for i in range ( length - 1 , - 1 , - 1 ) : group += num [ i ] if ( i >= 0 ) : sum = sum + group * p *= ( - 1 ) : sum = sum + group * p *= ( - 1 ) return ( sum % 13 == 0 )

def checkDivisibility ( num ) : length = num . length ( ) sum = 0 p = 1 for i in range ( length - 1 , - 1 , - 1 ) : group = 0 group += num [ i ] - '0' group += ( num [ i ] - '0' ) * 10 group += ( num [ i ] - '0' ) * 100 sum = sum + group * p p *= ( - 1 ) sum = sum + group * p return ( sum % 13 == 0 )

42.18
36.91
55.95
50.6
static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } }

def isDvisibleBy12 ( num ) : if ( len ( num ) >= 3 ) : d1 = int ( num [ len ( num ) - 1 ] ) if ( d1 % 2 != 0 ) : return False d2 = int ( num [ len ( num ) - 2 ] ) sum = 0 for i in range ( 0 , len ( num ) ) : sum += int ( num [ i ] ) return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) else : number = int ( num ) return ( number % 12 == 0 )

def isDvisibleBy12 ( num ) : if num [ 0 ] == ' ' : d1 = 0 d2 = 0 for i in range ( num . length ( ) ) : sum = 0 for i in range ( num . length ( ) ) : sum += num [ i ] if ( d1 % 2 != 0 ) : return false d1 = ( int ) num . charAt ( num . length ( ) - 1 ) if ( d2 % 2 != 0 ) : return false d1 = ( int ) num . charAt ( num [ length ( ) - 2 ] if ( d1 % 2 == 0 ) : return ( d2 * 10 + d1 ) % 4 == 0 ) return ( number % 12 == 0 )

def isDvisibleBy12 ( num ) : if num . length >= 3 : d1 = ( int ) num . charAt ( num . length ( ) - 1 ) if ( d1 % 2 != 0 ) : return False d2 = ( int ) num . charAt ( num . length ( ) - 2 ) sum = 0 for i in range ( 0 , len ( num ) ) : sum += num [ i ] return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )

42.19
40.48
64.35
44.08
static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) System . out . print ( arr [ i ] + " " ) ; } }

def printDistinct ( arr , n ) : for i in range ( 0 , n ) : d = 0 for j in range ( 0 , i ) : if ( arr [ i ] == arr [ j ] ) : d = 1 break if ( d == 0 ) : print ( arr [ i ] )

def printDistinct ( arr , n ) : for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : break if ( i == j ) : print ( arr [ i ] + " " ) if ( j == i ) : print ( arr [ j ] + " " ) if ( i == j ) : print ( arr [ i ] + " " ) if ( j ==

def printDistinct ( arr , n ) : for i in range ( n ) : for j in range ( i ) : if ( arr [ i ] == arr [ j ] ) : break if ( i == j ) : print ( arr [ i ] + " " )

42.23
37.55
52.63
46.75
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ; SortedMap < Integer , Integer > st = new TreeMap < > ( ) ; for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) { st . put ( x . getKey ( ) , x . getValue ( ) ) ; } int cumul = 0 ; for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) { cumul += x . getValue ( ) ; System . out . println ( x . getKey ( ) + " " + cumul ) ; } }

def countFreq ( a , n ) : hm = { } for i in range ( 0 , n ) : hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 st = set ( ) for x in hm : st . add ( ( x , hm [ x ] ) ) cumul = 0 for x in sorted ( st ) : cumul += x [ 1 ] print ( x [ 0 ] , cumul )

def countFreq ( a , n ) : hm = dict ( ) for i in range ( n ) : hm . put ( a [ i ] , 1 ) for i in range ( n ) : hm . put ( a [ i ] , 1 ) st = dict ( ) for x in hm . entrySet ( ) : st . put ( x . getKey ( ) , x . getValue ( ) ) cumul = 0 for x in st . entrySet ( ) : cumul += x .

def countFreq ( a , n ) : hm = new HashMap ( ) for i in range ( n ) : hm . put ( a [ i ] , hm [ a [ i ] ] == None ? 1 : hm [ a [ i ] ] + 1 ) st = new TreeMap ( ) for x in hm : st [ x [ 0 ] ] = x [ 1 ] cumul = 0 for x in st : cumul += x [ 1 ] print ( x [ 0 ] + " " + cumul )

42.24
35.83
43.23
38.83
static void KSwapMaximum ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int indexPosition = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( k <= j - i ) break ; if ( arr [ j ] > arr [ indexPosition ] ) indexPosition = j ; } for ( int j = indexPosition ; j > i ; -- j ) SwapInts ( arr , j , j - 1 ) ; k -= indexPosition - i ; } }

def KSwapMaximum ( n , k ) : global arr for i in range ( 0 , n - 1 ) : if ( k > 0 ) : indexPosition = i for j in range ( i + 1 , n ) : if ( k <= j - i ) : break if ( arr [ j ] > arr [ indexPosition ] ) : indexPosition = j for j in range ( indexPosition , i , - 1 ) : t = arr [ j ] arr [ j ] = arr [ j - 1 ] arr [ j - 1 ] = t k = k - indexPosition - i

def KSwapMaximum ( arr , n , k ) : for i in range ( 0 , n - 1 ) : if ( k <= i ) : break for j in range ( i + 1 , n ) : if ( arr [ j ] > arr [ indexPosition ] ) : indexPosition = j if ( arr [ j ] > arr [ indexPosition ] ) : break k -= indexPosition - i break if ( arr [ j ] > arr [ indexPosition ] ) : break if ( arr [ j ] > arr [ indexPosition ] ) : break if ( k <= j - i ) : break if ( k <= j - i ) : break if ( arr [ j ] > arr [ indexPosition ] ) : indexPosition = j break if ( arr [ j ] > arr [ indexPosition ] ) : j -= 1 else : SwapInts ( arr , j , j - 1 )

def KSwapMaximum ( arr , n , k ) : for i in range ( n ) : for j in range ( i + 1 , n ) : if ( k <= j - i ) : break if ( arr [ j ] > arr [ indexPosition ] ) : indexPosition = j if ( j > i ) : SwapInts ( arr , j , j - 1 ) k -= indexPosition - i

42.32
42.9
48.1
72.06
public static String recursiveReverse ( char [ ] str ) { Stack < Character > st = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ; i ++ ) { str [ i ] = st . peek ( ) ; st . pop ( ) ; } return String . valueOf ( str ) ; }

def recursiveReverse ( str ) : stack = [ ] for i in range ( len ( str ) ) : stack . append ( str [ i ] ) for i in range ( len ( str ) ) : str [ i ] = stack . pop ( )

def recursiveReverse ( str ) : st = list ( ) for i in range ( str . length ) : st . append ( str [ i ] ) str . reverse ( ) st . pop ( ) return String . valueOf ( str )

def recursiveReverse ( str ) : st = [ ] for i in range ( len ( str ) ) : st . append ( str [ i ] ) for i in range ( 0 , len ( str ) ) : str [ i ] = st [ i ] for i in range ( 0 , len ( str ) ) : str [ i ] = st [ i ] st . pop ( ) return string . valueOf ( str )

42.34
45.22
41.04
47.52
public static String nextWord ( String str ) { if ( str == "" ) return "a" ; int i = str . length ( ) - 1 ; while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + 'a' ; else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ; return str ; }

def nextWord ( s ) : if ( s == "" ) : return "a" i = len ( s ) - 1 while ( s [ i ] == 'z' and i >= 0 ) : i -= 1 if ( i == - 1 ) : s = s + 'a' else : s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) return s

def nextWord ( str ) : if ( str == "" ) : return "a" i = str . length ( ) - 1 while ( str [ i ] == 'z' and i >= 0 ) : i -= 1 str = str [ 0 : i ] + ( char ) ( ( int ) ( str [ i ] ) + 1 ) return str

def nextWord ( str ) : if str == "" : return "a" i = str . length ( ) - 1 while str [ i ] == 'z' and i >= 0 : i -- if ( i == - 1 ) : str = str + 'a' else : str = str [ 0 : i ] + ( char ) ( ( int ( str [ i ] ) + 1 ) + str [ i + 1 ] ) return str

42.34
37.81
42.3
43.4
int binarySearch ( int arr [ ] , int x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }

def binarySearch ( arr , l , r , x ) : while l <= r : mid = l + ( r - l ) // 2 if arr [ mid ] == x : return mid elif arr [ mid ] < x : l = mid + 1 else : r = mid - 1 return - 1

def binarySearch ( arr , x ) : l = 0 r = arr . length - 1 while l <= r : m = l + ( r - l ) // 2 if arr [ m ] == x : return m

def binarySearch ( arr , x ) : l = 0 r = arr . length - 1 while l <= r : m = l + ( r - l ) / 2 if ( arr [ m ] == x ) : return m if ( arr [ m ] < x ) : l = m + 1 else : r = m - 1 return - 1

42.4
34.83
65.11
50.19
static void sortArray ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int index = - 1 ; int maximum = - 999999 ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int [ ] new_arr = new int [ n ] ; int k = 0 ; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ] ; else new_arr [ k ++ ] = arr [ j -- ] ; } while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ; while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ; new_arr [ n - 1 ] = maximum ; for ( int p = 0 ; p < n ; p ++ ) arr [ p ] = new_arr [ p ] ; }

def sortArray ( arr , n , A , B , C ) : for i in range ( n ) : arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ) index = - ( sys . maxsize - 1 ) maximum = - ( sys . maxsize - 1 ) for i in range ( n ) : if maximum < arr [ i ] : index = i maximum = arr [ i ] i = 0 j = n - 1 new_arr = [ 0 ] * n k = 0 while i < index and j > index : if arr [ i ] < arr [ j ] : new_arr [ k ] = arr [ i ] k += 1 i += 1 else : new_arr [ k ] = arr [ j ] k += 1 j -= 1 while i < index : new_arr [ k ] = arr [ i ] k += 1 i += 1 while j > index : new_arr [ k ] = arr [ j ] k += 1 j -= 1 new_arr [ n - 1 ] = maximum for i in range ( n ) : arr [ i ] = new_arr [ i ]

def sortArray ( arr , n , A , B , C ) : arr . sort ( reverse = True ) index = - 1 maximum = - 999999 for i in range ( n ) : if ( arr [ i ] < arr [ j ] ) : maximum = arr [ i ] i = 0 j = n - 1 while ( i < index && j > index ) : new_arr [ k ++ ] = arr [ i ++ ] while ( i > index ) : new_arr [ k ++ ] = arr [ j -- ] if ( j > index ) : new_arr [ k ++ ] = arr [ j -- ] k = 0 for p in range ( 0 , n ) : if ( arr [ i ] < arr [ j ] ) : new_arr [ k ++ ] = arr [ i ++ ] if ( j > index ) : new_arr [ k ++ ] = arr [ j -- ] if ( i < index ) : new_arr [ k ++ ] = arr [ i ++ ] else : new_arr [ k ++ ] = arr [ j -- ] return new_arr [ n - 1 ]

def sortArray ( arr , n , A , B , C ) : for i in range ( n ) : arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C * arr [ i ] for i in range ( n ) : if ( maximum < arr [ i ] ) : index = i maximum = arr [ i ] i = 0 j = n - 1 while i < index and j > index : if ( arr [ i ] < arr [ j ] ) : if ( arr [ i ] < arr [ j ] ) : new_arr [ k ++ ] = arr [ i ++ ] else : new_arr [ k ++ ] = arr [ j -- ] i += 1 while j > index : new_arr [ k ++ ] = arr [ i ++ ] while i < index : new_arr [ k ++ ] = arr [ i ++ ] j -= 1 new_arr [ n - 1 ] = maximum for p in range ( 0 , n ) : arr [ p ] = new_arr [ p ] return

42.41
42.74
49.23
49.01
static boolean prevPermutation ( char [ ] str ) { int n = str . length - 1 ; int i = n ; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) { i -- ; } if ( i <= 0 ) { return false ; } int j = i - 1 ; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) { j ++ ; } swap ( str , i - 1 , j ) ; StringBuilder sb = new StringBuilder ( String . valueOf ( str ) ) ; sb . reverse ( ) ; str = sb . toString ( ) . toCharArray ( ) ; return true ; }

def prevPermutation ( str ) : n = len ( str ) - 1 i = n while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : i -= 1 if ( i <= 0 ) : return False j = i - 1 while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : j += 1 str = list ( str ) temp = str [ i - 1 ] str [ i - 1 ] = str [ j ] str [ j ] = temp str = '' . join ( str ) str [ : : - 1 ] return True , str

def prevPermutation ( str ) : n = len ( str ) i = n - 1 while i > 0 and str [ i - 1 ] <= str [ i ] : i -= 1 j = n - 1 while j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] : j += 1 swap ( str , i - 1 , j ) sb = new StringBuilder ( String . valueOf ( str ) ) sb . reverse ( ) str = sb .

def prevPermutation ( str ) : n = str . length - 1 i = n while i > 0 and str [ i - 1 ] <= str [ i ] : i -= 1 if i <= 0 : return False j = i - 1 while j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] : j += 1 swap ( str , i - 1 , j ) sb = new StringBuilder ( str ) sb . reverse ( ) str = sb . toString ( ) . toCharArray ( ) return True

42.43
46.42
55.36
45.13
static int findLargestSumPair ( ) { int first , second ; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ] ; second = arr [ 1 ] ; } else { first = arr [ 1 ] ; second = arr [ 0 ] ; } for ( int i = 2 ; i < arr . length ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } return ( first + second ) ; }

def findLargestSumPair ( arr , n ) : if arr [ 0 ] > arr [ 1 ] : first = arr [ 0 ] second = arr [ 1 ] else : first = arr [ 1 ] second = arr [ 0 ] for i in range ( 2 , n ) : if arr [ i ] > first : second = first first = arr [ i ] elif arr [ i ] > second and arr [ i ] != first : second = arr [ i ] return ( first + second )

def findLargestSumPair ( arr ) : first , second = arr [ 0 ] , arr [ 1 ] for i in range ( 2 , arr . length ) : if ( arr [ 0 ] > arr [ 1 ] ) : first = arr [ 0 ] second = arr [ 1 ] i = 2 while i < arr . length : if ( arr [ i ] > second ) : second = first first = arr [ i ] i = 2 if ( arr [ i ] > first && arr [ i ] != first ) : second = arr [ i ] if ( arr [ i ] > second ) : second = arr [ i ] if ( arr [ i ] > first && arr [ i ] != second ) : second = arr [ i ] if ( arr [ i ] != first ) : return ( first + second )

def findLargestSumPair ( arr ) : first , second = arr [ 0 ] , arr [ 1 ] for i in range ( 2 , len ( arr ) ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second and arr [ i ] != first ) : second = arr [ i ] return ( first + second )

42.46
41.3
87.89
86.77
static boolean isPermutedMatrix ( int mat [ ] [ ] , int n ) { String str_cat = "" ; for ( int i = 0 ; i < n ; i ++ ) { str_cat = str_cat + "-" + String . valueOf ( mat [ 0 ] [ i ] ) ; } str_cat = str_cat + str_cat ; for ( int i = 1 ; i < n ; i ++ ) { String curr_str = "" ; for ( int j = 0 ; j < n ; j ++ ) { curr_str = curr_str + "-" + String . valueOf ( mat [ i ] [ j ] ) ; } if ( str_cat . contentEquals ( curr_str ) ) { return false ; } } return true ; }

def isPermutedMatrix ( mat , n ) : str_cat = "" for i in range ( n ) : str_cat = str_cat + "-" + str ( mat [ 0 ] [ i ] ) str_cat = str_cat + str_cat for i in range ( 1 , n ) : curr_str = "" for j in range ( n ) : curr_str = curr_str + "-" + str ( mat [ i ] [ j ] ) if ( str_cat . find ( curr_str ) ) : return True return False

def isPermutedMatrix ( mat , n ) : str_cat = "" for i in range ( 1 , n ) : str_cat = str_cat + "-" str_cat = "" for j in range ( 1 , n ) : curr_str = curr_str + str_cat if ( str_cat . contentEquals ( curr_str ) ) : return false

def isPermutedMatrix ( mat , n ) : str_cat = "" for i in range ( 1 , n ) : str_cat = str_cat + "-" + str ( mat [ 0 ] [ i ] ) str_cat = str_cat + str_cat for i in range ( 1 , n ) : curr_str = "" for j in range ( i , n ) : curr_str = curr_str + "-" + str ( mat [ i ] [ j ] ) if ( str_cat . contentEquals ( curr_str ) ) : return False return True

42.48
31.38
59.05
48.07
public static int jumpSearch ( int [ ] arr , int x ) { int n = arr . length ; int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ; int prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += ( int ) Math . floor ( Math . sqrt ( n ) ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }

def jumpSearch ( arr , x , n ) : step = math . sqrt ( n ) prev = 0 while arr [ int ( min ( step , n ) - 1 ) ] < x : prev = step step += math . sqrt ( n ) if prev >= n : return - 1 while arr [ int ( prev ) ] < x : prev += 1 if prev == min ( step , n ) : return - 1 if arr [ int ( prev ) ] == x : return prev return - 1

def jumpSearch ( arr , x ) : n = arr . length step = 0 while ( arr [ min ( step , n ) - 1 ] < x ) : prev = step step += ( int ) Math . floor ( n ) if ( prev >= n ) : return - 1 prev = min ( step , n ) - 1 while ( arr [ prev ] < x ) : prev += ( int ) Math . floor ( n ) if ( prev == min ( step , n ) ) : return - 1 if ( arr [ prev ] == x ) : return prev

def jumpSearch ( arr , x ) : n = arr . length step = ( float ( 'inf' ) ) prev = 0 while arr [ min ( step , n ) - 1 ] < x : prev = step step += ( float ( 'inf' ) ) if ( prev >= n ) : return - 1 while arr [ prev ] < x : prev += ( float ( 'inf' ) ) if ( prev == min ( step , n ) ) : return - 1 if arr [ prev ] == x : return prev return - 1

42.49
36.94
53.42
57.44
static int findSubarraySum ( int [ ] arr , int n ) { int res = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( m . containsKey ( sum ) ) { m . put ( sum , m . get ( sum ) + 1 ) ; } else { m . put ( sum , 1 ) ; } } } for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) if ( x . getValue ( ) == 1 ) res += x . getKey ( ) ; return res ; }

def findSubarraySum ( arr , n ) : res = 0 m = dict ( ) for i in range ( n ) : Sum = 0 for j in range ( i , n ) : Sum += arr [ j ] m [ Sum ] = m . get ( Sum , 0 ) + 1 for x in m : if m [ x ] == 1 : res += x return res

def findSubarraySum ( arr , n ) : res = 0 for i in range ( 0 , n ) : sum = 0 for j in range ( i , n ) : sum += arr [ j ] if ( m . containsKey ( sum ) ) : m . put ( sum , 1 ) else : res += sum if ( x . getValue ( ) == 1 ) : res += x . getKey ( ) return res

def findSubarraySum ( arr , n ) : res = 0 m = list ( ) for i in range ( n ) : sum = 0 for j in range ( i , n ) : sum += arr [ j ] if ( m . containsKey ( sum ) ) : m [ sum ] = m [ sum ] + 1 else : m [ sum ] = 1 return res

42.51
39.74
30.88
26.24
static void myCopy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }

def myCopy ( s1 , s2 ) : for i in range ( len ( s1 ) ) : s2 [ i ] = s1 [ i ]

def myCopy ( s1 , s2 ) : s1 . sort ( reverse = True ) s2 . sort ( reverse = True ) i = 0 for i in range ( s1 . length ) : s2 [ i ] = s1 [ i ] i += 1 return

def myCopy ( s1 , s2 ) : s1 . sort ( reverse = True ) s2 . sort ( reverse = True )

42.66
39.26
44.17
38.81
static void printDistinct ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR && index [ i ] != n ; i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ; }

def printDistinct ( Str ) : n = len ( Str ) count = [ 0 for i in range ( MAX_CHAR ) ] index = [ n for i in range ( MAX_CHAR ) ] for i in range ( n ) : x = ord ( Str [ i ] ) count [ x ] += 1 if ( count [ x ] == 1 and x != '' ) : index [ x ] = i if ( count [ x ] == 2 ) : index [ x ] = n index = sorted ( index ) for i in range ( MAX_CHAR ) : if index [ i ] == n : break print ( Str [ index [ i ] ] , end = "" )

def printDistinct ( str ) : MAX_CHAR = 8 index = [ MAX_CHAR for i in range ( MAX_CHAR ) ] for i in range ( 0 , n ) : count [ i ] = 0 for x in str [ i ] : if ( count [ x ] == 1 and x != ' ' ) : index [ x ] = i if ( count [ x ] == 2 ) : index [ x ] = n return count = [ 0 for i in range

def printDistinct ( str ) : count = [ 0 for i in range ( MAX_CHAR ) ] index = [ MAX_CHAR ] for i in range ( MAX_CHAR ) : count [ i ] = 0 index [ i ] = n for i in range ( n ) : x = str [ i ] if count [ x ] == 1 and x != ' ' : index [ x ] = i if count [ x ] == 2 : index [ x ] = n

42.69
46.11
100.0
100.0
static int recSearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return recSearch ( arr , l + 1 , r - 1 , x ) ; }

def recSearch ( arr , l , r , x ) : if r < l : return - 1 if arr [ l ] == x : return l if arr [ r ] == x : return r return recSearch ( arr , l + 1 , r - 1 , x )

def recSearch ( arr , l , r , x ) : if ( arr [ l ] == x ) : return l if ( arr [ r ] == x ) : return r

def recSearch ( arr , l , r , x ) : if r < l : return - 1 if arr [ l ] == x : return l if arr [ r ] == x : return r return recSearch ( arr , l + 1 , r - 1 , x )

42.73
45.29
44.78
39.04
static int firstNonRepeating ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; return - 1 ; }

def firstNonRepeating ( arr , n ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 for i in range ( n ) : if mp [ arr [ i ] ] == 1 : return arr [ i ] return - 1

def firstNonRepeating ( arr , n ) : m = defaultdict ( int ) for i in range ( 0 , n ) : if ( m . containsKey ( arr [ i ] ) ) : return arr [ i ] m . put ( arr [ i ] , 1 ) if ( m [ arr [ i ] ] == 1 ) : return arr [ i ]

def firstNonRepeating ( arr , n ) : m = list ( ) for i in range ( n ) : if ( m . containsKey ( arr [ i ] ) ) : m [ arr [ i ] ] = m [ arr [ i ] ] + 1 else : m [ arr [ i ] ] = 1 return arr [ i ]

42.75
42.21
100.0
100.0
static int multiplyBySeven ( int n ) { return ( ( n << 3 ) - n ) ; }

def multiplyBySeven ( n ) : return ( ( n << 3 ) - n )

def multiplyBySeven ( n ) : return ( n

def multiplyBySeven ( n ) : return ( ( n << 3 ) - n )

42.75
50.98
76.62
62.97
static void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " " ) ; square = square + odd ; odd = odd + 2 ; } }

def printSquares ( n ) : square = 0 odd = 1 for x in range ( 0 , n ) : print ( square , end = "" ) square = square + odd odd = odd + 2

def printSquares ( n ) : square = 0 odd = 1 for x in range ( n ) : print ( square + " " ) odd = odd + 2 for x in range ( n ) : print ( square + " " ) square = square + odd print ( odd + " " ) odd = odd + 2 print ( square )

def printSquares ( n ) : square = 0 odd = 1 for x in range ( n ) : print ( square + " " ) square = square + odd odd = odd + 2

42.79
40.82
44.34
43.32
void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( "The two reppeated elements are :" ) ; System . out . println ( x + " " + y ) ; }

def printRepeating ( arr , size ) : xor = arr [ 0 ] n = size - 2 x = 0 y = 0 for i in range ( 1 , size ) : xor ^= arr [ i ] for i in range ( 1 , n + 1 ) : xor ^= i set_bit_no = xor & ~ ( xor - 1 ) for i in range ( 0 , size ) : if ( arr [ i ] & set_bit_no ) : x = x ^ arr [ i ] else : y = y ^ arr [ i ] for i in range ( 1 , n + 1 ) : if ( i & set_bit_no ) : x = x ^ i else : y = y ^ i print ( "Thetworepeating" , "elementsare" , y , x )

def printRepeating ( arr , size ) : xor = 0 for i in range ( size ) : xor ^= arr [ i ] for i in range ( 1 , n ) : set_bit_no = ( xor & ~ ( xor - 1 ) ) x = x ^ arr [ i ] y = y ^ arr [ i ] if ( a != 0 ) : x = x ^ arr [ i ] else y = y ^ arr [ i ] if ( a != 0 ) : x = x ^ arr [ i ] if ( a != 0 ) : x = x ^ arr [ i ] if ( a != 0 ) : x = x ^ arr [ i ] if ( a != 0 ) : y = y ^ i else : print ( "The two reppeated elements are :" ) y = y ^ i print ( "The two reppeated elements are :" ) print ( x + " " + y )

def printRepeating ( arr , size ) : xor = arr [ 0 ] for i in range ( 1 , size ) : xor ^= arr [ i ] for i in range ( 1 , size ) : a = arr [ i ] & set_bit_no ; if ( a != 0 ) : x = x ^ arr [ i ] else : y = y ^ arr [ i ] for i in range ( 1 , n ) : a = arr [ i ] & set_bit_no if ( a != 0 ) : x = x ^ i y = y ^ i for i in range ( 1 , n ) : a = i & set_bit_no if ( a != 0 ) : x = x ^ i y = y ^ i for i in range ( 1 , n ) : a = i & set_bit_no if ( a != 0 ) : x = x ^ i y = y ^ i for i in range ( 1 , n ) : a = i & set_bit_no if ( a != 0 ) : x = x ^ i y = y ^ i

42.8
43.44
84.84
64.63
static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }

def maximumSegments ( n , a , b , c ) : dp = [ - 1 ] * ( n + 10 ) dp [ 0 ] = 0 for i in range ( 0 , n ) : if ( dp [ i ] != - 1 ) : if ( i + a <= n ) : dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) if ( i + b <= n ) : dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) if ( i + c <= n ) : dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) return dp [ n ]

def maximumSegments ( n , a , b , c ) : dp = [ - 1 for i in range ( n ) ] for i in range ( 0 , n ) : if ( dp [ i ] != - 1 ) : dp [ i ] = max ( dp [ i ] + 1 , dp [ i + a ] ) if ( dp [ i ] + 1 , dp [ i + b ] ) return dp [ n ]

def maximumSegments ( n , a , b , c ) : dp = [ 0 for i in range ( n ) ] for i in range ( n ) : if dp [ i ] != - 1 : if ( i + a <= n ) : dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) if ( i + b <= n ) : dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) if ( i + c <= n ) : dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) return dp [ n ]

42.84
45.07
88.5
73.24
static int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }

def maxDiff ( arr , n ) : SubsetSum_1 = 0 SubsetSum_2 = 0 for i in range ( 0 , n ) : isSingleOccurance = True for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : isSingleOccurance = False arr [ i ] = arr [ j ] = 0 break if ( isSingleOccurance == True ) : if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] return abs ( SubsetSum_1 - SubsetSum_2 )

def maxDiff ( arr , n ) : SubsetSum_1 = 0 SubsetSum_2 = 0 for i in range ( 0 , n ) : if ( arr [ i ] == arr [ j ] ) : isSingleOccurance = false arr [ i ] = arr [ j ] = 0 break if ( isSingleOccurance ) : SubsetSum_1 += arr [ i ] SubsetSum_2 += arr [ i ] if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] if ( arr [ i ] > 0 ) : SubsetSum_2 += arr [ i ] if ( arr [ i ] > 0 ) : SubsetSum_2 += arr [ i ] else : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] return SubsetSum_1

def maxDiff ( arr , n ) : SubsetSum_1 = 0 SubsetSum_2 = 0 for i in range ( 0 , n - 1 , - 1 ) : isSingleOccurance = True for j in range ( i + 1 , n - 1 ) : if ( arr [ i ] == arr [ j ] ) : isSingleOccurance = False arr [ i ] = arr [ j ] = 0 break if isSingleOccurance : if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] return abs ( SubsetSum_1 - SubsetSum_2 )

42.84
36.58
84.0
62.98
static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }

def maxSubArraySum ( a , size ) : max_so_far = - maxsize - 1 max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( 0 , size ) : max_ending_here += a [ i ] if max_so_far < max_ending_here : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 return ( end - start + 1 )

def maxSubArraySum ( a , size ) : max_so_far = float ( 'inf' ) for i in range ( size ) : max_ending_here = float ( 'inf' ) for i in range ( size ) : max_so_far = max_ending_here + a [ i ] s = i + 1 if ( max_so_far < max_ending_here ) : max_ending_here = 0 start = s end = i if ( max_ending_here > 0 ) : max_so_far = max_ending_here = 0 max_so_far = max_ending_here if ( max_ending_here < 0 ) : max_ending_here = 0 s = i + 1 return max_so_far

def maxSubArraySum ( a , size ) : max_so_far = float ( 'inf' ) max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( size ) : max_ending_here += a [ i ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 return ( end - start + 1 )

42.89
38.04
48.2
32.33
static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; }

def calculate ( N ) : length = len ( N ) l = int ( ( length ) / 2 ) count = 0 for i in range ( l + 1 ) : s = N [ 0 : 0 + i ] l1 = len ( s ) t = N [ i : l1 + i ] try : if s [ 0 ] == '0' or t [ 0 ] == '0' : continue except : continue if s == t : count += 1 return count

def calculate ( N ) : len = len * 2 for i in range ( len ) : s = N [ 0 : i ] t = N [ i : l1 + i ] if ( s [ 0 ] == '0' or t [ 0 ] == '0' ) : count += 1 elif ( s [ 0 ] == '0' ) : count += 1 elif ( t [ 0 ] == '0' ) : count += 1 elif ( s [ 0 ] == '0' ) : continue if ( t ) == 0 ) : count += 1 return count

def calculate ( N ) : len = len ( N ) l = ( len ) // 2 count = 0 for i in range ( 1 , l ) : s = N [ 0 , i ] l1 = s . length ( ) t = N [ i : l1 + i ] if ( s [ 0 ] == '0' or t [ 0 ] == '0' ) : continue if ( s [ 0 ] == '0' or t [ 0 ] == '0' ) : continue if ( s [ 0 ] == '0' and t [ 0 ] == '0' ) : count += 1 return count

42.9
48.27
38.28
31.94
static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }

def isPowerOfFour ( n ) : if ( n == 0 ) : return False while ( n != 1 ) : if ( n % 4 != 0 ) : return False n = n // 4 return True

def isPowerOfFour ( n ) : if ( n == 0 ) : return 1 n = n / 4 while n != 1 : if ( n % 4 != 0 ) : return 0 n = n / 4 while n != 1 : if ( n % 4 != 0 ) : return 0 n = n / 4 return 1

def isPowerOfFour ( n ) : if n == 0 : return 0 while n != 1 : if n % 4 != 0 : return 0 n = n / 4 return 1

42.91
41.12
55.32
38.08
static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . substring ( i , i + len ) ; } Arrays . sort ( arr ) ; String res = "" ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }

def lexicographicSubConcat ( s ) : n = len ( s ) sub_count = ( n * ( n + 1 ) ) // 2 arr = [ 0 ] * sub_count index = 0 for i in range ( n ) : for j in range ( 1 , n - i + 1 ) : arr [ index ] = s [ i : i + j ] index += 1 arr . sort ( ) res = "" for i in range ( sub_count ) : res += arr [ i ] return res

def lexicographicSubConcat ( s ) : n = len ( s ) sub_count = len ( s ) for i in range ( 0 , n ) : arr [ index ++ ] = s [ i : i + len ] sub_count -= 1 res = "" for i in range ( 0 , sub_count ) : res += arr [ i ] return res

def lexicographicSubConcat ( s ) : sub_count = n * ( n + 1 ) / 2 arr = list ( ) index = 0 for i in range ( 0 , sub_count ) : for len in range ( 1 , n ) : arr [ index ++ ] = s [ i : i + len ] sort ( arr ) res = "" for i in range ( 0 , sub_count ) : res += arr [ i ] return res

43.0
30.62
100.0
100.0
static int areaSquare ( int side ) { int area = side * side ; return area ; }

def areaSquare ( side ) : area = side * side return area

def areaSquare ( side ) : return area

def areaSquare ( side ) : area = side * side return area

43.04
34.0
39.65
39.7
static String decToBin ( int n ) { if ( n == 0 ) return "0" ; String bin = "" ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; }

def decToBin ( n ) : if ( n == 0 ) : return "0" bin = "" while ( n > 0 ) : if ( n & 1 == 0 ) : bin = '0' + bin else : bin = '1' + bin n = n >> 1 return bin

def decToBin ( n ) : n = n >> 1 bin = "" while ( n > 0 ) : bin = ( n & 1 ) == 0 ? '0' : '1' ) + bin n >>= 1 bin = "" while ( n > 0 ) : bin = ( n & 1 ) == 0 : '1' ) + bin return bin

def decToBin ( n ) : if n == 0 : return "0" bin = "" while n > 0 : bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin n >>= 1 return bin

43.05
39.94
49.62
31.58
static void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " " ) ; } } }

def subArray ( arr , n ) : for i in range ( 0 , n ) : for j in range ( i , n ) : for k in range ( i , j + 1 ) : print ( arr [ k ] , end = "" ) print ( "\n" , end = "" )

def subArray ( arr , n ) : for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : for k in range ( i , j + 1 , n ) : print ( arr [ k ] + " " ) if ( k <= n ) : print ( arr [ k ] + " " ) if ( j == i ) : print ( arr [ k ] + " " ) if ( k <= n ) : print ( arr [ k ] )

def subArray ( n ) : for i in range ( n ) : for j in range ( n ) : for k in range ( i , n ) : print ( arr [ k ] )

43.05
33.37
65.2
48.9
static int countWays ( int n ) { int table [ ] = new int [ n + 1 ] ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; return table [ n ] ; }

def CountWays ( n ) : table = [ 0 ] * ( n + 1 ) table [ 0 ] = 1 for i in range ( 1 , n ) : for j in range ( i , n + 1 ) : table [ j ] += table [ j - i ] return table [ n ]

def countWays ( n ) : table = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : table [ i ] += table [ i - 1 ] return table [ n ]

def countWays ( n ) : table = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : table [ j ] += table [ j - i ] return table [ n ]

43.06
27.14
51.31
49.34
static float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { System . out . println ( "Not a valid triangle" ) ; System . exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }

def findArea ( a , b , c ) : if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : print ( 'Notavalidtrianglen' ) return s = ( a + b + c ) / 2 area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 print ( 'Areaofatraingleis%f' % area )

def findArea ( a , b , c ) : if ( a < 0 || b < 0 || c < 0 ) : return ( float ) float . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) return ( float ) float . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) )

def findArea ( a , b , c ) : if a < 0 or b < 0 or c < 0 : print ( "Invalid input" ) raise ValueError ( "Invalid input" ) s = ( a + b + c ) / 2 return ( float ) sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) )

43.06
40.01
36.97
38.4
static int interpolationSearch ( int x ) { int lo = 0 , hi = ( arr . length - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) { if ( arr [ lo ] == x ) return lo ; return - 1 ; } int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) lo = pos + 1 ; else hi = pos - 1 ; } return - 1 ; }

def interpolationSearch ( arr , n , x ) : lo = 0 hi = ( n - 1 ) while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : if lo == hi : if arr [ lo ] == x : return lo ; return - 1 ; pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ) if arr [ pos ] == x : return pos if arr [ pos ] < x : lo = pos + 1 ; else : hi = pos - 1 ; return - 1

def interpolationSearch ( arr , x ) : lo = 0 hi = ( arr . length - 1 ) while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : if ( arr [ lo ] == x ) : return lo if ( arr [ lo ] < x ) : lo = pos + 1 else : hi = pos - 1 if ( arr [ pos ] > x ) : hi = pos + 1 else : return - 1

def interpolationSearch ( x ) : lo = 0 hi = ( arr . length - 1 ) while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : if ( lo == hi ) : if ( arr [ lo ] == x ) : return lo if ( arr [ lo ] < x ) : lo = pos + 1 else : hi = pos - 1 return - 1

43.09
51.09
82.09
82.63
static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }

def longestSubseqWithDiffOne ( arr , n ) : dp = [ 1 for i in range ( n ) ] for i in range ( n ) : for j in range ( i ) : if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) result = 1 for i in range ( n ) : if ( result < dp [ i ] ) : result = dp [ i ] return result

def longestSubseqWithDiffOne ( arr , n ) : dp = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : if ( arr [ i ] == arr [ j ] + 1 ) : dp [ i ] = max ( dp [ i ] , dp [ j ] - 1 ) return result

def longestSubseqWithDiffOne ( arr , n ) : dp = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : dp [ i ] = 1 for i in range ( 1 , n ) : if ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) : dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) result = 1 for i in range ( 0 , n ) : if ( result < dp [ i ] ) : result = dp [ i ] return result

43.12
32.07
39.4
32.92
static int removeConsecutiveSame ( Vector < String > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v . get ( i ) . equals ( v . get ( i + 1 ) ) ) { v . remove ( i ) ; v . remove ( i ) ; if ( i > 0 ) i -- ; n = n - 2 ; } else i ++ ; } return v . size ( ) ; }

def removeConsecutiveSame ( v ) : n = len ( v ) i = 0 while ( i < n - 1 ) : if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) : v = v [ : i ] v = v [ : i ] if ( i > 0 ) : i -= 1 n = n - 2 else : i += 1 return len ( v [ : i - 1 ] )

def removeConsecutiveSame ( v ) : n = v . size ( ) for i in range ( 0 , n - 2 ) : if ( v [ i ] == v [ i + 1 ] ) : v . remove ( i ) n = n - 2 else : i += 1 if ( v [ i ] == v [ i + 1 ] ) : v . remove ( i ) n = n - 2 else : i += 1 } return n

def removeConsecutiveSame ( v ) : n = v . size ( ) for i in range ( n ) : if ( v [ i ] == v [ i + 1 ] ) : v . remove ( i ) v . remove ( i ) if ( i > 0 ) : i -= 1 n = n - 2 return v . size ( )

43.2
59.77
60.1
66.05
public static void dfs ( LinkedList < Integer > list [ ] , int node , int arrival ) { System . out . println ( node ) ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] . get ( i ) != arrival ) dfs ( list , list [ node ] . get ( i ) , node ) ; } }

def dfs ( List , node , arrival ) : print ( node ) for i in range ( len ( List [ node ] ) ) : if ( List [ node ] [ i ] != arrival ) : dfs ( List , List [ node ] [ i ] , node )

def dfs ( list , node , arrival ) : print ( list [ node ] ) print ( arrival ) for i in range ( 0 , list [ node ] . size ( ) ) : if ( list [ node ] [ i ] != arrival ) dfs ( list , node , arrival ) : print ( list [ node ] [ i ] , node ) return print ( list [ node ] [ i ] )

def dfs ( list , node , arrival ) : list . sort ( reverse = True ) for i in range ( len ( list [ node ] ) ) : if list [ node ] [ i ] != arrival : dfs ( list , list [ node ] [ i ] , node )

43.27
34.33
37.52
33.15
static void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( "%d " , i ) ; else { System . out . printf ( "%d " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( "%d " , v . get ( i ) ) ; }

def printDivisors ( n ) : list = [ ] for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : if ( n % i == 0 ) : if ( n / i == i ) : print ( i , end = "" ) else : print ( i , end = "" ) list . append ( int ( n / i ) ) for i in list [ : : - 1 ] : print ( i , end = "" )

def printDivisors ( n ) : v = new Vector < Integer > ( ) for i in range ( 1 , n ) : if ( n % i == 0 ) : print ( "%d " , i ) v . add ( n / i ) else : print ( "%d " , i ) v . add ( n / i ) } for i in range ( 1 , n ) : if ( n % i == 0 ) : print ( "%d " , i )

def printDivisors ( n ) : v = list ( ) for i in range ( len ( v ) ) : if ( n % i == 0 ) : if ( n / i == i ) : print ( i ) else : print ( "%d" , i ) v . add ( n / i )

43.29
35.73
45.51
33.72
static int countWays ( String s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( 0 ) - 'a' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }

def countWays ( s ) : count = [ 0 ] * 26 for x in s : count [ ord ( x ) - ord ( 'a' ) ] = ( count [ ord ( x ) - ord ( 'a' ) ] ) + 1 count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1 ans = 1 for i in range ( 26 ) : if ( count [ i ] != 0 ) : ans *= count [ i ] return ans

def countWays ( s ) : count = [ 0 for i in range ( len ( s ) ) ] for i in range ( 0 , len ( s ) ) : count [ s [ i ] - 'a' ] ++ ans = 1 for i in range ( 0 , 26 ) : if ( count [ i ] != 0 ) : ans *= count [ i ] return ans

def countWays ( s ) : count = [ 0 for i in range ( 26 ) ] for i in range ( 0 , 26 ) : count [ s [ i ] - 'a' ] += 1 count [ s [ 0 ] - 'a' ] = 1 ans = 1 for i in range ( 0 , 26 ) : if count [ i ] != 0 : ans *= count [ i ] return ans

43.3
46.59
65.7
56.83
static int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }

def maximumSum ( arr , n , k ) : for i in range ( 1 , k + 1 ) : min = + 2147483647 index = - 1 for j in range ( n ) : if ( arr [ j ] < min ) : min = arr [ j ] index = j if ( min == 0 ) : break arr [ index ] = - arr [ index ] sum = 0 for i in range ( n ) : sum += arr [ i ] return sum

def maximumSum ( arr , n , k ) : min = - 2147483647 for i in range ( 1 , k ) : if ( arr [ i ] < min ) : min = arr [ i ] index = j break if ( min == 0 ) : break arr [ index ] = - arr [ index ] if ( min == 0 ) : break arr [ index ] = - arr [ index ] if ( min == 0 ) : break arr [ index ] = - arr [ index ] if ( min == 0 ) : break arr [ index ] = - arr [ index ] if ( min == 0 ) : break return sum

def maximumSum ( arr , n , k ) : for i in range ( k ) : min = + 2147483647 for j in range ( 1 , k ) : if ( arr [ j ] < min ) : min = arr [ j ] index = j if ( min == 0 ) : break arr [ index ] = - arr [ index ] return sum

43.31
37.19
73.91
57.13
static int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }

def count ( a , b ) : m = len ( a ) n = len ( b ) lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( n + 1 ) : lookup [ 0 ] [ i ] = 0 for i in range ( m + 1 ) : lookup [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if a [ i - 1 ] == b [ j - 1 ] : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] else : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] return lookup [ m ] [ n ]

def count ( a , b ) : lookup = [ 0 for i in range ( m + 1 , n + 1 ) ] for i in range ( 1 , m + 1 , n ) : if ( a [ i ] == b [ j - 1 ] ) : lookup [ i ] [ j ] = 1 else : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] return lookup [ m ] [ n ]

def count ( a , b ) : m = a . length n = b . length lookup = [ 0 for i in range ( m + 1 , n + 1 ) ] for i in range ( 1 , m + 1 , - 1 ) : lookup [ i ] [ 0 ] = 0 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n ) : if ( a [ i - 1 ] == b [ j - 1 ] ) : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] else : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] return lookup [ m ] [ n ]

43.33
30.15
22.44
17.64
static void printFun ( int test ) { if ( test < 1 ) return ; else { System . out . printf ( "%d " , test ) ; printFun ( test - 1 ) ; System . out . printf ( "%d " , test ) ; return ; } }

def printFun ( test ) : if ( test < 1 ) : return else : print ( test , end = "" ) printFun ( test - 1 ) print ( test , end = "" ) return

def printFun ( test ) : if ( test == 1 ) : return printFun ( test - 1 ) else : printFun ( test ) printFun ( test - 1 ) printFun ( test ) return printFun ( test - 1 )

def printFun ( test ) : if test < 1 : return printFun ( test - 1 )

43.37
46.01
51.94
51.97
static int policeThief ( char arr [ ] , int n , int k ) { int res = 0 ; ArrayList < Integer > thi = new ArrayList < Integer > ( ) ; ArrayList < Integer > pol = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 'P' ) pol . add ( i ) ; else if ( arr [ i ] == 'T' ) thi . add ( i ) ; } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi . get ( l ) < pol . get ( r ) ) l ++ ; else r ++ ; } return res ; }

def policeThief ( arr , n , k ) : i = 0 l = 0 r = 0 res = 0 thi = [ ] pol = [ ] while i < n : if arr [ i ] == 'P' : pol . append ( i ) elif arr [ i ] == 'T' : thi . append ( i ) i += 1 while l < len ( thi ) and r < len ( pol ) : if ( abs ( thi [ l ] - pol [ r ] ) <= k ) : res += 1 l += 1 r += 1 elif thi [ l ] < pol [ r ] : l += 1 else : r += 1 return res

def policeThief ( arr , n , k ) : thi = list ( ) pol = list ( ) for i in range ( n ) : if ( arr [ i ] == 'P' ) thi . add ( i ) elif ( arr [ i ] == 'T' ) pol . add ( i ) else : res += 1 l = 0 r = 0 while l < thi . size ( ) and r < pol . size ( ) : if ( thi [ l ] > pol [ r ] = thi [ l ] < pol [ r ] ) : l += 1 else : r += 1 if ( thi [ l ] < pol [ r ] ) : res += 1 else : if ( thi [ l ] < pol [ r ] ) : l += 1 else : r += 1 return res

def policeThief ( arr , n , k ) : res = 0 thi = list ( ) pol = list ( ) for i in range ( n ) : if ( arr [ i ] == 'P' ) : pol . add ( i ) else : thi . append ( i ) for i in range ( n ) : if ( arr [ i ] == 'T' ) : thi . add ( i ) else : thi . append ( i ) l = 0 r = 0 while l < thi . size ( ) and r < pol . size ( ) : if ( abs ( thi [ l ] - pol [ r ] ) <= k ) : res += 1 l += 1 r += 1 else : res += 1 return res

43.41
39.23
55.94
36.8
static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( "x = " + i + ", y = " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( "No solution" ) ; }

def solution ( a , b , n ) : i = 0 while i * a <= n : if ( n - ( i * a ) ) % b == 0 : print ( "x=" , i , ",y=" , int ( ( n - ( i * a ) ) / b ) ) return 0 i = i + 1 print ( "Nosolution" )

def solution ( a , b , n ) : for i in range ( 0 , a , b ) : if ( n - ( i * a ) ) % b == 0 : print ( "Solution: " + i ) return print ( "No solution: " + n ) return print ( "No solution: " )

def solution ( a , b , n ) : for i in range ( n ) : if ( n - ( i * a ) ) % b == 0 : print ( "x = " + i , y = " + ( n - ( i * a ) ) / b ) return

43.5
29.57
31.1
25.92
static int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }

def countSolutions ( n ) : res = 0 x = 0 while ( x * x < n ) : y = 0 while ( x * x + y * y < n ) : res = res + 1 y = y + 1 x = x + 1 return res

def countSolutions ( n ) : res = 0 for x in range ( 0 , n ) : for y in range ( 0 , n ) : if ( x * x + y * y < n ) : res += 1 return res

def countSolutions ( n ) : res = 0 for x in range ( n ) : for y in range ( 0 , n ) : for x in range ( 0 , n ) : for y in range ( 0 , x * x + y * y , n ) : res += ( x , y ) return res

43.53
44.78
70.25
72.62
static int countSeq ( int n , int diff ) { if ( Math . abs ( diff ) > n ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ; int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ; return res ; }

def countSeq ( n , diff ) : if ( abs ( diff ) > n ) : return 0 if ( n == 1 and diff == 0 ) : return 2 if ( n == 1 and abs ( diff ) == 1 ) : return 1 res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) return res

def countSeq ( n , diff ) : if ( diff == 0 ) : return 0 if n == 1 and diff == 1 : return 2 * countSeq ( n - 1 , diff + 1 ) + countSeq ( n - 1 , diff - 1 ) return 1

def countSeq ( n , diff ) : if abs ( diff ) > n : return 0 if n == 1 and diff == 0 : return 2 if n == 1 and diff == 1 : return 1 res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) return res

43.56
48.97
26.32
31.06
static void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( "" ) ; }

def digitsNum ( N ) : if ( N == 0 ) : print ( "0" , end = "" ) if ( N % 9 != 0 ) : print ( N % 9 , end = "" ) for i in range ( 1 , int ( N / 9 ) + 1 ) : print ( "9" , end = "" ) for i in range ( 1 , N + 1 ) : print ( "0" , end = "" ) print ( )

def digitsNum ( N ) : if ( N == 0 ) : print ( "0" ) elif ( N % 9 == 0 ) : print ( ( N % 9 ) ) else : print ( ( N % 9 ) ) for i in range ( 1 , N / 9 ) : print ( i ) if ( i <= ( N / 9 ) ) : print ( "0" ) else : print ( i ) print ( "9" ) for i in range ( 1 , N ) : if ( i <= ( N ) : if ( i <= N ) : print ( "1" )

def digitsNum ( N ) : if N == 0 : print ( "0" ) if N % 9 != 0 : print ( ( N % 9 ) ) for i in range ( 1 , N // 9 ) : print ( ( i , ) )

43.63
38.48
80.6
60.85
static int findElement ( int [ ] arr , int n ) { int [ ] leftMax = new int [ n ] ; leftMax [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ; int rightMin = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ; rightMin = Math . min ( rightMin , arr [ i ] ) ; } return - 1 ; }

def findElement ( arr , n ) : leftMax = [ None ] * n leftMax [ 0 ] = float ( '-inf' ) for i in range ( 1 , n ) : leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) rightMin = float ( 'inf' ) for i in range ( n - 1 , - 1 , - 1 ) : if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] : return i rightMin = min ( rightMin , arr [ i ] ) return - 1

def findElement ( arr , n ) : leftMax = [ INT_MAX for i in range ( n ) ] rightMin = INT_MAX for i in range ( n - 1 , - 1 , - 1 ) : if ( leftMax [ i ] < arr [ i ] ) : return i rightMin = min ( rightMin , arr [ i ] ) return - 1

def findElement ( arr , n ) : leftMax = [ INT_MIN for i in range ( n ) ] leftMax [ 0 ] = INT_MIN_VALUE for i in range ( 1 , n ) : leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) rightMin = INT_MAX_VALUE for i in range ( n - 1 , - 1 ) : if ( leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] ) : return i rightMin = min ( rightMin , arr [ i ] ) return - 1

43.66
32.58
56.88
42.5
public static int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }

def countarray ( n , k , x ) : dp = list ( ) dp . append ( 0 ) dp . append ( 1 ) i = 2 while i < n : dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) i = i + 1 return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] )

def countarray ( n , k , x ) : dp = [ 0 for i in range ( n ) ] dp [ 1 ] = ( k - 2 ) * dp [ n - 1 ] + ( k - 1 ) * dp [ n - 2 ] return ( x == 1 ? dp [ n - 2 ] : dp [ n - 1 ] )

def countarray ( n , k , x ) : dp = [ 0 for i in range ( 109 ) ] dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n ) : dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] )

43.72
62.7
90.67
85.61
static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }

def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) radSumSq = ( r1 + r2 ) * ( r1 + r2 ) if ( distSq == radSumSq ) : return 1 elif ( distSq > radSumSq ) : return - 1 else : return 0

def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) return distSq

def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) radSumSq = ( r1 + r2 ) * ( r1 + r2 ) if distSq == radSumSq : return 1 else : if ( distSq > radSumSq ) : return - 1 else : return 0

43.76
39.05
72.88
78.78
static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }

def winner ( a , n , k ) : if k >= n - 1 : return n best = 0 times = 0 for i in range ( n ) : if a [ i ] > best : best = a [ i ] if i == True : times = 1 else : times += 1 if times >= k : return best return best

def winner ( a , n , k ) : n = len ( a ) for i in range ( n ) : if ( a [ i ] > best ) : best = a [ i ] times = 1 if ( times >= k ) : return best

def winner ( a , n , k ) : if k >= n - 1 : return n best = 0 times = 0 for i in range ( 0 , n ) : if ( a [ i ] > best ) : best = a [ i ] if ( i == 1 ) times = 1 else : times += 1 if ( times >= k ) : return best

43.82
49.66
100.0
100.0
static float circumferenceparallelogram ( float a , float b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; }

def circumferenceparallelogram ( a , b ) : return ( ( 2 * a ) + ( 2 * b ) )

def circumferenceparallelogram ( a , b ) : return ( a + b )

def circumferenceparallelogram ( a , b ) : return ( ( 2 * a ) + ( 2 * b ) )

43.86
38.08
60.97
49.09
static int LCSubStr ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int [ ] [ ] len = new int [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }

def LCSubStr ( X , Y ) : m = len ( X ) n = len ( Y ) result = 0 len_mat = np . zeros ( ( 2 , n ) ) currRow = 0 for i in range ( m ) : for j in range ( n ) : if ( i == 0 | j == 0 ) : len_mat [ currRow ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 result = max ( result , len_mat [ currRow ] [ j ] ) else : len_mat [ currRow ] [ j ] = 0 currRow = 1 - currRow return result

def LCSubStr ( X , Y ) : m = len ( X ) n = len ( Y ) currRow = 0 for i in range ( m ) : for j in range ( n ) : if ( X [ i ] == Y [ j - 1 ] ) : len [ currRow ] [ j ] = len [ 1 - currRow ] [ ( j - 1 ) ] + 1 else : len [ currRow ] [ j ] = 0 for i in range

def LCSubStr ( X , Y ) : m = X . length n = Y . length result = 0 for i in range ( m ) : for j in range ( n ) : if ( i == 0 || j == 0 ) : len [ currRow ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 result = max ( result , len [ currRow ] [ j ] ) currRow = 1 - currRow return result

43.87
43.51
61.74
49.24
static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }

def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if B [ i ] : if A [ i ] != i + 1 : A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] for i in range ( n ) : if A [ i ] != i + 1 : return False return True

def sortedAfterSwap ( A , B , n ) : t = 0 for i in range ( 0 , n - 1 ) : if ( A [ i ] != i + 1 ) : t = A [ i ] A [ i ] = A [ i + 1 ] return 1

def sortedAfterSwap ( A , B , n ) : t = 0 for i in range ( n ) : if B [ i ] != 0 : if A [ i ] != i + 1 : t = A [ i ] A [ i ] = A [ i + 1 ] A [ i + 1 ] = A [ i + 1 ] A [ i + 1 ] = t return 1

43.92
47.46
51.48
44.03
static boolean findDuplicateparenthesis ( String s ) { Stack < Character > Stack = new Stack < > ( ) ; char [ ] str = s . toCharArray ( ) ; for ( char ch : str ) { if ( ch == ')' ) { char top = Stack . peek ( ) ; Stack . pop ( ) ; int elementsInside = 0 ; while ( top != '(' ) { elementsInside ++ ; top = Stack . peek ( ) ; Stack . pop ( ) ; } if ( elementsInside < 1 ) { return true ; } } else { Stack . push ( ch ) ; } } return false ; }

def findDuplicateparenthesis ( string ) : Stack = [ ] for ch in string : if ch == ')' : top = Stack . pop ( ) elementsInside = 0 while top != '(' : elementsInside += 1 top = Stack . pop ( ) if elementsInside < 1 : return True else : Stack . append ( ch ) return False

def findDuplicateparenthesis ( s ) : Stack = new Stack < Character > ( ) for ch in str : if ( ch == '(' ) : top = Stack . peek ( ) Stack . pop ( ) elementsInside = 0 while top != ')' : elementsInside += 1 top = Stack . peek ( ) Stack . pop ( ) if ( elementsInside < 1 ) : return true else : Stack . append ( ch ) if ( elementsInside < 1 ) : return true

def findDuplicateparenthesis ( s ) : Stack = list ( ) for ch in str : if ch == ')' : top = Stack . peek ( ) Stack . pop ( ) int elementsInside = 0 while ( top != ')' ) : elementsInside ++ top = Stack . peek ( ) Stack . pop ( ) if elementsInside < 1 : return True return False

43.92
56.46
62.67
68.27
static int lis ( int [ ] arr , int n ) { int [ ] mpis = new int [ n ] ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; for ( int k = 0 ; k < mpis . length ; k ++ ) { if ( mpis [ k ] > max ) { max = mpis [ k ] ; } } return max ; }

def lis ( arr , n ) : mpis = [ 0 ] * ( n ) for i in range ( n ) : mpis [ i ] = arr [ i ] for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] return max ( mpis )

def lis ( arr , n ) : mpis = [ INT_MAX for i in range ( n ) ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] ) : mpis [ i ] = arr [ j ] * arr [ i ] else : mpis [ i ] = mpis [ j ] * arr [ i ] for k in range ( 0 , n ) : if ( mpis [ k ] > max ) : max = mpis [ k ] if ( mpis [ k ] > max ) : max = mpis [ k ] if ( mpis [ k ] > max ) : max = mpis [ k ] if ( mpis [ k ] > max ) : max = mpis [ k ] if ( mpis [ k ] > max ) : max = mpis [ k ] return max

def lis ( arr , n ) : mpis = [ INT_MAX for i in range ( n ) ] for i in range ( 1 , n ) : mpis [ i ] = arr [ i ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] return max

43.94
37.97
46.29
37.06
static boolean canFormPalindrome ( String str ) { int count [ ] = new int [ NO_OF_CHARS ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }

def canFormPalindrome ( st ) : count = [ 0 ] * ( NO_OF_CHARS ) for i in range ( 0 , len ( st ) ) : count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 odd = 0 for i in range ( 0 , NO_OF_CHARS ) : if ( count [ i ] & 1 ) : odd = odd + 1 if ( odd > 1 ) : return False return True

def canFormPalindrome ( str ) : count = [ 0 for i in range ( NO_OF_CHARS ) ] for i in range ( NO_OF_CHARS ) : if ( count [ i ] & 1 ) == 1 : odd = 0 for i in range ( NO_OF_CHARS ) : if ( count [ i ] & 1 ) == 1 : odd += 1 if ( odd > 1 ) : return false return true

def canFormPalindrome ( str ) : count = [ 0 for i in range ( NO_OF_CHARS ) ] for i in range ( NO_OF_CHARS ) : count [ ( int ) ( str [ i ] ) ] += 1 odd = 0 for i in range ( NO_OF_CHARS ) : if ( count [ i ] & 1 ) == 1 : odd += ( odd > 1 ) return False return True

44.03
47.26
68.66
53.12
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }

def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : maxSum = 0 arr . sort ( ) i = N - 1 while ( i >= 0 ) : if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i ] maxSum += arr [ i - 1 ] i -= 1 i -= 1 return maxSum

def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : maxSum = 0 for i in range ( N ) : if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i ] i -= 1 if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i ] i -= 1 else : maxSum += arr [ i ] i -= 1 if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i - 1 ] return maxSum

def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : maxSum = 0 for i in range ( N - 1 , - 1 , - 1 ) : if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i ] maxSum += arr [ i - 1 ] -- i return maxSum

44.04
61.26
44.02
51.44
public static void search ( int [ ] arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . println ( "The required element is " + arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else if ( mid % 2 == 1 ) { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }

def search ( arr , low , high ) : if low > high : return None if low == high : return arr [ low ] mid = low + ( high - low ) / 2 if mid % 2 == 0 : if arr [ mid ] == arr [ mid + 1 ] : return search ( arr , mid + 2 , high ) else : return search ( arr , low , mid ) else : if arr [ mid ] == arr [ mid - 1 ] : return search ( arr , mid + 1 , high ) else : return search ( arr , low , mid - 1 )

def search ( arr , low , high ) : if low == high : return if high == 0 : search ( arr , low , high ) return if low == high : print ( arr [ low ] ) return print ( arr [ low ] ) return print ( arr [ low ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) else : search ( arr , low , mid ) if ( mid % 2 == 1 ) : if ( arr [ mid ] == arr [ mid - 1 ] == arr [ mid ] == arr [ mid - 1 ] ) : search ( arr , mid + 1 , high ) return if mid % 2 == 0 ) : print ( arr [ mid ] == arr [ mid - 1 ] ) return print ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid - 1 , mid )

def search ( arr , low , high ) : if low > high : print ( "The required element is " + arr [ low ] ) return if high == low : print ( "The required element is " + arr [ low ] ) return if low == high : print ( "The required element is " + arr [ low ] ) return if high == mid : search ( arr , low , mid ) elif high == mid - 1 : search ( arr , mid + 1 , high ) else : search ( arr , low , mid - 1 )

44.06
42.86
69.76
59.32
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) invcount ++ ; } } } } return invcount ; }

def getInvCount ( arr ) : n = len ( arr ) invcount = 0 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if arr [ i ] > arr [ j ] : for k in range ( j + 1 , n ) : if arr [ j ] > arr [ k ] : invcount += 1 return invcount

def getInvCount ( arr , n ) : invcount = 0 for i in range ( 0 , n - 2 , - 1 ) : if ( arr [ i ] > arr [ j ] ) : invcount += 1 if ( arr [ j ] > arr [ k ] ) : invcount += 1 if ( arr [ i ] > arr [ k ] ) : invcount += 1 if ( arr [ j ] > arr [ k ] ) : invcount += 1 }

def getInvCount ( arr , n ) : invcount = 0 for i in range ( n ) : for j in range ( i + 1 , n - 2 , - 1 ) : if ( arr [ i ] > arr [ j ] ) : for k in range ( j + 1 , n ) : if ( arr [ j ] > arr [ k ] ) : invcount += [ k ] return invcount

44.06
49.12
32.58
27.98
static void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + " " ) ; if ( n >= 1 ) System . out . print ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + " " ) ; a = b ; b = c ; } }

def fib ( n ) : a = 0 b = 1 if ( n >= 0 ) : print ( a , end = '' ) if ( n >= 1 ) : print ( b , end = '' ) for i in range ( 2 , n + 1 ) : c = a + b print ( c , end = '' ) a = b b = c

def fib ( n ) : a = 0 b = 1 c = 0 for i in range ( 2 , n ) : a = b c = a + b if ( n >= 2 ) : print ( a + " " ) if ( n >= 1 ) : print ( b + " " ) if ( n >= 2 ) : print ( c + " " ) ; b = c if ( n >= 1 ) : print ( c + " " ) ; n = 2

def fib ( n ) : a = 0 b = 1 c = a + b for i in range ( 2 , n ) : c = a + b b = c a = b b = c

44.08
34.01
42.94
37.04
public static int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }

def sumofFactors ( n ) : if ( n % 2 != 0 ) : return 0 res = 1 for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : count = 0 curr_sum = 1 curr_term = 1 while ( n % i == 0 ) : count = count + 1 n = n // i if ( i == 2 and count == 1 ) : curr_sum = 0 curr_term = curr_term * i curr_sum = curr_sum + curr_term res = res * curr_sum if ( n >= 2 ) : res = res * ( 1 + n ) return res

def sumofFactors ( n ) : res = 1 for i in range ( 2 , sqrt ( n ) ) : curr_sum = 1 curr_term = 1 n = n / i if ( i == 2 and count == 1 ) : curr_sum = 0 curr_term *= i if ( count == 1 ) : curr_sum = 0 res *= curr_sum if ( n >= 2 ) : res *= ( 1 + n ) return res

def sumofFactors ( n ) : res = 1 for i in range ( 2 , math . sqrt ( n ) ) : count = 0 curr_sum = 1 curr_term = 1 while n % i == 0 : count += 1 n = n / i if i == 2 and count == 1 : curr_sum = 0 curr_term *= i curr_sum += curr_term if n >= 2 : res *= ( 1 + n ) return res

44.18
50.11
66.3
56.53
void printRepeating ( int arr [ ] , int size ) { int i ; System . out . println ( "The repeating elements are : " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + " " ) ; } }

def printRepeating ( arr , size ) : print ( "Therepeatingelementsare" , end = "" ) for i in range ( 0 , size ) : if ( arr [ abs ( arr [ i ] ) ] > 0 ) : arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] else : print ( abs ( arr [ i ] ) , end = "" )

def printRepeating ( arr , size ) : arr . sort ( reverse = True ) i = 0 for i in range ( size ) : if ( arr [ i ] > 0 ) : arr [ i ] = - arr [ Math . abs ( arr [ i ] ) ] else : print ( arr [ i ] , end = "" ) for i in range ( 0 , size ) : if ( arr [ i ] > 0 ) : arr [ i ] = - arr [ i ] if ( arr [ i ] > 0 ) : arr [ i ] = - arr [ abs ( arr [ i ] ) else : print ( i + " " )

def printRepeating ( arr , size ) : arr . sort ( reverse = True ) for i in range ( size ) : if arr [ abs ( arr [ i ] ) ] > 0 : arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] else : print ( abs ( arr [ i ] ) + " " )

44.29
54.67
93.76
78.66
static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }

def minRemove ( arr , n ) : LIS = [ 0 for i in range ( n ) ] len = 0 for i in range ( n ) : LIS [ i ] = 1 for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) len = max ( len , LIS [ i ] ) return ( n - len )

def minRemove ( arr , n ) : LIS = [ 0 for i in range ( n ) ] len = 0 for i in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] ) : LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) return n - len

def minRemove ( arr , n ) : LIS = [ 1 for i in range ( n ) ] len = 0 for i in range ( 1 , n ) : LIS [ i ] = 1 for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) len = max ( len , LIS [ i ] ) return n - len

44.3
36.69
31.6
29.91
static int longLenStrictBitonicSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > inc = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > dcr = new HashMap < Integer , Integer > ( ) ; int len_inc [ ] = new int [ n ] ; int len_dcr [ ] = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ; len_inc [ i ] = len + 1 ; inc . put ( arr [ i ] , len_inc [ i ] ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . containsKey ( arr [ i ] - 1 ) ) len = dcr . get ( arr [ i ] - 1 ) ; len_dcr [ i ] = len + 1 ; dcr . put ( arr [ i ] , len_dcr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }

def longLenStrictBitonicSub ( arr , n ) : inc , dcr = dict ( ) , dict ( ) len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n longLen = 0 for i in range ( n ) : len = 0 if inc . get ( arr [ i ] - 1 ) in inc . values ( ) : len = inc . get ( arr [ i ] - 1 ) inc [ arr [ i ] ] = len_inc [ i ] = len + 1 for i in range ( n - 1 , - 1 , - 1 ) : len = 0 if dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) : len = dcr . get ( arr [ i ] - 1 ) dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 for i in range ( n ) : if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) : longLen = len_inc [ i ] + len_dcr [ i ] - 1 return longLen

def longLenStrictBitonicSub ( arr , n ) : inc = new HashMap < Integer , Integer > ( ) dcr = new HashMap < Integer , Integer > ( ) len_inc = [ 0 for i in range ( n ) ] len_dcr = [ 0 for i in range ( n ) ] for i in range ( n - 1 , - 1 ) : if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] ) len_inc [ i ] = len + 1 longLen = len_inc [ i ] + len_dcr [ i ] - 1 if ( dcr . containsKey ( arr [ i ] - 1 ) : longLen = len_inc [ i ] + len_dcr [ i ] - 1 return longLen

def longLenStrictBitonicSub ( arr , n ) : inc = [ 0 for k in range ( n ) ] dcr = [ 0 for k in range ( n ) ] len_inc = [ 0 for k in range ( n ) ] len_dcr = [ 0 for k in range ( n ) ] longLen = 0 for i in range ( n ) : len = 0 if ( inc . containsKey ( arr [ i ] - 1 ) ) : len = inc [ arr [ i ] - 1 ] len_inc [ i ] = len + 1 inc . put ( arr [ i ] , len_inc [ i ] ) dcr [ i ] = len_dcr [ i ] return longLen

44.34
41.64
89.76
78.39
static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }

def findCountOfSolutions ( n , p ) : ans = 0 for x in range ( 1 , p ) : if ( ( x * x ) % p == 1 ) : last = x + p * ( n / p ) if ( last > n ) : last -= p ans += ( ( last - x ) / p + 1 ) return int ( ans )

def findCountOfSolutions ( n , p ) : ans = 0 for x in range ( 1 , n , p ) : if ( x * x ) % p == 1 : ans += ( x * x ) / p + 1 return ans

def findCountOfSolutions ( n , p ) : ans = 0 for x in range ( p ) : if ( ( x * x ) % p == 1 ) : last = x + p * ( n / p ) if ( last > n ) : last -= p ans += ( ( last - x ) / p + 1 ) return ans

44.35
39.31
54.11
40.1
static void unique ( int mat [ ] [ ] , int n , int m ) { int maximum = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; int b [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) b [ mat [ i ] [ j ] ] ++ ; for ( int i = 1 ; i <= maximum ; i ++ ) if ( b [ i ] == 1 ) System . out . print ( i + " " ) ; flag = 1 ; if ( flag == 0 ) { System . out . println ( "No unique element " + "in the matrix" ) ; } }

def unique ( mat , n , m ) : maximum = 0 flag = 0 for i in range ( 0 , n ) : for j in range ( 0 , m ) : if ( maximum < mat [ i ] [ j ] ) : maximum = mat [ i ] [ j ] uniqueElementDict = [ 0 ] * ( maximum + 1 ) for i in range ( 0 , n ) : for j in range ( 0 , m ) : uniqueElementDict [ mat [ i ] [ j ] ] += 1 for key in range ( maximum + 1 ) : if uniqueElementDict [ key ] == 1 : print ( key , end = "" ) flag = 1 if ( flag == 0 ) : print ( "Nouniqueelementinthematrix" )

def unique ( mat , n , m ) : maximum = 0 for i in range ( n , m ) : if ( maximum < mat [ i ] [ j ] ) : maximum = mat [ i ] [ j ] flag = 1 else : for i in range ( 1 , n , m ) : if ( b [ i ] == 1 ) : print ( i + " " ) flag = 1 if ( flag == 0 ) : print ( "No unique element " + "

def unique ( mat , n , m ) : maximum = 0 flag = 0 for i in range ( n ) : for j in range ( m ) : if maximum < mat [ i ] [ j ] : maximum = mat [ i ] [ j ] if maximum < mat [ i ] [ j ] : maximum = mat [ i ] [ j ] b [ mat [ i ] [ j ] ] += 1 for i in range ( 1 , maximum + 1 ) : if ( b [ i ] == 1 ) : print ( i + " " ) flag = 1 if flag == 0 : print ( "No unique element " + "in the matrix" )

44.35
45.66
53.98
49.0
static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ++ ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }

def checkReverse ( arr , n ) : if ( n == 1 ) : return True i = 1 for i in range ( 1 , n ) : if arr [ i - 1 ] < arr [ i ] : if ( i == n ) : return True j = i while ( arr [ j ] < arr [ j - 1 ] ) : if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : return False j += 1 if ( j == n ) : return True k = j if ( arr [ k ] < arr [ i - 1 ] ) : return False while ( k > 1 and k < n ) : if ( arr [ k ] < arr [ k - 1 ] ) : return False k += 1 return True

def checkReverse ( arr , n ) : if ( n == 1 ) : return true for i in range ( 1 , n ) : if ( arr [ i ] < arr [ i - 1 ] ) : return false else : j = i while ( arr [ j ] < arr [ j - 1 ] ) : if ( arr [ j ] < arr [ j - 2 ] ) : return false else : k = j while ( arr [ k ] < arr [ k -

def checkReverse ( arr , n ) : if n == 1 : return True j = i ++ while arr [ j ] < arr [ j - 1 ] : if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : return false , } j ++ if ( j == n ) : return True k = j if arr [ k ] < arr [ i - 1 ] : return false if k > 1 and k < n : if ( arr [ k ] < arr [ k - 1 ] ) : return false k ++ return True

44.38
52.43
92.05
84.37
public static void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }

def splitArr ( arr , n , k ) : for i in range ( 0 , k ) : x = arr [ 0 ] for j in range ( 0 , n - 1 ) : arr [ j ] = arr [ j + 1 ] arr [ n - 1 ] = x

def splitArr ( arr , n , k ) : arr . sort ( reverse = True ) for i in range ( 0 , n , k ) : x = arr [ 0 ] for j in range ( 0 , n - 1 ) : arr [ j ] = arr [ j + 1 ] if ( j < n - 1 ) : arr [ j ] = arr [ j + 1 ] if ( j < n - 1 ) : arr [ j ] = arr [ j + 1 ] if ( j ) : arr [ n - 1 ] = x return arr [ n - 1 ]

def splitArr ( arr , n , k ) : for i in range ( k ) : x = arr [ 0 ] for j in range ( 0 , n - 1 , - 1 ) : arr [ j ] = arr [ j + 1 ] arr [ n - 1 ] = x

44.4
43.24
59.31
50.13
int fib ( int n ) { if ( lookup [ n ] == NIL ) { if ( n <= 1 ) lookup [ n ] = n ; else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; } return lookup [ n ] ; }

def fib ( n , lookup ) : if n == 0 or n == 1 : lookup [ n ] = n if lookup [ n ] is None : lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) return lookup [ n ]

def fib ( n ) : lookup . sort ( reverse = True ) lookup [ n ] = NIL if ( n <= 1 ) : lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) else : lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) return lookup [ n ]

def fib ( n ) : if lookup [ n ] == NIL : if n <= 1 : lookup [ n ] = n else : lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) return lookup [ n ]

44.42
42.82
69.49
48.87
private static void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }

def printSorted ( arr , start , end ) : if start > end : return printSorted ( arr , start * 2 + 1 , end ) print ( arr [ start ] , end = "" ) printSorted ( arr , start * 2 + 2 , end )

def printSorted ( arr , start , end ) : if ( start > end ) : print ( arr [ start ] , end ) printSorted ( arr , start * 2 + 1 , end ) print ( arr [ start ] , end * 2 + 2 ) printSorted ( arr , start * 2 + 2 , end ) print ( arr [ start ] , end * 2 + 1 ) printSorted ( arr , start * 2 + 2 , end ) print ( arr [ start ] )

def printSorted ( arr , start , end ) : if start > end : return printSorted ( arr , start * 2 + 1 , end ) printSorted ( arr , start * 2 + 1 , end )

44.43
68.2
39.82
52.82
void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ; } }

def sortInWave ( arr , n ) : for i in range ( 0 , n , 2 ) : if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) : arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]

def sortInWave ( arr , n ) : for i in range ( 0 , n ) : if ( arr [ i ] > arr [ i ] ) swap ( arr , i - 1 , i ) if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) swap ( arr , i + 1 , i ) if ( i < n - 2 and arr [ i ] > arr [ i ] ) swap ( arr , i - 1 , i ) if ( i < n - 1 ) : swap ( arr , i , i + 1 ) : if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 )

def sortInWave ( arr , n ) : for i in range ( n ) : if i > 0 and arr [ i - 1 ] > arr [ i ] : swap ( arr , i - 1 , i ) if i < n - 1 and arr [ i ] < arr [ i + 1 ] : swap ( arr , i , i + 1 )

44.44
36.07
79.63
68.42
static int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) { int X [ ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 }; int Y [ ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 }; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }

def findPossibleMoves ( mat , p , q ) : global n , m X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] count = 0 for i in range ( 8 ) : x = p + X [ i ] y = q + Y [ i ] if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) : count += 1 return count

def findPossibleMoves ( mat , p , q ) : X = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 1 } Y = { 1 , 2 , 1 , 2 , 1 , 1 } count = 0 for i in range ( 0 , 8 ) : if ( mat [ x ] [ y ] == 0 ) : count += 1 elif ( mat [ x ] [ y ] == 0 ) : count += 1 return count

def findPossibleMoves ( mat , p , q ) : X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] Y = [ 1 , 2 , 2 , 1 , 1 , 2 , 1 , 2 ] count = 0 for i in range ( 8 ) : x = p + X [ i ] y = q + Y [ i ] if x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 : count ++ return count

44.51
42.23
86.18
86.36
static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }

def countSetBitsRec ( num ) : nibble = 0 if ( 0 == num ) : return num_to_bits [ 0 ] nibble = num & 0xf return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 )

def countSetBitsRec ( num ) : nibble = 0 if ( 0 == num ) : return num_to_bits [ nibble ]

def countSetBitsRec ( num ) : nibble = 0 if 0 == num : return num_to_bits [ 0 ] nibble = num & 0xf return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 )

44.52
39.84
58.89
50.86
static int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um . put ( curr_sum , um . get ( curr_sum ) == null ? 1 : um . get ( curr_sum ) + 1 ) ; } int count = 0 ; for ( Map . Entry < Integer , Integer > itr : um . entrySet ( ) ) { if ( itr . getValue ( ) > 1 ) count += ( ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) / 2 ) ; } if ( um . containsKey ( 0 ) ) count += um . get ( 0 ) ; return count ; }

def countSubarrWithEqualZeroAndOne ( arr , n ) : um = dict ( ) curr_sum = 0 for i in range ( n ) : curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) if um . get ( curr_sum ) : um [ curr_sum ] += 1 else : um [ curr_sum ] = 1 count = 0 for itr in um : if um [ itr ] > 1 : count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) if um . get ( 0 ) : count += um [ 0 ] return int ( count )

def countSubarrWithEqualZeroAndOne ( arr , n ) : um = defaultdict ( int ) for i in range ( n ) : curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] for i in range ( n ) : curr_sum += ( arr [ i ] == 0 ) ? 1 : arr [ i ] um . put ( curr_sum , um [ curr_sum ] + 1 ) count = 0 for itr in um : if ( itr . getValue ( ) > 1 ) : count += um [ itr ] if ( um [ 0 ] > 1 ) : count += ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) return count

def countSubarrWithEqualZeroAndOne ( arr , n ) : um = list ( ) curr_sum = 0 for i in range ( n ) : curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] um [ curr_sum ] = um [ curr_sum ] == null ? 1 : um [ curr_sum ] + 1 count = 0 for entry in um . entrySet ( ) : if ( itr [ 1 ] > 1 ) : count += ( ( itr [ 1 ] * ( itr [ 1 ] - 1 ) ) / 2 ) if um . containsKey ( 0 ) : count += um . get ( 0 ) return count

44.54
53.94
54.22
47.39
static int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }

def minTimeForWritingChars ( N , insrt , remov , cpy ) : if N == 0 : return 0 if N == 1 : return insrt dp = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : if i % 2 == 0 : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + cpy ) else : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) // 2 ] + cpy + remov ) return dp [ N ]

def minTimeForWritingChars ( N , insert , remove , copy ) : if ( N == 1 ) : return insert if ( N == 2 ) : return remove dp [ ] = new int [ N + 1 ] for i in range ( 1 , N ) : dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) else : dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i + 1 ] ) return dp [ i ] if ( i % 2 == 0 ) : dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) return dp [ N ]

def minTimeForWritingChars ( N , insert , remove , copy ) : dp = [ 0 for k in range ( N ) ] for i in range ( 1 , N ) : if ( i % 2 == 0 ) : dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) else : dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) return dp [ N ]

44.6
33.05
70.11
41.38
static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }

def CountPairs ( n ) : k = n imin = 1 ans = 0 while ( imin <= n ) : imax = n / k ans += k * ( imax - imin + 1 ) imin = imax + 1 k = n / imin return ans

def CountPairs ( n ) : k = 1 imin = 1 ans = 0 for imin <= n : ans += k * imin if ( imin <= n ) : ans += k * imax - imin + 1 else : ans += k * imax - imin + 1 return ans

def CountPairs ( n ) : imin = 1 ans = 0 while imin <= n : imax = n // k ans += k * ( imax - imin + 1 ) imin = imax + 1 k = n / imin

44.63
39.39
41.7
38.44
void cocktailSort ( int a [ ] ) { boolean swapped = true ; int start = 0 ; int end = a . length ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i < end - 1 ; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; swapped = false ; end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } start = start + 1 ; } }

def cocktailSort ( a ) : n = len ( a ) swapped = True start = 0 end = n - 1 while ( swapped == True ) : swapped = False for i in range ( start , end ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True if ( swapped == False ) : break swapped = False end = end - 1 for i in range ( end - 1 , start - 1 , - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True start = start + 1

def cocktailSort ( a ) : swapped = true end = a . length for start in range ( start , end ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] = a [ i + 1 ] swapped = true end = end - 1 for i in range ( start , end - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] = a [ i + 1 ] = temp swapped = true if ( swapped == false ) : break swapped = false end = end - 1 while i >= start : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] = a [ i + 1 ] swapped = true end = end - 1 while i >= start : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] = a [ i + 1 ] = temp swapped = true break end = end - 1 break if ( swapped == false ) : break swapped = false start = end - 1 while i >= end : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] = a [

def cocktailSort ( a ) : swapped = True for i in range ( end ) : if ( a [ i ] > a [ i + 1 ] ) : temp = a [ i ] a [ i ] = a [ i + 1 ] a [ i + 1 ] = temp swapped = True except : pass start = start + 1 end = end - 1 for i in range ( start , end - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : temp = a [ i ] a [ i ] = a [ i + 1 ] a [ i + 1 ] = temp swapped = true end = end - 1 for i in range ( start , end - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : temp = a [ i ] a [ i ] = a [ i + 1 ] a [ i + 1 ] = temp swapped = true end = end - 1 for i in range ( start , end - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : temp = a [ i ] a [ i ] = a [ i + 1 ] a [ i + 1 ] = temp swapped

44.65
42.32
44.79
38.96
static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }

def MaximumDecimalValue ( mat , n ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] if ( mat [ 0 ] [ 0 ] == 1 ) : dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , n ) : if ( mat [ 0 ] [ i ] == 1 ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i else : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] for i in range ( 1 , n ) : if ( mat [ i ] [ 0 ] == 1 ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i else : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( mat [ i ] [ j ] == 1 ) : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ n - 1 ] [ n - 1 ]

def MaximumDecimalValue ( mat , n ) : dp = [ INT_MAX for k in range ( n ) ] for k in range ( n ) : if ( mat [ 0 ] [ 0 ] == 1 ) : dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] else : dp [ 0 ] [ i ] = dp [ 0 ] [ i ] [ 0 ] = dp [ 0 ] [ i - 1 ] for i in range ( 1 , n ) : if ( mat [ i ] [ 0 ] == 1 ) : dp [ i ] [ j ] = ( int ) ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ 0 ] [ j ]

def MaximumDecimalValue ( mat , n ) : dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , n ) : if mat [ i ] [ j ] == 1 : dp [ i ] [ j ] = ( int ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i ) ) else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = i - 1 ] [ j ] } for i in range ( 1 , n ) : if mat [ i ] [ j ] == 1 : dp [ i ] [ j ] = ( int ) ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ]

44.67
42.55
48.26
40.81
static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; }

def check ( st ) : n = len ( st ) digitSum = 0 for i in range ( 0 , n ) : digitSum = digitSum + ( int ) ( st [ i ] ) return ( digitSum % 9 == 0 )

def check ( str ) : digitSum = 0 for i in range ( n ) : digitSum += ( str [ i ] - '0' ) return ( digitSum % 9 == 0 )

def check ( str ) : n = str . length digitSum = 0 for i in range ( n ) : digitSum += ( str [ i ] - '0' ) return ( digitSum % 9 == 0 )

44.67
44.01
68.92
42.67
static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }

def lastNon0Digit ( n ) : if ( n < 10 ) : return dig [ n ] if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 else : return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 return 0

def lastNon0Digit ( n ) : dig = lastNon0DigitList ( n ) if ( n % 10 == 0 ) : return dig [ n ] if n % 5 == 0 : return lastNon0Digit ( n / 5 ) * dig [ n % 10 ] else : return lastNon0Digit ( n / 5 ) * dig [ n % 10 ]

def lastNon0Digit ( n ) : if n < 10 : return dig [ n ] if ( ( n / 10 ) % 10 ) % 2 == 0 : return ( 6 , lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 else : return ( 4 , lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10

44.69
46.7
74.04
51.2
static void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }

def insertionSortRecursive ( arr , n ) : if n <= 1 : return insertionSortRecursive ( arr , n - 1 ) last = arr [ n - 1 ] j = n - 2 while ( j >= 0 and arr [ j ] > last ) : arr [ j + 1 ] = arr [ j ] j = j - 1 arr [ j + 1 ] = last

def insertionSortRecursive ( arr , n ) : if ( n <= 0 ) : return arr [ 0 ] = arr [ n - 1 ] j = n - 2 while ( j >= 0 and arr [ j ] > last ) : arr [ j + 1 ] = arr [ j ] j -= 1 last = arr [ n - 1 ] while ( j >= 0 and arr [ j ] > last ) : arr [ j + 1 ] = arr [ j ] j -= 1 if arr [ j ] > last : arr [ j + 1 ] = last j -= 1 arr [ j + 1 ] = last return arr [ n - 1 ]

def insertionSortRecursive ( arr , n ) : if n <= 1 : return arr [ n - 1 ] last = arr [ n - 1 ] j = n - 2 while j >= 0 and arr [ j ] > last : arr [ j + 1 ] = arr [ j ] j -- arr [ j + 1 ] = last arr [ j + 1 ] = last

44.7
41.59
44.36
45.4
static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }

def countRect ( n ) : ans = 0 for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : height = length while ( height * length <= n ) : ans += 1 height += 1 return ans

def countRect ( n ) : ans = 0 for length in range ( 1 , n ) : for height in range ( 1 , n ) : ans += 1 return ans

def countRect ( n ) : ans = 0 for length in range ( 1 , sqrt ( n ) ) : for height in range ( 1 , sqrt ( n ) ) : ans += 1 for length in range ( 1 , n ) : for height in range ( height , n ) : ans += 1 return ans

44.73
35.71
68.3
52.58
static int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }

def maxvolume ( s ) : length = int ( s / 3 ) s -= length breadth = s / 2 height = s - breadth return int ( length * breadth * height )

def maxvolume ( s ) : length = s / 4 breadth = s / 2 height = s - breadth return length

def maxvolume ( s ) : length = s / 3 s -= length breadth = s / 2 height = s - breadth return length * breadth * height

44.76
35.22
57.66
44.88
static int minInsertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }

def minInsertion ( tr1 ) : n = len ( str1 ) res = 0 count = [ 0 for i in range ( 26 ) ] for i in range ( n ) : count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( 26 ) : if ( count [ i ] % 2 == 1 ) : res += 1 if ( res == 0 ) : return 0 else : return res - 1

def minInsertion ( str ) : n = len ( str ) count = [ 0 for i in range ( n ) ] for i in range ( 0 , 26 ) : if ( count [ i ] % 2 == 1 ) : res += 1 return ( res == 0 ) ? 0 : res - 1

def minInsertion ( str ) : res = 0 count = [ 0 for i in range ( n ) ] for i in range ( 26 ) : count [ str [ i ] - 'a' ] += 1 for i in range ( n ) : count [ str [ i ] - 'a' ] += 1 if ( count [ i ] % 2 == 1 ) : res += ( res == 0 ) ? 0 : res - 1 return ( res == 0 ) ? 0 : res - 1

44.82
50.36
60.78
55.57
public static void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

def printSmall ( arr , n , k ) : for i in range ( k , n ) : max_var = arr [ k - 1 ] pos = k - 1 for j in range ( k - 2 , - 1 , - 1 ) : if ( arr [ j ] > max_var ) : max_var = arr [ j ] pos = j if ( max_var > arr [ i ] ) : j = pos while ( j < k - 1 ) : arr [ j ] = arr [ j + 1 ] j += 1 arr [ k - 1 ] = arr [ i ] for i in range ( 0 , k ) : print ( arr [ i ] , end = "" )

def printSmall ( arr , n , k ) : arr . sort ( reverse = True ) max_var = arr [ k - 1 ] pos = k - 1 for j in range ( k - 2 , - 1 , - 1 ) : if ( max_var > arr [ j ] ) : max_var = arr [ j ] pos = j if ( max_var > arr [ i ] ) : arr [ j ] = arr [ i ] j = pos if ( j < k - 1 ) : arr [ k - 1 ] = arr [ j + 1 ] j += 1 arr [ k - 1 ] = arr [ i ] i -= 1 if ( j >= 0 ) : max_var = arr [ j ] if ( max_var > arr [ i ] ) : arr [ j ] = arr [ j + 1 ] j -= 1 if ( max_var > arr [ i ] ) : arr [ j ] = arr [ i ] j += 1 ] k - 1 ] = j break if ( j < k - 1 ] ) : arr [ j ] = arr [ j + 1 ] j += 1 ] i -= 1 else : print ( " " )

def printSmall ( arr , n , k ) : max_var = arr [ k - 1 ] pos = k - 1 for j in range ( k - 2 , - 1 , - 1 ) : if ( arr [ j ] > max_var ) : max_var = arr [ j ] pos = j while ( j < k - 1 ) : arr [ j ] = arr [ j + 1 ] j += 1 arr [ k - 1 ] = arr [ i ]

44.86
65.09
70.36
71.09
static void findCombinations ( String str , int index , String out ) { if ( index == str . length ( ) ) System . out . println ( out ) ; for ( int i = index ; i < str . length ( ) ; i ++ ) findCombinations ( str , i + 1 , out + "(" + str . substring ( index , i + 1 ) + ")" ) ; }

def findCombinations ( string , index , out ) : if index == len ( string ) : print ( out ) for i in range ( index , len ( string ) , 1 ) : findCombinations ( string , i + 1 , out + "(" + string [ index : i + 1 ] + ")" )

def findCombinations ( str , index , out ) : if ( index == 0 ) print ( out ) else print ( out + "(" + str [ index : index + 1 ] + ")" ) for i in range ( index + 1 , len ( str ) ) : findCombinations ( str , i + 1 , out + "(" + str [ index : i + 1 ] + ")" ) print ( out ) return

def findCombinations ( str , index , out ) : if index == str . length ( ) : print ( out ) for i in range ( index , len ( str ) ) : findCombinations ( str , i + 1 , out + "(" + str [ index : i + 1 ] + ")" )

44.91
45.59
77.48
57.51
static int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 }; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }

def remainderWith7 ( num ) : series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] series_index = 0 result = 0 for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : digit = ord ( num [ i ] ) - 48 result += digit * series [ series_index ] series_index = ( series_index + 1 ) % 6 result %= 7 if ( result < 0 ) : result = ( result + 7 ) % 7 return result

def remainderWith7 ( num ) : series = [ 1 , 3 , 2 , - 1 , - 3 , 2 ] series_index = 0 for i in range ( len ( num ) ) : result += digit * series [ series_index ] series_index = ( series_index + 1 ) % 6 result %= 7 return result

def remainderWith7 ( num ) : series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] result = 0 for i in range ( len ( num ) - 1 , - 1 , - 1 ) : digit = num [ i ] - '0' result += digit * series [ series_index ] series_index = ( series_index + 1 ) % 6 result %= 7 if result < 0 : result = ( result + 7 ) % 7 return result

44.93
36.65
65.84
60.2
static int rangeGCD ( int n , int m ) { return ( n == m ) ? n : 1 ; }

def rangeGCD ( n , m ) : return n if ( n == m ) else 1

def rangeGCD ( n , m ) : return n

def rangeGCD ( n , m ) : return ( n == m )

44.95
42.41
58.31
47.81
static int countMinOperations ( int n ) { int result = 0 ; while ( true ) { int zero_count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) break ; else if ( arr [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 1 ) { arr [ j ] -- ; result ++ ; } } } }

def countMinOperations ( target , n ) : result = 0 while ( True ) : zero_count = 0 i = 0 while ( i < n ) : if ( ( target [ i ] & 1 ) > 0 ) : break elif ( target [ i ] == 0 ) : zero_count += 1 i += 1 if ( zero_count == n ) : return result if ( i == n ) : for j in range ( n ) : target [ j ] = target [ j ] // 2 result += 1 for j in range ( i , n ) : if ( target [ j ] & 1 ) : target [ j ] -= 1 result += 1

def countMinOperations ( arr , n ) : result = 0 zero_count = 0 for i in range ( n ) : if ( arr [ i ] % 2 == 1 ) : arr [ i ] -= 1 result += zero_count if ( i == n ) : for j in range ( i , n ) : if ( arr [ j ] % 2 == 1 ) : arr [ j ] -= 1 result += zero_count if ( j == n ) : arr [ j ] = arr [ j ] if ( arr [ j ] == 0 ) : return result

def countMinOperations ( n ) : result = 0 while True : zero_count = 0 for i in range ( n ) : if ( arr [ i ] % 2 == 1 ) : break else : if ( arr [ i ] == 0 ) : zero_count += 1 if ( zero_count == n ) : return result if ( i == n ) : for j in range ( i , n ) : arr [ j ] = arr [ j ] // 2 result += } for j in range ( i , n ) : if ( arr [ j ] % 2 == 1 ) : arr [ j ] -- result +=

45.0
36.24
85.27
87.05
static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; }

def fib ( n ) : if n < 6 : return f [ n ] t = 5 fn = 5 while t < n : fn = round ( fn * PHI ) t += 1 return fn

def fib ( n ) : f = [ 0 for n in range ( 6 ) ] t = 0 fn = 5 while ( t < n ) : fn = ( int ) Math . round ( fn * PHI ) t += 1 return f [ n ]

def fib ( n ) : if n < 6 : return f [ n ] t = 5 fn = 5 while t < n : fn = ( int ) Math . round ( fn * PHI ) t += 1 return fn

45.03
71.03
44.89
38.06
static void findString ( String str , int n , int k ) { if ( k == 0 ) { System . out . println ( str ) ; ; return ; } String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 . charAt ( i ) != 'a' ) { str2 = str2 . substring ( 0 , i ) + 'a' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == 'a' ) { str2 = str2 . substring ( 0 , i ) + 'b' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } System . out . println ( str2 ) ; }

def findString ( str , n , k ) : if ( k == 0 ) : print ( str ) return str2 = str p = 0 for i in range ( 0 , n , 1 ) : if ( str2 [ i ] != 'a' ) : str2 = str2 . replace ( str2 [ i ] , 'a' ) p += 1 if ( p == k ) : break if ( p < k ) : i = n - 1 while ( i >= 0 ) : if ( str [ i ] == 'a' ) : str2 = str2 . replace ( str2 [ i ] , 'b' ) p += 1 if ( p == k ) : break i -= 1 print ( str2 )

def findString ( str , n , k ) : if ( k == 0 ) : print ( str ) ; return str2 = str p = 0 for i in range ( n ) : if ( str2 [ i ] != 'a' ) : str2 = str2 [ 0 : i ] + 'a' + str2 [ i + 1 ] p += 1 if ( p == k ) : break str2 = str2 [ i ] if ( p == k ) : break return str2 = str2 [ i ] if ( p < k ) : : print ( str2 ) return str2 = str [ p : ] for i in range ( n - 1 , - 1 ) : if ( str2 [ i ] != 'b' ) : str2 = str2 [ 0 : i ] + 'b' + str2 [ i + 1 ] p -= 1 if ( p == k ) : break str2 = str2 [ i ] if ( p == k ) : break str2 = str2 [ 0 ] if ( p == k ) : print ( str2 ) return str2

def findString ( str , n , k ) : p = 0 for i in range ( n ) : if ( str2 [ i ] != 'a' ) : str2 = str2 [ 0 : i ] + 'a' + str2 [ i + 1 : i + 1 ] p += if ( p == k ) : break for i in range ( n ) : if ( str2 [ i ] != 'b' ) : str2 = str2 [ 0 : i ] + 'b' + str2 [ i + 1 : i + 1 ] p += if ( p == k ) : break print ( str2 )

45.04
39.81
64.41
39.42
void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( "Repeated Elements are :" ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " " ) ; } } }

def printRepeating ( arr , size ) : print ( "Repeatingelementsare" , end = '' ) for i in range ( 0 , size ) : for j in range ( i + 1 , size ) : if arr [ i ] == arr [ j ] : print ( arr [ i ] , end = '' )

def printRepeating ( arr , size ) : for i in range ( 0 , size ) : for j in range ( i + 1 , size ) : if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] + " " ) if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] + " " ) if ( arr [ i ] == arr [ j ] ) : print ( arr [ j ] ) : pass

def printRepeating ( arr , size ) : for i in range ( size ) : for j in range ( i + 1 , size ) : if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] )

45.08
44.77
53.61
49.79
public static void ReversespiralPrint ( int m , int n , int a [ ] [ ] ) { long b [ ] = new long [ 100 ] ; int i , k = 0 , l = 0 ; int z = 0 ; int size = m * n ; while ( k < m && l < n ) { int val ; for ( i = l ; i < n ; ++ i ) { val = a [ k ] [ i ] ; b [ z ] = val ; ++ z ; } k ++ ; for ( i = k ; i < m ; ++ i ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; ++ z ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { val = a [ m - 1 ] [ i ] ; b [ z ] = val ; ++ z ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { val = a [ i ] [ l ] ; b [ z ] = val ; ++ z ; } l ++ ; } } for ( int x = size - 1 ; x >= 0 ; -- x ) { System . out . print ( b [ x ] + " " ) ; } }

def ReversespiralPrint ( m , n , a ) : b = [ 0 for i in range ( 100 ) ] i , k , l = 0 , 0 , 0 z = 0 size = m * n while ( k < m and l < n ) : val = 0 for i in range ( l , n ) : val = a [ k ] [ i ] b [ z ] = val z += 1 k += 1 for i in range ( k , m ) : val = a [ i ] [ n - 1 ] b [ z ] = val z += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : val = a [ m - 1 ] [ i ] b [ z ] = val z += 1 m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : val = a [ i ] [ l ] b [ z ] = val z += 1 l += 1 for i in range ( size - 1 , - 1 , - 1 ) : print ( b [ i ] , end = "" )

def ReversespiralPrint ( m , n , a ) : b = [ 0 for k in range ( m , n ) ] for l in range ( n ) : val = a [ k ] [ i ] b [ z ] = val ++ z if ( k < m ) : for i in range ( n - 1 , - 1 , - 1 ) : val = a [ i ] [ n - 1 ] b [ z ] = val ++ z if ( l < n ) : val = a [ k ] [ l ] = val if ( k < m ) : for i in range ( m - 1 , - 1 ) : val = a [ i ] [ l ] b [ z ] = val yield return b [ z ]

def ReversespiralPrint ( m , n , a ) : b = [ 0 for k in range ( m , n ) ] l = 0 z = 0 while k < m and l < n : val = a [ k ] [ i ] ; b [ z ] = val ++ z k ++ for i in range ( k , m ) : val = a [ i ] [ n - 1 ] b [ z ] = val ++ z if k < m : for i in range ( n ) : val = a [ i ] [ n - 1 ] b [ z ] = val ++ z if k < m : for i in range ( n ) : val = a [ i ] [ n - 1 ] b [ z ] = val ++ z k -- if k < m : for i in range ( n ) : val = a [ i ] [ n - 1 ] b [ z ] = val ++ z k -- if k < m : for i in range ( n ) : val = a [ i ] [ n - 1 ] b [ z ] = val ++ z k -- if l < n : for i in range ( m - 1 ) : val = a [ i ] [ l ] b [

45.23
41.34
69.87
60.41
static int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n > 2 ) res *= ( 1 + n ) ; return res ; }

def sumofFactors ( n ) : res = 1 for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : curr_sum = 1 curr_term = 1 while n % i == 0 : n = n / i curr_term = curr_term * i curr_sum += curr_term res = res * curr_sum if n > 2 : res = res * ( 1 + n ) return res

def sumofFactors ( n ) : res = 1 for i in range ( 2 , sqrt ( n ) ) : curr_sum = 1 curr_term = 1 n = n / i res *= curr_sum if ( n > 2 ) : res *= ( 1 + n ) return res

def sumofFactors ( n ) : res = 1 for i in range ( 2 , math . sqrt ( n ) ) : curr_sum = 1 curr_term = 1 while n % i == 0 : n = n / i curr_term *= i curr_sum += curr_term res *= curr_sum if n > 2 : res *= ( 1 + n ) return res

45.24
37.67
51.34
44.6
static void printTreeEdges ( int prufer [ ] , int m ) { int vertices = m + 2 ; int vertex_set [ ] = new int [ vertices ] ; for ( int i = 0 ; i < vertices ; i ++ ) vertex_set [ i ] = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ; System . out . print ( "\nThe edge set E(G) is :\n" ) ; int j = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) { vertex_set [ j ] = - 1 ; System . out . print ( "(" + ( j + 1 ) + ", " + prufer [ i ] + ") " ) ; vertex_set [ prufer [ i ] - 1 ] -- ; break ; } } } j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) { System . out . print ( "(" + ( i + 1 ) + ", " ) ; j ++ ; } else if ( vertex_set [ i ] == 0 && j == 1 ) System . out . print ( ( i + 1 ) + ")\n" ) ; } }

def printTreeEdges ( prufer , m ) : vertices = m + 2 vertex_set = [ 0 ] * vertices for i in range ( vertices - 2 ) : vertex_set [ prufer [ i ] - 1 ] += 1 print ( "TheedgesetE(G)is:" ) j = 0 for i in range ( vertices - 2 ) : for j in range ( vertices ) : if ( vertex_set [ j ] == 0 ) : vertex_set [ j ] = - 1 print ( "(" , ( j + 1 ) , "," , prufer [ i ] , ")" , sep = "" , end = "" ) vertex_set [ prufer [ i ] - 1 ] -= 1 break j = 0 for i in range ( vertices ) : if ( vertex_set [ i ] == 0 and j == 0 ) : print ( "(" , ( i + 1 ) , "," , sep = "" , end = "" ) j += 1 elif ( vertex_set [ i ] == 0 and j == 1 ) : print ( ( i + 1 ) , ")" )

def printTreeEdges ( prufer , m ) : vertex_set = [ 0 for i in range ( vertices ) ] for i in range ( vertices - 2 , - 1 , - 1 ) : if ( vertex_set [ i ] == 0 ) : print ( "(" + ( i + 1 ) + ", " ) ; j = 0 for i in range ( 0 , vertices - 2 , - 1 ) : if ( vertex_set [ i ] == 0 and j == 1 ) : print ( "(" + ( j + 1 ) + ")\n" ) ; else : print ( "(" + ( i + 1 ) + ", " ) j += 1 else : print ( "(" + ( i + 1 ) + ", " ) j -= 1 if ( vertex_set [ i ] == 0 ) : print ( "(" + ( i + 1 ) break if ( vertex_set [ i ] == 0 ) : print ( "(" + ( i + 1 ) + ")\n" ) j += 1 else : print ( "(" + ( j + ")\n" )

def printTreeEdges ( prufer , m ) : vertex_set = [ 0 for k in range ( m ) ] for i in range ( m ) : vertex_set [ i ] = 0 for j in range ( 0 , vertices ) : if ( vertex_set [ j ] == 0 ) : vertex_set [ j ] = - 1 print ( "(" + ( j + 1 ) + ", " + prufer [ i ] + ") " ) vertex_set [ prufer [ i ] - 1 ] -= 1 elif ( vertex_set [ i ] == 0 and j == 0 ) : print ( "(" + ( i + 1 ) + ", " ) j += 1 elif ( vertex_set [ i ] == 0 and j == 1 ) : print ( ( i + 1 ) + ")\n" )

45.32
29.76
58.83
37.93
static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " " ) ; else System . out . print ( 0 + " " ) ; } System . out . println ( ) ; } return 0 ; }

def Identity ( size ) : for row in range ( 0 , size ) : for col in range ( 0 , size ) : if ( row == col ) : print ( "1" , end = "" ) else : print ( "0" , end = "" ) print ( )

def identity ( num ) : row , col = 0 , 0 for row in range ( num ) : for col in range ( row , num ) : if ( row == col ) : print ( 1 + " " ) else : print ( 0 + " " ) return 1

def identity ( num ) : row , col = 0 , 0 for row in range ( num ) : for col in range ( num ) : if ( row == col ) : print ( 1 , end = "" ) else : print ( 0 , end = "" ) return 0

45.34
34.72
37.12
36.03
static boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }

def isConvertible ( str1 , str2 , k ) : if ( ( len ( str1 ) + len ( str2 ) ) < k ) : return True commonLength = 0 for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : if ( str1 [ i ] == str2 [ i ] ) : commonLength += 1 else : break if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : return True return False

def isConvertible ( str1 , str2 , k ) : if ( str1 . length ( ) + str2 . length ( ) ) < k : return true ; commonLength = 0 for i in range ( k - str1 . length ( ) - str2 . length ( ) : if ( str1 == str2 ) : commonLength += 1 if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) : return true

def isConvertible ( str1 , str2 , k ) : commonLength = 0 for i in range ( k ) : if ( str1 == str2 ) : commonLength += 1 else : break if ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 : return True return False

45.46
44.27
48.7
55.98
static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) S . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! S . contains ( arr [ i ] - 1 ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }

def findLongestConseqSubseq ( arr , n ) : s = Set ( ) ans = 0 for ele in arr : s . add ( ele ) for i in range ( n ) : if ( arr [ i ] - 1 ) not in s : j = arr [ i ] while ( j in s ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans

def findLongestConseqSubseq ( arr , n ) : S = set ( ) for i in range ( 0 , n ) : if ( S . contains ( arr [ i ] - 1 ) ) : j = arr [ i ] while ( S . contains ( j ) ) : j += 1 if ( ans < j - arr [ i ] ) : ans = j - arr [ i ] else : ans = j - arr [ i ] if ( ans < j

def findLongestConseqSubseq ( arr , n ) : S = list ( ) ans = 0 for i in range ( n ) : S . add ( arr [ i ] ) for i in range ( n ) : if ( not S . contains ( arr [ i ] - 1 ) ) : j = arr [ i ] while ( S . contains ( j ) ) : j += if ( ans < j - arr [ i ] ) : ans = j - arr [ i ] return ans

45.47
34.59
79.24
55.62
public static int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }

def findStep ( n ) : if ( n == 1 or n == 0 ) : return 1 elif ( n == 2 ) : return 2 else : return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 )

def findStep ( n ) : if ( n == 1 ) : return 1 else : return findStep ( n - 1 ) + findStep ( n - 2 )

def findStep ( n ) : if n == 1 or n == 0 : return 1 elif n == 2 : return 2 else : return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 )

45.51
31.4
36.98
24.15
static int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; }

def sumOfLargePrimeFactor ( n ) : prime = [ 0 ] * ( n + 1 ) sum = 0 max = int ( n / 2 ) for p in range ( 2 , max + 1 ) : if prime [ p ] == 0 : for i in range ( p * 2 , n + 1 , p ) : prime [ i ] = p for p in range ( 2 , n + 1 ) : if prime [ p ] : sum += prime [ p ] else : sum += p return sum

def sumOfLargePrimeFactor ( n ) : prime = [ 0 for k in range ( n ) ] for p in range ( 2 , max ) : if ( prime [ p ] == 0 ) : sum += prime [ p ] else : sum += p } for p in range ( 2 , max ) : if ( prime [ p ] != 0 ) : sum += prime [ p ] else : sum += p } return sum

def sumOfLargePrimeFactor ( n ) : prime = [ 0 for p in range ( n ) ] max = n // 2 for p in range ( 2 , max ) : if ( prime [ p ] == 0 ) : for i in range ( p * 2 , n ) : prime [ i ] = p

45.52
41.46
81.32
65.75
static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }

def dealnnoy ( n , m ) : dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] for i in range ( m ) : dp [ 0 ] [ i ] = 1 for i in range ( 1 , m + 1 ) : dp [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] return dp [ m ] [ n ]

def dealnnoy ( n , m ) : dp = [ 1 ] * ( n + 1 ) dp [ 0 ] = [ 1 for i in range ( 1 , m + 1 ) ] for i in range ( 1 , n ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] return dp [ m ] [ n ]

def dealnnoy ( n , m ) : dp = [ 0 for i in range ( m ) ] for i in range ( m + 1 , n + 1 ) : dp [ 0 ] [ i ] = 1 for i in range ( 1 , m ) : dp [ 0 ] [ i ] = 1 for i in range ( 1 , m ) : for j in range ( 1 , n ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] return dp [ m ] [ n ]

45.52
38.83
54.95
46.61
static void luDecomposition ( int [ ] [ ] mat , int n ) { int [ ] [ ] lower = new int [ n ] [ n ] ; int [ ] [ ] upper = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) lower [ i ] [ i ] = 1 ; else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } } System . out . println ( setw ( 2 ) + " Lower Triangular" + setw ( 10 ) + "Upper Triangular" ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [ j ] + "\t" ) ; System . out . print ( "\t" ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [ j ] + "\t" ) ; System . out . print ( "\n" ) ; } }

def luDecomposition ( mat , n ) : lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : for k in range ( i , n ) : sum = 0 for j in range ( i ) : sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) upper [ i ] [ k ] = mat [ i ] [ k ] - sum for k in range ( i , n ) : if ( i == k ) : lower [ i ] [ i ] = 1 else : sum = 0 for j in range ( i ) : sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) print ( "LowerTriangular\t\tUpperTriangular" ) for i in range ( n ) : for j in range ( n ) : print ( lower [ i ] [ j ] , end = "\t" ) print ( "" , end = "\t" ) for j in range ( n ) : print ( upper [ i ] [ j ] , end = "\t" ) print ( "" )

def luDecomposition ( mat , n ) : lower = [ 0 for i in range ( n ) ] upper = [ 0 for i in range ( n ) ] for k in range ( i , n ) : sum = 0 for i in range ( i , n ) : sum += ( lower [ i ] [ j ] * upper [ j ] [ i ] ) upper [ i ] [ i ] = ( mat [ i ] [ i ] - sum ) / upper [ i ] [ i ] if ( k == n ) : lower [ i ] [ i ] = 1 else : lower [ i ] [ i ] = 0 lower [ k ] [ i ] = 1 print ( setw ( 2 ) + lower [ i ] [ j ] + setw ( 10 ) + upper [ i ] [ i ] ) print ( setw ( 4 ) + lower [ k ] [ i ] = ( mat [ i ] [ i ] - sum )

def luDecomposition ( mat , n ) : lower = [ 1 for k in range ( n ) ] upper = [ 1 for k in range ( n ) ] for i in range ( n ) : lower [ i ] [ i ] = 1 for k in range ( i ) : sum = 0 for j in range ( i ) : sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) upper [ i ] [ k ] = mat [ i ] [ k ] - sum ) if ( i == k ) : lower [ i ] [ i ] = 1 else : sum = 0 for k in range ( i , n ) : sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ]

45.53
27.13
100.0
100.0
public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }

def gcd ( a , b ) : if a == 0 : return b return gcd ( b % a , a )

def gcd ( a , b ) : if ( a == 0 ) : return b

def gcd ( a , b ) : if a == 0 : return b return gcd ( b % a , a )

45.54
42.99
45.54
42.99
static int lis ( int arr [ ] , int n ) { max_ref = 1 ; _lis ( arr , n ) ; return max_ref ; }

def lis ( arr ) : global maximum n = len ( arr ) maximum = 1 _lis ( arr , n ) return maximum

def lis ( arr , n ) : max_ref = 1 _lis ( arr , n ) return max_ref

def lis ( arr , n ) : max_ref = 1 _lis ( arr , n ) return max_ref

45.54
42.99
45.54
42.99
static int lis ( int arr [ ] , int n ) { max_ref = 1 ; _lis ( arr , n ) ; return max_ref ; }

def lis ( arr ) : global maximum n = len ( arr ) maximum = 1 _lis ( arr , n ) return maximum

def lis ( arr , n ) : max_ref = 1 _lis ( arr , n ) return max_ref

def lis ( arr , n ) : max_ref = 1 _lis ( arr , n ) return max_ref

45.56
35.33
61.08
34.79
static void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }

def decToBinary ( n ) : binaryNum = [ 0 ] * n i = 0 while ( n > 0 ) : binaryNum [ i ] = n % 2 n = int ( n / 2 ) i += 1 for j in range ( i - 1 , - 1 , - 1 ) : print ( binaryNum [ j ] , end = "" )

def decToBinary ( n ) : binaryNum = [ 0 for i in range ( 32 ) ] for i in range ( 32 ) : binaryNum [ i ] = n % 2 n /= 2 i ++ for j in range ( i - 1 , - 1 , - 1 ) : print ( binaryNum [ j ] ) j = i - 1 if ( j >= 0 ) : print ( binaryNum [ j ] ) j -= 1 else : print ( binaryNum [ j ] )

def decToBinary ( n ) : binaryNum = [ 0 for k in range ( 32 ) ] for i in range ( 32 ) : binaryNum [ i ] = n % 2 n = n // 2 i += 1 for j in range ( i - 1 , - 1 ) : print ( binaryNum [ j ] )

45.59
38.82
70.4
57.65
static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }

def SieveOfEratosthenes ( n , isPrime ) : isPrime [ 0 ] = isPrime [ 1 ] = False for i in range ( 2 , n + 1 ) : isPrime [ i ] = True for p in range ( 2 , n + 1 ) : if ( p * p <= n and isPrime [ p ] == True ) : for i in range ( p * 2 , n + 1 , p ) : isPrime [ i ] = False p += 1

def SieveOfEratosthenes ( n , isPrime ) : isPrime [ 0 ] = isPrime [ 1 ] = false for p in range ( 2 , n ) : if ( isPrime [ p ] == true ) : for i in range ( p * 2 , n ) : isPrime [ i ] = false return

def SieveOfEratosthenes ( n , isPrime ) : isPrime [ 0 ] = isPrime [ 1 ] = False for i in range ( 2 , n ) : isPrime [ i ] = False for p in range ( 2 , p * n ) : if ( isPrime [ p ] == True ) : for i in range ( p * 2 , n ) : isPrime [ i ] = False return isPrime

45.6
45.45
92.44
92.68
static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }

def findSum ( n ) : n -= 1 sum = 0 sum += ( n * ( n + 1 ) ) / 2 sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 return int ( sum )

def findSum ( n ) : sum = 0 sum += ( n * ( n + 1 ) ) * ( 2 * n + 1 ) ) return sum

def findSum ( n ) : n -= 1 sum = 0 sum += ( n * ( n + 1 ) ) / 2 sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 return sum

45.61
35.25
61.6
52.33
static void bubbleSort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; } }

def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : swapped = False for j in range ( 0 , n - i - 1 ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] swapped = True if swapped == False : break

def bubbleSort ( arr , n ) : swapped = false for i in range ( 0 , n - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : swapped = true arr [ i ] = arr [ i + 1 ] j = n - i - 1 if ( arr [ j ] > arr [ j + 1 ] ) : swapped = true break if ( swapped == false ) : break return

def bubbleSort ( arr , n ) : swapped = False for i in range ( n ) : swapped = False for j in range ( n - i - 1 , - 1 , - 1 ) : if ( arr [ j ] > arr [ j + 1 ] ) : temp = arr [ j ] arr [ j ] = arr [ j + 1 ] arr [ j + 1 ] = temp swapped = True break if swapped == false : break

45.62
41.44
50.81
40.7
public static int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum1 += stack1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum2 += stack2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum3 += stack3 [ i ] ; int top1 = 0 , top2 = 0 , top3 = 0 ; int ans = 0 ; while ( true ) { if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ; if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ] ; else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ] ; else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ] ; } }

def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : sum1 , sum2 , sum3 = 0 , 0 , 0 for i in range ( n1 ) : sum1 += stack1 [ i ] for i in range ( n2 ) : sum2 += stack2 [ i ] for i in range ( n3 ) : sum3 += stack3 [ i ] top1 , top2 , top3 = 0 , 0 , 0 ans = 0 while ( 1 ) : if ( top1 == n1 or top2 == n2 or top3 == n3 ) : return 0 if ( sum1 == sum2 and sum2 == sum3 ) : return sum1 if ( sum1 >= sum2 and sum1 >= sum3 ) : sum1 -= stack1 [ top1 ] top1 = top1 + 1 elif ( sum2 >= sum3 and sum2 >= sum3 ) : sum2 -= stack2 [ top2 ] top2 = top2 + 1 elif ( sum3 >= sum2 and sum3 >= sum1 ) : sum3 -= stack3 [ top3 ] top3 = top3 + 1

def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : sum1 = 0 sum2 = 0 sum3 = 0 for i in range ( 0 , n1 , n2 , n3 ) : sum1 += stack1 [ i ] for i in range ( 0 , n1 , n2 , n3 ) : sum2 += stack2 [ i ] for i in range ( 0 , n1 , n2 , n3 ) : sum3 += stack3 [ i ] if ( i == 0 ) : sum1 += stack1 [ i ] if ( sum1 >= sum2 and sum1 >= sum3 ) : sum2 -= stack2 [ top2 ++ ] else : sum3 -= stack3 [ top3 ++ ] if ( sum3 >= sum1 ) : sum3 -= stack3 [ top3 ++ ] return sum1

def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : sum1 = 0 sum2 = 0 sum3 = 0 top1 = 0 top2 = 0 top3 = 0 ans = 0 while True : if ( top1 == n1 or top2 == n2 or top3 == n3 ) : return sum1 if ( sum1 == sum2 and sum2 == sum3 ) : return sum1 if ( sum1 == sum2 and sum2 == sum3 ) : return sum1 if ( sum1 >= sum2 and sum1 >= sum3 ) : sum1 -= stack1 [ top1 ++ ] else : if ( sum2 >= sum3 and sum2 >= sum1 ) : sum2 -= stack2 [ top2 ++ ] else : if ( sum3 >= sum3 and sum3 >= sum1 ) : sum3 -= stack3 [ top3 ++ ] else : ans += stack3 [ top3 ++ ] return ans

45.62
37.14
49.76
41.03
boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { int i = 0 , j = 0 ; Arrays . sort ( set1 ) ; Arrays . sort ( set2 ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }

def areDisjoint ( set1 , set2 , m , n ) : set1 . sort ( ) set2 . sort ( ) i = 0 ; j = 0 while ( i < m and j < n ) : if ( set1 [ i ] < set2 [ j ] ) : i += 1 elif ( set2 [ j ] < set1 [ i ] ) : j += 1 else : return False return True

def aredisjoint ( set1 , set2 ) : i = 0 j = 0 for i in range ( set1 . length ) : if ( set1 [ i ] < set2 [ j ] ) : j += 1 else : if ( set1 [ i ] > set2 [ j ] ) : i += 1 else : return false

def aredisjoint ( set1 , set2 ) : i = 0 j = 0 for k in range ( len ( set1 ) ) : if ( set1 [ i ] < set2 [ j ] ) : i += 1 else : if ( set1 [ i ] > set2 [ j ] ) : j += 1 else : return False return True

45.69
52.28
74.11
57.71
static int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }

def getTotalNumberOfSequences ( m , n ) : T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if i == 0 or j == 0 : T [ i ] [ j ] = 0 elif i < j : T [ i ] [ j ] = 0 elif j == 1 : T [ i ] [ j ] = i else : T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] return T [ m ] [ n ]

def getTotalNumberOfSequences ( m , n ) : T = [ 0 for i in range ( m + 1 , n ) ] for j in range ( n + 1 ) : if ( i == 0 || j == 0 ) : T [ i ] [ j ] = 0 else : T [ i ] [ j ] = i if ( i == 1 ) : T [ i ] [ j ] = T [ i - 1 ] [ j ] = T [ i / 2 ] [ j - 1 ] if ( j == 1 ) : T [ i ] [ j ] = T [ i - 1 ] [ j - 1 ] if ( j == 1 ) : T [ i ] [ j ] = T [ i - 1 ] [ j ] = T [ i - 1 ] [ j ] = T [ i - 1 ] [ j ] = T [ i - 1 ] [ j ] = T [ i - 1 ] [ j - 1 ] [ j - 1 ] return T [ m ] [ n ]

def getTotalNumberOfSequences ( m , n ) : T [ ] [ ] = [ 0 for i in range ( m + 1 , n + 1 ) ] for i in range ( m + 1 , n + 1 ) : for j in range ( n + 1 ) : if ( i == 0 || j == 0 ) : T [ i ] [ j ] = 0 else : if ( i < j ) : T [ i ] [ j ] = 0 else : if ( j == 1 ) : T [ i ] [ j ] = i else : T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] return T [ m ] [ n ]

45.84
63.89
51.21
39.13
static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }

def isPowerOfTwo ( n ) : if ( n == 0 ) : return False while ( n != 1 ) : if ( n % 2 != 0 ) : return False n = n // 2 return True

def isPowerOfTwo ( n ) : if ( n == 0 ) : return false n = n // 2 while n != 1 : if ( n % 2 != 0 ) : return false n = n / 2 while n != 1 : if ( n % 2 != 0 ) : return false n = n / 2 return true

def isPowerOfTwo ( n ) : if n == 0 : return False while n != 1 : if n % 2 != 0 : return False n = n / 2 return True

45.93
49.92
50.81
56.4
static void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; }

def gnomeSort ( arr , n ) : index = 0 while index < n : if index == 0 : index = index + 1 if arr [ index ] >= arr [ index - 1 ] : index = index + 1 else : arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] index = index - 1 return arr

def gnomeSort ( arr , n ) : index = 0 while ( index < n ) : if ( arr [ index ] >= arr [ index - 1 ] ) : index += 1 else : temp = 0 arr [ index ] = arr [ index - 1 ] arr [ index - 1 ] = temp index += 1 if ( arr [ index ] >= arr [ index - 1 ] ) : index -= 1 else : temp = 0 arr [ index ] = arr [ index - 1 ]

def gnomeSort ( arr , n ) : index = 0 while index < n : if ( arr [ index ] >= arr [ index - 1 ] ) : index ++ if ( arr [ index ] >= arr [ index - 1 ] ) : index ++ else : temp = 0 temp = arr [ index ] arr [ index ] = arr [ index - 1 ] arr [ index ] = arr [ index - 1 ] arr [ index - 1 ] = temp index --

45.98
59.09
56.21
72.03
static void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) System . out . print ( "No" ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( "No" ) ; else System . out . print ( "Yes" ) ; }

def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) if ( dis1 != dis2 ) : print ( "No" ) elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : print ( "No" ) else : print ( "Yes" )

def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : dis1 = ( long ) Math . pow ( a1 - a1 , 2 ) + ( long ) Math . pow ( a2 - a2 , 2 ) if ( dis1 != dis2 ) : print ( "No" ) else : if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a

def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) dis2 = ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) if dis1 != dis2 : print ( "No" ) else : if b1 == ( ( a1 + c1 ) / 2.0 ) and b2 == ( ( a2 + c2 ) / 2.0 ) : print ( "No" ) else : if b1 == ( ( a1 + c1 ) / 2.0 ) and b2 == ( ( a2 + c2 ) / 2.0 ) : print ( "Yes" ) else : print ( "No" )

46.0
39.04
64.85
51.28
static boolean isPresent ( String s , String q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; }

def isPresent ( s , q ) : freq = [ 0 ] * MAX_CHAR for i in range ( 0 , len ( s ) ) : freq [ ord ( s [ i ] ) ] += 1 for i in range ( 0 , len ( q ) ) : freq [ ord ( q [ i ] ) ] -= 1 if ( freq [ ord ( q [ i ] ) ] < 0 ) : return False return True

def isPresent ( s , q ) : freq = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( 0 , len ( s ) ) : freq [ s [ i ] ] += 1 if ( freq [ s [ i ] ] < 0 ) : return false return true

def isPresent ( s , q ) : freq = [ MAX_CHAR for i in range ( len ( s ) ) ] for i in range ( len ( q ) ) : freq [ s [ i ] ] += 1 for i in range ( len ( q ) ) : freq [ q [ i ] ] -= 1 if ( freq [ q [ i ] ] < 0 ) : return False return True

46.04
60.36
43.92
56.15
static void generate ( int ones , int zeroes , String str , int len ) { if ( len == str . length ( ) ) { System . out . print ( str + " " ) ; return ; } generate ( ones + 1 , zeroes , str + "1" , len ) ; if ( ones > zeroes ) { generate ( ones , zeroes + 1 , str + "0" , len ) ; } }

def generate ( ones , zeroes , str , len1 ) : if ( len1 == len ( str ) ) : print ( str , end = "" ) return generate ( ones + 1 , zeroes , str + "1" , len1 ) if ( ones > zeroes ) : generate ( ones , zeroes + 1 , str + "0" , len1 )

def generate ( ones , zeroes , str , len ) : if ( len == 0 ) : print ( str ) return generate ( ones , zeroes , str + "1" , len ) if ( ones > zeroes ) : generate ( ones , zeroes , str + "0" , len ) if ( ones > zeroes ) : generate ( ones , zeroes , str + "1" , len ) return generate ( ones , zeroes , str + "0" , len )

def generate ( ones , zeroes , str , len ) : if ones > zeroes : generate ( ones , zeroes , str + "1" , len ) if ones > zeroes : generate ( ones , zeroes + 1 , str + "0" , len )

46.04
42.99
64.47
48.64
static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] < ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }

def getMedian ( ar1 , ar2 , n ) : i = 0 j = 0 m1 = - 1 m2 = - 1 count = 0 while count < n + 1 : count += 1 if i == n : m1 = m2 m2 = ar2 [ 0 ] break elif j == n : m1 = m2 m2 = ar1 [ 0 ] break if ar1 [ i ] < ar2 [ j ] : m1 = m2 m2 = ar1 [ i ] i += 1 else : m1 = m2 m2 = ar2 [ j ] j += 1 return ( m1 + m2 ) / 2

def getMedian ( ar1 , ar2 , n ) : m1 = - 1 m2 = - 1 for count in range ( n ) : if ( ar1 [ 0 ] < ar2 [ 0 ] ) : m1 = m2 m2 = ar1 [ 0 ] i ++ else : m1 = m2 m2 = ar2 [ 0 ] j += 1 if ( ar1 [ i ] < ar2 [ j ] ) : m1 = m2 ; m2 = ar1 [ i ] break if ( ar2 [ j ] < ar1 [ i ] : m1 = m2 ; m2 = ar2 [ j ] break if ( ar1 [ i ] < ar2 [ j ] : m1 = m2 ; m2 = ar1 [ i ] j += 1 else : m1 = m2 m2 = ar2 [ j ] i += 1 else : m1 = m2 m2 = ar1 [ j ] return ( m1 + m2 ) / 2

def getMedian ( ar1 , ar2 , n ) : i = 0 j = 0 m1 = - 1 m2 = - 1 for count in range ( n ) : if ( i == n ) : m1 = m2 , m2 = ar2 [ 0 ] break if ( j == n ) : m1 = m2 , m2 = ar1 [ 0 ] break if ( ar1 [ i ] < ar2 [ j ] ) : m1 = m2 , m2 = ar1 [ i ] i ++ else : m1 = m2 , m2 = ar2 [ j ] j ++ return ( m1 + m2 ) / 2

46.07
45.98
68.99
70.79
static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }

def isPowerOfK ( n , k ) : oneSeen = False while ( n > 0 ) : digit = n % k if ( digit > 1 ) : return False if ( digit == 1 ) : if ( oneSeen ) : return False oneSeen = True n //= k return True

def isPowerOfK ( n , k ) : oneSeen = false n /= k while n > 0 : if ( digit > 1 ) : return false if ( digit == 1 ) : oneSeen = true n /= k return oneSeen

def isPowerOfK ( n , k ) : oneSeen = False while n > 0 : digit = n % k if digit > 1 : return False , if ( digit == 1 ) : if ( oneSeen ) : return False , oneSeen = True n /= k return True

46.09
64.04
56.3
65.55
static int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - 'a' ) || i == ( str . charAt ( i ) - 'A' ) ) { result ++ ; } } return result ; }

def findCount ( str ) : result = 0 for i in range ( len ( str ) ) : if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : result += 1 return result

def findCount ( str ) : result = 0 for i in range ( len ( str ) ) : if ( i == ( str [ i ] - 'a' ) || i == ( str [ i ] - 'A' ) ) : result += 1 elif ( i == ( str [ i ] - 'a' ) ) : result += 1 elif ( i == ( str [ i ] - 'A' ) ) : result += 1 else : return result

def findCount ( str ) : result = 0 for i in range ( len ( str ) ) : if i == ( str [ i ] - 'a' ) or i == ( str [ i ] - 'A' ) : result += 1 return result

46.13
46.73
49.31
35.74
static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " " ) ; }

def findElements ( arr , n ) : first = - sys . maxsize second = - sys . maxsize for i in range ( 0 , n ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] for i in range ( 0 , n ) : if ( arr [ i ] < second ) : print ( arr [ i ] , end = "" )

def findElements ( arr , n ) : first = float ( 'inf' ) second = float ( 'inf' ) for i in range ( 0 , n ) : if ( arr [ i ] < first ) : first = arr [ i ] second = arr [ i ] if ( arr [ i ] < second ) : print ( arr [ i ] + " " ) return for i in range ( 0 , n ) : if ( arr [ i ] < first ) : print ( arr [ i ] > second ) : second = arr [ i ] if ( arr [ i ] < second ) : print ( arr [ i ] + " " ) return if ( arr [ i ] < second ) : print ( arr [ i ] + " " ) return

def findElements ( arr , n ) : first = INT_MIN_VALUE second = INT_MAX for i in range ( n ) : if arr [ i ] > first : second = first first = arr [ i ] elif arr [ i ] > second : second = arr [ i ] if arr [ i ] < second : print ( arr [ i ] + " " )

46.14
36.86
52.67
42.46
static String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; String result = "" ; while ( i >= 0 ) { if ( str . charAt ( i ) == ' ' ) { start = i + 1 ; while ( start != end ) result += str . charAt ( start ++ ) ; result += ' ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str . charAt ( start ++ ) ; return result ; }

def wordReverse ( str ) : i = len ( str ) - 1 start = end = i + 1 result = '' while i >= 0 : if str [ i ] == '' : start = i + 1 while start != end : result += str [ start ] start += 1 result += '' end = i i -= 1 start = 0 while start != end : result += str [ start ] start += 1 return result

def wordReverse ( str ) : i = len ( str ) - 1 start , end = i + 1 , len ( str ) if ( str [ i ] == ' ' ) : start = i - 1 while ( start != end ) : result += str [ start ++ ] result += ' ' end = i i -= 1 if ( str [ i ] == ' ' ) : start = i + 1 while ( start != end ) : result += str [ start ++ ] result +=

def wordReverse ( str ) : i = str . length ( ) - 1 start , end = i + 1 result = "" while i >= 0 : if ( str [ i ] == ' ' ) : start = i + 1 while ( start != end ) : result += str [ start ++ ] result += ' ' end = i i -= 1 start = 0 while ( start != end ) : result += str [ start ++ ] result += ' ' end = i return result

46.16
39.76
32.5
34.77
public static void oddEvenSort ( int arr [ ] , int n ) { boolean isSorted = false ; while ( ! isSorted ) { isSorted = true ; int temp = 0 ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } } return ; }

def oddEvenSort ( arr , n ) : isSorted = 0 while isSorted == 0 : isSorted = 1 temp = 0 for i in range ( 1 , n - 1 , 2 ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 for i in range ( 0 , n - 1 , 2 ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 return

def oddEvenSort ( arr , n ) : isSorted = false for i in range ( 1 , n ) : if ( arr [ i ] > arr [ i + 1 ] ) : temp = arr [ i ] arr [ i ] = arr [ i + 1 ] arr [ i + 1 ] = temp isSorted = false } for i in range ( 1 , n - 2 ) : if ( arr [ i ] > arr [ i + 1 ] ) : temp =

def oddEvenSort ( arr , n ) : isSorted = False while not isSorted : isSorted = True for i in range ( 1 , n - 2 , - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : temp = arr [ i ] arr [ i ] = arr [ i + 1 ] arr [ i + 1 ] = temp isSorted = False

46.18
40.35
48.44
45.52
static boolean checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( "Pair elements are %d and %d\n" , arr [ i ] , val ) ; return true ; } s . add ( arr [ i ] ) ; } return false ; }

def checkPair ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : sum += arr [ i ] if sum % 2 != 0 : return False sum = sum / 2 for i in range ( n ) : val = sum - arr [ i ] if arr [ i ] not in s : s . add ( arr [ i ] ) if val in s : print ( "Pairelementsare" , arr [ i ] , "and" , int ( val ) )

def checkPair ( arr , n ) : sum = 0 for i in range ( n ) : sum += arr [ i ] if ( sum % 2 != 0 ) : return false ; sum = sum / 2 s = new HashSet < Integer > ( ) for i in range ( 0 , n ) : if ( val == arr [ i ] ) : return true else : s . add ( val ) : return true

def checkPair ( arr , n ) : sum = 0 for i in range ( n ) : sum += arr [ i ] for k in range ( n ) : sum += arr [ k ] val = sum - arr [ i ] if ( s . contains ( val ) and val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) : return True s . add ( arr [ i ] ) return False

46.24
42.59
42.71
45.55
static void printSumTricky ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int stripSum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + " " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " " ) ; } System . out . println ( ) ; } }

def printSumTricky ( mat , k ) : global n if k > n : return stripSum = [ [ None ] * n for i in range ( n ) ] for j in range ( n ) : Sum = 0 for i in range ( k ) : Sum += mat [ i ] [ j ] stripSum [ 0 ] [ j ] = Sum for i in range ( 1 , n - k + 1 ) : Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) stripSum [ i ] [ j ] = Sum for i in range ( n - k + 1 ) : Sum = 0 for j in range ( k ) : Sum += stripSum [ i ] [ j ] print ( Sum , end = "" ) for j in range ( 1 , n - k + 1 ) : Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) print ( Sum , end = "" ) print ( )

def printSumTricky ( mat , n , k ) : stripSum = [ 0 for j in range ( n ) ] for i in range ( 0 , n - k + 1 , - 1 ) : sum += mat [ i ] [ j ] stripSum [ i ] [ j ] = sum if ( k > n - k + 1 ) : print ( sum + " " ) for j in range ( 0 , n - k + 1 , - 1 ) : sum += ( stripSum [ i ] [ j ] = sum if ( j < n - k + 1 ) : sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) print ( sum ) stripSum [ i ] [ j ] = sum print ( " " )

def printSumTricky ( mat , k ) : stripSum [ ] = [ 0 for k in range ( n ) ] for j in range ( k ) : sum = 0 for i in range ( 0 , n , k ) : sum += mat [ i ] [ j ] stripSum [ 0 ] [ j ] = sum for i in range ( 1 , n - k + 1 ) : sum += stripSum [ i ] [ j ] for j in range ( 1 , n - k + 1 ) : sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) print ( sum )

46.35
58.17
58.11
56.69
static void pythagoreanTriplets ( int limit ) { int a , b , c = 0 ; int m = 2 ; while ( c < limit ) { for ( int n = 1 ; n < m ; ++ n ) { a = m * m - n * n ; b = 2 * m * n ; c = m * m + n * n ; if ( c > limit ) break ; System . out . println ( a + " " + b + " " + c ) ; } m ++ ; } }

def pythagoreanTriplets ( limits ) : c , m = 0 , 2 while c < limits : for n in range ( 1 , m ) : a = m * m - n * n b = 2 * m * n c = m * m + n * n if c > limits : break print ( a , b , c ) m = m + 1

def pythagoreanTriplets ( limit ) : a = b = c = 0 for n in range ( 1 , limit ) : a = m * m - n * n b = 2 * m * n c = m * m + n * n if ( c > limit ) : break print ( a + " " + b + " " + c ) m += 1 while ( c < limit ) : break print ( a + " " + b + " " )

def pyagoreanTriplets ( limit ) : a = 0 b = 0 c = 0 m = 2 while c < limit : for n in range ( 1 , m ) : a = m * m - n * n b = 2 * m * n c = m * m + n * n if ( c > limit ) : break print ( a + " " + b + " " + c ) m ++

46.37
42.45
77.16
66.95
public static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }

def maxLenSub ( arr , n ) : mls = [ ] max = 0 for i in range ( n ) : mls . append ( 1 ) for i in range ( n ) : for j in range ( i ) : if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : mls [ i ] = mls [ j ] + 1 for i in range ( n ) : if ( max < mls [ i ] ) : max = mls [ i ] return max

def maxLenSub ( arr , n ) : mls = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : if ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 : mls [ i ] = mls [ j ] + 1 return max

def maxLenSub ( arr , n ) : mls = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : mls [ i ] = 1 for i in range ( 1 , n ) : for j in range ( i , n ) : if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : mls [ i ] = mls [ j ] + 1 for i in range ( 0 , n ) : if ( max < mls [ i ] ) : max = mls [ i ] return max

46.48
37.68
58.87
56.8
static int countUnique ( int mat [ ] [ ] , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }

def countUnique ( mat , n , m ) : rowsum = [ 0 ] * n colsum = [ 0 ] * m for i in range ( n ) : for j in range ( m ) : if ( mat [ i ] [ j ] != 0 ) : rowsum [ i ] += 1 colsum [ j ] += 1 uniquecount = 0 for i in range ( n ) : for j in range ( m ) : if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : uniquecount += 1 return uniquecount

def countUnique ( mat , n , m ) : rowsum = [ 0 for i in range ( n , m ) ] colsum = [ 0 for i in range ( n , m ) ] for j in range ( 0 , n , m ) : if ( mat [ i ] [ j ] != 0 ) : rowsum [ i ] += 1 colsum [ j ] += 1 return uniquecount

def countUnique ( mat , n , m ) : rowsum = [ 0 for k in range ( n ) ] colsum = [ 0 for k in range ( n ) ] for i in range ( n ) : if ( mat [ i ] [ j ] != 0 ) : rowsum [ i ] += 1 colsum [ j ] += 1 uniquecount = 0 for i in range ( 0 , n ) : for j in range ( m ) : if ( mat [ i ] [ j ] != 0 ) : rowsum [ i ] += 1 colsum [ j ] += 1 uniquecount = 0 for i in range ( 0 , n ) : for j in range ( m ) : if ( mat [ i ] [ j ] != 0 ) : rowsum [ i ] += 1 colsum [ j ] += 1 return uniquecount

46.62
36.08
45.75
49.49
public static void psuedoBinary ( int n ) { while ( n != 0 ) { int temp = n , m = 0 , p = 1 ; while ( temp != 0 ) { int rem = temp % 10 ; temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } System . out . print ( m + " " ) ; n = n - m ; } System . out . println ( " " ) ; }

def psuedoBinary ( n ) : while ( n > 0 ) : temp = n m = 0 p = 1 while ( temp ) : rem = temp % 10 temp = int ( temp / 10 ) if ( rem != 0 ) : m += p p *= 10 print ( m , end = "" ) n = n - m

def psuedoBinary ( n ) : n = n % 10 p = 1 while ( n != 0 ) : temp = n // 10 m = 0 p = 1 n = n - m if ( temp != 0 ) : m += p elif ( temp != 0 ) : m += p else : p *= 10 print ( m + " " ) n = n - m

def psuedoBinary ( n ) : n = n != 0 m = 0 p = 1 while n != 0 : temp = n , m = 0 , p = 1 while temp != 0 : rem = temp % 10 m += p p *= 10 temp = temp / 10 if rem != 0 : m += p p *= 10 print ( m + " " ) n = n - m

46.66
37.86
27.52
30.13
static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; } } for ( i = 0 ; i < n ; i ++ ) { if ( P [ 0 ] [ i ] == true ) C [ i ] = 0 ; else { C [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ] ; } } } return C [ n - 1 ] ; }

def minPalPartion ( str1 ) : n = len ( str1 ) C = [ 0 ] * ( n + 1 ) P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n ) : P [ i ] [ i ] = True for L in range ( 2 , n + 1 ) : for i in range ( n - L + 1 ) : j = i + L - 1 if ( L == 2 ) : P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) else : P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) for i in range ( n ) : if ( P [ 0 ] [ i ] == True ) : C [ i ] = 0 else : C [ i ] = sys . maxsize for j in range ( i ) : if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) : C [ i ] = 1 + C [ j ] return C [ n - 1 ]

def minPalPartion ( str ) : n = len ( str ) P = [ True for i in range ( n ) ] for j in range ( n - 2 , - 1 , - 1 ) : if ( str [ i ] == str [ j ] ) : P [ i ] [ j ] = ( str [ i ] == str [ j - 1 ] ) : P [ i ] [ j ] = ( P [ i ] [ j ] == true ) : C [ i ] = 1 + C [ j ] if ( L == 2 ) : P [ i ] [ j ] = True else : C [ i ] = float ( 'inf' ) for j in range ( 0 , n - 1 , - 1 ) : if ( P [ j + 1 ] [ i ] == true ) : C [ i ] = 1 + C [ j ] return C [ n - 1 ]

def minPalPartion ( str ) : C = [ 0 for i in range ( n ) ] P = [ True for i in range ( n ) ] for L in range ( 2 , L + 1 , - 1 ) : for i in range ( n ) : j = i + L - 1 if L == 2 : P [ i ] [ j ] = ( str [ i ] == str [ j ] ) else : P [ i ] [ j ] = ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] return C [ n - 1 ]

46.69
60.0
59.0
46.58
void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( "Repeated elements are : " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }

def printRepeating ( arr , size ) : count = [ 0 ] * size print ( "Repeatingelementsare" , end = "" ) for i in range ( 0 , size ) : if ( count [ arr [ i ] ] == 1 ) : print ( arr [ i ] , end = "" ) else : count [ arr [ i ] ] = count [ arr [ i ] ] + 1

def printRepeating ( arr , size ) : count = [ 0 for i in range ( size ) ] for i in range ( 0 , size ) : if ( count [ arr [ i ] ] == 1 ) : print ( arr [ i ] , end = "" ) count [ arr [ i ] ] = 1 print ( arr [ i ] , end = "" ) for i in range ( size ) : if ( count [ arr [ i ] ] == 1 ) : print ( arr [ i ] , end = "" ) : count [ arr [ i ] ] += 1 else : count [ arr [ i ] ] = 1 print ( arr [ i ] , end = "" )

def printRepeating ( arr , size ) : count = [ 0 for i in range ( size ) ] for i in range ( size ) : if ( count [ arr [ i ] ] == 1 ) : print ( arr [ i ] + " " ) else : count [ arr [ i ] ] += 1

46.71
33.33
70.27
71.83
static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }

def getParity ( n ) : parity = 0 while n : parity = ~ parity n = n & ( n - 1 ) return parity

def getParity ( n ) : parity = false n &= ( n - 1 ) parity = ! parity parity = parity return parity

def getParity ( n ) : parity = False while n != 0 : parity = not parity n = n & ( n - 1 ) return parity

46.9
37.39
49.75
44.07
static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( "Angle cannot" + " be formed" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }

def arcLength ( diameter , angle ) : if angle >= 360 : print ( "Anglecannotbeformed" ) return 0 else : arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) return arc

def arcLength ( diameter , angle ) : pi = 22.0 / 7.0 arc = 0 for angle in range ( 0 , 360 ) : arc += ( pi * diameter ) * ( angle / 360.0 ) return arc

def arcLength ( diameter , angle ) : pi = 22.0 / 7.0 arc = ( pi * diameter ) * ( angle / 360.0 ) return arc

46.94
40.63
69.83
72.82
static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }

def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count

def nextPowerOf2 ( n ) : count = 0 while ( n != 0 ) : n >>= 1 count += 1 return 1 << count

def nextPowerOf2 ( n ) : count = 0 if n > 0 and ( n & ( n - 1 ) ) == 0 : return n while n != 0 : n >>= 1 count += 1 return 1 << count

46.94
40.63
69.83
72.82
static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }

def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count

def nextPowerOf2 ( n ) : count = 0 while ( n != 0 ) : n >>= 1 count += 1 return 1 << count

def nextPowerOf2 ( n ) : count = 0 if n > 0 and ( n & ( n - 1 ) ) == 0 : return n while n != 0 : n >>= 1 count += 1 return 1 << count

46.99
51.41
80.43
77.32
static void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + "\t" ) ; else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + "\t" ) ; } System . out . println ( ) ; } }

def printSpiral ( n ) : for i in range ( 0 , n ) : for j in range ( 0 , n ) : x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) if ( i <= j ) : print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = "\t" ) else : print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = "\t" ) print ( )

def printSpiral ( n ) : for i in range ( n ) : for j in range ( i + 1 , n ) : if ( i <= j ) : print ( ( n - 2 * x ) * ( n - 2 * x ) + ( i - x ) , ( j - x ) + "\t" ) else : print ( ( n - 2 * x - 2 ) * ( n - 2 * x ) + ( i - x ) , ( j - x ) ) if ( j <= n ) : print ( n - 2 * x ) * ( n - 2 * x ) + ( j - x ) + "\t" ) else : print ( ( n - 2 * x ) * ( n - 2 * x ) + ( i - x ) + ( j - x ) System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x ) + ( i - x ) + ( j - x ) + "\t" )

def printSpiral ( n ) : for i in range ( n ) : for j in range ( n ) : x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) if i <= j : print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + "\t" ) else : print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) )

47.04
30.55
79.53
51.09
static void printNos ( int n ) { if ( n > 0 ) { printNos ( n - 1 ) ; System . out . print ( n + " " ) ; } return ; }

def printNos ( n ) : if n > 0 : printNos ( n - 1 ) print ( n , end = '' )

def printNos ( n ) : printNos ( n - 1 ) printNos ( n ) return ; } printNos ( n )

def printNos ( n ) : if n > 0 : printNos ( n - 1 ) print ( n )

47.05
51.05
55.11
45.6
public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( "Pattern found at index " + i ) ; } }

def search ( pat , txt ) : M = len ( pat ) N = len ( txt ) for i in range ( N - M + 1 ) : j = 0 while ( j < M ) : if ( txt [ i + j ] != pat [ j ] ) : break j += 1 if ( j == M ) : print ( "Patternfoundatindex" , i )

def search ( txt , pat ) : M = len ( pat ) for i in range ( N - M ) : for j in range ( 0 , M ) : if ( txt [ i + j ] != pat [ j ] ) : break if ( j == M ) : print ( "Pattern found at index " + i ) return if ( j == M ) : print ( "Pattern found at index " + i ) return if ( j == M ) : print ( "

def search ( txt , pat ) : M = pat . length N = txt . length for i in range ( N - M ) : for j in range ( 0 , M , - 1 ) : if ( txt [ i + j ] != pat [ j ] ) : break if ( j == M ) : print ( "Pattern found at index " + i )

47.07
52.76
75.72
72.32
static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }

def minimizeWithKSwaps ( arr , n , k ) : for i in range ( n - 1 ) : pos = i for j in range ( i + 1 , n ) : if ( j - i > k ) : break if ( arr [ j ] < arr [ pos ] ) : pos = j for j in range ( pos , i , - 1 ) : arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] k -= pos - i

def minimizeWithKSwaps ( arr , n , k ) : for i in range ( 0 , n ) : for j in range ( i + 1 , n , k ) : if ( arr [ j ] < arr [ pos ] ) : pos = j if ( j - i > k ) : break if ( arr [ j ] < arr [ pos ] ) : break if ( arr [ j ] > arr [ j - 1 ] ) : arr [ j ] = arr [ j - 1 ] = temp k -= pos - i break if ( arr [ j ] < arr [ pos ] ) : break if ( j - i > k ) : break temp = arr [ j ] arr [ j ] = arr [ j - 1 ] arr [ j ] = temp k -= pos - i

def minimizeWithKSwaps ( arr , n , k ) : for i in range ( n ) : pos = i for j in range ( i + 1 , n ) : if ( j - i > k ) : break if ( arr [ j ] < arr [ pos ] ) : pos = j if j > i : temp = arr [ j ] arr [ j ] = arr [ j - 1 ] arr [ j - 1 ] = temp k -= pos - i

47.14
43.07
51.52
40.8
static int longLenSub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }

def longLenSub ( arr , n ) : um = defaultdict ( lambda : 0 ) longLen = 0 for i in range ( n ) : len1 = 0 if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : len1 = um [ arr [ i ] - 1 ] if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : len1 = um [ arr [ i ] + 1 ] um [ arr [ i ] ] = len1 + 1 if longLen < um [ arr [ i ] ] : longLen = um [ arr [ i ] ] return longLen

def longLenSub ( arr , n ) : um = new HashMap < Integer , Integer > ( ) for i in range ( n ) : if ( um . containsKey ( arr [ i ] - 1 ) and len < um . get ( arr [ i ] - 1 ) ) : len = um [ arr [ i ] - 1 ] if ( longLen < um . get ( arr [ i ] ) ) : longLen = um . get ( arr [ i ] ) : longLen = um [ i ] if ( longLen < um [ arr [ i ] + 1 ] ) : longLen = um . get ( arr [ i ] ) : longLen = um [ arr [ i ] + 1 ] if ( longLen < um . get ( arr [ i ] ) : longLen = um [ arr [ i ] return longLen

def longLenSub ( arr , n ) : um = new HashMap ( ) for i in range ( n ) : len = 0 if ( um . containsKey ( arr [ i ] - 1 ) and len < um [ i ] - 1 ) : len = um [ arr [ i ] - 1 ] if ( um . containsKey ( arr [ i ] + 1 ) and len < um [ i ] + 1 ) : len = um [ arr [ i ] + 1 ] um . put ( arr [ i ] , len + 1 ) if ( longLen < um . get ( arr [ i ] ) ) : longLen = um . get ( arr [ i ] ) return longLen

47.24
44.91
100.0
100.0
static int intersection ( int n ) { return n * ( n - 1 ) ; }

def intersection ( n ) : return n * ( n - 1 )

def intersection ( n ) : return n

def intersection ( n ) : return n * ( n - 1 )

47.24
55.83
81.56
62.76
static void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }

def solve ( i , par , a , n , k , current_ans ) : if ( par > k ) : return 0 global ans if ( par == k and i == n - 1 ) : ans = min ( ans , current_ans ) return 0 for j in range ( i + 1 , n ) : solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) )

def solve ( i , par , a , n , k , ans ) : if ( par == k ) : ans = min ( ans , current_ans ) return for j in range ( i + 1 , n ) : solve ( j , par , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ans = min ( ans , current_ans ) return if ( a [ j ] > a [ i + 1 ] - a [ i + 1 ] ) : ans = min ( ans , current_ans ) return for j in range ( i + 1 , n ) : solve ( j , par , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) )

def solve ( i , par , a , n , k , current_ans ) : if par == k and i == n - 1 : ans = min ( ans , current_ans ) return for j in range ( i + 1 , n ) : solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) )

47.24
44.91
100.0
100.0
static int fun ( int n ) { return n & ( n - 1 ) ; }

def fun ( n ) : return n & ( n - 1 )

def fun ( n ) : return n

def fun ( n ) : return n & ( n - 1 )

47.26
41.52
60.08
48.15
static void CountTriangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } System . out . print ( "No of possible solutions: " + count ) ; }

def CountTriangles ( A ) : n = len ( A ) A . sort ( ) count = 0 for i in range ( n - 1 , 0 , - 1 ) : l = 0 r = i - 1 while ( l < r ) : if ( A [ l ] + A [ r ] > A [ i ] ) : count += r - l r -= 1 else : l += 1 print ( "Noofpossiblesolutions:" , count )

def CountTriangles ( A ) : n = len ( A ) for i in range ( n ) : if ( A [ i ] > A [ n - 1 ] ) : count += l - r elif ( A [ i ] > A [ n - 1 ] ) : count += r - l else : r -= 1 } count = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( A [ i ] > A [ n -

def CountTriangles ( A ) : count = 0 for i in range ( n ) : l = 0 r = i - 1 while l < r : if ( A [ l ] + A [ r ] > A [ i ] ) : count += r - l r -- else : l += 1 print ( "No of possible solutions: " + count )

47.34
42.88
47.79
42.58
static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( "Maximum Number of Guests = " + max_guests + " at time " + time ) ; }

def findMaxGuests ( arrl , exit , n ) : arrl . sort ( ) exit . sort ( ) guests_in = 1 max_guests = 1 time = arrl [ 0 ] i = 1 j = 0 while ( i < n and j < n ) : if ( arrl [ i ] <= exit [ j ] ) : guests_in = guests_in + 1 if ( guests_in > max_guests ) : max_guests = guests_in time = arrl [ i ] i = i + 1 else : guests_in = guests_in - 1 j = j + 1 print ( "MaximumNumberofGuests=" , max_guests , "attime" , time )

def findMaxGuests ( arrl , exit , n ) : arrl . sort ( ) exit . sort ( ) max_guests = 1 time = arrl [ 0 ] for i in range ( n ) : if ( arrl [ i ] <= exit [ j ] ) : max_guests = guests_in if ( guests_in > max_guests ) : max_guests = guests_in time = arrl [ i ] elif ( guest

def findMaxGuests ( arrl , exit , n ) : guests_in = 1 max_guests = 1 time = arrl [ 0 ] i = 1 while i < n and j < n : if ( arrl [ i ] <= exit [ j ] ) : guests_in ++ if ( guests_in > max_guests ) : max_guests = guests_in time = arrl [ i ] i += 1 else : guests_in -- j = n while i < n and j < n : if ( arrl [ i ] <= exit [ j ] ) : guests_in ++ if ( guests_in > max_guests ) : max_guests = guests_in time = arrl [ i ] i += 1 else : j += 1 print ( "Maximum Number of Guests = " + max_guests + " at time " + time )

47.35
44.9
50.01
48.36
static long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; }

def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) return math . floor ( x ) + 1

def findDigits ( n ) : if ( n == 0 ) : return 0 if ( n <= 1 ) : return 1 x = ( n * M_E ) + ( n * M_PI * n ) / 2.0 ) return ( long ) x + 1

def findDigits ( n ) : if n < 0 : return 0 if n <= 1 : return 1 x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) return ( long ) floor ( x ) + 1

47.44
38.21
68.9
53.52
static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] , j = 0 ; Arrays . fill ( allocation , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } System . out . print ( "\nProcess No.\tProcess Size\tBlock no.\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) { System . out . print ( allocation [ i ] + 1 ) ; } else { System . out . print ( "Not Allocated" ) ; } System . out . println ( "" ) ; } }

def NextFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n j = 0 for i in range ( n ) : while j < m : if blockSize [ j ] >= processSize [ i ] : allocation [ i ] = j blockSize [ j ] -= processSize [ i ] break j = ( j + 1 ) % m print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )

def NextFit ( blockSize , m , processSize , n ) : allocation = [ - 1 for i in range ( n ) ] for j in range ( 0 , m ) : if ( blockSize [ j ] >= processSize [ i ] ) : allocation [ i ] = j break if ( allocation [ i ] != - 1 ) : print ( allocation [ i ] + 1 ) else : print ( "Allocated" ) ; } System . out . print ( "" ) ; for i in range

def NextFit ( blockSize , m , processSize , n ) : allocation = [ - 1 for k in range ( n ) ] for i in range ( n ) : if ( blockSize [ j ] >= processSize [ i ] ) : allocation [ i ] = j blockSize [ j ] -= processSize [ i ] break j = ( j + 1 ) % m print ( i + 1 + "\t" + processSize [ i ] + "\t\t" ) if ( allocation [ i ] != - 1 ) : print ( allocation [ i ] + 1 ) else : print ( "Not Allocated" )

47.49
38.95
20.1
27.36
public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int divisors [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; }

def findMaxGCD ( arr , n ) : high = 0 i = 0 while i < n : high = max ( high , arr [ i ] ) i = i + 1 divisors = [ 0 ] * ( high + 1 ) i = 0 while i < n : j = 1 while j <= math . sqrt ( arr [ i ] ) : if ( arr [ i ] % j == 0 ) : divisors [ j ] = divisors [ j ] + 1 if ( j != arr [ i ] / j ) : divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] + 1 j = j + 1 i = i + 1 i = high while i >= 1 : if ( divisors [ i ] > 1 ) : return i i = i - 1 return 1

def findMaxGCD ( arr , n ) : high = 0 for i in range ( n ) : high = max ( high , arr [ i ] ) for i in range ( n ) : if ( arr [ i ] % j == 0 ) : divisors [ j ] = 1 if ( j != arr [ i ] / j ) : divisors [ j ] += 1 if ( j != arr [ i ] / j ) : divisors [ arr [ i ] = j if ( j != arr [ i ] / j ) : divisors [ arr [ i ] / j ] > 1 ) : return i

def findMaxGCD ( arr , n ) : high = 0 for i in range ( n ) : for j in range ( 1 , n ) : if ( arr [ i ] % j == 0 ) : divisors [ j ] += 1 if ( j != arr [ i ] / j ) : divisors [ arr [ i ] / j ] += 1 return i

47.52
37.92
51.16
42.81
public static int sum ( int a [ ] , int n ) { Map < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt . containsKey ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 ) ; if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) ; if ( cnt . containsKey ( a [ i ] ) ) { cnt . put ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) ; } else { cnt . put ( a [ i ] , 1 ) ; } } return ans ; }

def sum ( a , n ) : cnt = dict ( ) ans = 0 pre_sum = 0 for i in range ( n ) : ans += ( i * a [ i ] ) - pre_sum pre_sum += a [ i ] if ( a [ i ] - 1 ) in cnt : ans -= cnt [ a [ i ] - 1 ] if ( a [ i ] + 1 ) in cnt : ans += cnt [ a [ i ] + 1 ] if a [ i ] not in cnt : cnt [ a [ i ] ] = 0 cnt [ a [ i ] ] += 1 return ans

def sum ( a , n ) : cnt = Counter ( ) for i in range ( n ) : ans += ( i * a [ i ] ) - pre_sum pre_sum += a [ i ] if ( cnt . containsKey ( a [ i ] ) ) : ans -= cnt . get ( a [ i ] ) if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) if ( cnt .

def sum ( a , n ) : cnt = [ 0 for i in range ( n ) ] pre_sum = 0 for i in range ( n ) : ans += ( i * a [ i ] ) - pre_sum pre_sum += a [ i ] if cnt . containsKey ( a [ i ] - 1 ) : ans -= cnt . get ( a [ i ] - 1 ) if cnt . containsKey ( a [ i ] + 1 ) : ans += cnt . get ( a [ i ] + 1 ) if cnt . containsKey ( a [ i ] ) : cnt . put ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) else : cnt . put ( a [ i ] , 1 ) return ans

47.53
56.45
48.96
69.69
static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }

def swap ( xp , yp ) : xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]

def swap ( xp , yp ) : xp . sort ( reverse = True ) yp . sort ( reverse = True ) xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ]

def swap ( xp , yp ) : xp = xp [ 0 ] ^ yp [ 0 ] yp = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]

47.55
38.23
59.85
51.62
static int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }

def countNonDecreasing ( n ) : dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] for i in range ( 10 ) : dp [ i ] [ 1 ] = 1 for digit in range ( 10 ) : for len in range ( 2 , n + 1 ) : for x in range ( digit + 1 ) : dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] count = 0 for i in range ( 10 ) : count += dp [ i ] [ n ] return count

def countNonDecreasing ( n ) : dp = [ 0 for i in range ( 10 , n + 1 ) ] dp [ 0 ] [ n ] = 1 for digit in range ( 0 , 9 , n ) : dp [ digit ] [ len ] = dp [ digit ] [ len - 1 ] for x in range ( 0 , digit + 1 , n ) : if ( x <= digit ) : dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] if ( x <= digit ) : dp [ digit ] [ len ] += dp [ digit ] [ len - 1 ] return count

def countNonDecreasing ( n ) : dp = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : dp [ i ] [ 1 ] = 1 for digit in range ( 0 , 9 , n ) : for len in range ( 2 , n ) : for x in range ( 2 , len ) : dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] return count

47.55
39.43
58.27
44.58
public static int findNth ( int n ) { int count = 0 ; for ( int curr = 1 ; ; curr ++ ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }

def findNth ( n ) : count = 0 for curr in itertools . count ( ) : sum = 0 x = curr while ( x ) : sum = sum + x % 10 x = x // 10 if ( sum == 10 ) : count = count + 1 if ( count == n ) : return curr return - 1

def findNth ( n ) : count = 0 for curr in range ( 1 , n ) : sum = 0 for x in range ( curr , 100 ) : sum = sum + x % 10 if ( sum == 10 ) : count ++ return curr

def findNth ( n ) : count = 0 for curr in range ( 1 , n ) : sum = 0 for x in range ( 1 , n ) : sum = sum + x % 10 if ( sum == 10 ) : count ++ if ( count == n ) : return curr

47.58
35.23
78.38
60.36
static int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }

def possibleStrings ( n , r , b , g ) : fact = [ 0 for i in range ( n + 1 ) ] fact [ 0 ] = 1 for i in range ( 1 , n + 1 , 1 ) : fact [ i ] = fact [ i - 1 ] * i left = n - ( r + g + b ) sum = 0 for i in range ( 0 , left + 1 , 1 ) : for j in range ( 0 , left - i + 1 , 1 ) : k = left - ( i + j ) sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) return sum

def possibleStrings ( n , r , b , g ) : fact = [ 1 for i in range ( n ) ] for i in range ( 1 , n + 1 ) : fact [ i ] = fact [ i - 1 ] * i + 1 if ( i <= left ) : for j in range ( left - i , j + 1 ) : sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] ) return sum

def possibleStrings ( n , r , b , g ) : fact = [ 1 for i in range ( n ) ] for i in range ( 1 , n + 1 ) : fact [ i ] = fact [ i - 1 ] * i left = n - ( r + g + b ) sum = 0 for i in range ( 0 , left ) : for j in range ( i + 1 , left - i ) : k = left - ( i + j ) sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) return sum

47.64
50.22
66.2
49.56
static void printSquares ( int n ) { int square = 0 , prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; System . out . print ( square + " " ) ; prev_x = x ; } }

def printSquares ( n ) : square = 0 ; prev_x = 0 ; for x in range ( 0 , n ) : square = ( square + x + prev_x ) print ( square , end = "" ) prev_x = x

def printSquares ( n ) : square = 0 prev_x = 0 for x in range ( 0 , n ) : square = ( square + x + prev_x ) print ( square + " " ) prev_x = x for x in range ( 0 , n ) : square = ( square + x + prev_x ) print ( square + " " ) prev_x = x

def printSquares ( n ) : square = 0 prev_x = 0 for x in range ( n ) : square = ( square + x + prev_x ) print ( square + " " ) prev_x = x

47.64
53.71
76.62
58.56
static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }

def transpose ( A ) : for i in range ( N ) : for j in range ( i + 1 , N ) : A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ]

def transpose ( A , N ) : A . sort ( reverse = True ) for i in range ( 0 , N ) : for j in range ( i + 1 , N ) : if ( A [ i ] [ j ] != A [ j ] [ i ] ) : A [ i ] [ j ] = A [ j ] [ i ] temp = A [ i ] [ j ] A [ j ] [ i ] = temp A [ i ] [ j ] = temp

def transpose ( A [ ] [ ] ) : for i in range ( N ) : for j in range ( i + 1 , N ) : temp = A [ i ] [ j ] A [ i ] [ j ] = A [ j ] [ i ] A [ j ] [ i ] = temp

47.71
32.86
31.5
22.03
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { return i ; } } return - 1 ; }

def search ( arr , n , x ) : i = 0 for i in range ( i , n ) : if ( arr [ i ] == x ) : return i return - 1

def search ( arr , n , x ) : if ( arr [ i ] == x ) : return i

def search ( arr , n , x ) : if x in arr : return i return - 1

47.74
53.64
59.26
63.84
static boolean checkDuplicatesWithinK ( int arr [ ] , int k ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( set . contains ( arr [ i ] ) ) return true ; set . add ( arr [ i ] ) ; if ( i >= k ) set . remove ( arr [ i - k ] ) ; } return false ; }

def checkDuplicatesWithinK ( arr , n , k ) : myset = [ ] for i in range ( n ) : if arr [ i ] in myset : return True myset . append ( arr [ i ] ) if ( i >= k ) : myset . remove ( arr [ i - k ] ) return False

def checkDuplicatesWithinK ( arr , k ) : set = new HashSet < Integer > ( ) for i in range ( 0 , arr . length , k ) : if ( set . contains ( arr [ i ] ) ) : return true set . add ( arr [ i ] ) if ( i >= k ) : set . remove ( arr [ i - k ] ) return true

def checkDuplicatesWithinK ( arr , k ) : set = [ ] for i in range ( len ( arr ) ) : if ( set . contains ( arr [ i ] ) ) : return True ; set . add ( arr [ i ] ) if ( i >= k ) : set . remove ( arr [ i - k ] ) return False

47.75
73.95
87.82
88.86
static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; }

def isHeap ( arr , i , n ) : if i > int ( ( n - 2 ) / 2 ) : return True if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : return True return False

def isHeap ( arr , i , n ) : if ( i > n - 2 ) : return true if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) : return true if ( arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 2 , n ) ) : return true if ( arr [ i ] >= arr [ 2 * i + 1 , n ) : return true if ( arr [ i ] >= arr [ 2 * i + 1 ] and isHeap ( arr , 2 * i + 2 , n ) ) : return true

def isHeap ( arr , i , n ) : if i > ( n - 2 ) / 2 : return True if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) : return True return False

47.76
44.73
58.53
55.57
static int maxdiff ( int arr [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; }

def maxdiff ( arr , n ) : freq = defaultdict ( lambda : 0 ) for i in range ( n ) : freq [ arr [ i ] ] += 1 ans = 0 for i in range ( n ) : for j in range ( n ) : if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) return ans

def maxdiff ( arr , n ) : freq = defaultdict ( int ) for i in range ( n ) : freq . put ( arr [ i ] , 1 ) for j in range ( 0 , n ) : if ( freq [ arr [ i ] ] == null ) : freq [ arr [ i ] ] = 1 ans = max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) else : ans = max ( ans , freq [ i ] ) if ( freq [ i ] > arr [ j ] ) and arr [ i ] < arr [ j ] ) : ans = max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) : ans = max ( ans , freq [ arr [ i ] ) else : ans = max ( ans , freq . get ( arr [ i ] ) - freq [ j ] ) return ans

def maxdiff ( arr , n ) : freq = { } for i in range ( n ) : for j in range ( 0 , n ) : if freq [ i ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) elif freq [ i ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : ans = max ( ans , freq [ arr [ j ] ] - freq [ i ] ) else : if freq [ i ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) else : if freq [ i ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) return ans

47.8
36.73
55.56
40.04
static int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }

def countSolutions ( n ) : x = 0 res = 0 yCount = 0 while ( yCount * yCount < n ) : yCount = yCount + 1 while ( yCount != 0 ) : res = res + yCount x = x + 1 while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : yCount = yCount - 1 return res

def countSolutions ( n ) : res = 0 x = 0 yCount = 0 for yCount in range ( n ) : res += yCount yCount = 0 while ( yCount != 0 and ( x * x + ( yCount - 1 ) * yCount >= n ) ) : yCount -= 1 x += 1 while ( yCount != 0 and ( x * x + ( yCount - 1 ) * yCount >= n ) ) : yCount -= 1 if ( yCount != 0 ) : res += yCount if ( yCount != 0 ) : res += yCount

def countSolutions ( n ) : x = 0 yCount = 0 for yCount in range ( n ) : while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) : yCount -- res += yCount x += 1 while yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) : yCount -- return res

47.81
42.32
73.15
63.9
static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }

def MaxDotProduct ( A , B , m , n ) : dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 , 1 ) : for j in range ( i , m + 1 , 1 ) : dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) return dp [ n ] [ m ]

def MaxDotProduct ( A , B , m , n ) : dp = [ INT_MAX for row in dp ] : row . append ( max ( A [ n ] * B [ m - 1 ] ) ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) return dp [ n ] [ m ]

def MaxDotProduct ( A , B , m , n ) : dp = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) return dp [ n ] [ m ]

47.9
55.95
58.67
49.36
static void spiralFill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k ] [ i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = val ++ ; } l ++ ; } } }

def spiralFill ( m , n , a ) : val = 1 k , l = 0 , 0 while ( k < m and l < n ) : for i in range ( l , n ) : a [ k ] [ i ] = val val += 1 k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = val val += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : a [ m - 1 ] [ i ] = val val += 1 m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : a [ i ] [ l ] = val val += 1 l += 1

def spiralFill ( m , n , a ) : a . sort ( reverse = True ) k = 0 l = 0 for k in range ( m , n ) : for i in range ( l , n ) : a [ k ] [ i ] = val ++ l += 1 if ( k < m ) : for i in range ( n - 1 , - 1 ) : a [ i ] [ n - 1 ] = val ++ n -= 1 if ( l < n ) : for i in range ( k , m ) : : a [ i ] [ l ] = val += 1 if ( l < n ) : for ( int i = n - 1 ; i >= k ; -- i ) : a [ i ] [ l ] = val ++ m -= 1 if ( k < m ) : for i in range ( n - 1 , - 1 ) : a [ i ] [ l ] = val ++ if ( l < n ) : for ( int i = m - 1 : i = k - 1 : a [ i ] [ l ] = val += 1 if ( l < n ) : for ( int i = m - 1 ; i >= k : : a [ i ] [ l ] = val

def spiralFill ( m , n , a ) : val = 1 k = 0 l = 0 while k < m and l < n : for i in range ( l , n ) : a [ k ] [ i ] = val ++ k ++ for i in range ( k , m ) : a [ i ] [ n - 1 ] = val ++ n -- if k < m : for i in range ( n - 1 , m ) : a [ i ] [ n - 1 ] = val ++ m -- if l < n : for i in range ( m - 1 , k ) : a [ i ] [ l ] = val ++ l ++

47.94
41.65
69.36
49.32
static int maxSubArraySum ( int a [ ] ) { int size = a . length ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }

def maxSubArraySum ( a , size ) : max_so_far = - maxint - 1 max_ending_here = 0 for i in range ( 0 , size ) : max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if max_ending_here < 0 : max_ending_here = 0 return max_so_far

def maxSubArraySum ( a ) : size = a . length max_so_far = float ( 'inf' ) for i in range ( size ) : max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) max_so_far = max_ending_here max_ending_here = 0 for i in range ( size ) : max_ending_here = max_ending_here + a [ i ] if ( max_ending_here < 0 ) : max_ending_here = 0 return max_so_far

def maxSubArraySum ( a ) : size = a . length max_so_far = float ( 'inf' ) max_ending_here = 0 for i in range ( 0 , size ) : max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if ( max_ending_here < 0 ) : max_ending_here = 0 return max_so_far

47.97
44.05
70.7
77.3
static int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }

def numberOfPaths ( p , q ) : dp = [ 1 for i in range ( q ) ] for i in range ( p - 1 ) : for j in range ( 1 , q ) : dp [ j ] += dp [ j - 1 ] return dp [ q - 1 ]

def numberOfPaths ( m , n ) : dp = [ 1 for i in range ( m , n ) ] for i in range ( 0 , m , n ) : dp [ i ] += dp [ i - 1 ] return dp [ n - 1 ]

def numberOfPaths ( m , n ) : dp = [ 1 for i in range ( m ) ] for i in range ( m , n ) : for j in range ( 1 , n ) : dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ]

48.08
34.83
54.26
45.4
boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }

def areConsecutive ( arr , n ) : if ( n < 1 ) : return False Min = min ( arr ) Max = max ( arr ) if ( Max - Min + 1 == n ) : visited = [ False for i in range ( n ) ] for i in range ( n ) : if ( visited [ arr [ i ] - Min ] != False ) : return False visited [ arr [ i ] - Min ] = True return True return False

def areConsecutive ( arr , n ) : if ( n == 0 ) : return areConsecutive ( arr , n - 1 ) else : visited = [ false for i in range ( 0 , n ) ] for i in range ( 0 , max - min + 1 ) : if ( visited [ arr [ i ] - min ] != false ) : return false visited [ arr [ i ] - min ] = true return true

def areConsecutive ( arr , n ) : if n < 1 : return False min = getMin ( arr , n ) max = getMax ( arr , n ) if max - min + 1 == n : visited = [ ] for i in range ( 0 , n ) : if ( visited [ arr [ i ] - min ] != False ) : return False visited [ arr [ i ] - min ] = True return True

48.13
39.81
54.24
45.24
static void printMinIndexChar ( String str , String patt ) { int minIndex = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != Integer . MAX_VALUE ) System . out . println ( "Minimum Index Character = " + str . charAt ( minIndex ) ) ; else System . out . println ( "No character present" ) ; }

def printMinIndexChar ( Str , patt ) : minIndex = 10 ** 9 m = len ( Str ) n = len ( patt ) for i in range ( n ) : for j in range ( m ) : if ( patt [ i ] == Str [ j ] and j < minIndex ) : minIndex = j break if ( minIndex != 10 ** 9 ) : print ( "MinimumIndexCharacter=" , Str [ minIndex ] ) else : print ( "Nocharacterpresent" )

def printMinIndexChar ( str , patt ) : minIndex = Integer . MAX_VALUE for i in range ( n , m ) : for j in range ( i , n ) : if ( patt [ i ] == str [ j ] ) : minIndex = j if ( minIndex != Integer . MAX_VALUE ) : print ( "Minimum Index Character = " + str [ minIndex ] ) else : print ( "No character present" ) return

def printMinIndexChar ( str , patt ) : minIndex = INT_MAX m = str . length n = patt . length for i in range ( 0 , n ) : for j in range ( 0 , m ) : if ( patt [ i ] == str [ j ] and j < minIndex ) : minIndex = j break if minIndex != INT_MAX_VALUE : print ( "Minimum Index Character = " + str [ minIndex ] ) else : print ( "No character present" )

48.14
35.49
80.54
89.44
static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }

def round ( n ) : a = ( n // 10 ) * 10 b = a + 10 return ( b if n - a > b - n else a )

def round ( n ) : a = n % 10 b = n % 10 return ( n - a > b - n ) ? a : b

def round ( n ) : a = ( n // 10 ) * 10 b = a + 10 return ( n - a > b - n )

48.15
41.9
58.75
44.59
static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( f2 + " " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }

def printFibonacciNumbers ( n ) : f1 = 0 f2 = 1 if ( n < 1 ) : return for x in range ( 0 , n ) : print ( f2 , end = "" ) next = f1 + f2 f1 = f2 f2 = next

def printFibonacciNumbers ( n ) : f1 = 0 f2 = 1 for i in range ( 1 , n ) : print ( f1 + f2 ) f1 = f2 f2 = next for i in range ( 1 , n ) : print ( f2 + " " ) f2 = next

def printFibonacciNumbers ( n ) : f1 = 0 f2 = 1 for i in range ( 1 , n ) : print ( f2 + " " ) next = f1 + f2 f1 = f2 f2 = next

48.21
49.34
71.3
62.88
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; rightsum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }

def equilibrium ( arr ) : leftsum = 0 rightsum = 0 n = len ( arr ) for i in range ( n ) : leftsum = 0 rightsum = 0 for j in range ( i ) : leftsum += arr [ j ] for j in range ( i + 1 , n ) : rightsum += arr [ j ] if leftsum == rightsum : return i return - 1

def equilibrium ( arr , n ) : leftsum , rightsum = 0 for i in range ( n ) : leftsum = 0 for j in range ( i + 1 , n ) : rightsum += arr [ j ] if ( leftsum == rightsum ) : return i

def equilibrium ( arr , n ) : leftsum , rightsum = 0 for i in range ( n ) : leftsum = 0 for j in range ( i + 1 , n ) : leftsum += arr [ j ] rightsum = 0 for j in range ( i + 1 , n ) : rightsum += arr [ j ] if ( leftsum == rightsum ) : return i return - 1

48.23
54.19
60.52
51.09
static void countFreq ( int a [ ] , int n ) { int hm [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { System . out . println ( a [ i ] + "->" + cumul ) ; } hm [ a [ i ] ] = 0 ; } }

def countFreq ( a , n ) : hm = dict ( ) for i in range ( n ) : hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 cumul = 0 for i in range ( n ) : cumul += hm [ a [ i ] ] if ( hm [ a [ i ] ] > 0 ) : print ( a [ i ] , "->" , cumul ) hm [ a [ i ] ] = 0

def countFreq ( a , n ) : hm = [ 0 for i in range ( n ) ] cumul = 0 for i in range ( 0 , n ) : cumul += hm [ a [ i ] ] if ( hm [ a [ i ] ] != 0 ) : print ( a [ i ] + "->" + cumul ) hm [ a [ i ] ] = 0 cumul = 0 for i in range ( 0 , n ) : cumul += hm [ a [ i ] = 0 if ( hm [ a [ i ] != 0 ) : print ( a [ i ] + "->" + cumul ) hm [ a [ i ] = 0 hm [ a [ i ] ] = 0 print ( hm [ a [ i ]

def countFreq ( a , n ) : hm = [ 0 for i in range ( n ) ] cumul = 0 for i in range ( 0 , n ) : cumul += hm [ a [ i ] ] if ( hm [ a [ i ] ] != 0 ) : print ( a [ i ] + "->" + cumul ) hm [ a [ i ] ] = 0

48.27
49.87
50.89
61.22
static double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; }

def circumference ( r ) : return ( 2 * PI * r )

def circumference ( r ) : cir = PI * r

def circumference ( r ) : PI = 3.1415 cir = 2 * PI * r return cir

48.37
43.29
46.4
45.98
static int waysToArrange ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }

def waysToArrange ( N , K , k ) : C = np . zeros ( ( N + 1 , N + 1 ) ) for i in range ( N + 1 ) : for j in range ( i + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) dp = np . zeros ( ( K + 1 ) ) count = 0 dp [ 0 ] = 1 for i in range ( K ) : dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) count += k [ i ] return dp [ K ]

def waysToArrange ( N , K , k ) : C = [ INT_MAX for i in range ( N , K ) ] dp = [ INT_MAX for i in range ( 0 , N , K ) ] count = 0 for j in range ( 0 , N , k ) : dp [ i ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) count += k [ i ] if ( j == 0 ) : dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] return dp [ K ]

def waysToArrange ( N , K , k ) : C = [ 0 for i in range ( N ) ] for i in range ( N ) : for j in range ( i , N ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) count += k [ i ] return dp [ K ]

48.42
48.1
65.12
41.83
static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }

def binarySearch ( arr , low , high , key ) : if ( high < low ) : return - 1 mid = ( low + high ) / 2 if ( key == arr [ int ( mid ) ] ) : return mid if ( key > arr [ int ( mid ) ] ) : return binarySearch ( arr , ( mid + 1 ) , high , key ) return ( binarySearch ( arr , low , ( mid - 1 ) , key ) )

def binarySearch ( arr , low , high , key ) : if ( key == arr [ mid ] ) : return mid if ( key < arr [ mid ] ) : return binarySearch ( arr , low , mid , key ) return binarySearch ( arr , mid + 1 , high , key ) return binarySearch ( arr , low , mid - 1 )

def binarySearch ( arr , low , high , key ) : if high < low : return - 1 mid = ( low + high ) // 2 if key == arr [ mid ] : return mid if key > arr [ mid ] : return binarySearch ( arr , ( mid + 1 ) , high , key ) return binarySearch ( arr , low , ( mid - 1 ) , key )

48.48
35.13
72.57
68.9
static float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }

def calc_Expectation ( a , n ) : prb = 1 / n sum = 0 for i in range ( 0 , n ) : sum += ( a [ i ] * prb ) return float ( sum )

def calc_Expectation ( a , n ) : prb = 1.0f for i in range ( n ) : sum += a [ i ] * prb return sum

def calc_Expectation ( a , n ) : prb = ( 1 / n ) sum = 0 for i in range ( 0 , n ) : sum += a [ i ] * prb return sum

48.49
38.95
70.58
53.86
static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }

def zigzag ( n , k ) : dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , n + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) return dp [ n ] [ k ]

def zigzag ( n , k ) : dp = [ 1 ] * ( n + 1 ) dp [ 0 ] = [ 1 for i in range ( 1 , n ) ] for j in range ( 1 , k ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] return dp [ n ] [ k ]

def zigzag ( n , k ) : dp [ ] = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : dp [ i ] [ 0 ] = 1 for i in range ( 1 , n ) : dp [ i ] [ 0 ] = 0 for i in range ( 1 , n ) : for j in range ( 1 , k ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] return dp [ n ] [ k ]

48.5
39.16
54.6
46.69
static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }

def lis ( arr ) : n = len ( arr ) lis = [ 1 ] * n for i in range ( 1 , n ) : for j in range ( 0 , i ) : if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : lis [ i ] = lis [ j ] + 1 maximum = 0 for i in range ( n ) : maximum = max ( maximum , lis [ i ] ) return maximum

def lis ( arr , n ) : lis = [ 0 for i in range ( n ) ] for j in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] ) : lis [ i ] = 1 else : max = lis [ i ] for i in range ( 1 , n ) : if ( max < lis [ i ] ) : max = lis [ i ] return max

def lis ( arr , n ) : lis = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : lis [ i ] = 1 for i in range ( 1 , n ) : for j in range ( i , n ) : if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 for i in range ( 0 , n ) : if ( max < lis [ i ] ) : max = lis [ i ] return max

48.5
39.16
54.6
46.69
static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }

def lis ( arr ) : n = len ( arr ) lis = [ 1 ] * n for i in range ( 1 , n ) : for j in range ( 0 , i ) : if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : lis [ i ] = lis [ j ] + 1 maximum = 0 for i in range ( n ) : maximum = max ( maximum , lis [ i ] ) return maximum

def lis ( arr , n ) : lis = [ 0 for i in range ( n ) ] for j in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] ) : lis [ i ] = 1 else : max = lis [ i ] for i in range ( 1 , n ) : if ( max < lis [ i ] ) : max = lis [ i ] return max

def lis ( arr , n ) : lis = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : lis [ i ] = 1 for i in range ( 1 , n ) : for j in range ( i , n ) : if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 for i in range ( 0 , n ) : if ( max < lis [ i ] ) : max = lis [ i ] return max

48.51
38.81
65.5
55.05
static boolean distributingBalls ( long k , long n , String str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }

def distributingBalls ( k , n , string ) : a = [ 0 ] * MAX_CHAR for i in range ( n ) : a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR ) : if ( a [ i ] > k ) : return False return True

def distributingBalls ( k , n , str ) : a = [ 0 for i in range ( n ) ] for i in range ( 0 , MAX_CHAR ) : if ( a [ i ] > k ) : return false return true

def distributingBalls ( k , n , str ) : a = [ MAX_CHAR for i in range ( n ) ] for i in range ( 0 , n ) : a [ str [ i ] - 'a' ] += 1 for i in range ( 0 , MAX_CHAR ) : if ( a [ i ] > k ) : return False return True

48.52
41.22
85.53
64.31
static int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }

def countNums ( n , x , y ) : arr = [ False for i in range ( n + 2 ) ] if ( x <= n ) : arr [ x ] = True if ( y <= n ) : arr [ y ] = True result = 0 for i in range ( min ( x , y ) , n + 1 ) : if ( arr [ i ] ) : if ( i + x <= n ) : arr [ i + x ] = True if ( i + y <= n ) : arr [ i + y ] = True result = result + 1 return result

def countNums ( n , x , y ) : arr = [ false for i in range ( n ) ] for i in range ( x , y ) : if ( arr [ i ] ) : if ( i + x <= n ) : arr [ i + x ] = true result += 1 elif ( i + y <= n ) : arr [ i + y ] = true return result

def countNums ( n , x , y ) : arr = [ True for i in range ( n ) ] for k in range ( n ) : if ( x <= n ) : arr [ x ] = True if ( y <= n ) : arr [ y ] = True result = 0 for i in range ( min ( x , y ) , n ) : if ( arr [ i ] ) : if ( i + x <= n ) : arr [ i + x ] = True if ( i + y <= n ) : arr [ i + y ] = True result += 1 return result

48.53
47.11
69.93
47.44
static int findMaxProduct ( int arr [ ] , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxval = 1 ; int minval = 1 ; int prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; }

def findMaxProduct ( arr , n ) : ans = - float ( 'inf' ) maxval = 1 minval = 1 for i in range ( 0 , n ) : if arr [ i ] > 0 : maxval = maxval * arr [ i ] minval = min ( 1 , minval * arr [ i ] ) elif arr [ i ] == 0 : minval = 1 maxval = 0 elif arr [ i ] < 0 : prevMax = maxval maxval = minval * arr [ i ] minval = prevMax * arr [ i ] ans = max ( ans , maxval ) if maxval <= 0 : maxval = 1 return ans

def findMaxProduct ( arr , n ) : ans = float ( 'inf' ) maxval = 1 minval = 1 for i in range ( n ) : if ( arr [ i ] > 0 ) : maxval = maxval * arr [ i ] minval = minval * arr [ i ] prevMax = maxval maxval = minval * arr [ i ] if ( maxval <= 0 ) : maxval = 1 else : minval = 1 prevMax = maxval if ( maxval <=

def findMaxProduct ( arr , n ) : maxval = 1 minval = 1 prevMax = maxval maxval = minval * arr [ i ] minval = min ( 1 , minval * arr [ i ] ) elif ( arr [ i ] == 0 ) : minval = 1 maxval = 0 elif ( arr [ i ] < 0 ) : prevMax = maxval maxval = minval * arr [ i ] maxval = minval * arr [ i ] minval = prevMax * arr [ i ] ans = max ( ans , maxval ) if ( maxval <= 0 ) : maxval = 1 return ans

48.55
28.44
67.2
67.92
static boolean isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }

def isDivBy9 ( n ) : if ( n == 0 or n == 9 ) : return True if ( n < 9 ) : return False return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )

def isDivBy9 ( n ) : if ( n == 1 || n == 9 ) : return isDivBy9 ( n >> 3 ) and isDivBy9 ( n & 7 ) : return isDivBy9 ( n >> 3 ) and isDivBy9 ( n & 7 )

def isDivBy9 ( n ) : if n == 0 or n == 9 : return True if n < 9 : return False return isDivBy9 ( ( int ( n >> 3 ) - ( int ( n & 7 ) ) )

48.6
49.04
65.79
53.46
static String sortString ( String str , int n ) { String new_str = "" ; for ( int i = 'a' ; i <= 'z' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str . charAt ( j ) == i ) new_str += str . charAt ( j ) ; return new_str ; }

def sortString ( str , n ) : new_str = "" for i in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : for j in range ( n ) : if ( str [ j ] == chr ( i ) ) : new_str += str [ j ] return new_str

def sortString ( str , n ) : new_str = "" for i in range ( 'a' , 'z' ) : if ( str [ i ] == i ) : new_str += str [ j ] return new_str

def sortString ( str , n ) : new_str = "" for i in range ( 'a' , 'z' , n ) : for j in range ( n ) : if ( str [ i ] == i ) : new_str += str [ j ] return new_str

48.62
39.25
54.09
41.53
static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) { j ++ ; i ++ ; } else if ( arr1 [ j ] > arr2 [ i ] ) return false ; } if ( i < n ) return false ; else return true ; }

def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 if m < n : return 0 arr1 . sort ( ) arr2 . sort ( ) while i < n and j < m : if arr1 [ j ] < arr2 [ i ] : j += 1 elif arr1 [ j ] == arr2 [ i ] : j += 1 i += 1 elif arr1 [ j ] > arr2 [ i ] : return 0 return False if i < n else True

def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( m , n ) : if ( arr1 [ j ] < arr2 [ i ] ) : j += 1 else : if ( arr1 [ j ] == arr2 [ i ] ) : i += 1 else : if ( arr1 [ j ] > arr2 [ i ] ) : return false return true

def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( n ) : if ( arr1 [ j ] < arr2 [ i ] ) : j += 1 elif ( arr1 [ j ] == arr2 [ i ] ) : j += 1 i += 1 elif ( arr1 [ j ] > arr2 [ i ] ) : return False return True

48.68
40.97
44.79
43.01
static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }

def maxRowDiff ( mat , m , n ) : rowSum = [ 0 ] * m for i in range ( 0 , m ) : sum = 0 for j in range ( 0 , n ) : sum += mat [ i ] [ j ] rowSum [ i ] = sum max_diff = rowSum [ 1 ] - rowSum [ 0 ] min_element = rowSum [ 0 ] for i in range ( 1 , m ) : if ( rowSum [ i ] - min_element > max_diff ) : max_diff = rowSum [ i ] - min_element if ( rowSum [ i ] < min_element ) : min_element = rowSum [ i ] return max_diff

def maxRowDiff ( mat , m , n ) : rowSum = [ 0 for i in range ( m , n ) ] for i in range ( m , n ) : sum = 0 for j in range ( n ) : sum += mat [ i ] [ j ] rowSum [ i ] = sum if ( rowSum [ i ] > max_diff ) max_diff = rowSum [ i ] - min_element > max_diff : max_diff =

def maxRowDiff ( mat , m , n ) : rowSum = [ 0 for k in range ( m ) ] for i in range ( 1 , m ) : if ( rowSum [ i ] - min_element > max_diff ) : max_diff = rowSum [ i ] - min_element if ( rowSum [ i ] < min_element ) : min_element = rowSum [ i ] return max_diff

48.73
30.67
40.27
26.96
static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 }; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }

def dayofweek ( d , m , y ) : t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] y -= m < 3 return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 )

def dayofweek ( d , m , y ) : t = { 0 , 1 , 2 , 4 , 6 , 1 , 2 , 4 } y -= ( m < 3 ) ? 1 : 0 y -= ( m < 3 ) ? 1 : 0 ) return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7

def dayofweek ( d , m , y ) : t = [ 0 for k in range ( m ) ] y -= ( m < 3 ) ? 1 : 0 return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7

48.76
44.37
66.84
62.56
static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; }

def minJumps ( arr , l , h ) : if ( h == l ) : return 0 if ( arr [ l ] == 0 ) : return float ( 'inf' ) min = float ( 'inf' ) for i in range ( l + 1 , h + 1 ) : if ( i < l + arr [ l ] + 1 ) : jumps = minJumps ( arr , i , h ) if ( jumps != float ( 'inf' ) and jumps + 1 < min ) : min = jumps + 1 return min

def minJumps ( arr , l , h ) : if ( l == h ) : return 0 if ( arr [ l ] == 0 ) : return float ( 'inf' ) for i in range ( l + 1 , h ) : if ( jumps != float ( 'inf' ) ) : min = jumps + 1 return min

def minJumps ( arr , l , h ) : if h == l : return 0 if l == h : return 0 if arr [ l ] == 0 : return float ( 'inf' ) min = float ( 'inf' ) for i in range ( l + 1 , h ) : jumps = minJumps ( arr , i , h ) if jumps != float ( 'inf' ) and jumps + 1 < min : min = jumps + 1 return min

48.77
41.11
70.21
76.14
static void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { Set < Integer > s = new HashSet < Integer > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) System . out . println ( "Invalid k" ) ; else System . out . println ( l + " " + r ) ; }

def minRange ( arr , n , k ) : l = 0 r = n for i in range ( n ) : s = [ ] for j in range ( i , n ) : s . append ( arr [ j ] ) if ( len ( s ) == k ) : if ( ( j - i ) < ( r - l ) ) : r = j l = i break if ( j == n ) : break if ( l == 0 and r == n ) : print ( "Invalidk" ) else : print ( l , r )

def minRange ( arr , n , k ) : l = 0 r = 0 for i in range ( 0 , n , k ) : s . add ( arr [ i ] ) if ( s . size ( ) == k ) : r = j i = 0 for j in range ( i , n , k ) : if ( j - i ) < ( r - l ) : l = j if ( r - l ) < ( l - r ) : r =

def minRange ( arr , n , k ) : l = 0 r = n for i in range ( n ) : s = list ( ) for j in range ( i , n ) : s . add ( arr [ j ] ) if ( s . size ( ) == k ) : if ( j - i ) < ( r - l ) : r = j l = i break if j == n : break if j == n : break if l == 0 and r == n : print ( "Invalid k" ) else : print ( l + " " + r )

48.77
46.37
50.09
47.99
static void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ ] [ ] = new char [ m ] [ n ] ; char x = 'X' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? 'X' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) System . out . print ( a [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

def fill0X ( m , n ) : i , k , l = 0 , 0 , 0 r = m c = n a = [ [ None ] * n for i in range ( m ) ] x = 'X' while k < m and l < n : for i in range ( l , n ) : a [ k ] [ i ] = x k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = x n -= 1 if k < m : for i in range ( n - 1 , l - 1 , - 1 ) : a [ m - 1 ] [ i ] = x m -= 1 if l < n : for i in range ( m - 1 , k - 1 , - 1 ) : a [ i ] [ l ] = x l += 1 x = 'X' if x == '0' else '0' for i in range ( r ) : for j in range ( c ) : print ( a [ i ] [ j ] , end = "" ) print ( )

def fill0X ( m , n ) : a = [ CHAR_MAX for k in range ( m , n ) ] l = 0 for i in range ( m , n ) : a [ i ] [ i ] = x l += 1 if ( k < m ) : for i in range ( m , n ) : a [ i ] [ n - 1 ] = x n -= 1 if ( l < n ) : for i in range ( k , m ) : a [ i ] [ l ] = x = x for i in range ( k , n ) : a [ i ] [ l ] = x if ( i >= k : a [ i ] [ l ] = x m -= 1 x = 'X' if ( x == '0' ) : print ( a [ i ] [ j ] = '0' ) else : print ( a [ i ] [ j ] = 'X'

def fill0X ( m , n ) : a [ k ] = [ x for k in range ( m ) ] for i in range ( l , n ) : a [ k ] [ i ] = x k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = x n -= 1 if k < m : for i in range ( n - 1 , m ) : a [ i ] [ n - 1 ] = x m -= 1 if l < n : for i in range ( m - 1 , k ) : a [ i ] [ l ] = x m -= 1 l += 1 x = ( x == '0' ) ? 'X' : '0'

48.77
49.94
62.85
56.87
static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( "No pairs exists" ) ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } System . out . println ( "Max product pair is { " + a + ", " + b + "}" ) ; }

def maxProduct ( arr , n ) : if ( n < 2 ) : print ( "Nopairsexists" ) return a = arr [ 0 ] b = arr [ 1 ] for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] * arr [ j ] > a * b ) : a = arr [ i ] b = arr [ j ] print ( "Maxproductpairis{" , a , "," , b , "}" , sep = "" )

def maxProduct ( arr , n ) : if ( n == 0 ) : print ( "No pairs exists" ) ; return ; } a = arr [ 0 ] b = arr [ 1 ] for i in range ( 0 , n ) : if ( arr [ i ] * arr [ j ] > a * b ) : a = arr [ i ] b = arr [ j ] if ( arr [ i ] * arr [ j ] > a * b ) : b = arr [ i ] if ( arr [ i ] * arr [ j ] > a * b ) : b = arr [ j ] print ( "Max product pair is { " + a + ", " + b ) return

def maxProduct ( arr , n ) : a = arr [ 0 ] b = arr [ 1 ] for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] * arr [ j ] > a * b ) : a = arr [ i ] b = arr [ j ] if arr [ i ] * arr [ j ] > a * b : a = arr [ i ] b = arr [ j ] print ( "Max product pair is { " + a + ", " + b + "}" )

48.8
56.89
59.67
73.55
static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }

def maxSumWO3Consec ( n ) : if ( sum [ n ] != - 1 ) : return sum [ n ] if ( n == 0 ) : sum [ n ] = 0 return sum [ n ] if ( n == 1 ) : sum [ n ] = arr [ 0 ] return sum [ n ] if ( n == 2 ) : sum [ n ] = arr [ 1 ] + arr [ 0 ] return sum [ n ] sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) return sum [ n ]

def maxSumWO3Consec ( n ) : sum [ n ] = - 1 if n == - 1 : return sum [ n ] = 0 if n == 0 : return sum [ n ] = 0 if n == 1 : return sum [ n ] = arr [ 0 ] if n == 2 : return sum [ n ] = arr [ 1 ] + arr [ 0 ] if n == 3 : return sum [ n ] = maxSumWO3Consec ( n - 1 ) if ( n == n ) : return sum [ n ] = maxSumWO3Consec ( n - 1 ) else : return sum [ n ] = maxSumWO3Consec ( n - 1 )

def maxSumWO3Consec ( n ) : sum [ n ] = - 1 if n == 0 : return sum [ n ] = 0 if n == 1 : return sum [ n ] = 0 if n == 1 : return sum [ n ] = arr [ 0 ] if n == 2 : return sum [ n ] = arr [ 1 ] + arr [ 0 ] if n == 3 : return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) )

48.86
43.08
67.68
58.04
static void printRoots ( int n ) { double theta = 3.14 * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . println ( real ) ; if ( img >= 0 ) System . out . println ( " + i " ) ; else System . out . println ( " - i " ) ; System . out . println ( Math . abs ( img ) ) ; } }

def printRoots ( n ) : theta = math . pi * 2 / n for k in range ( 0 , n ) : real = math . cos ( k * theta ) img = math . sin ( k * theta ) print ( real , end = "" ) if ( img >= 0 ) : print ( "+i" , end = "" ) else : print ( "-i" , end = "" ) print ( abs ( img ) )

def printRoots ( n ) : theta = 3.14 * 2 / n for k in range ( n ) : real = cos ( k * theta ) img = sin ( k * theta ) if ( img >= 0 ) : print ( " + i " ) else : print ( " - i " ) print ( real )

def printRoots ( n ) : theta = 3.14 * 2 / n for k in range ( n ) : real = math . cos ( k * theta ) img = math . sin ( k * theta ) print ( real ) if ( img >= 0 ) : print ( " + i " ) else : print ( " - i " ) print ( abs ( img ) )

48.94
33.63
63.85
52.72
static void reorder ( ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }

def reorder ( arr , index , n ) : temp = [ 0 ] * n for i in range ( 0 , n ) : temp [ index [ i ] ] = arr [ i ] for i in range ( 0 , n ) : arr [ i ] = temp [ i ] index [ i ] = i

def reorder ( arr , index ) : temp = [ 0 for i in range ( arr . length ) ] index = [ 0 for i in range ( arr . length ) ] arr [ i ] = temp [ i ] index [ i ] = i return arr

def reorder ( arr ) : temp = [ INT_MAX for i in range ( arr . length ) ] for i in range ( 0 , arr . length ) : arr [ index [ i ] ] = arr [ i ] for i in range ( 0 , arr . length ) : arr [ i ] = temp [ i ] index [ i ] = i

48.98
42.54
41.04
45.53
static void Round_off ( double N , double n ) { int h ; double l , a , b , c , d , e , i , j , m , f , g ; b = N ; c = floor ( N ) ; for ( i = 0 ; b >= 1 ; ++ i ) b = b / 10 ; d = n - i ; b = N ; b = b * pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ( ceil ( b ) ) ; h = ( int ) ( f - 2 ) ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; System . out . println ( "The number after rounding-off is " + j ) ; }

def Round_off ( N , n ) : b = N c = floor ( N ) i = 0 while ( b >= 1 ) : b = b / 10 i = i + 1 d = n - i b = N b = b * pow ( 10 , d ) e = b + 0.5 if ( float ( e ) == float ( ceil ( b ) ) ) : f = ( ceil ( b ) ) h = f - 2 if ( h % 2 != 0 ) : e = e - 1 j = floor ( e ) m = pow ( 10 , d ) j = j / m print ( "Thenumberafterrounding-offis" , j )

def Round_off ( N , n ) : l = 0.0 for i in range ( n ) : b = floor ( N ) c = floor ( N ) d = n - i b = b * pow ( 10 , d ) e = b + 0.5 f = ( ceil ( b ) ) h = ( int ) ( f - 2 ) if ( h % 2 != 0 ) : e = e - 1 else : f = ( float ) e if ( f ) : h = ( float ) ( f ) if ( h % 2 != 0 ) : e = e - 1 h = ( int ) ( f - 2 ) if ( h % 2 != 0 ) : e = e - 1 ) j = floor ( e ) m = pow ( 10 , d ) j = j / m

def Round_off ( N , n ) : c = floor ( N ) for i in range ( n ) : b = N c = floor ( N ) for i in range ( 1 , n ) : b = b / 10 d = n - i b = N b = b * pow ( 10 , d ) e = b + 0.5 if ( float ) e == ( float ) ceil ( b ) : f = ( ceil ( b ) ) h = ( int ) ( f - 2 ) if ( h % 2 != 0 ) : e = e - 1 else : j = floor ( e ) m = pow ( 10 , d ) j = j / m l = float ( 'inf' ) a = float ( 'inf' ) b = N c = floor ( N ) for i in range ( 1 , n ) : b = b * 10 d = n - i b = b * pow ( 10 , d ) e = b + 0.5 if ( float ) e == ( float ) ceil ( b ) : f = ( ceil ( b ) ) h = ( int ( f - 2 ) ) if ( h % 2 != 0 ) : e = e - 1

48.98
41.15
28.2
20.67
static void alternateSort ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { System . out . print ( arr [ j -- ] + " " ) ; System . out . print ( arr [ i ++ ] + " " ) ; } if ( n % 2 != 0 ) System . out . print ( arr [ i ] ) ; }

def alternateSort ( arr , n ) : arr . sort ( ) i = 0 j = n - 1 while ( i < j ) : print ( arr [ j ] , end = "" ) j -= 1 print ( arr [ i ] , end = "" ) i += 1 if ( n % 2 != 0 ) : print ( arr [ i ] )

def alternateSort ( arr , n ) : arr . sort ( reverse = True ) i = 0 j = n - 1 while ( i < j ) : print ( arr [ j -- ] + " " ) if ( n % 2 != 0 ) : print ( arr [ i ] ) if ( n % 2 != 0 ) : print ( arr [ j ] ) if ( n % 2 != 0 ) : print ( arr [ i ] ) if ( n % 2 != 0 ) : print ( arr [ j ] )

def alternateSort ( arr , n ) : i = 0 j = n - 1 while i < j : print ( arr [ j -- ] + " " ) print ( arr [ i ++ ] )

49.0
36.9
54.83
43.9
public static void findPair ( int [ ] arr , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( Integer i : arr ) { s . add ( i ) ; } boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( s . contains ( sum ) ) { found = true ; System . out . println ( arr [ i ] + " " + arr [ j ] ) ; } } } if ( found == false ) System . out . println ( "Not Exist " ) ; }

def findPair ( arr , n ) : s = { i : 1 for i in arr } found = False for i in range ( n ) : for j in range ( i + 1 , n ) : if arr [ i ] + arr [ j ] in s . keys ( ) : print ( arr [ i ] , arr [ j ] ) found = True if found == False : print ( "Notexist" )

def findPair ( arr , n ) : s = new HashSet < Integer > ( ) for i in range ( n ) : s . add ( i ) for j in range ( i + 1 , n ) : if ( s . contains ( sum ) ) : found = true print ( arr [ i ] + " " + arr [ j ] ) if ( found == false ) print ( "Not Exist " ) return

def findPair ( arr , n ) : s = list ( ) found = False for i in range ( n ) : for j in range ( i + 1 , n ) : sum = arr [ i ] + arr [ j ] if ( s . contains ( sum ) ) : found = True if ( arr [ i ] == sum ) : found = True System . out . println ( arr [ i ] + " " + arr [ j ] ) return found

49.01
43.28
68.11
61.37
static int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_neg = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) { return 0 ; } if ( count_neg % 2 == 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) { return 0 ; } prod = prod / max_neg ; } return prod ; }

def maxProductSubset ( a , n ) : if n == 1 : return a [ 0 ] max_neg = - 999999999999 count_neg = 0 count_zero = 0 prod = 1 for i in range ( n ) : if a [ i ] == 0 : count_zero += 1 continue if a [ i ] < 0 : count_neg += 1 max_neg = max ( max_neg , a [ i ] ) prod = prod * a [ i ] if count_zero == n : return 0 if count_neg & 1 : if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : return 0 prod = int ( prod / max_neg ) return prod

def maxProductSubset ( a , n ) : count_neg = 0 count_zero = 0 prod = 1 for i in range ( n ) : if ( a [ i ] == 0 ) : count_zero += 1 continue if ( a [ i ] < 0 ) : count_neg += 1 max_neg = max ( max_neg , a [ i ] ) prod = prod * a [ i ] if ( count_zero == n ) : return 0

def maxProductSubset ( a , n ) : max_neg = float ( 'inf' ) count_neg = 0 count_zero = 0 prod = 1 for i in range ( n ) : if ( a [ i ] == 0 ) : count_zero += 1 max_neg = max ( max_neg , a [ i ] ) prod = prod * a [ i ] if count_zero == n : return 0 if count_neg % 2 == 1 : if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : return 0 prod = prod / max_neg return prod

49.02
40.14
49.02
40.14
static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) j ++ ; return ( j == m ) ; }

def isSubSequence ( str1 , str2 , m , n ) : j = 0 i = 0 while j < m and i < n : if str1 [ j ] == str2 [ i ] : j = j + 1 i = i + 1 return j == m

def isSubSequence ( str1 , str2 , m , n ) : j = 0 for i in range ( n ) : if ( str1 [ j ] == str2 [ i ] ) : j += 1 return ( j == m )

def isSubSequence ( str1 , str2 , m , n ) : j = 0 for i in range ( n ) : if ( str1 [ j ] == str2 [ i ] ) : j += 1 return ( j == m )

49.09
35.12
82.29
79.83
static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( "Touch" ) ; else if ( radius > dist ) System . out . println ( "Intersect" ) ; else System . out . println ( "Outside" ) ; }

def checkCollision ( a , b , c , x , y , radius ) : dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) if ( radius == dist ) : print ( "Touch" ) elif ( radius > dist ) : print ( "Intersect" ) else : print ( "Outside" )

def checkCollision ( a , b , c , x , y , radius ) : if ( radius == dist ) : print ( "Touch" ) elif ( radius > dist ) : print ( "Intersect" ) else : print ( "Outside" ) ; return

def checkCollision ( a , b , c , x , y , radius ) : dist = ( abs ( a * x + b * y + c ) ) / float ( a * a + b * b ) if radius == dist : print ( "Touch" ) elif ( radius > dist ) : print ( "Intersect" ) else : print ( "Outside" )

49.1
37.1
42.83
36.82
static boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }

def isPower ( x , y ) : res1 = math . log ( y ) / math . log ( x ) res2 = math . log ( y ) / math . log ( x ) return 1 if ( res1 == res2 ) else 0

def isPower ( x , y ) : res1 = ( int ) Math . log ( y ) / ( int ) x res2 = ( double ) Math . log ( y ) / ( double ) x return ( res1 == res2 )

def isPower ( x , y ) : res1 = ( float ( y ) ) / ( float ( x ) ) res2 = float ( y ) / ( float ( x ) ) return ( res1 == res2 )

49.11
48.54
57.61
45.96
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }

def countPairs ( str1 ) : result = 0 ; n = len ( str1 ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : result += 1 ; return result ;

def countPairs ( str ) : result = 0 for i in range ( len ( str ) ) : for j in range ( i + 1 , n ) : if ( str [ i ] - str [ j ] ) == Math . abs ( i - j ) : result += 1 return result

def countPairs ( str ) : result = 0 n = str . length for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) : result += 1 return result

49.14
37.02
74.73
50.21
static boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( oneSeen == true ) return false ; while ( i < n && s . charAt ( i ) == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }

def checkIfAllTogether ( s , c ) : oneSeen = False i = 0 n = len ( s ) while ( i < n ) : if ( s [ i ] == c ) : if ( oneSeen == True ) : return False while ( i < n and s [ i ] == c ) : i = i + 1 oneSeen = True else : i = i + 1 return True

def checkIfAllTogether ( s , c ) : oneSeen = false for i in range ( len ( s ) ) : if ( s [ i ] == c ) : oneSeen = true i += 1 elif ( s [ i ] == c ) : if ( oneSeen == true ) : return false else : i += 1 oneSeen = true return true

def checkIfAllTogether ( s , c ) : oneSeen = False i = 0 n = s . length ( ) while i < n : if ( s [ i ] == c ) : if ( oneSeen == True ) : return False while ( i < n and s [ i ] == c ) : i ++ oneSeen = True else : i += 1 return True

49.17
47.68
66.53
54.64
static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int l = 1 ; l < k ; l ++ ) { for ( int i = l ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } } for ( int i = k - 1 ; i < n ; i ++ ) { sum += dp [ k - 1 ] [ i ] ; } return sum ; }

def numOfIncSubseqOfSizeK ( arr , n , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ] for i in range ( n ) : dp [ 0 ] [ i ] = 1 for l in range ( 1 , k ) : for i in range ( l , n ) : dp [ l ] [ i ] = 0 for j in range ( l - 1 , i ) : if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ l - 1 ] [ j ] Sum = 0 for i in range ( k - 1 , n ) : Sum += dp [ k - 1 ] [ i ] return Sum

def numOfIncSubseqOfSizeK ( arr , n , k ) : dp = [ 0 for i in range ( k ) ] for l in range ( 1 , k ) : sum += dp [ 0 ] [ i ] if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ l - 1 ] [ j ] if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ l - 1 ] [ j ] if ( arr [ j ] < arr [ i ] ) : sum += dp [ l - 1 ] [ j ] if ( arr [ j ] < arr [ i ] ) : sum += dp [ k - 1 ] [ i ] if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ k - 1 ] [ j ] return sum

def numOfIncSubseqOfSizeK ( arr , n , k ) : dp = [ 0 for k in range ( k ) ] for l in range ( 1 , k , - 1 ) : for i in range ( n ) : dp [ 0 ] [ i ] = 1 for i in range ( l ) : dp [ l ] [ i ] = 0 for j in range ( l - 1 , i ) : if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ l - 1 ] [ j ] return sum

49.24
44.05
36.64
32.74
static void minMaxValues ( int [ ] arr , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = true ; } } } double max_value = - 1 * INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . print ( "Maximum Value: " + ( int ) max_value + "\n" + "Minimum Value: " + ( int ) min_value + "\n" ) ; }

def minMaxValues ( arr , n , m ) : sum = 0 INF = 1000000000 MAX = 50 for i in range ( 0 , ( n + m ) ) : sum += arr [ i ] arr [ i ] += 50 dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 0 , ( n + m ) ) : for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : for j in range ( 0 , MAX * MAX + 1 ) : if ( dp [ k - 1 ] [ j ] ) : dp [ k ] [ j + arr [ i ] ] = 1 max_value = - 1 * INF min_value = INF for i in range ( 0 , MAX * MAX + 1 ) : if ( dp [ n ] [ i ] ) : temp = i - 50 * n max_value = max ( max_value , temp * ( sum - temp ) ) min_value = min ( min_value , temp * ( sum - temp ) ) print ( "MaximumValue:{}\nMinimumValue:{}" . format ( max_value , min_value ) )

def minMaxValues ( arr , n , m ) : sum = 0 for i in range ( n , m ) : sum += arr [ i ] dp = [ False for k in range ( n , i + 1 ) ] for j in range ( MAX * MAX + 1 ) : if ( dp [ k - 1 ] [ j ] ) : dp [ k ] [ j + arr [ i ] ] = true else : max_value = - 1 * INF min_value = INF for k in range ( n , i + 1 ) : if ( dp [ n ] [ i ] ) : max_value = min ( max_value , temp * ( sum - temp ) ) min_value = min ( min_value , temp * ( sum - temp ) print ( "Maximum Value: " + ( int ) max_value + "\n" ) print ( "Minimum Value: " + ( int ) min_value

def minMaxValues ( arr , n , m ) : sum = 0 for i in range ( n + m ) : sum += arr [ i ] arr [ i ] += 50 dp [ 0 ] [ 0 ] = True for i in range ( n + m ) : for k in range ( n , i + 1 ) : if ( dp [ n ] [ i ] ) : dp [ k ] [ j + arr [ i ] ] = True for k in range ( i + 1 , MAX * MAX + 1 ) : if ( dp [ k - 1 ] [ j ] ) : dp [ k ] [ j + arr [ i ] ] = True

49.24
40.98
41.87
33.15
static void generateGrayarr ( int n ) { if ( n <= 0 ) return ; ArrayList < String > arr = new ArrayList < String > ( ) ; arr . add ( "0" ) ; arr . add ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . add ( arr . get ( j ) ) ; for ( j = 0 ; j < i ; j ++ ) arr . set ( j , "0" + arr . get ( j ) ) ; for ( j = i ; j < 2 * i ; j ++ ) arr . set ( j , "1" + arr . get ( j ) ) ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) System . out . println ( arr . get ( i ) ) ; }

def generateGrayarr ( n ) : if ( n <= 0 ) : return arr = list ( ) arr . append ( "0" ) arr . append ( "1" ) i = 2 j = 0 while ( True ) : if i >= 1 << n : break for j in range ( i - 1 , - 1 , - 1 ) : arr . append ( arr [ j ] ) for j in range ( i ) : arr [ j ] = "0" + arr [ j ] for j in range ( i , 2 * i ) : arr [ j ] = "1" + arr [ j ] i = i << 1 for i in range ( len ( arr ) ) : print ( arr [ i ] )

def generateGrayarr ( n ) : if ( n <= 1 ) : return ; arr = list ( ) for i in range ( 2 , n ) : for j in range ( i - 1 , - 1 , - 1 ) : arr . add ( arr [ j ] ) for j in range ( i - 1 , - 1 ) : arr . set ( j , "0" + arr [ j ] ) if ( j < 2 * i ) : arr . set ( j , "1" + arr [ j ] ) : arr . set ( j , "1" + arr [ j ] ) for i in range ( 2 , n ) : if ( j >= 0 ) : arr . set ( j , "1" + arr [ j ] ) return arr [ i ]

def generateGrayarr ( n ) : arr = [ "0" for i in range ( n ) ] for i in range ( 2 << n ) : arr . add ( arr [ i ] ) for j in range ( i , 2 * n ) : arr . set ( j , "0" + arr [ j ] ) for j in range ( i , 2 * i ) : arr . set ( j , "1" + arr [ j ] ) for i in range ( i + 1 , n ) : for j in range ( i + 1 , n ) : arr . set ( j , "0" + arr [ j ] ) for j in range ( i + 1 , n ) : arr . set ( j , "1" + arr [ j ] )

49.29
40.64
49.06
40.45
static String longestRepeatedSubstring ( String str ) { int n = str . length ( ) ; int LCSRe [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; String res = "" ; int res_length = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) { LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ; if ( LCSRe [ i ] [ j ] > res_length ) { res_length = LCSRe [ i ] [ j ] ; index = Math . max ( i , index ) ; } } else { LCSRe [ i ] [ j ] = 0 ; } } } if ( res_length > 0 ) { for ( i = index - res_length + 1 ; i <= index ; i ++ ) { res += str . charAt ( i - 1 ) ; } } return res ; }

def longestRepeatedSubstring ( str ) : n = len ( str ) LCSRe = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] res = "" res_length = 0 index = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) : LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 if ( LCSRe [ i ] [ j ] > res_length ) : res_length = LCSRe [ i ] [ j ] index = max ( i , index ) else : LCSRe [ i ] [ j ] = 0 if ( res_length > 0 ) : for i in range ( index - res_length + 1 , index + 1 ) : res = res + str [ i - 1 ] return res

def longestRepeatedSubstring ( str ) : LCSRe = [ 0 for i in range ( n ) ] for j in range ( i + 1 , n ) : if ( str [ i - 1 ] == str [ j - 1 ] ) : LCSRe [ i ] [ j ] = 1 elif ( str [ i - 1 ] == str [ j - 1 ] ) : LCSRe [ i ] [ j ] = ( j - i ) else : res_length = LCSRe [ i ] [ j ] = 0 res_length = LCSRe [ i ] [ j ] if ( res_length > 0 ) : res_length = LCSRe [ i ] [ j ] > 0 ) : res_length = LCSRe [ i ] [ j ] = 0 else : res += str [ i - 1 ] [ j - 1 ]

def longestRepeatedSubstring ( str ) : LCSRe [ ] [ ] = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : for j in range ( i + 1 , n ) : if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) : LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 if LCSRe [ i ] [ j ] > res_length : res_length = LCSRe [ i ] [ j ] index = max ( i , index ) return res

49.36
41.59
84.1
69.6
static float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }

def correlationCoefficient ( X , Y , n ) : sum_X = 0 sum_Y = 0 sum_XY = 0 squareSum_X = 0 squareSum_Y = 0 i = 0 while i < n : sum_X = sum_X + X [ i ] sum_Y = sum_Y + Y [ i ] sum_XY = sum_XY + X [ i ] * Y [ i ] squareSum_X = squareSum_X + X [ i ] * X [ i ] squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] i = i + 1 corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) return corr

def correlationCoefficient ( X , Y , n ) : sum_X = 0 sum_Y = 0 sum_XY = 0 squareSum_X = 0 squareSum_Y = 0 for i in range ( n ) : sum_X = sum_X + X [ i ] sum_Y = sum_Y + Y [ i ] sum_XY = sum_XY + X [ i ] * Y [ i ] squareSum_X = squareSum_X + Y [ i ] * X [ i ] squareSum_Y = squareSum_Y = squareSum_Y = squareSum_X + sum_Y * sum_X squareSum_Y = squareSum_Y + sum_Y * sum_X return corr

def correlationCoefficient ( X , Y , n ) : sum_X = 0 sum_Y = 0 sum_XY = 0 sum_X = 0 sum_Y = 0 sum_X = 0 sum_Y = 0 sum_XY = 0 squareSum_X = 0 squareSum_Y = 0 for i in range ( n ) : sum_X = sum_X + X [ i ] sum_Y = sum_Y + Y [ i ] sum_XY = sum_XY + X [ i ] * Y [ i ] squareSum_X = squareSum_X + X [ i ] * X [ i ] squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) return corr

49.36
44.94
52.47
48.0
static void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + " " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; System . out . print ( binom + " " ) ; } System . out . println ( ) ; } }

def printbinomial ( max ) : for m in range ( max + 1 ) : print ( '%2d' % m , end = '' ) binom = 1 for x in range ( m + 1 ) : if m != 0 and x != 0 : binom = binom * ( m - x + 1 ) / x print ( '%4d' % binom , end = '' ) print ( "\n" , end = '' )

def printbinomial ( max ) : for m in range ( max ) : print ( m , end = "" ) for x in range ( 0 , max ) : print ( x , end = "" ) binom = 1 for m in range ( 0 , max ) : if ( m != 0 ) : binom = binom * ( m - x + 1 ) / x print ( binom ) if ( x != 0 ) : binom = binom * m -

def printbinomial ( max ) : for m in range ( max ) : binom = 1 for x in range ( 0 , max ) : if m != 0 and x != 0 : binom = binom * ( m - x + 1 ) / x print ( binom + " " )

49.39
35.65
63.15
46.67
static void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }

def rearrange ( a , size ) : positive = 0 negative = 1 while ( True ) : while ( positive < size and a [ positive ] >= 0 ) : positive = positive + 2 while ( negative < size and a [ negative ] <= 0 ) : negative = negative + 2 if ( positive < size and negative < size ) : temp = a [ positive ] a [ positive ] = a [ negative ] a [ negative ] = temp else : break

def rearrange ( a , size ) : positive = 0 negative = 1 temp = a [ positive ] a [ positive ] = a [ negative ] temp = a [ positive ] a [ negative ] = temp positive = 1 negative = 0 while ( positive < size && negative < size ) : temp = a [ positive ] a [ positive ] = a [ negative ] a [ negative ] = temp positive = 1 temp = a [ positive ] a [ positive ] = a [ negative ] if temp

def rearrange ( a , size ) : positive = 0 negative = 1 while True : while True : while positive < size and a [ positive ] >= 0 : positive += 2 while negative < size and a [ negative ] <= 0 : negative += 2 if positive < size and a [ negative ] <= 0 : temp = a [ positive ] a [ positive ] = a [ negative ] a [ negative ] = temp

49.39
46.39
67.35
65.32
static int pageFaults ( int pages [ ] , int n , int capacity ) { HashSet < Integer > s = new HashSet < > ( capacity ) ; Queue < Integer > indexes = new LinkedList < > ( ) ; int page_faults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( ! s . contains ( pages [ i ] ) ) { s . add ( pages [ i ] ) ; page_faults ++ ; indexes . add ( pages [ i ] ) ; } } else { if ( ! s . contains ( pages [ i ] ) ) { int val = indexes . peek ( ) ; indexes . poll ( ) ; s . remove ( val ) ; s . add ( pages [ i ] ) ; indexes . add ( pages [ i ] ) ; page_faults ++ ; } } } return page_faults ; }

def pageFaults ( pages , n , capacity ) : s = set ( ) indexes = Queue ( ) page_faults = 0 for i in range ( n ) : if ( len ( s ) < capacity ) : if ( pages [ i ] not in s ) : s . add ( pages [ i ] ) page_faults += 1 indexes . put ( pages [ i ] ) else : if ( pages [ i ] not in s ) : val = indexes . queue [ 0 ] indexes . get ( ) s . remove ( val ) s . add ( pages [ i ] ) indexes . put ( pages [ i ] ) page_faults += 1 return page_faults

def pageFaults ( pages , n , capacity ) : s = set ( ) indexes = set ( ) for i in range ( n ) : if ( s . contains ( pages [ i ] ) ) : s . add ( pages [ i ] ) page_faults += 1 elif ( s . size ( ) < capacity ) : s . remove ( pages [ i ] ) page_faults += 1 indexes . add ( pages [ i ] ) else : page_faults +=

def pageFaults ( pages , n , capacity ) : s = list ( ) indexes = list ( ) page_faults = 0 for i in range ( n ) : if ( s . size ( ) < capacity ) : if ( not s . contains ( pages [ i ] ) ) : s . add ( pages [ i ] ) page_faults ++ indexes . add ( pages [ i ] ) else : if ( not s . contains ( pages [ i ] ) ) : val = indexes . peek ( ) indexes . poll ( ) s . remove ( val ) s . add ( pages [ i ] ) indexes . add ( pages [ i ] ) page_faults ++ return page_faults

49.42
43.45
47.72
38.53
static void findDivision ( String str , int a , int b ) { int len = str . length ( ) ; int [ ] lr = new int [ len + 1 ] ; lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a ; for ( int i = 1 ; i < len ; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str . charAt ( i ) - ( int ) '0' ) ) % a ; int [ ] rl = new int [ len + 1 ] ; rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int ) '0' ) % b ; int power10 = 10 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i ) - ( int ) '0' ) * power10 ) % b ; power10 = ( power10 * 10 ) % b ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { System . out . println ( "YES" ) ; for ( int k = 0 ; k <= i ; k ++ ) System . out . print ( str . charAt ( k ) ) ; System . out . print ( ", " ) ; for ( int k = i + 1 ; k < len ; k ++ ) System . out . print ( str . charAt ( k ) ) ; return ; } } System . out . println ( "NO" ) ; }

def findDivision ( str , a , b ) : lenn = len ( str ) lr = [ 0 ] * ( lenn + 1 ) lr [ 0 ] = ( int ( str [ 0 ] ) ) % a for i in range ( 1 , lenn ) : lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str [ i ] ) ) % a rl = [ 0 ] * ( lenn + 1 ) rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b power10 = 10 for i in range ( lenn - 2 , - 1 , - 1 ) : rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b power10 = ( power10 * 10 ) % b for i in range ( 0 , lenn - 1 ) : if ( lr [ i ] != 0 ) : continue if ( rl [ i + 1 ] == 0 ) : print ( "YES" ) for k in range ( 0 , i + 1 ) : print ( str [ k ] , end = "" ) print ( "," , end = "" ) for i in range ( i + 1 , lenn ) : print ( str [ k ] , end = "" ) return print ( "NO" )

def findDivision ( str , a , b ) : lr = [ 0 for k in range ( len ) ] rl = [ len + 1 ] for i in range ( len ) : lr [ i ] = ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str [ i ] - ( int ) '0' ) * power10 ) % b rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str [ i ] ) * power10 ) % b ) power10 = ( power10 * 10 ) % b for i in range ( len - 2 , len - 1 ) : rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str [ i ] - ( int ) '0' ) * power10 ) % b ) power10 = ( power10 * 10 ) % b for i in range ( len - 1 , len ) : if ( rl [ i + 1 ] == 0 ) : print ( str [ k ] ) : print ( "YES" ) print ( "NO" ) continue if ( rl [ i + 1 ] == 0 ) : print ( "NO" ) continue if ( rl [ i + 1 ] == 0 )

def findDivision ( str , a , b ) : lr = [ 0 for k in range ( len ) ] lr [ i ] = ( lr [ i - 1 ] * 10 ) % a for i in range ( 1 , len ) : lr [ i ] = ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str [ i ] - ( int ) '0' ) % b power10 = 10 for i in range ( len - 2 , - 1 ) : rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str [ i ] - ( int ) '0' ) * power10 ) % b power10 = ( power10 * 10 ) % b for i in range ( len - 2 , - 1 ) : rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str [ i ] - ( int ) '0' ) * power10 ) % b power10 = ( power10 * 10 ) % b for i in range ( len - 2 , - 1 ) : rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str [ i ] - ( int ) '0' ) * power10 )

49.43
42.8
55.68
43.41
static int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int mod_arr [ ] = new int [ n ] ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( um . containsKey ( mod_arr [ i ] ) == false ) um . put ( mod_arr [ i ] , i ) ; else if ( max < ( i - um . get ( mod_arr [ i ] ) ) ) max = i - um . get ( mod_arr [ i ] ) ; } return max ; }

def longSubarrWthSumDivByK ( arr , n , k ) : um = { i : 0 for i in range ( 8 ) } mod_arr = [ 0 for i in range ( n ) ] max = 0 curr_sum = 0 for i in range ( n ) : curr_sum += arr [ i ] mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k for i in range ( n ) : if ( mod_arr [ i ] == 0 ) : max = i + 1 elif ( mod_arr [ i ] in um ) : um [ mod_arr [ i ] ] = i else : if ( max < ( i - um [ mod_arr [ i ] ] ) ) : max = i - um [ mod_arr [ i ] ] return max

def longSubarrWthSumDivByK ( arr , n , k ) : um = { } mod_arr = [ 0 for i in range ( n ) ] curr_sum = 0 for i in range ( n ) : if ( arr [ i ] == 0 ) : max = i + 1 else : um . put ( mod_arr [ i ] , i ) if ( max < ( i - um . get ( mod_arr [ i ] ) ) : max = i - um [ mod_arr [ i ] ) ) : max = i - um [ mod_arr [ i ] ) : max = i - um [ mod_arr [ i ] ) else : max = i - um [ mod_arr [ i ] ) : um . put ( mod_arr [ i ] , i ) else : if ( max < ( i - um [ mod_arr [ i ] ) ) : max = i - um [ mod_arr [ i ] ) ) : max = i - um [ mod_arr [ i ] ) return max

def longSubarrWthSumDivByK ( arr , n , k ) : um = list ( ) for i in range ( n ) : curr_sum += arr [ i ] mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k max = 0 for i in range ( n ) : if ( mod_arr [ i ] == 0 ) : max = i + 1 else : if ( um . containsKey ( mod_arr [ i ] ) == False ) : um . put ( mod_arr [ i ] , i ) else : max = i - um . get ( mod_arr [ i ] ) return max

49.44
53.26
35.24
49.38
static void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( " Frequency of odd number =" + odd + " \n" ) ; System . out . print ( " Frequency of even number = " + even + " \n" ) ; }

def freq ( ar , m , n ) : even = 0 odd = 0 for i in range ( m ) : for j in range ( n ) : if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : even += 1 else : odd += 1 print ( "Frequencyofoddnumber=" , odd ) print ( "Frequencyofevennumber=" , even )

def freq ( ar , m , n ) : even = 0 odd = 0 for i in range ( m , n ) : if ( ar [ i ] [ j ] % 2 == 0 ) : even = 1 odd = 0 for j in range ( n ) : if ( ar [ i ] [ j ] % 2 == 0 ) : odd = 1 print ( " Frequency of even number =" + even + " \n" ) print ( " Frequency of odd number =

def freq ( ar , m , n ) : even = 0 odd = 0 for i in range ( m ) : for j in range ( n ) : if ( ar [ i ] [ j ] % 2 ) == 0 : even = float ( ar [ i ] [ j ] ) elif ( ar [ i ] [ j ] % 2 ) == 0 : odd = float ( ar [ i ] [ j ] ) elif ( ar [ i ] [ j ] % 2 ) == 0 : even = float ( ar [ i ] [ j ] ) else : odd = float ( ar [ i ] [ j ] ) print ( " Frequency of odd number =" + odd + " \n" )

49.5
41.2
63.85
46.86
static void solve ( int n , int t , char s [ ] ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } System . out . print ( s ) ; }

def solve ( n , t , p ) : s = list ( p ) for i in range ( 0 , t ) : for j in range ( 0 , n - 1 ) : if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) : temp = s [ j ] s [ j ] = s [ j + 1 ] s [ j + 1 ] = temp j = j + 1 print ( '' . join ( s ) )

def solve ( n , t , s ) : s . sort ( reverse = True ) for i in range ( 0 , n , t ) : if ( s [ i ] == 'G' ) : s [ i ] = s [ j + 1 ] j += 1 else : s [ i ] = s [ j ] s [ j + 1 ] = temp s [ j ] = s [ j + 1 ] j += 1 if ( s [ j ] == 'B' ) : s [ j ] = s [ j + 1 ] == 'G' ) : s [ j ] = temp return s

def solve ( n , t , s ) : for i in range ( t ) : for j in range ( n ) : if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) : temp = s [ j ] s [ j ] = s [ j + 1 ] s [ j + 1 ] = temp j += 1

49.5
42.52
71.44
59.0
static int largestKSubmatrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }

def largestKSubmatrix ( a ) : dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] result = 0 for i in range ( Row ) : for j in range ( Col ) : if ( i == 0 or j == 0 ) : dp [ i ] [ j ] = 1 else : if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 else : dp [ i ] [ j ] = 1 result = max ( result , dp [ i ] [ j ] ) return result

def largestKSubmatrix ( a , Row , Col ) : dp = [ INT_MAX for i in range ( Row , Col ) ] for j in range ( 0 , Col ) : if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] and dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = 1 dp [ i ] [ j - 1 ] [ j ] > dp [ i - 1 ] [ j ] + 1 ] dp [ i - 1 ] [ j ] = dp [

def largestKSubmatrix ( a ) : dp = [ 0 for i in range ( Row ) ] result = 0 for i in range ( Row , Col ) : if ( i == 0 or j == 0 ) : dp [ i ] [ j ] = 1 else : if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] and dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i ] [ j - 1 ] + 1 else : dp [ i ] [ j ] = 1 result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ] return result

49.57
36.51
51.46
41.3
static int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }

def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 if ( dp [ position ] [ previous_sum ] != - 1 ) : return dp [ position ] [ previous_sum ] dp [ position ] [ previous_sum ] = 0 res = 0 sum = 0 for i in range ( position , length ) : sum += ( ord ( num [ i ] ) - ord ( '0' ) ) if ( sum >= previous_sum ) : res += countGroups ( i + 1 , sum , length , num ) dp [ position ] [ previous_sum ] = res return res

def countGroups ( position , previous_sum , length , dp ) : dp . sort ( reverse = True ) res = 0 for i in range ( position , length ) : sum += ( num [ i ] - '0' ) dp [ position ] [ previous_sum ] = res res += countGroups ( position , previous_sum , length , dp ) : if ( sum >= previous_sum ) : res += countGroups ( i + 1 , sum , length , num ) return res

def countGroups ( position , previous_sum , length , num ) : dp = { } for k in range ( position , length ) : sum = 0 for i in range ( position , length ) : sum += ( num [ i ] - '0' ) if ( sum >= previous_sum ) : res += countGroups ( i + 1 , sum , length , num ) dp [ position ] [ previous_sum ] = res return res

49.57
43.99
94.25
70.5
static pair mirrorImage ( double a , double b , double c , double x1 , double y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return new pair ( x , y ) ; }

def mirrorImage ( a , b , c , x1 , y1 ) : temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) x = temp * a + x1 y = temp * b + y1 return ( x , y )

def mirrorImage ( a , b , c , x1 , y1 ) : temp = - 2 * ( a * x1 + b * y1 + c ) return new pair ( x , y )

def mirrorImage ( a , b , c , x1 , y1 ) : temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) x = temp * a + x1 y = temp * b + y1 return new pair ( x , y )

49.59
42.48
58.27
46.6
static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }

def countFriendsPairings ( n ) : a , b , c = 1 , 2 , 0 if ( n <= 2 ) : return n for i in range ( 3 , n + 1 ) : c = b + ( i - 1 ) * a a = b b = c return c

def countFriendsPairings ( n ) : a = 1 b = 2 c = 0 for i in range ( 3 , n ) : c = b + ( i - 1 ) * a b = c return c

def countFriendsPairings ( n ) : a = 1 b = 2 c = 0 for i in range ( 3 , n ) : c = b + ( i - 1 ) * a a = b b = c return c

49.6
50.23
47.39
33.25
static void printkthnode ( Vector < pair > adj [ ] , int wt [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) Collections . sort ( adj [ i ] , new Comparator < pair > ( ) { public int compare ( pair p1 , pair p2 ) { return p1 . first - p2 . first ; } } ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) System . out . print ( adj [ i ] . get ( adj [ i ] . size ( ) - k ) . second + " " ) ; else System . out . print ( "-1" ) ; } }

def printkthnode ( adj , wt , n , k ) : for i in range ( n ) : adj [ i ] . sort ( ) for i in range ( n ) : if ( len ( adj [ i ] ) >= k ) : print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = "" ) else : print ( "-1" , end = "" )

def printkthnode ( adj , wt , n , k ) : adj . sort ( reverse = True ) wt . sort ( reverse = True ) for i in range ( 0 , n , k ) : if ( adj [ i ] [ 0 ] . size ( ) >= k ) : print ( adj [ i ] [ 0 ] [ adj [ i ] [ 0 ] . size ( ) - k ] . second + " " ) else : print ( "-1" )

def printkthnode ( adj , wt , n , k ) : for i in range ( n ) : if adj [ i ] . size ( ) >= k : print ( adj [ i ] [ adj [ i ] . size ( ) - k ] . second + " " ) else : print ( "-1" )

49.61
36.05
62.29
55.17
static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += str . charAt ( i ) - '0' ; return ( sum == n - 1 || sum == 1 ) ; }

def isOneFlip ( str ) : sum = 0 n = len ( str ) for i in range ( 0 , n ) : sum += int ( str [ i ] ) - int ( '0' ) return ( sum == n - 1 or sum == 1 )

def isOneFlip ( str ) : sum = 0 for i in range ( n ) : sum += str [ i ] - '0' if ( sum == n - 1 ) : return ( sum == 1 )

def isOneFlip ( str ) : sum = 0 n = str . length ( ) for i in range ( n ) : sum += str [ i ] - '0' return ( sum == n - 1 or sum == 1 )

49.74
42.41
71.98
54.9
static int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }

def findMinX ( num , rem , k ) : x = 1 while ( True ) : j = 0 while ( j < k ) : if ( x % num [ j ] != rem [ j ] ) : break j += 1 if ( j == k ) : return x x += 1

def findMinX ( num , rem , k ) : x = 1 for j in range ( 0 , k ) : if ( x % num [ j ] != rem [ j ] ) : break return x

def findMinX ( num , rem , k ) : x = 1 while True : for j in range ( k ) : if ( x % num [ j ] != rem [ j ] ) : break if ( j == k ) : return x x += 1 return x

49.78
32.97
55.1
37.34
static boolean check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { deg_sum += degree [ i ] ; } return ( 2 * ( n - 1 ) == deg_sum ) ; }

def check ( degree , n ) : deg_sum = sum ( degree ) if ( 2 * ( n - 1 ) == deg_sum ) : return True else : return False

def check ( degree , n ) : deg_sum = 0 for i in range ( n ) : deg_sum += degree [ i ] if ( 2 * n == deg_sum ) : return ( n - 1 ) == deg_sum

def check ( degree , n ) : deg_sum = 0 for i in range ( n ) : deg_sum += degree [ i ] return ( 2 * ( n - 1 ) == deg_sum )

49.83
55.43
65.54
53.87
static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }

def countPairsWithDiffK ( arr , n , k ) : count = 0 arr . sort ( ) l = 0 r = 0 while r < n : if arr [ r ] - arr [ l ] == k : count += 1 l += 1 r += 1 elif arr [ r ] - arr [ l ] > k : l += 1 else : r += 1 return count

def countPairsWithDiffK ( arr , n , k ) : count = 0 l = 0 r = 0 while ( r < n ) : if ( arr [ r ] - arr [ l ] == k ) : count ++ l += 1 elif ( arr [ r ] - arr [ l ] > k ) : r += 1 else : if ( arr [ r ] - arr [ l ] < k ) : l += 1 else : r += 1 if ( arr [ r ] - arr [ l ] > k ) : count += 1 return count

def countPairsWithDiffK ( arr , n , k ) : count = 0 for r in range ( n ) : if ( arr [ r ] - arr [ l ] == k ) : count ++ l += 1 r += 1 elif ( arr [ r ] - arr [ l ] > k ) : l += 1 else : r += 1 return count

49.86
38.57
62.28
51.91
static boolean isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } } return subset [ sum ] [ n ] ; }

def isSubsetSum ( set , n , sum ) : subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) for i in range ( n + 1 ) : subset [ i ] [ 0 ] = True for i in range ( 1 , sum + 1 ) : subset [ 0 ] [ i ] = False for i in range ( 1 , n + 1 ) : for j in range ( 1 , sum + 1 ) : if j < set [ i - 1 ] : subset [ i ] [ j ] = subset [ i - 1 ] [ j ] if j >= set [ i - 1 ] : subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) return subset [ n ] [ sum ]

def isSubsetSum ( set , n , sum ) : subset = [ False for i in range ( sum + 1 , n + 1 ) ] for i in range ( 1 , sum ) : subset [ i ] [ j ] = subset [ i ] [ j - 1 ] if ( i >= set [ j - 1 ] ) : subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] if ( i >= set [ j - 1 ] ) : subset [ i ] [ j ] = subset [ i ] [ j - 1 ] if ( i >= set [ j - 1 ] ) : subset [ i ] [ j ] = subset [ i ] [ j ] return subset [ sum ] [ n ]

def isSubsetSum ( set , n , sum ) : subset [ ] = [ True for i in range ( sum ) ] for i in range ( sum + 1 , n + 1 ) : subset [ 0 ] [ i ] = True for i in range ( 1 , sum ) : subset [ i ] [ 0 ] = False for i in range ( 1 , sum ) : for j in range ( 1 , n ) : subset [ i ] [ j ] = subset [ i ] [ j - 1 ] if ( i >= set [ j - 1 ] ) : subset [ i ] [ j ] = subset [ i ] [ j ] or subset [ i - set [ j - 1 ] ] [ j - 1 ] return subset [ sum ] [ n ]

49.95
41.0
37.45
39.62
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { int p = i - 1 ; System . out . println ( "Sum found between indexes " + start + " and " + p ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } System . out . println ( "No subarray found" ) ; return 0 ; }

def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] start = 0 i = 1 while i <= n : while curr_sum > sum and start < i - 1 : curr_sum = curr_sum - arr [ start ] start += 1 if curr_sum == sum : print ( "Sumfoundbetweenindexes" ) print ( "%dand%d" % ( start , i - 1 ) ) return 1 if i < n : curr_sum = curr_sum + arr [ i ] i += 1 print ( "Nosubarrayfound" ) return 0

def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] for i in range ( 1 , n ) : while ( curr_sum > sum && start < i - 1 ) : curr_sum = curr_sum - arr [ start ] start += 1 if ( curr_sum == sum ) : p = i - 1 else : curr_sum = curr_sum + arr [ i ] if ( i < n ) curr_sum =

def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] start = 0 for i in range ( 1 , n ) : while ( curr_sum > sum and start < i - 1 ) : curr_sum = curr_sum - arr [ start ] start ++ if ( curr_sum == sum ) : p = i - 1 System . out . println ( "Sum found between indexes " + start + " and " + p ) return 1 if ( curr_sum == sum ) : p = i - 1 System . out . println ( "Sum found between indexes " + start + " and " + p ) return 1 return 0

49.96
33.31
47.38
32.88
private static void findCount ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; }

def findCount ( n , sum ) : start = math . pow ( 10 , n - 1 ) end = math . pow ( 10 , n ) - 1 count = 0 i = start while ( i <= end ) : cur = 0 temp = i while ( temp != 0 ) : cur += temp % 10 temp = temp // 10 if ( cur == sum ) : count = count + 1 i += 9 else : i = i + 1 print ( count )

def findCount ( n , sum ) : start = 1 end = ( int ) Math . pow ( 10 , n - 1 ) for i in range ( start , end ) : cur = 0 temp = i while ( temp != 0 ) : cur += temp / 10 i += temp if ( cur == sum ) : count ++ ; i += 9 else : i += 1

def findCount ( n , sum ) : count = 0 i = start while i < end : cur = 0 for k in range ( n ) : cur += k [ 0 ] temp = i while ( temp != 0 ) : cur += temp % 10 temp = temp / 10 if ( cur == sum ) : count ++ i += 9 else : i += ++

49.97
49.98
65.65
59.22
static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }

def maximumSumSubarray ( arr , n ) : min_prefix_sum = 0 res = - math . inf prefix_sum = [ ] prefix_sum . append ( arr [ 0 ] ) for i in range ( 1 , n ) : prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) for i in range ( n ) : res = max ( res , prefix_sum [ i ] - min_prefix_sum ) min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) return res

def maximumSumSubarray ( arr , n ) : prefix_sum = [ 0 for k in range ( n ) ] for i in range ( n ) : prefix_sum [ i ] = arr [ i ] min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) res = max ( res , prefix_sum [ i ] - min_prefix_sum ) min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) min_prefix_sum = prefix_sum [ i ] for i in range ( n ) : res = max ( res , prefix_sum [ i ] - min_prefix_sum ) min_prefix_sum = max ( min_prefix_sum , prefix_sum [ i ] ) return res

def maximumSumSubarray ( arr , n ) : min_prefix_sum = 0 res = float ( 'inf' ) prefix_sum = [ 0 ] for i in range ( 1 , n ) : prefix_sum [ i ] = arr [ 0 ] for i in range ( 1 , n ) : prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] for i in range ( 0 , n ) : res = max ( res , prefix_sum [ i ] - min_prefix_sum ) min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) return res

49.98
38.96
84.32
66.87
public static long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }

def countBT ( h ) : MOD = 1000000007 dp = [ 0 for i in range ( h + 1 ) ] dp [ 0 ] = 1 dp [ 1 ] = 1 for i in range ( 2 , h + 1 ) : dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD return dp [ h ]

def countBT ( h ) : dp = [ 0 for i in range ( h ) ] for i in range ( 2 , h + 1 ) : dp [ i ] = ( dp [ i - 1 ] * dp [ i - 2 ] ) % MOD return dp [ h ]

def countBT ( h ) : dp = [ 1 for i in range ( h ) ] dp [ 0 ] = 1 dp [ 1 ] = 1 for i in range ( 2 , h ) : dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD return dp [ h ]

50.02
38.5
76.38
53.18
static double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }

def gcd ( a , b ) : if ( a < b ) : return gcd ( b , a ) if ( abs ( b ) < 0.001 ) : return a else : return ( gcd ( b , a - math . floor ( a / b ) * b ) )

def gcd ( b , a ) : if ( a > b ) : return gcd ( b , a ) else : return gcd ( b , a - Math . floor ( a / b ) * b )

def gcd ( a , b ) : if a < b : return gcd ( b , a ) if abs ( b ) < 0.001 : return a else : return ( gcd ( b , a - Math . floor ( a / b ) * b ) )

50.03
48.94
58.14
53.21
int countSubStr ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }

def countSubStr ( st , n ) : m = 0 for i in range ( 0 , n ) : if ( st [ i ] == '1' ) : m = m + 1 return m * ( m - 1 ) // 2

def countSubStr ( str , n ) : m = 0 for i in range ( n ) : if ( str [ i ] == '1' ) : m += 1 return m

def countSubStr ( str , n ) : m = 0 for i in range ( n ) : if str [ i ] == '1' : m += 1 return m * ( m - 1 ) / 2

50.09
44.36
51.81
56.86
static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) s . add ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ; if ( j != n ) continue ; System . out . print ( i + ", " ) ; } }

def permutatedRows ( mat , m , n , r ) : s = set ( ) for j in range ( n ) : s . add ( mat [ r ] [ j ] ) for i in range ( m ) : if i == r : continue for j in range ( n ) : if mat [ i ] [ j ] not in s : j = j - 2 break if j + 1 != n : continue print ( i )

def permutatedRows ( mat , m , n , r ) : s = set ( ) for j in range ( 0 , n ) : if ( s . contains ( mat [ r ] [ j ] ) ) : break if ( j != n ) : continue print ( i + ", " ) print ( j + ", " ) print ( mat [ i ] [ j ] )

def permutatedRows ( mat , m , n , r ) : s = list ( ) for i in range ( m ) : if ( i == r ) : continue , j for j in range ( n ) : if ( not s . contains ( mat [ i ] [ j ] ) ) : break if ( j != n ) : continue print ( i + ", " )

50.14
41.52
38.66
36.64
public static int MinimumCost ( int cost [ ] , int n , int W ) { Vector < Integer > val = new Vector < Integer > ( ) ; Vector < Integer > wt = new Vector < Integer > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt . get ( i - 1 ) ] + val . get ( i - 1 ) ) ; } } return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? - 1 : min_cost [ n ] [ W ] ; }

def MinimumCost ( cost , n , W ) : val = list ( ) wt = list ( ) size = 0 for i in range ( n ) : if ( cost [ i ] != - 1 ) : val . append ( cost [ i ] ) wt . append ( i + 1 ) size += 1 n = size min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] for i in range ( W + 1 ) : min_cost [ 0 ] [ i ] = INF for i in range ( 1 , n + 1 ) : min_cost [ i ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , W + 1 ) : if ( wt [ i - 1 ] > j ) : min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] else : min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) if ( min_cost [ n ] [ W ] == INF ) : return - 1 else : return min_cost [ n ] [ W ]

def MinimumCost ( cost , n , W ) : val = new Vector < Integer > ( ) wt = new Vector < Integer > ( ) size = 0 for i in range ( n , W ) : if ( cost [ i ] != - 1 ) : val . add ( cost [ i ] ) size += 1 for i in range ( n , W ) : if ( wt [ i ] > j ) : min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] += val [ i - 1 ] + val . get ( i - 1 ) else : min_cost [ i ] = min_cost [ i ] [ j ] if ( val [ i - 1 ] > j ) : min_cost [ i ] [ j ] = min_cost [ i ] [ j - wt . get ( i - 1 ) > j ) : min_cost [ i ] [ j ] = min_cost [ i ] [ j ] + val [ i - 1 ] return min_cost [ n ] [ W ]

def MinimumCost ( cost , n , W ) : val = list ( ) wt = list ( ) size = 0 for i in range ( n + 1 , W + 1 ) : if ( cost [ i ] != - 1 ) : val . add ( cost [ i ] ) wt . add ( i + 1 ) size += 1 min_cost [ i ] [ W ] = 0 for i in range ( 1 , n ) : min_cost [ i ] [ 0 ] = 0 for i in range ( 1 , n ) : if ( cost [ i ] != - 1 ) : val . add ( cost [ i ] ) wt . add ( i + 1 ) size += 1 return ( min_cost [ n ] [ W ] == defMinimumCost ( cost , n , W ) )

50.14
39.88
63.78
46.89
static void printMaxSubSquare ( int M [ ] [ ] ) { int i , j ; int R = M . length ; int C = M [ 0 ] . length ; int S [ ] [ ] = new int [ R ] [ C ] ; int max_of_s , max_i , max_j ; for ( i = 0 ; i < R ; i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ] ; for ( j = 0 ; j < C ; j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ] ; for ( i = 1 ; i < R ; i ++ ) { for ( j = 1 ; j < C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 ; else S [ i ] [ j ] = 0 ; } } max_of_s = S [ 0 ] [ 0 ] ; max_i = 0 ; max_j = 0 ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( max_of_s < S [ i ] [ j ] ) { max_of_s = S [ i ] [ j ] ; max_i = i ; max_j = j ; } } } System . out . println ( "Maximum size sub-matrix is: " ) ; for ( i = max_i ; i > max_i - max_of_s ; i -- ) { for ( j = max_j ; j > max_j - max_of_s ; j -- ) { System . out . print ( M [ i ] [ j ] + " " ) ; } System . out . println ( ) ; } }

def printMaxSubSquare ( M ) : R = len ( M ) C = len ( M [ 0 ] ) S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ] for i in range ( 1 , R ) : for j in range ( 1 , C ) : if ( M [ i ] [ j ] == 1 ) : S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1 else : S [ i ] [ j ] = 0 max_of_s = S [ 0 ] [ 0 ] max_i = 0 max_j = 0 for i in range ( R ) : for j in range ( C ) : if ( max_of_s < S [ i ] [ j ] ) : max_of_s = S [ i ] [ j ] max_i = i max_j = j print ( "Maximumsizesub-matrixis:" ) for i in range ( max_i , max_i - max_of_s , - 1 ) : for j in range ( max_j , max_j - max_of_s , - 1 ) : print ( M [ i ] [ j ] , end = "" ) print ( "" )

def printMaxSubSquare ( M ) : S = [ 0 for k in range ( R , C ) ] for i in range ( R , C ) : S [ i ] = [ 0 for k in range ( R , C ) ] for j in range ( 0 , C ) : if ( M [ i ] [ j ] == 1 ) : S [ i ] [ j ] = min ( S [ i ] [ j ] , S [ i - 1 ] [ j - 1 ] ) else : S [ i ] [ j ] = min ( S [ i ] [ j ] ) max_of_s = S [ i ] [ j ] if ( max_of_s < S [ i ] [ j ] ) : max_of_s = S [ i ] [ j ] if ( max_of_s < S [ i ] [ j ] : max_of_s = S [ i ] [ j ] ) max_j = 0 else : max_of_s = 1 max_of_s = S [ i ] [ j ] max_of_s = S [ i ] [ j ] if ( max_of_s > S [ i ] [ j ] ) : max

def printMaxSubSquare ( M , S ) : S [ i ] . sort ( reverse = True ) max_of_s = S [ 0 ] [ 0 ] max_i = 0 max_j = 0 for i in range ( 0 , R , C ) : for j in range ( 1 , C ) : if ( M [ i ] [ j ] == 1 ) : S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 else : S [ i ] [ j ] = 0 } max_of_s = S [ 0 ] [ 0 ] max_i = 0 max_j = 0 for i in range ( 0 , R , C ) : for j in range ( 1 , C ) : if ( max_of_s < S [ i ] [ j ] ) : max_of_s = S [ i ] [ j ] max_i = 0 max_j = 0 for j in range ( 1 , C ) : if ( max_of_s < S [ i ] [ j ] ) : max

50.15
43.57
60.31
54.07
static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }

def minimumCostOfBreaking ( X , Y , m , n ) : res = 0 X . sort ( reverse = True ) Y . sort ( reverse = True ) hzntl = 1 vert = 1 i = 0 j = 0 while ( i < m and j < n ) : if ( X [ i ] > Y [ j ] ) : res += X [ i ] * vert hzntl += 1 i += 1 else : res += Y [ j ] * hzntl vert += 1 j += 1 total = 0 while ( i < m ) : total += X [ i ] i += 1 res += total * vert total = 0 while ( j < n ) : total += Y [ j ] j += 1 res += total * hzntl return res

def minimumCostOfBreaking ( X , Y , m , n ) : res = 0 for i in range ( m , n ) : res += X [ i ] * vert hzntl = 1 vert = 1 while i < m and j < n : if ( X [ i ] > Y [ j ] ) : res += X [ i ] * hzntl vert += 1 i += 1 elif ( Y [ j ] > X [ i ] ) : res += Y [ j ] * hzntl = 1 if ( Y [ j ] > Y [ j ] ) : res += Y [ j ] * hzntl hzntl += Y [ j ] * vert return res

def minimumCostOfBreaking ( X , Y , m , n ) : res = 0 hzntl = 1 vert = 1 i = 0 j = 0 while i < m and j < n : if ( X [ i ] > Y [ j ] ) : res += X [ i ] * vert hzntl ++ i += 1 else : res += Y [ j ] * hzntl vert += i j += 1 total = 0 while ( i < m ) : total += X [ i ++ ] res += total * vert total = 0 while ( j < n ) : total += Y [ j ++ ] res += total * hzntl total = 0 while ( i < m ) : total += X [ i ++ ] res += total * vert total = 0 while ( j < n ) : total += Y [ j ++ ] res += total * hzntl total = 0 while ( j < n ) : total += Y [ j ++ ] res += total * hzntl return res

50.15
43.65
56.23
51.39
static int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }

def maxDifference ( arr , N , k ) : S = 0 S1 = 0 max_difference = 0 for i in range ( N ) : S += arr [ i ] arr . sort ( reverse = True ) M = max ( k , N - k ) for i in range ( M ) : S1 += arr [ i ] max_difference = S1 - ( S - S1 ) return max_difference

def maxDifference ( arr , N , k ) : S = 0 S1 = 0 for i in range ( 0 , N ) : S += arr [ i ] S1 = arr [ i ] max_difference = S1 - ( S - S1 ) return max_difference

def maxDifference ( arr , N , k ) : S = 0 S1 = 0 max_difference = 0 for i in range ( 0 , N , k ) : S += arr [ i ] if arr [ i ] < arr [ j ] : temp = arr [ i ] arr [ i ] = arr [ j ] arr [ j ] = temp max_difference = S1 - ( S - S1 ) return max_difference

50.2
40.73
60.56
47.35
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str . charAt ( i + k ) - '0' ) ; rightsum += ( str . charAt ( i + k + length / 2 ) - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }

def findLength ( str ) : n = len ( str ) maxlen = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n , 2 ) : length = j - i + 1 leftsum = 0 rightsum = 0 for k in range ( 0 , int ( length / 2 ) ) : leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) ) if ( leftsum == rightsum and maxlen < length ) : maxlen = length return maxlen

def findLength ( str ) : n = len ( str ) for i in range ( n ) : for j in range ( i + 1 , n ) : leftsum = 0 rightsum = 0 for k in range ( 0 , length / 2 ) : leftsum += ( str [ i + k ] - '0' ) rightsum += ( str [ i + k + length / 2 ] ) maxlen += length if ( leftsum == rightsum ) : maxlen = length

def findLength ( str ) : maxlen = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : length = j - i + 1 leftsum = 0 rightsum = 0 for k in range ( 0 , length ) : leftsum += ( str [ i + k ] - '0' ) rightsum += ( str [ i + k + length / 2 ] - '0' ) if ( leftsum == rightsum and maxlen < length ) : maxlen = length return maxlen

50.2
42.8
61.27
45.3
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" ) ; }

def printClosest ( ar1 , ar2 , m , n , x ) : diff = sys . maxsize l = 0 r = n - 1 while ( l < m and r >= 0 ) : if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : res_l = l res_r = r diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) if ar1 [ l ] + ar2 [ r ] > x : r = r - 1 else : l = l + 1 print ( "Theclosestpairis[" , ar1 [ res_l ] , "," , ar2 [ res_r ] , "]" )

def printClosest ( ar1 , ar2 , m , n , x ) : res_l = 0 res_r = 0 diff = float ( 'inf' ) for l in range ( m , n ) : if ( ar1 [ l ] + ar2 [ r ] - x ) < diff : res_l = l res_r = r diff = float ( 'inf' ) while ( l < m && r >= 0 ) : if ( ar1 [ l ] + ar2 [ r ] > x ) : diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : res_l = l res_r = r break if ( ar1 [ l ] + ar2 [ r ] > x ) : r -= 1 else : break print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" )

def printClosest ( ar1 , ar2 , m , n , x ) : diff = float ( 'inf' ) for l in range ( m , n ) : if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) : res_l = l res_r = r diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) if ( ar1 [ l ] + ar2 [ r ] > x ) : r -= 1 l += 1 else : r -= 1 print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" )

50.2
39.01
84.79
63.78
static void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + " " ) ; } }

def reverseFibonacci ( n ) : a = [ 0 ] * n a [ 0 ] = 0 a [ 1 ] = 1 for i in range ( 2 , n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] for i in range ( n - 1 , - 1 , - 1 ) : print ( a [ i ] , end = "" )

def reverseFibonacci ( n ) : a = [ 0 for k in range ( n ) ] for i in range ( n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] print ( a [ i ] ) i = n - 1 while i >= 0 : print ( a [ i ] + " " ) i -= 1 print ( a [ i ] ) i -= 1 print ( " \n " ) for i in range

def reverseFibonacci ( n ) : a . sort ( reverse = True ) a [ 0 ] = 0 a [ 1 ] = 1 for i in range ( 2 , n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] for i in range ( n - 1 , - 1 , - 1 ) : print ( a [ i ] )

50.2
41.46
100.0
100.0
static int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }

def perimeter ( diameter , height ) : return 2 * ( diameter + height )

def perimeter ( diameter , height ) : return diameter

def perimeter ( diameter , height ) : return 2 * ( diameter + height )

50.3
49.23
65.93
48.72
static void maxMin ( int arr [ ] [ ] , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } System . out . print ( "Maximum = " + max + ", Minimum = " + min ) ; }

def MAXMIN ( arr , n ) : MIN = 10 ** 9 MAX = - 10 ** 9 for i in range ( n ) : for j in range ( n // 2 + 1 ) : if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : if ( MIN > arr [ i ] [ n - j - 1 ] ) : MIN = arr [ i ] [ n - j - 1 ] if ( MAX < arr [ i ] [ j ] ) : MAX = arr [ i ] [ j ] else : if ( MIN > arr [ i ] [ j ] ) : MIN = arr [ i ] [ j ] if ( MAX < arr [ i ] [ n - j - 1 ] ) : MAX = arr [ i ] [ n - j - 1 ] print ( "MAXimum=" , MAX , ",MINimum=" , MIN )

def maxMin ( arr , n ) : min = + 2147483647 max = - 2147483647 for i in range ( n ) : for j in range ( n // 2 if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : min = arr [ i ] [ n - j - 1 ] if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] if ( min > arr [ i ] [ n - j - 1 ] ) : min = arr [ i ] [ n - j - 1 ] if ( max < arr [ i ] [ j ] ) : max = arr [ i ] [ j ] if ( max < arr [ i ] [ n - j - 1 ] ) : max = arr [ i ] [ j ] if ( max < arr [ i ] [ j ] ) : max = arr [ i ] [ j ] if ( min > arr [ i ] [ n - j - 1 ] ) : min = arr [ i ] [ n - j - 1 ] if ( max < arr [ i ] [ j ] ) : max = arr [ i ] [ j ] if ( max < arr [ i ]

def maxMin ( arr , n ) : min = + 2147483647 max = - 2147483648 for i in range ( n ) : if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : if ( min > arr [ i ] [ n - j - 1 ] ) : min = arr [ i ] [ n - j - 1 ] if ( max < arr [ i ] [ j ] ) : max = arr [ i ] [ j ] if ( max < arr [ i ] [ n - j - 1 ] ) : max = arr [ i ] [ n - j - 1 ] if ( min > arr [ i ] [ j ] ) : min = arr [ i ] [ j ] if ( max < arr [ i ] [ n - j - 1 ] ) : max = arr [ i ] [ n - j - 1 ] return

50.34
40.07
53.31
48.54
static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } }

def sort012 ( a , arr_size ) : lo = 0 hi = arr_size - 1 mid = 0 while mid <= hi : if a [ mid ] == 0 : a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] lo = lo + 1 mid = mid + 1 elif a [ mid ] == 1 : mid = mid + 1 else : a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] hi = hi - 1

def sort012 ( a , arr_size ) : lo = 0 hi = arr_size - 1 while lo <= hi : mid = lo + 1 switch ( a [ mid ] ) : temp = a [ lo ] a [ lo ] = a [ mid ] a [ mid ] = temp lo += 1 mid -= 1 break if ( a [ mid ] == 0 ) : temp = a [ mid ] a [ mid ] = a [ hi ] hi -= 1 break if

def sort012 ( a , arr_size ) : lo = 0 hi = arr_size - 1 mid = 0 while mid <= hi : switch ( a [ mid ] ) : case 0 : temp = a [ lo ] a [ lo ] = a [ mid ] a [ mid ] = temp lo ++ mid += 1 break case 1 : mid += 1 break case 2 : mid -= 1 break : temp = a [ mid ] a [ mid ] = a [ hi ] a [ hi ] = temp hi -= 1 break

50.46
57.39
78.47
73.6
static void spiralPrint ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { System . out . print ( a [ k ] [ i ] + " " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { System . out . print ( a [ i ] [ n - 1 ] + " " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( a [ m - 1 ] [ i ] + " " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( a [ i ] [ l ] + " " ) ; } l ++ ; } } }

def spiralPrint ( m , n , a ) : k = 0 l = 0 while ( k < m and l < n ) : for i in range ( l , n ) : print ( a [ k ] [ i ] , end = "" ) k += 1 for i in range ( k , m ) : print ( a [ i ] [ n - 1 ] , end = "" ) n -= 1 if ( k < m ) : for i in range ( n - 1 , ( l - 1 ) , - 1 ) : print ( a [ m - 1 ] [ i ] , end = "" ) m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : print ( a [ i ] [ l ] , end = "" ) l += 1

def spiralPrint ( m , n , a ) : k = 0 l = 0 for k in range ( m , n ) : for i in range ( l , n ) : print ( a [ k ] [ i ] + " " ) ; } l += 1 if ( k < m ) : for i in range ( k , m ) : print ( a [ i ] [ n - 1 ] + " " ) ; } n -= 1 if ( l < n ) : for i in a [ k ] [ i ] = l : print ( a [ k ] [ l ] + " " ) ; if ( k < m ) : print ( a [ i ] [ n - 1 ] [ i ] + " " ) ; } m -= 1 if ( l < n ) : for i in range ( k , m ) : print ( a [ i ] [ l ] + " " ) ; } m -= 1 if ( k < n ) : print ( a [ i ] [ k ] [ l ] = n - 1 ] [ l ] + " " )

def spiralPrint ( m , n , a ) : k = 0 l = 0 while k < m and l < n : for i in range ( l , n ) : print ( a [ k ] [ i ] , end = "" ) k += 1 for i in range ( k , m ) : print ( a [ i ] [ n - 1 ] , end = "" ) n -= 1 if k < m : for i in range ( n - 1 , m ) : print ( a [ i ] [ n - 1 ] , end = "" ) m -= 1 if l < n : for i in range ( m - 1 , k ) : print ( a [ i ] [ l ] , end = "" ) l += 1

50.46
55.71
51.11
45.2
static int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }

def minSum ( arr , n ) : dp = [ 0 ] * n if ( n == 1 ) : return arr [ 0 ] if ( n == 2 ) : return min ( arr [ 0 ] , arr [ 1 ] ) if ( n == 3 ) : return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) if ( n == 4 ) : return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) dp [ 0 ] = arr [ 0 ] dp [ 1 ] = arr [ 1 ] dp [ 2 ] = arr [ 2 ] dp [ 3 ] = arr [ 3 ] for i in range ( 4 , n ) : dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) )

def minSum ( arr , n ) : dp = [ INT_MAX for k in range ( n ) ] if ( n == 1 ) : return arr [ 0 ] if n == 2 : return min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] ) if n == 4 : return min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] ) dp [ 3 ] = arr [ 3 ] for i in range ( 4 , n ) : dp [ i ] = arr [ i ] if ( n == 5 ) : return min ( dp [ 0 ] , dp [ n - 1 ] , dp [ n - 2 ] ) return min ( dp [ 0 ] , dp [ n - 1 ] ) , min ( dp [ n - 3 ] )

def minSum ( arr , n ) : dp = [ 0 for k in range ( n ) ] dp [ 0 ] = arr [ 0 ] dp [ 1 ] = arr [ 1 ] dp [ 2 ] = arr [ 2 ] dp [ 3 ] = arr [ 3 ] for i in range ( 4 , n ) : dp [ i ] = arr [ i ] + Math . min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) )

50.53
38.68
58.29
38.87
static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }

def areElementsContiguous ( arr , n ) : max1 = max ( arr ) min1 = min ( arr ) m = max1 - min1 + 1 if ( m > n ) : return False visited = [ 0 ] * m for i in range ( 0 , n ) : visited [ arr [ i ] - min1 ] = True for i in range ( 0 , m ) : if ( visited [ i ] == False ) : return False return True

def areElementsContiguous ( arr , n ) : max = float ( 'inf' ) min = float ( 'inf' ) for i in range ( n ) : max = max + 1 min = min + 1 m = max - min + 1 if ( m > n ) : return false visited = [ false for i in range ( 0 , n ) ] for i in range ( 0 , m ) : if ( visited [ arr [ i ] - min ] == false ) : return true

def areElementsContiguous ( arr , n ) : max = float ( 'inf' ) min = float ( 'inf' ) m = max - min + 1 if m > n : return False visited = [ bool ( i ) for i in range ( n ) ] for i in range ( n ) : visited [ arr [ i ] - min ] = True for i in range ( m ) : if ( visited [ i ] == False ) : return False return True

50.62
30.75
55.84
52.25
static int findSum ( int arr [ ] , int n ) { int sum = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { sum += arr [ i ] ; s . add ( arr [ i ] ) ; } } return sum ; }

def findSum ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : if arr [ i ] not in s : s . add ( arr [ i ] ) for i in s : sum = sum + i return sum

def findSum ( arr , n ) : sum = 0 s = new HashSet < Integer > ( ) for i in range ( 0 , n ) : if ( arr [ i ] ) : sum += arr [ i ] s . add ( arr [ i ] ) return sum

def findSum ( arr , n ) : sum = 0 s = list ( ) for i in range ( n ) : if not s . contains ( arr [ i ] ) : sum += arr [ i ] s . add ( arr [ i ] ) return sum

50.64
45.81
55.55
46.76
static int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }

def findmin ( p , n ) : a , b , c , d = 0 , 0 , 0 , 0 for i in range ( n ) : if ( p [ i ] [ 0 ] <= 0 ) : a += 1 elif ( p [ i ] [ 0 ] >= 0 ) : b += 1 if ( p [ i ] [ 1 ] >= 0 ) : c += 1 elif ( p [ i ] [ 1 ] <= 0 ) : d += 1 return min ( [ a , b , c , d ] )

def findmin ( p , n ) : a = 0 b = 0 c = 0 d = 0 for i in range ( n ) : if ( p [ i ] . x <= 0 ) : a += 1 elif ( p [ i ] . x >= 0 ) : b += 1 if ( p [ i ] . y <= 0 ) : c += 1 d = 1 return min ( a , b )

def findmin ( p , n ) : a = 0 b = 0 c = 0 d = 0 for i in range ( n ) : if ( p [ i ] <= 0 ) : a += 1 else : if ( p [ i ] . x >= 0 ) b += 1 if ( p [ i ] . y >= 0 ) c += 1 elif ( p [ i ] . y <= 0 ) : d += } return min ( min ( a , b ) , min ( c , d ) )

50.72
58.17
68.07
66.58
static int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }

def breakSum ( n ) : if ( n == 0 or n == 1 ) : return n return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n )

def breakSum ( n ) : if ( n == 0 ) : return n return breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 )

def breakSum ( n ) : if n == 0 or n == 1 : return n return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) , n )

50.73
32.54
62.21
43.54
public static void shuffle ( int card [ ] , int n ) { Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + rand . nextInt ( 52 - i ) ; int temp = card [ r ] ; card [ r ] = card [ i ] ; card [ i ] = temp ; } }

def shuffle ( card , n ) : for i in range ( n ) : r = i + ( random . randint ( 0 , 55 ) % ( 52 - i ) ) tmp = card [ i ] card [ i ] = card [ r ] card [ r ] = tmp

def shuffle ( card , n ) : rand = new Random ( ) for i in range ( 0 , n ) : r = i + rand . nextInt ( 52 - i ) card [ r ] = card [ i ] i = temp return card

def shuffle ( card , n ) : card . sort ( reverse = True ) for i in range ( n ) : r = i + rand . randint ( 52 - i ) card [ r ] = card [ i ] card [ i ] = temp

50.77
46.62
77.53
59.33
static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }

def patternCount ( str ) : last = str [ 0 ] i = 1 counter = 0 while ( i < len ( str ) ) : if ( str [ i ] == '0' and last == '1' ) : while ( str [ i ] == '0' ) : i += 1 if ( str [ i ] == '1' ) : counter += 1 last = str [ i ] i += 1 return counter

def patternCount ( str ) : counter = 0 last = str [ 0 ] for i in range ( 1 , len ( str ) ) : if ( str [ i ] == '0' ) : counter += 1 last = str [ i ] i ++ if ( last == '1' ) : counter += 1 else : last = str [ i ] if ( str [ i ] == '0' ) : counter += 1 last = str [ i ] i ++ if ( str [ i ] == '1' ) : last = str [ i ] if ( last == '1' ) : break return counter

def patternCount ( str ) : last = str . charAt ( 0 ) counter = 0 while i < str . length ( ) : if ( str [ i ] == '0' and last == '1' ) : while ( str [ i ] == '0' ) : i += 1 if ( str [ i ] == '1' ) : counter += 1 last = str [ i ] i ++ return counter

50.78
37.69
88.5
63.98
static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N || j >= N ) { return 0 ; } int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( int ) ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } }

def maxDecimalValue ( mat , i , j , p ) : if i >= N or j >= N : return 0 result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) if mat [ i ] [ j ] == 1 : return pow ( 2 , p ) + result else : return result

def maxDecimalValue ( mat , i , j , p ) : if ( i >= N || j >= N ) : return 0 for i in range ( N ) : result = maxDecimalValue ( mat , i , j , p + 1 ) if ( mat [ i ] [ j ] == 1 ) : return ( int ) ( pow ( 2 , p ) + result ) elif ( mat [ i ] [ j ] == 0 ) : return result

def maxDecimalValue ( mat , i , j , p ) : if i >= N or j >= N : return 0 result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) if mat [ i ] [ j ] == 1 : return ( int ( math . pow ( 2 , p ) + result ) ) else : return result

50.79
44.62
54.07
35.46
static int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }

def countFact ( low , high ) : fact = 1 x = 1 while ( fact < low ) : fact = fact * x x += 1 res = 0 while ( fact <= high ) : res += 1 fact = fact * x x += 1 return res

def countFact ( low , high ) : fact = 1 x = 1 while ( fact < low ) : fact = fact * x x += 1 return res

def countFact ( low , high ) : fact = 1 x = 1 while fact < low : fact = fact * x x ++ res = 0 while fact <= high : res += [ fact , fact * x ] return res

50.79
53.4
74.22
64.63
static char maxRepeating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } } return res ; }

def maxRepeating ( str ) : l = len ( str ) count = 0 res = str [ 0 ] for i in range ( l ) : cur_count = 1 for j in range ( i + 1 , l ) : if ( str [ i ] != str [ j ] ) : break cur_count += 1 if cur_count > count : count = cur_count res = str [ i ] return res

def maxRepeating ( str ) : len = len ( str ) for i in range ( len ) : for j in range ( i + 1 , len ) : if ( str [ i ] != str [ j ] ) : break count = cur_count for i in range ( i + 1 , len ) : if ( str [ i ] != str [ j ] ) : break res = str [ i ] count = cur_count res = str [ i ] if

def maxRepeating ( str ) : count = 0 res = str . charAt ( 0 ) for i in range ( 0 , len ) : cur_count = 1 for j in range ( i + 1 , len ) : if ( str [ i ] != str [ j ] ) : break cur_count += 1 if ( cur_count > count ) : count = cur_count res = str [ i ] return res

50.81
42.06
67.28
61.01
static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }

def getMinSquares ( n ) : if n <= 3 : return n ; res = n for x in range ( 1 , n + 1 ) : temp = x * x ; if temp > n : break else : res = min ( res , 1 + getMinSquares ( n - temp ) ) return res ;

def getMinSquares ( n ) : if ( n <= 1 ) : return 1 else : res = min ( res , getMinSquares ( n - 1 ) ) for x in range ( 1 , n ) : if ( temp > n ) : break return 1 + getMinSquares ( n - temp )

def getMinSquares ( n ) : res = n for x in range ( 1 , n ) : temp = x * x if ( temp > n ) : break else : res = min ( res , 1 + getMinSquares ( n - temp ) ) return res

50.82
41.68
56.31
49.63
static int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }

def evenSum ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n + 1 ) ) : if j == 0 or j == i : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] sum = 0 ; for i in range ( 0 , n + 1 ) : if n % 2 == 0 : sum = sum + C [ n ] [ i ] return sum

def evenSum ( n ) : C = [ [ 0 for i in range ( n ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , n ) : if ( j == 0 || j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] return sum

def evenSum ( n ) : C [ ] = [ 0 for i in range ( n ) ] for i in range ( 0 , n + 1 , - 1 ) : sum += C [ n ] [ i ] for j in range ( 0 , n ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] return sum

50.86
42.06
56.57
41.17
static String convert ( String s ) { int n = s . length ( ) ; String s1 = "" ; s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ' && i < n ) { s1 = s1 + " " + Character . toLowerCase ( s . charAt ( i + 1 ) ) ; i ++ ; } else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ; } return s1 ; }

def convert ( s ) : n = len ( s ) s1 = "" s1 = s1 + s [ 0 ] . lower ( ) i = 1 while i < n : if ( s [ i ] == '' and i <= n ) : s1 = s1 + "" + ( s [ i + 1 ] ) . lower ( ) i = i + 1 else : s1 = s1 + ( s [ i ] ) . upper ( ) i = i + 1 return s1

def convert ( s ) : n = len ( s ) s1 = "" for i in range ( 1 , n ) : if ( s [ i ] == ' ' ) : s1 = s1 + " " + s [ i + 1 ] i += 1 elif ( s [ i ] == ' ' ) : s1 = s1 + " " + s [ i + 1 ] i += 1 else : s1 = s1 + Character . toUpperCase ( s [ i ] ) return s1

def convert ( s ) : n = len ( s ) s1 = "" s1 = s1 + Character . toLowerCase ( s [ 0 ] ) for i in range ( 1 , n ) : if ( s [ i ] == ' ' and i < n ) : s1 = s1 + " " + Character . toLowerCase ( s [ i + 1 ] ) i += 1 else : s1 = s1 + Character . toUpperCase ( s [ i ] ) return s1

50.87
44.53
36.95
38.99
static void divisibilityCheck ( List < Integer > arr , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr . get ( i ) ) ; max_ele = Math . max ( max_ele , arr . get ( i ) ) ; } LinkedHashSet < Integer > res = new LinkedHashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) * 2 ; j <= max_ele ; j += arr . get ( i ) ) { if ( s . contains ( j ) ) res . add ( j ) ; } } List < Integer > list = new ArrayList < Integer > ( res ) ; Collections . reverse ( list ) ; for ( Integer temp : list ) System . out . print ( temp + " " ) ; }

def divisibilityCheck ( arr , n ) : s = dict ( ) max_ele = - 10 ** 9 for i in range ( n ) : s [ arr [ i ] ] = 1 max_ele = max ( max_ele , arr [ i ] ) res = dict ( ) for i in range ( n ) : if ( arr [ i ] != 0 ) : for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : if ( j in s . keys ( ) ) : res [ j ] = 1 for x in res : print ( x , end = "" )

def divisibilityCheck ( arr , n ) : s = list ( ) max_ele = 0 for i in range ( n ) : s . add ( arr [ i ] ) max_ele = max ( max_ele , arr [ i ] ) for i in range ( n ) : if ( arr [ i ] != 0 ) : for j in range ( max_ele , arr [ i ] ) : if ( s [ j ] != 0 ) : res .

def divisibilityCheck ( arr , n ) : s = list ( ) max_ele = Integer . MIN_VALUE for i in range ( n ) : s . add ( arr [ i ] ) max_ele = max ( max_ele , arr [ i ] ) for i in range ( n ) : if arr [ i ] != 0 : for j in arr [ i ] * 2 : if ( s [ j ] == 0 ) : res . add ( j ) if ( arr [ i ] != 0 ) : for j in range ( max_ele ) : if ( s [ j ] == 0 ) : res . add ( j ) if ( arr [ i ] != 0 ) : for j in range ( max_ele ) : if ( s [ j ] == 0 ) : res . add ( j ) if ( arr [ i ] != 0 ) : for j in range ( max_ele ) : if ( s [ j ] == 0 ) : res . add ( j ) return list

50.93
41.86
79.92
79.15
static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; }

def findElement ( arr , ranges , rotations , index ) : for i in range ( rotations - 1 , - 1 , - 1 ) : left = ranges [ i ] [ 0 ] right = ranges [ i ] [ 1 ] if ( left <= index and right >= index ) : if ( index == left ) : index = right else : index = index - 1 return arr [ index ]

def findElement ( arr , ranges , rotations , index ) : for i in range ( rotations ) : if ( left <= index && right >= index ) : index = left break if ( index == left ) : index = right else : index -= 1 return arr [ index ]

def findElement ( arr , ranges , rotations , index ) : for i in range ( rotations ) : left = ranges [ i ] [ 0 ] right = ranges [ i ] [ 1 ] if ( left <= index and right >= index ) : if ( index == left ) : index = right else : index -- return arr [ index ]

50.95
42.17
68.24
66.39
static float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }

def getArea ( a ) : area = ( math . pi * a * a ) / 4 return area

def getArea ( a ) : area = ( float ) ( a * a )

def getArea ( a ) : area = ( float ( math . PI * a * a ) ) / 4 return area

50.99
48.01
41.95
28.61
static void printPowerSet ( char [ ] set , int set_size ) { long pow_set_size = ( long ) Math . pow ( 2 , set_size ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { for ( j = 0 ; j < set_size ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( set [ j ] ) ; } System . out . println ( ) ; } }

def printPowerSet ( set , set_size ) : pow_set_size = ( int ) ( math . pow ( 2 , set_size ) ) counter = 0 j = 0 for counter in range ( 0 , pow_set_size ) : for j in range ( 0 , set_size ) : if ( ( counter & ( 1 << j ) ) > 0 ) : print ( set [ j ] , end = "" ) print ( "" )

def printPowerSet ( set , set_size ) : pow_set_size = ( long ) pow ( 2 , set_size ) for j in range ( 0 , set_size ) : if ( counter & ( 1 << j ) ) > 0 : print ( set [ j ] ) if ( counter & ( 1 << j ) ) > 0 : print ( set [ j ] ) if ( counter & ( 1 << j ) ) > 0 : print ( set [

def printPowerSet ( set , set_size ) : for counter in range ( pow_set_size ) : for j in range ( 0 , set_size ) : if ( counter & ( 1 << j ) ) > 0 : print ( set [ j ] )

51.0
56.23
54.51
55.87
static void alternateSubarray ( boolean arr [ ] , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { System . out . print ( count -- + " " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + " " ) ; } }

def alternateSubarray ( arr , n ) : count = 1 prev = arr [ 0 ] for i in range ( 1 , n ) : if ( ( arr [ i ] ^ prev ) == 0 ) : while ( count ) : print ( count , end = "" ) count -= 1 count += 1 prev = arr [ i ] while ( count ) : print ( count , end = "" ) count -= 1

def alternateSubarray ( arr , n ) : count = 1 prev = arr [ 0 ] for i in range ( n ) : if ( arr [ i ] ^ prev ) == false : while ( count > 0 ) : print ( count -- + " " ) prev = arr [ i ] count = 1 prev = arr [ i ] if ( prev ) : print ( count -- + " " ) prev = arr [ i ] if ( count != 0 ) : print ( count -- )

def alternateSubarray ( arr , n ) : count = 1 prev = arr [ 0 ] for i in range ( n ) : if ( arr [ i ] ^ prev ) == false : while ( count > 0 ) : print ( count -- ) : print ( count -- ) prev = arr [ i ]

51.06
41.7
55.75
45.17
public static String smallestNumber ( String str ) { char [ ] num = str . toCharArray ( ) ; int n = str . length ( ) ; int [ ] rightMin = new int [ n ] ; rightMin [ n - 1 ] = - 1 ; int right = n - 1 ; for ( int i = n - 2 ; i >= 1 ; i -- ) { if ( num [ i ] > num [ right ] ) rightMin [ i ] = right ; else { rightMin [ i ] = - 1 ; right = i ; } } int small = - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( num [ i ] != '0' ) { if ( small == - 1 ) { if ( num [ i ] < num [ 0 ] ) small = i ; } else if ( num [ i ] < num [ small ] ) small = i ; } if ( small != - 1 ) { char temp ; temp = num [ 0 ] ; num [ 0 ] = num [ small ] ; num [ small ] = temp ; } else { for ( int i = 1 ; i < n ; i ++ ) { if ( rightMin [ i ] != - 1 ) { char temp ; temp = num [ i ] ; num [ i ] = num [ rightMin [ i ] ] ; num [ rightMin [ i ] ] = temp ; break ; } } } return ( new String ( num ) ) ; }

def smallestNumber ( num ) : num = list ( num ) n = len ( num ) rightMin = [ 0 ] * n right = 0 rightMin [ n - 1 ] = - 1 ; right = n - 1 ; for i in range ( n - 2 , 0 , - 1 ) : if num [ i ] > num [ right ] : rightMin [ i ] = right else : rightMin [ i ] = - 1 right = i small = - 1 for i in range ( 1 , n ) : if num [ i ] != '0' : if small == - 1 : if num [ i ] < num [ 0 ] : small = i elif num [ i ] < num [ small ] : small = i if small != - 1 : num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ] else : for i in range ( 1 , n ) : if rightMin [ i ] != - 1 : num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] break return '' . join ( num )

def smallestNumber ( str ) : num = str . toCharArray ( ) rightMin = [ - 1 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( num [ i ] > num [ right ] ) rightMin [ i ] = right else : small = i for i in range ( 1 , n ) : if ( num [ i ] < num [ 0 ] ) : small = i if ( num [ i ] > num [ small ] ) : right = i if ( num [ i ] < num [ small ] ) : small = i if ( num [ i ] < num [ rightMin [ i ] ) : temp = num [ i ] num [ i ] = num [ rightMin [ i ] ] = temp break if ( small != - 1 ) : temp = num [ i ] num [ i ] = num [ rightMin [ i ] = num [ rightMin [ i ] break if ( rightMin [ i ] != - 1 ) : temp = num [ i ] num [ rightMin [ i ] = temp break return ( new String ( num ) )

def smallestNumber ( str ) : num = str . splitlines ( ) rightMin = [ - 1 for i in range ( n ) ] rightMin [ n - 1 ] = - 1 right = n - 1 for i in range ( n ) : if num [ i ] != '0' : if ( small == - 1 ) : if ( num [ i ] < num [ 0 ] ) : small = i elif ( num [ i ] < num [ small ] ) : small = i if ( num [ i ] < num [ small ] ) : small = i if ( small != - 1 ) : temp = num [ 0 ] num [ 0 ] = num [ small ] num [ small ] = temp else : for i in range ( 1 , n ) : if ( rightMin [ i ] != - 1 ) : temp = num [ i ] num [ i ] = num [ rightMin [ i ] ] num [ rightMin [ i ] ] = temp break return ( new String ( num ) )

51.11
37.04
53.85
55.84
static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }

def binaryToDecimal ( n ) : num = n dec_value = 0 base1 = 1 len1 = len ( num ) for i in range ( len1 - 1 , - 1 , - 1 ) : if ( num [ i ] == '1' ) : dec_value += base1 base1 = base1 * 2 return dec_value

def binaryToDecimal ( n ) : num = n + "" dec_value = 0 base = 1 for i in range ( len ) : if ( num [ i ] == '1' ) : dec_value += base base = 1 else : dec_value += base * 2 return dec_value

def binaryToDecimal ( n ) : num = n dec_value = 0 base = 1 len = num . length ( ) for i in range ( len - 1 , - 1 , - 1 ) : if ( num [ i ] == '1' ) : dec_value += base base = base * 2 elif ( num [ i ] == '0' ) : dec_value += base base = base * 2 return dec_value

51.11
47.73
61.05
62.19
static String compute ( String str , int n ) { String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ; int l = str . length ( ) ; String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str . charAt ( i ) ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - 'a' ) ; return answer ; }

def compute ( st , n ) : reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" l = len ( st ) answer = "" for i in range ( 0 , n ) : answer = answer + st [ i ] for i in range ( n , l ) : answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( 'a' ) ] ) return answer

def compute ( str , n ) : reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" l = str . length ( ) for i in range ( n , l ) : answer = answer + str [ i ] for i in range ( n , l ) : answer = answer + reverseAlphabet [ str [ i ] - 'a' ] return answer

def compute ( str , n ) : reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" l = str . length ( ) answer = "" for i in range ( 0 , n , l ) : answer = answer + str [ i ] for i in range ( n , l ) : answer = answer + reverseAlphabet [ str [ i ] - 'a' ] return answer

51.19
47.31
44.63
39.54
static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " " ) ; else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " " ) ; else { System . out . print ( arr2 [ j ++ ] + " " ) ; i ++ ; } } while ( i < m ) System . out . print ( arr1 [ i ++ ] + " " ) ; while ( j < n ) System . out . print ( arr2 [ j ++ ] + " " ) ; return 0 ; }

def printUnion ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and j < n : if arr1 [ i ] < arr2 [ j ] : print ( arr1 [ i ] ) i += 1 elif arr2 [ j ] < arr1 [ i ] : print ( arr2 [ j ] ) j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1 while i < m : print ( arr1 [ i ] ) i += 1 while j < n : print ( arr2 [ j ] ) j += 1

def printUnion ( arr1 , arr2 , m , n ) : i = 0 j = 0 while i < m and j < n : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ++ ] + " " ) else : print ( arr2 [ j ++ ] + " " ) i += 1 while j < n : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ] ) : print ( arr2 [ j ++ ] + " " ) else : print ( arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " " ) else : print ( arr2 [ j ++ ] + " " ) return 0

def printUnion ( arr1 , arr2 , m , n ) : i = 0 j = 0 while i < m and j < n : if arr1 [ i ] < arr2 [ j ] : print ( arr1 [ i ++ ] , end = "" ) elif arr2 [ j ] < arr1 [ i ] : print ( arr2 [ j ++ ] , end = "" ) i += 1

51.26
40.37
56.88
56.46
static void recaman ( int n ) { if ( n <= 0 ) return ; System . out . printf ( "%d, " , 0 ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . contains ( curr ) ) curr = prev + i ; s . add ( curr ) ; System . out . printf ( "%d, " , curr ) ; prev = curr ; } }

def recaman ( n ) : if ( n <= 0 ) : return print ( 0 , "," , end = '' ) s = set ( [ ] ) s . add ( 0 ) prev = 0 for i in range ( 1 , n ) : curr = prev - i if ( curr < 0 or curr in s ) : curr = prev + i s . add ( curr ) print ( curr , "," , end = '' ) prev = curr

def recaman ( n ) : if ( n <= 0 ) : return ; s = set ( ) for i in range ( 1 , n ) : if ( s . contains ( prev ) ) : curr = prev + i s . add ( curr ) prev = curr if ( curr < 0 ) : curr = prev + i s . add ( curr ) : prev = curr if ( s . contains ( curr ) ) : curr = prev + i s . add ( curr )

def recaman ( n ) : if n <= 0 : return s = list ( ) s . add ( 0 ) prev = 0 for i in range ( 1 , n ) : curr = prev - i if curr < 0 or s . contains ( curr ) : curr = prev + i s . add ( curr ) System . out . printf ( "%d, " , curr ) prev = curr

51.28
46.77
37.4
40.53
static int countRotations ( String n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }

def countRotations ( n ) : l = len ( n ) if ( l == 1 ) : oneDigit = ( int ) ( n [ 0 ] ) if ( oneDigit % 4 == 0 ) : return 1 return 0 count = 0 for i in range ( 0 , l - 1 ) : twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 return count

def countRotations ( n ) : len = len ( n ) if ( len == 1 ) : oneDigit = ( n [ 0 ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) count = 0 for i in range ( len ) : twoDigit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) if ( twoDigit % 4 == 0 ) count ++ if ( twoDigit > 1 ) : count += 1 if ( twoDigit % 4 == 0 ) : count += 1 twoDigit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) return count

def countRotations ( n ) : twoDigit , count = 0 for i in range ( len ) : twoDigit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) if ( twoDigit % 4 == 0 ) : count += 1 twoDigit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) if ( twoDigit % 4 == 0 ) : count += 1 return count

51.55
43.87
53.29
36.31
static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) pq . add ( A [ i ] + B [ j ] ) ; int count = 0 ; while ( count < K ) { System . out . println ( pq . peek ( ) ) ; pq . remove ( ) ; count ++ ; } }

def KMaxCombinations ( A , B , N , K ) : pq = PriorityQueue ( ) for i in range ( 0 , N ) : for j in range ( 0 , N ) : a = A [ i ] + B [ j ] pq . put ( ( - a , a ) ) count = 0 while ( count < K ) : print ( pq . get ( ) [ 1 ] ) count = count + 1

def KMaxCombinations ( A , B , N , K ) : pq = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) for i in range ( 0 , N , K ) : pq . add ( A [ i ] + B [ j ] ) count = 0 while ( count < K ) : print ( pq [ peek ( ) ] ) pq . remove ( ) count += 1 if ( count < K ) : print ( pq [ peek ( )

def KMaxCombinations ( A , B , N , K ) : pq = list ( reversed ( list ( range ( N ) ) ) for i in range ( N ) : for j in range ( N ) : pq . add ( A [ i ] + B [ j ] ) count = 0 while count < K : print ( pq . peek ( ) ) pq . remove ( ) count ++

51.62
30.99
45.75
28.38
static int smallest ( int x , int y , int z ) { if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ; return ( ( x / z ) != 1 ) ? x : z ; }

def smallest ( x , y , z ) : if ( not ( y / x ) ) : return y if ( not ( y / z ) ) else z return x if ( not ( x / z ) ) else z

def smallest ( x , y , z ) : if ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z return ( x / z ) != 1 ) ? x : z

def smallest ( x , y , z ) : if ( y / x ) != 1 : return ( ( y / z ) != 1 ) return ( ( y / z ) != 1 )

51.74
47.78
46.91
45.3
static int possibleWays ( int n , int m , int k ) { int [ ] [ ] dp = new int [ N ] [ N ] ; int [ ] [ ] presum = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; presum [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = 0 ; presum [ 0 ] [ i ] = 1 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ; if ( j > k ) { dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ; } } for ( int j = 1 ; j < n + 1 ; j ++ ) { presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }

def possibleWays ( n , m , k ) : dp = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] presum = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] for i in range ( 1 , n + 1 ) : dp [ 0 ] [ i ] = 0 presum [ 0 ] [ i ] = 1 for i in range ( 0 , m + 1 ) : presum [ i ] [ 0 ] = 1 dp [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = presum [ i - 1 ] [ j ] if j > k : dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] for j in range ( 1 , n + 1 ) : presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] return dp [ m ] [ n ]

def possibleWays ( N , m , k ) : dp = [ 0 for i in range ( N ) ] presum = [ 0 for i in range ( N ) ] for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = 0 presum [ i ] [ j ] = 1 i = 0 ; i < m + 1 : i += 1 if ( j > k ) : dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] if ( j > k ) : dp [ i ] [ j ] = dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] if ( j > k ) : dp [ i ] [ j ] -= presum [ i - 1 ] [ j - 1 ] return dp [ m ] [ n ] [ k ]

def possibleWays ( n , m , k ) : dp = [ 0 for k in range ( n ) ] presum = [ 0 for k in range ( n ) ] for i in range ( 1 , m + 1 , - 1 ) : dp [ i ] [ j ] = presum [ i - 1 ] [ j ] if ( j > k ) : dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] : } for j in range ( 1 , n + 1 ) : presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] return dp [ m ] [ n ]

51.75
37.41
81.91
64.4
static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }

def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len

def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 for end in range ( 0 , n ) : while ( curr_sum <= x && end < n ) : curr_sum += arr [ end ++ ] if ( curr_sum > x ) : min_len = end - start curr_sum -= arr [ start ++ ] if ( min_len < 1 ) : min_len = end - start return min_len

def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while end < n : while ( curr_sum <= x and end < n ) : curr_sum += arr [ end ++ ] while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ++ ] return min_len

51.76
44.74
46.12
42.17
static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; for ( int x = x1 , y = y1 ; x <= x2 ; x ++ ) { System . out . print ( "(" + x + "," + y + ")\n" ) ; slope_error_new += m_new ; if ( slope_error_new >= 0 ) { y ++ ; slope_error_new -= 2 * ( x2 - x1 ) ; } } }

def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( y2 - y1 ) slope_error_new = m_new - ( x2 - x1 ) y = y1 for x in range ( x1 , x2 + 1 ) : print ( "(" , x , "," , y , ")\n" ) slope_error_new = slope_error_new + m_new if ( slope_error_new >= 0 ) : y = y + 1 slope_error_new = slope_error_new - 2 * ( x2 - x1 )

def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( x2 - x1 ) slope_error_new = m_new - ( y2 - y1 ) for x in range ( x1 , y1 ) : slope_error_new -= 2 * ( x2 - x1 ) if ( slope_error_new >= 0 ) : y += 1 slope_error_new -= 2 *

def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( y2 - y1 ) for x in range ( x1 , x2 ) : print ( "(" + x + "," + y + ")" ) slope_error_new += m_new if slope_error_new >= 0 : y += 1 slope_error_new -= 2 * ( x2 - x1 )

51.79
45.72
82.82
61.8
static int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }

def PositionRightmostSetbit ( n ) : position = 1 m = 1 while ( not ( n & m ) ) : m = m << 1 position += 1 return position

def PositionRightmostSetbit ( n ) : position = 1 m = 1 while ( ( n & m ) == 0 ) : m = m << 1 position ++ while ( ( n & m ) == 0 ) : m = m << 1 return position

def PositionRightmostSetbit ( n ) : position = 1 m = 1 while ( n & m ) == 0 : m = m << 1 position += 1 return position

51.82
61.65
51.2
59.07
static boolean isPossible ( String str , int n ) { int len = str . length ( ) ; if ( len >= n ) return true ; return false ; }

def isPossible ( str , n ) : l = len ( str ) if ( l >= n ) : return True return False

def isPossible ( str , n ) : len = str . length ( ) if ( len >= n ) : return true

def isPossible ( str , n ) : len = str . length ( ) if len >= n : return True return False

51.82
43.39
57.48
47.9
static void kmax ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_so_far = Integer . MIN_VALUE ; int max_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) { max_so_far = max_here ; start = s ; end = i ; } if ( max_here < 0 ) { max_here = 0 ; s = i + 1 ; } } System . out . println ( "Maximum non-overlapping sub-arraysum" + ( c + 1 ) + ": " + max_so_far + ", starting index: " + start + ", ending index: " + end + "." ) ; for ( int l = start ; l <= end ; l ++ ) arr [ l ] = Integer . MIN_VALUE ; } System . out . println ( ) ; }

def kmax ( arr , k , n ) : for c in range ( k ) : max_so_far = - float ( "inf" ) max_here = 0 start = 0 end = 0 s = 0 for i in range ( n ) : max_here += arr [ i ] if ( max_so_far < max_here ) : max_so_far = max_here start = s end = i if ( max_here < 0 ) : max_here = 0 s = i + 1 print ( "Maximumnon-overlappingsub-arraysum" , c + 1 , ":" , max_so_far , ",startingindex:" , start , ",endingindex:" , end , "." , sep = "" ) for l in range ( start , end + 1 ) : arr [ l ] = - float ( "inf" ) print ( )

def kmax ( arr , k , n ) : max_so_far = float ( 'inf' ) for c in range ( k ) : max_here = arr [ i ] for i in range ( n ) : max_so_far += arr [ i ] start = s end = i + 1 max_here = float ( 'inf' ) for i in range ( n ) : max_here += arr [ i ] if ( max_so_far < max_here ) : max_here = max_here if ( max_so_far < max_here ) : max_so_far = max_here if ( max_here < 0 ) : max_here = 0 s = i + 1 if ( max_here < 0 ) : max_here = 0 print ( "Maximum non-overlapping sub-arraysum" + ( c + 1 )

def kmax ( arr , k , n ) : max_so_far = float ( 'inf' ) max_here = 0 start = 0 end = 0 s = 0 for i in range ( n ) : max_here += arr [ i ] if ( max_so_far < max_here ) : max_so_far = max_here start = s end = i if max_here < 0 : max_here = 0 s = i + 1 print ( "Maximum non-overlapping sub-arraysum" + ( c + 1 ) + ": " + max_so_far + ", starting index: " + start + ", ending index: " + end + "." ) for l in start : arr [ l ] = float ( 'inf' )

51.83
47.79
74.79
59.25
static int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_root ) + l ) ; }

def minDaysToEmpty ( C , l ) : if ( l >= C ) : return C eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 return math . ceil ( eq_root ) + l

def minDaysToEmpty ( C , l ) : eq_root = ( 1 + 8 * ( C - l ) ) - 1 ) / 2 return ( int ) ( eq_root + l )

def minDaysToEmpty ( C , l ) : if l >= C : return C eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 return ( int ( ceil ( eq_root ) + l ) )

51.88
47.61
78.56
68.58
static int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }

def maxSumIS ( arr , n ) : max = 0 msis = [ 0 for x in range ( n ) ] for i in range ( n ) : msis [ i ] = arr [ i ] for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : msis [ i ] = msis [ j ] + arr [ i ] for i in range ( n ) : if max < msis [ i ] : max = msis [ i ] return max

def maxSumIS ( arr , n ) : msis = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] ) : msis [ i ] = arr [ j ] + arr [ i ] max = msis [ i ] if ( max < msis [ i ] ) : max = msis [ i ] return max

def maxSumIS ( arr , n ) : msis = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : msis [ i ] = arr [ i ] for i in range ( 1 , n ) : msis [ i ] = arr [ i ] for j in range ( i , n ) : if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : msis [ i ] = msis [ j ] + arr [ i ] for i in range ( 0 , n ) : if ( max < msis [ i ] ) : max = msis [ i ] return max

51.93
52.57
57.96
52.29
static int perfectSquare ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = "" ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { String str = "" ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str += s . charAt ( j ) ; } } if ( str . charAt ( 0 ) != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' ) ; int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . length ( ) ) { ans = ( int ) str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { System . out . print ( num + " " ) ; return n - ans ; } }

def perfectSquare ( s ) : n = len ( s ) ans = - 1 num = "" for i in range ( 1 , ( 1 << n ) ) : str = "" for j in range ( 0 , n ) : if ( ( i >> j ) & 1 ) : str = str + s [ j ] if ( str [ 0 ] != '0' ) : temp = 0 for j in range ( 0 , len ( str ) ) : temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) k = int ( math . sqrt ( temp ) ) if ( k * k == temp ) : if ( ans < len ( str ) ) : ans = len ( str ) num = str if ( ans == - 1 ) : return ans else : print ( "{}" . format ( num ) , end = "" ) return n - ans

def perfectSquare ( s ) : n = len ( s ) for i in range ( 1 << n ) : str = "" for j in range ( 1 << n ) : if ( ( i >> j ) & 1 ) == 1 : str += s [ j ] if ( str [ 0 ] != '0' ) : temp = 0 for j in range ( 1 , n ) : temp = temp * 10 + str [ j ] - '0' if ( k * k == temp ) : ans = ( int ) str = str [ j ] if ( k * k == temp ) : if ( ans < ( int ) str . length ( ) ) : ans = ( int ) str . length ( ) ) : num += str [ j ] return n - ans

def perfectSquare ( s ) : ans = - 1 num = "" for i in range ( 1 << n ) : str = "" for j in range ( 1 << n ) : if ( ( i >> j ) & 1 ) == 1 : str += s [ j ] if ( str [ 0 ] != '0' ) : temp = 0 for j in range ( str . length ( ) ) : temp = temp * 10 + ( int ) ( str [ j ] - '0' ) int k = ( int ) Math . sqrt ( temp ) if ( k * k == temp ) : if ( ans < ( int ) str . length ( ) ) : ans = ( int ) str . length ( ) num = str } } if ans == - 1 : return ans else : return n - ans

52.0
45.9
67.49
66.82
static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) { return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } }

def lcsOf3 ( i , j , k ) : if ( i == - 1 or j == - 1 or k == - 1 ) : return 0 if ( dp [ i ] [ j ] [ k ] != - 1 ) : return dp [ i ] [ j ] [ k ] if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) return dp [ i ] [ j ] [ k ] else : dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) return dp [ i ] [ j ] [ k ]

def lcsOf3 ( i , j , k ) : if ( i == - 1 || j == - 1 || k == - 1 ) : return dp [ i ] [ j ] [ k ] = - 1 elif ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] : return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) else : return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 )

def lcsOf3 ( i , j , k ) : if i == - 1 or j == - 1 or k == - 1 : return 0 dp [ i ] [ j ] [ k ] = - 1 if i == - 1 or j == - 1 or k == - 1 : return dp [ i ] [ j ] [ k ] = 0 if i == - 1 and j == Z : return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) else : return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) )

52.03
50.01
18.64
36.6
static int numoffbt ( int arr [ ] , int n ) { int maxvalue = - 2147483647 ; int minvalue = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { maxvalue = Math . max ( maxvalue , arr [ i ] ) ; minvalue = Math . min ( minvalue , arr [ i ] ) ; } int mark [ ] = new int [ maxvalue + 2 ] ; int value [ ] = new int [ maxvalue + 2 ] ; Arrays . fill ( mark , 0 ) ; Arrays . fill ( value , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ arr [ i ] ] = 1 ; value [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = minvalue ; i <= maxvalue ; i ++ ) { if ( mark [ i ] != 0 ) { for ( int j = i + i ; j <= maxvalue && j / i <= i ; j += i ) { if ( mark [ j ] == 0 ) continue ; value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; } } ans += value [ i ] ; } return ans ; }

def numoffbt ( arr , n ) : maxvalue = - 2147483647 minvalue = 2147483647 for i in range ( n ) : maxvalue = max ( maxvalue , arr [ i ] ) minvalue = min ( minvalue , arr [ i ] ) mark = [ 0 for i in range ( maxvalue + 2 ) ] value = [ 0 for i in range ( maxvalue + 2 ) ] for i in range ( n ) : mark [ arr [ i ] ] = 1 value [ arr [ i ] ] = 1 ans = 0 for i in range ( minvalue , maxvalue + 1 ) : if ( mark [ i ] != 0 ) : j = i + i while ( j <= maxvalue and j // i <= i ) : if ( mark [ j ] == 0 ) : continue value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) if ( i != j // i ) : value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) j += i ans += value [ i ] return ans

def numoffbt ( arr , n ) : maxvalue = - 2147483647 minvalue = 2147483647 for i in range ( n ) : maxvalue = max ( maxvalue , arr [ i ] ) value = [ 0 for i in range ( n ) ] mark = [ 0 for i in range ( n ) ] for i in range ( minvalue , maxvalue ) : mark [ arr [ i ] ] = 1 value [ arr [ i ] ] = 1 ans += value [ i ] if ( i in range ( minvalue , maxvalue ) : if ( mark [ i ] == 0 ) : continue if ( i != j / i ) : value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) return ans

def numoffbt ( arr , n ) : maxvalue = - 2147483647 minvalue = 2147483647 for i in range ( minvalue , maxvalue + 2 ) : maxvalue = max ( maxvalue , arr [ i ] ) minvalue = min ( minvalue , arr [ i ] ) for i in range ( n ) : mark [ arr [ i ] ] = 1 value [ arr [ i ] ] = 1 ans += value [ i ] return ans

52.04
54.61
73.68
53.87
static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

def longest ( a , n , k ) : freq = [ 0 ] * n start = 0 end = 0 now = 0 l = 0 for i in range ( n ) : freq [ a [ i ] ] += 1 if ( freq [ a [ i ] ] == 1 ) : now += 1 while ( now > k ) : freq [ a [ l ] ] -= 1 if ( freq [ a [ l ] ] == 0 ) : now -= 1 l += 1 if ( i - l + 1 >= end - start + 1 ) : end = i start = l for i in range ( start , end + 1 ) : print ( a [ i ] , end = "" )

def longest ( a , n , k ) : freq = [ 0 for i in range ( n ) ] start = 0 end = 0 for i in range ( 0 , n , k ) : freq [ a [ i ] ] += 1 if ( freq [ a [ i ] ] == 1 ) : now += k l = 0 for i in range ( start , end ) : if ( i - l + 1 >= end - start + 1 ) : end = i start =

def longest ( a , n , k ) : freq = [ 0 for i in range ( n ) ] start = 0 end = 0 now = 0 l = 0 for i in range ( start , end ) : freq [ a [ i ] ] += if ( freq [ a [ i ] ] == 1 ) : now += 1 while ( now > k ) : freq [ a [ l ] ] -- if ( freq [ a [ l ] ] == 0 ) now -- l ++ if ( i - l + 1 >= end - start + 1 ) : end = i start = l

52.09
45.34
48.35
63.33
public static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . length ( ) ; k ++ ) { String s1 = "" , s2 = "" , s3 = "" , s4 = "" ; try { s1 = s . substring ( 0 , i ) ; s2 = s . substring ( i , j - i ) ; s3 = s . substring ( j , k - j ) ; s4 = s . substring ( k , s . length ( ) - k ) ; } catch ( StringIndexOutOfBoundsException e ) { } if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) && strcheck ( s1 , s4 ) && strcheck ( s2 , s3 ) && strcheck ( s2 , s4 ) && strcheck ( s3 , s4 ) ) return true ; } } } return false ; }

def check ( s ) : if ( len ( s ) >= 10 ) : return True for i in range ( 1 , len ( s ) ) : for j in range ( i + 1 , len ( s ) ) : for k in range ( j + 1 , len ( s ) ) : s1 = s [ 0 : i ] s2 = s [ i : j - i ] s3 = s [ j : k - j ] s4 = s [ k : len ( s ) - k ] if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : return True return False

def check ( s ) : if ( s == "" ) : return true for i in range ( 1 , len ( s ) ) : for j in range ( i + 1 , len ( s ) ) : s1 = "" s2 = "" s3 = "" s4 = "" try : s1 = s [ 0 , i ] s2 = s [ i : j + 1 + k ] s3 = s [ j + 1 : k + 1 ] s4 = s [ k ] if ( s1 == s [ k ] ) : return true if ( strcheck ( s1 , s2 ) and strcheck ( s1 , s3 ) and strcheck ( s2 , s4 ) : return true

def check ( s ) : if len ( s ) >= 10 : return True for i in range ( 1 , len ( s ) ) : for j in range ( i + 1 , len ( s ) ) : for k in range ( j + 1 , len ( s ) ) : try : s1 = s [ 0 , i ] s2 = s [ i , j - i ] s3 = s [ j , k - j ] s4 = "" try : s1 = s [ 0 , i ] s2 = s [ i , j - i ] s3 = s [ j , k - j ] s4 = s [ k , s . length ( ) - k ] except ( ValueError , AttributeError ) : pass if strcheck ( s1 , s2 ) and strcheck ( s1 , s3 ) and strcheck ( s1 , s4 ) and strcheck ( s2 , s3 ) and strcheck ( s2 , s4 ) and strcheck ( s3 , s4 ) ) : return True return False

52.11
37.63
62.1
36.88
static void decToOctal ( int n ) { int [ ] octalNum = new int [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( octalNum [ j ] ) ; }

def decToOctal ( n ) : octalNum = [ 0 ] * 100 i = 0 while ( n != 0 ) : octalNum [ i ] = n % 8 n = int ( n / 8 ) i += 1 for j in range ( i - 1 , - 1 , - 1 ) : print ( octalNum [ j ] , end = "" )

def decToOctal ( n ) : octalNum = [ 0 for i in range ( 100 ) ] for i in range ( i , 100 ) : octalNum [ i ] = n % 8 n = n / 8 i ++ for j in range ( i - 1 , - 1 , - 1 ) : print ( octalNum [ j ] ) j -= 1 print ( octalNum [ j ] ) i -= 1 print ( octalNum [ i ]

def decToOctal ( n ) : octalNum = [ 0 for k in range ( 100 ) ] for i in range ( 0 , 100 ) : octalNum [ i ] = n % 8 n = n // 8 i += 1 for j in range ( i - 1 , - 1 ) : print ( octalNum [ j ] )

52.13
60.98
39.28
52.75
static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; }

def count ( n ) : if ( n < 4 ) : return - 1 rem = n % 4 if ( rem == 0 ) : return n // 4 if ( rem == 1 ) : if ( n < 9 ) : return - 1 return ( n - 9 ) // 4 + 1 if ( rem == 2 ) : return ( n - 6 ) // 4 + 1 if ( rem == 3 ) : if ( n < 15 ) : return - 1 return ( n - 15 ) // 4 + 2

def count ( n ) : n = int ( n ) rem = n % 4 if ( rem == 0 ) : return n / 4 if ( rem == 1 ) : return n - 9 if ( n < 6 ) : return - 1 return ( n - 6 ) / 4 + 1 if ( rem == 3 ) : return ( n - 15 ) / 4 + 2 else : return 0

def count ( n ) : rem = n % 4 if rem == 0 : return n / 4 if rem == 1 : if n < 9 : return - 1 return ( n - 9 ) / 4 + 1 if rem == 2 : return ( n - 6 ) / 4 + 1 if rem == 3 : return ( n - 15 ) / 4 + 2 return 0

52.14
48.95
63.52
59.5
static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }

def countIntegralSolutions ( n ) : result = 0 for i in range ( n + 1 ) : for j in range ( n + 1 ) : for k in range ( n + 1 ) : if i + j + k == n : result += 1 return result

def countIntegralSolutions ( n ) : result = 0 for i in range ( 0 , n ) : for j in range ( n ) : if ( i + j == n ) : result += 1 return result

def countIntegralSolutions ( n ) : result = 0 for i in range ( n ) : for j in range ( 0 , n , - 1 ) : for k in range ( 0 , n - i - j ) : if ( i + j + k == n ) : result += 1 return result

52.19
39.2
51.79
43.3
static int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }

def countWays ( N ) : if ( N == 1 ) : return 4 countB = 1 countS = 1 for i in range ( 2 , N + 1 ) : prev_countB = countB prev_countS = countS countS = prev_countB + prev_countS countB = prev_countS result = countS + countB return ( result * result )

def countWays ( N ) : countB = 1 countS = 1 prev_countB = 1 prev_countS = countS for i in range ( 2 , N ) : countB = prev_countB + prev_countS countS = prev_countB + prev_countS countB = prev_countS for i in range ( 2 , N ) : prev_countB = countB prev_countS = countS countB = prev

def countWays ( N ) : countB = 1 countS = 1 prev_countB = countB prev_countS = countS countS = prev_countB + prev_countS countB = prev_countS result = countS + countB return ( result * result )

52.24
41.55
42.23
37.74
static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }

def countSetBits ( n ) : i = 0 ans = 0 while ( ( 1 << i ) <= n ) : k = 0 change = 1 << i for j in range ( 0 , n + 1 ) : ans += k if change == 1 : k = not k change = 1 << i else : change -= 1 i += 1 return ans

def countSetBits ( n ) : i = 0 ans = 0 for i in range ( 1 , n ) : if ( 1 << i ) <= n : k = true change = 1 << i while ( change == 1 ) : k = ! k change = 1 << i if ( change == 1 ) : k = ! k change = 1 << i else : change -= 1 ans += 1 return ans

def countSetBits ( n ) : ans = 0 while ( 1 << i ) <= n : k = False change = 1 << i for j in range ( 0 , n ) : if ( k == True ) : ans += 1 else : ans += 0 if ( change == 1 ) : k = not k change = 1 << i while ( j <= n ) : if ( k == True ) : ans += 1 else : ans += 0 if ( change == 1 ) : k = not k change = 1 << i else : change -- i ++ return ans

52.28
36.82
52.65
33.0
static void bin ( Integer n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . printf ( "%d" , n & 1 ) ; }

def bin ( n ) : if ( n > 1 ) : bin ( n >> 1 ) print ( n & 1 , end = "" )

def bin ( n ) : bin ( n >> 1 ) if ( n > 1 ) bin ( n >> 1 ) if ( n & 1 ) : bin ( n & 1 )

def bin ( n ) : if n > 1 : bin ( n >> 1 ) sys . out . printf ( "%d" , n & 1 )

52.32
50.93
85.35
88.76
static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + " " + get_mid + " " + get_max ) ; }

def printSorted ( a , b , c ) : get_max = max ( a , max ( b , c ) ) get_min = - max ( - a , max ( - b , - c ) ) get_mid = ( a + b + c ) - ( get_max + get_min ) print ( get_min , "" , get_mid , "" , get_max )

def printSorted ( a , b , c ) : get_max = max ( a , b , c ) get_min = min ( a , b , c ) get_mid = ( a + b + c ) - ( get_max + get_min ) print ( get_min + " " + get_mid ) print ( get_max ) print ( " " + get_mid ) print ( " " + get_max ) print ( " " )

def printSorted ( a , b , c ) : get_max = max ( a , max ( b , c ) ) get_min = - max ( - a , max ( - b , - c ) ) get_mid = ( a + b + c ) - ( get_max + get_min ) print ( get_min + " " + get_mid + " " + get_max )

52.32
43.51
40.32
35.73
static int countPS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( ( i - j == 1 ) || ( i - j == - 1 ) ) { if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = 3 ; else return dp [ i ] [ j ] = 2 ; } if ( i == j ) return dp [ 1 ] [ j ] = 1 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }

def countPS ( i , j ) : if ( i >= n or j < 0 ) : return 0 if ( dp [ i ] [ j ] != - 1 ) : return dp [ i ] [ j ] if ( abs ( i - j ) == 1 ) : if ( str [ i ] == str [ j ] ) : dp [ i ] [ j ] = 3 return dp [ i ] [ j ] else : dp [ i ] [ j ] = 2 return dp [ i ] [ j ] if ( i == j ) : dp [ 1 ] [ j ] = 1 return dp [ 1 ] [ j ] elif ( str [ i ] == str [ j ] ) : dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) return dp [ i ] [ j ] else : dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) return dp [ i ] [ j ]

def countPS ( i , j ) : if ( i >= n || j >= n ) : return 0 for i in range ( n ) : if ( i == j ) : return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) else : return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 else : return dp [ i ] [ j ] = 2 if ( i == j ) : return dp [ 1 ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 else : return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) return dp [ i ] [ j ] = countPS ( i + 1 , j - 1 )

def countPS ( i , j ) : if i >= n or j < 0 : return 0 if i == j : return dp [ 1 ] [ j ] = 1 else : if ( i == j ) : return dp [ 1 ] [ j ] = 1 else : if ( str ( i ) == str ( j ) ) : return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 else : return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 )

52.43
57.7
76.0
59.68
static int findMinDiff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }

def findMinDiff ( arr , n ) : diff = 10 ** 20 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : if abs ( arr [ i ] - arr [ j ] ) < diff : diff = abs ( arr [ i ] - arr [ j ] ) return diff

def findMinDiff ( arr , n ) : diff = float ( 'inf' ) for i in range ( 0 , n - 1 , - 1 ) : if ( arr [ i ] - arr [ j ] ) < diff : diff = float ( 'inf' ) for j in range ( i + 1 , n ) : if ( arr [ i ] - arr [ j ] ) < diff : diff = abs ( ( arr [ i ] - arr [ j ] ) ) : diff = float ( arr [ i ] ) return diff

def findMinDiff ( arr , n ) : diff = INT_MAX for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) : diff = abs ( ( arr [ i ] - arr [ j ] ) ) return diff

52.46
35.34
74.43
61.56
public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }

def isPower ( x , y ) : if ( x == 1 ) : return ( y == 1 ) pow = 1 while ( pow < y ) : pow = pow * x return ( pow == y )

def isPower ( x , y ) : if ( x == 1 ) : return ( y == 1 ) : return ( pow == 1 )

def isPower ( x , y ) : if x == 1 : return ( y == 1 ) pow = 1 while pow < y : pow = pow * x return ( pow == y )

52.49
40.88
59.71
46.5
static int maximumSum ( int a [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a , i , n ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }

def maximumSum ( a , n ) : global M for i in range ( 0 , n ) : a [ i ] . sort ( ) sum = a [ n - 1 ] [ M - 1 ] prev = a [ n - 1 ] [ M - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : for j in range ( M - 1 , - 1 , - 1 ) : if ( a [ i ] [ j ] < prev ) : prev = a [ i ] [ j ] sum += prev break if ( j == - 1 ) : return 0 return sum

def maximumSum ( a , M , n ) : a . sort ( reverse = True ) sum = 0 for i in range ( n ) : if ( a [ i ] [ M ] < prev ) : prev = a [ i ] [ M ] sum += prev for j in range ( M - 1 , - 1 ) : if ( a [ i ] [ j ] < prev ) : prev = a [ i ] [ j ] sum += prev break if ( j ==

def maximumSum ( a , n ) : sum = a [ n - 1 ] [ M - 1 ] prev = a [ n - 1 ] [ M - 1 ] i = n - 2 while i >= 0 : for j in range ( M ) : if ( a [ i ] [ j ] < prev ) : prev = a [ i ] [ j ] sum += prev break if ( j == - 1 ) : return 0 return sum

52.52
41.42
78.26
61.38
public static int longOddEvenIncSeq ( int arr [ ] , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }

def longOddEvenIncSeq ( arr , n ) : lioes = list ( ) maxLen = 0 for i in range ( n ) : lioes . append ( 1 ) i = 1 for i in range ( n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : lioes [ i ] = lioes [ j ] + 1 for i in range ( n ) : if maxLen < lioes [ i ] : maxLen = lioes [ i ] return maxLen

def longOddEvenIncSeq ( arr , n ) : lioes = [ 0 for i in range ( n ) ] for j in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] ) : lioes [ i ] = 1 else : maxLen = 0 for i in range ( 1 , n ) : if ( maxLen < lioes [ i ] ) : maxLen = lioes [ i ] if ( maxLen > lioes [ i ] ) : maxLen = lioes [ i ] if ( maxLen < lioes [ i ] ) : maxLen = lioes [ i ] if ( maxLen < lioes [ i ] ) : maxLen = lioes [ i ] return maxLen

def longOddEvenIncSeq ( arr , n ) : lioes = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : lioes [ i ] = 1 for i in range ( 1 , n ) : if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : lioes [ i ] = lioes [ j ] + 1 for i in range ( 0 , n ) : if ( maxLen < lioes [ i ] ) : maxLen = lioes [ i ] return maxLen

52.57
43.46
47.12
43.4
static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }

def maxAlternateSum ( arr , n ) : if ( n == 1 ) : return arr [ 0 ] dec = [ 0 for i in range ( n + 1 ) ] inc = [ 0 for i in range ( n + 1 ) ] dec [ 0 ] = inc [ 0 ] = arr [ 0 ] flag = 0 for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ j ] > arr [ i ] ) : dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) flag = 1 elif ( arr [ j ] < arr [ i ] and flag == 1 ) : inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) result = - 2147483648 for i in range ( n ) : if ( result < inc [ i ] ) : result = inc [ i ] if ( result < dec [ i ] ) : result = dec [ i ] return result

def maxAlternateSum ( arr , n ) : if n == 1 : return arr [ 0 ] else : dec = [ 0 for k in range ( n ) ] inc = [ 0 for k in range ( n ) ] flag = 0 for i in range ( 1 , n ) : if ( arr [ j ] > arr [ i ] ) : dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) flag = 1 else : if ( arr [ j ] < arr [ i ] ) : inc [ i ] = max ( inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) return result

def maxAlternateSum ( arr , n ) : dec = [ 0 for k in range ( n ) ] inc = [ 0 for k in range ( n ) ] flag = 0 for i in range ( 1 , n ) : if ( arr [ j ] > arr [ i ] ) : dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) flag = 1 elif ( arr [ j ] < arr [ i ] and flag == 1 ) : inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) return result

52.57
55.24
72.93
73.89
static char first ( String str , int i ) { if ( str . charAt ( i ) == '\0' ) return 0 ; if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }

def first ( str , i ) : if ( str [ i ] == '\0' ) : return 0 if ( str [ i ] . isupper ( ) ) : return str [ i ] return first ( str , i + 1 )

def first ( str , i ) : if ( str [ i ] == '\0' ) : return 0 return first ( str , i + 1 )

def first ( str , i ) : if str [ i ] == '\0' : return 0 if Character . isUpperCase ( str [ i ] ) : return str [ i ] return first ( str , i + 1 )

52.58
44.8
46.99
41.28
static int numofsubset ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; }

def numofsubset ( arr , n ) : x = sorted ( arr ) count = 1 for i in range ( 0 , n - 1 ) : if ( x [ i ] + 1 != x [ i + 1 ] ) : count = count + 1 return count

def numofsubset ( arr , n ) : count = 1 for i in range ( n ) : if ( arr [ i ] + 1 != arr [ i + 1 ] ) : count ++ return count

def numofsubset ( arr , n ) : count = 1 for i in range ( n ) : if arr [ i ] + 1 != arr [ i + 1 ] : count += 1 return count

52.63
55.02
83.01
82.46
static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }

def printKDistinct ( arr , n , k ) : dist_count = 0 for i in range ( n ) : j = 0 while j < n : if ( i != j and arr [ j ] == arr [ i ] ) : break j += 1 if ( j == n ) : dist_count += 1 if ( dist_count == k ) : return arr [ i ] return - 1

def printKDistinct ( arr , n , k ) : dist_count = 0 for i in range ( 0 , n , k ) : if ( arr [ i ] == arr [ i ] ) : dist_count += 1 if ( dist_count == k ) : return arr [ i ]

def printKDistinct ( arr , n , k ) : dist_count = 0 for i in range ( n ) : for j in range ( n ) : if ( i != j and arr [ j ] == arr [ i ] ) : break if ( j == n ) : dist_count += 1 if ( dist_count == k ) : return arr [ i ] return - 1

52.68
48.43
24.18
30.31
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " Invalid Input " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( "The third Largest " + "element is %d\n" , third ) ; }

def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( "InvalidInput" ) return first = arr [ 0 ] for i in range ( 1 , arr_size ) : if ( arr [ i ] > first ) : first = arr [ i ] second = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > second and arr [ i ] < first ) : second = arr [ i ] third = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > third and arr [ i ] < second ) : third = arr [ i ] print ( "TheThirdLargest" , "elementis" , third )

def thirdLargest ( arr , arr_size ) : if ( arr_size < 2 ) : print ( "Invalid Input " ) ; return ; } int first = float ( 'inf' ) for i in range ( 1 , arr_size ) : if ( arr [ i ] > first && arr [ i ] < first ) second = arr [ i ] third = float ( 'inf' ) for i in range ( 0 , arr_size ) : if ( arr [ i ] > third ) : third = arr [ i ] if ( arr [ i ] > third and arr [ i ] < second ) : third = arr [ i ] if ( arr [ i ] > third ) : third = arr [ i ] if ( arr [ i ] > third ) : third = arr [ i ] < first ) : third = arr [ i ] print ( "The third Largest " + "element is %d\n" , third ) return

def thirdLargest ( arr , arr_size ) : first = arr [ 0 ] for i in range ( 1 , arr_size ) : if arr [ i ] > first and arr [ i ] < first : second = arr [ i ] third = arr [ i ] print ( "The third Largest " + "element is %d\n" , third )

52.71
54.54
58.08
48.08
static void search ( int arr [ ] , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . printf ( "The required element is %d " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }

def search ( arr , low , high ) : if low > high : return None if low == high : return arr [ low ] mid = ( low + high ) / 2 ; if mid % 2 == 0 : if arr [ mid ] == arr [ mid + 1 ] : return search ( arr , mid + 2 , high ) else : return search ( arr , low , mid ) else : if arr [ mid ] == arr [ mid - 1 ] : return search ( arr , mid + 1 , high ) else : return search ( arr , low , mid - 1 )

def search ( arr , low , high ) : if low == high : return if high == 0 : print ( arr [ low ] , end = "" ) return for mid in range ( low , high ) : if ( arr [ mid ] == arr [ mid + 1 ] ) : search ( arr , mid + 2 , high ) : search ( arr , low , mid ) else : print ( arr , mid - 1 ) return if ( arr [ mid ] == arr [ mid -

def search ( arr , low , high ) : if low > high : print ( "The required element is %d" , arr [ low ] ) return if high == low : print ( "The required element is %d" , arr [ low ] ) return if low == high : print ( "The required element is %d" , arr [ low ] ) return mid = ( low + high ) // 2 if mid % 2 == 0 : if ( arr [ mid ] == arr [ mid + 1 ] ) : search ( arr , mid + 2 , high ) else : search ( arr , low , mid ) else : if ( arr [ mid ] == arr [ mid - 1 ] ) : search ( arr , mid + 1 , high ) else : search ( arr , low , mid - 1 )

52.73
51.44
46.56
47.3
static int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) odd_count ++ ; if ( ( n & 2 ) != 0 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ; }

def isMultipleOf3 ( n ) : odd_count = 0 even_count = 0 if ( n < 0 ) : n = - n if ( n == 0 ) : return 1 if ( n == 1 ) : return 0 while ( n ) : if ( n & 1 ) : odd_count += 1 if ( n & 2 ) : even_count += 1 n = n >> 2 return isMultipleOf3 ( abs ( odd_count - even_count ) )

def isMultipleOf3 ( n ) : odd_count = 0 even_count = 0 n = n >> 1 while n != 0 : if ( n & 1 ) != 0 : odd_count += 1 if ( n & 2 ) != 0 : even_count += 1 n = n >> 2 while n != 0 : if ( n & 4 ) != 0 : even_count += 1 return isMultipleOf3 ( Math . abs ( odd_count - even_count )

def isMultipleOf3 ( n ) : odd_count = 0 even_count = 0 while n != 0 : if ( n & 1 ) != 0 : odd_count += 1 if ( n & 2 ) != 0 : even_count += n n = n >> 2 return isMultipleOf3 ( Math . abs ( odd_count - even_count ) )

52.74
40.73
50.15
38.47
static void findSymPairs ( int arr [ ] [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; Integer val = hM . get ( sec ) ; if ( val != null && val == first ) System . out . println ( "(" + sec + ", " + first + ")" ) ; else hM . put ( first , sec ) ; } }

def findSymPairs ( arr , row ) : hM = dict ( ) for i in range ( row ) : first = arr [ i ] [ 0 ] sec = arr [ i ] [ 1 ] if ( sec in hM . keys ( ) and hM [ sec ] == first ) : print ( "(" , sec , "," , first , ")" ) else : hM [ first ] = sec

def findSymPairs ( arr ) : hM = defaultdict ( int ) for i in range ( len ( arr ) ) : first = arr [ i ] [ 0 ] sec = arr [ i ] [ 1 ] val = hM [ first ] if ( val != null ) : print ( "(" + sec + ", " + first + ")" ) else : hM . put ( first , sec ) return hM

def findSymPairs ( arr ) : hM = { } for i in range ( len ( arr ) ) : first = arr [ i ] [ 0 ] sec = arr [ i ] [ 1 ] val = hM . get ( sec ) if ( val != None and val == first ) : print ( "(" + sec + ", " + first + ")" ) else : hM . put ( first , sec )

52.82
50.04
81.78
76.17
static boolean isDDM ( int m [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ; sum -= Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }

def isDDM ( m , n ) : for i in range ( 0 , n ) : sum = 0 for j in range ( 0 , n ) : sum = sum + abs ( m [ i ] [ j ] ) sum = sum - abs ( m [ i ] [ i ] ) if ( abs ( m [ i ] [ i ] ) < sum ) : return False return True

def isDDM ( m , n ) : m . sort ( reverse = True ) sum = 0 for i in range ( 0 , n ) : sum += Math . abs ( m [ i ] [ i ] ) sum -= Math . abs ( m [ i ] [ i ] ) if ( sum < 0 ) : return false return true

def isDDM ( m , n ) : for i in range ( n ) : sum = 0 for j in range ( 0 , n ) : sum += abs ( m [ i ] [ j ] ) sum -= abs ( m [ i ] [ i ] ) if ( math . abs ( m [ i ] [ i ] ) < sum ) : return False return True

52.83
43.09
64.51
49.22
static int countSub ( String str ) { int [ ] last = new int [ MAX_CHAR ] ; Arrays . fill ( last , - 1 ) ; int n = str . length ( ) ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( int ) str . charAt ( i - 1 ) ] ] ; last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ; } return dp [ n ] ; }

def countSub ( ss ) : last = [ - 1 for i in range ( MAX_CHAR + 1 ) ] n = len ( ss ) dp = [ - 2 for i in range ( n + 1 ) ] dp [ 0 ] = 1 for i in range ( 1 , n + 1 ) : dp [ i ] = 2 * dp [ i - 1 ] if last [ ord ( ss [ i - 1 ] ) ] != - 1 : dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ] last [ ord ( ss [ i - 1 ] ) ] = i - 1 return dp [ n ]

def countSub ( str , last ) : last = [ - 1 for k in range ( MAX_CHAR ) ] dp = [ 1 for i in range ( 1 , n + 1 ) ] for i in range ( 1 , n ) : dp [ i ] = 2 * dp [ i - 1 ] if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) : dp [ i ] = dp [ i ] - dp [ last [ ( i - 1 ] if ( last [ ( int ) str [ i - 1 ] != - 1 ) : dp [ i ] = dp [ i ] - dp [ last [ ( int ) str . charAt ( i - 1 ) ] return dp [ n ]

def countSub ( str ) : last = [ - 1 for i in range ( n ) ] dp = [ 1 for i in range ( 1 , n + 1 ) ] for i in range ( 1 , n + 1 ) : dp [ i ] = 2 * dp [ i - 1 ] if last [ ( int ) str [ i - 1 ] != - 1 : dp [ i ] = dp [ i ] - dp [ last [ ( int ) str [ i - 1 ] ] ] last [ ( int ) str [ i - 1 ] ] = ( i - 1 ) return dp [ n ]

52.91
82.89
90.59
74.6
static int minimum_cost ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }

def minimum_cost ( a , n ) : mn = sys . maxsize sum = 0 for i in range ( n ) : mn = min ( a [ i ] , mn ) sum += a [ i ] return mn * ( sum - mn )

def minimum_cost ( a , n ) : mn = Integer . MAX_VALUE sum = 0 for i in range ( n ) : mn = min ( a [ i ] , mn ) sum += a [ i ] for i in range ( n ) : mn = min ( a [ i ] , mn ) sum += a [ i ] if ( sum > mn ) : return mn * ( sum - mn )

def minimum_cost ( a , n ) : mn = INT_MAX_VALUE sum = 0 for i in range ( n ) : mn = min ( a [ i ] , mn ) sum += a [ i ] return mn * ( sum - mn )

52.92
47.32
58.58
53.48
static long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }

def answer ( n ) : dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] if ( n == 1 ) : return 10 for j in range ( 10 ) : dp [ 1 ] [ j ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 10 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] elif ( j == 9 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) sum = 0 for j in range ( 1 , 10 ) : sum = sum + dp [ n ] [ j ] return sum

def answer ( n ) : dp = [ 1 , 2 , 10 ] for i in range ( 2 , n ) : dp [ i ] = [ 1 , 2 , 10 ] for j in range ( 0 , 9 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] if ( j == 9 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] return sum

def answer ( n ) : dp [ ] = [ 10 for j in range ( n ) ] for i in range ( 2 , n ) : for j in range ( 2 , n ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] elif ( j == 9 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ]

52.99
48.18
74.47
61.91
public static int productSubSeqCount ( ArrayList < Integer > arr , int k ) { int n = arr . size ( ) ; int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }

def productSubSeqCount ( arr , k ) : n = len ( arr ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] for i in range ( 1 , k + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 return dp [ k ] [ n ]

def productSubSeqCount ( arr , k ) : dp = [ 1 ] [ n + 1 ] for i in range ( 1 , k + 1 , n ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if ( arr . get ( j - 1 ) <= i and arr . get ( j - 1 ) > 0 ) : dp [ i ] [ j ] += dp [ i ] [ j - 1 ] + 1 return dp [ k ] [ n ]

def productSubSeqCount ( arr , k ) : n = arr . size ( ) dp = [ k + 1 ] [ n + 1 ] for i in range ( 1 , k ) : for j in range ( 1 , n ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : dp [ i ] [ j ] += dp [ i / arr [ j - 1 ] ] [ j - 1 ] + 1 return dp [ k ] [ n ]

53.04
71.52
63.56
67.97
static int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }

def findMinInsertions ( str , l , h ) : if ( l > h ) : return sys . maxsize if ( l == h ) : return 0 if ( l == h - 1 ) : return 0 if ( str [ l ] == str [ h ] ) else 1 if ( str [ l ] == str [ h ] ) : return findMinInsertions ( str , l + 1 , h - 1 ) else : return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )

def findMinInsertions ( str , l , h ) : if ( l == h ) : return findMinInsertions ( str , l , h - 1 ) if ( str [ l ] == str [ h ] ) : return findMinInsertions ( str , l + 1 , h - 1 ) return findMinInsertions ( str , l , h - 1 ) if ( str [ l ] == str [ h ] ) : findMinInsertions ( str , l + 1 , h ) return findMinInsertions ( str , l + 1 , h - 1 ) : return findMinInsertions ( str , l , h - 1 ) if ( str [ l ] == str [ h ] ) : return findMinInsertions ( str , l + 1 , h - 1 ) return findMinInsertions ( str , l , h - 1 )

def findMinInsertions ( str , l , h ) : if l > h : return Integer . MAX_VALUE if l == h - 1 : return ( str [ l ] == str [ h ] ) ? 0 : 1 : ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1

53.08
37.67
48.38
36.29
static boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( "False" ) ; if ( n <= 3 ) System . out . println ( "False" ) ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }

def isComposite ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return False if ( n % 2 == 0 or n % 3 == 0 ) : return True i = 5 while ( i * i <= n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return True i = i + 6 return False

def isComposite ( n ) : if ( n <= 1 ) print ( "False" ) if ( n <= 3 ) print ( "False" ) if ( n <= 5 ) print ( "False" ) if ( n % 2 == 0 || n % 3 == 0 ) : return true else : for i in range ( 5 , 6 ) : if ( n % i == 0 || n % ( i + 2 ) == 0 ) : return true else : return false

def isComposite ( n ) : if n <= 1 : print ( "False" ) if n <= 3 : print ( "False" ) if n % 2 == 0 or n % 3 == 0 : return True for i in range ( 5 , n ) : if n % i == 0 or n % ( i + 2 ) == 0 : return True return False

53.1
50.69
98.32
88.66
static int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }

def getIndexInSortedArray ( arr , n , idx ) : result = 0 for i in range ( n ) : if ( arr [ i ] < arr [ idx ] ) : result += 1 if ( arr [ i ] == arr [ idx ] and i < idx ) : result += 1 return result ;

def getIndexInSortedArray ( arr , n , idx ) : result = 0 for i in range ( 0 , n ) : if ( arr [ i ] < arr [ idx ] ) : result ++ if ( arr [ i ] == arr [ idx ] ) : result ++ if ( arr [ i ] == arr [ idx ] ) : result ++ if ( arr [ i ] == arr [ idx ] ) : result ++ return result

def getIndexInSortedArray ( arr , n , idx ) : result = 0 for i in range ( n ) : if ( arr [ i ] < arr [ idx ] ) : result += 1 if ( arr [ i ] == arr [ idx ] and i < idx ) : result += 1 return result

53.11
35.71
91.17
61.62
static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }

def numberOfWays ( x ) : if x == 0 or x == 1 : return 1 else : return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )

def numberOfWays ( x ) : if ( x == 0 ) : return 1 else : return numberOfWays ( x - 1 ) + numberOfWays ( x - 2 )

def numberOfWays ( x ) : if x == 0 or x == 1 : return 1 else : return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 )

53.19
43.59
76.59
59.7
static int sumAtKthLevel ( String tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) sum += ( tree . charAt ( i ) - '0' ) ; } } return sum ; }

def sumAtKthLevel ( tree , k ) : level = - 1 sum = 0 n = len ( tree ) for i in range ( n ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 else : if ( level == k ) : sum += ( ord ( tree [ i ] ) - ord ( '0' ) ) return sum

def sumAtKthLevel ( tree , k ) : level = - 1 for i in range ( n ) : if ( tree [ i ] == '(' ) level += 1 elif ( tree [ i ] == ')' ) level -= 1 else : sum += ( tree [ i ] - '0' )

def sumAtKthLevel ( tree , k ) : level = - 1 sum = 0 n = tree . length ( ) for i in range ( 0 , n ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 if ( level == k ) : sum += ( tree [ i ] - '0' ) return sum

53.25
36.82
67.11
43.97
static double nthRoot ( int A , int N ) { double xPre = Math . random ( ) % 10 ; double eps = 0.001 ; double delX = 2147483647 ; double xK = 0.0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }

def nthRoot ( A , N ) : xPre = random . randint ( 1 , 101 ) % 10 eps = 0.001 delX = 2147483647 xK = 0.0 while ( delX > eps ) : xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N delX = abs ( xK - xPre ) xPre = xK return xK

def nthRoot ( A , N ) : xPre = 0 for k in range ( N ) : delX = abs ( xK - xPre ) if ( delX > eps ) : xK = ( N - 1.0 ) * xPre + ( double ) A / ( xPre , N - 1 ) ) / ( double ) N return xK

def nthRoot ( A , N ) : xPre = math . random ( ) eps = 0.001 delX = 2147483647 xK = 0.0 while delX > eps : xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N delX = Math . abs ( xK - xPre ) xPre = xK return xK

53.3
41.22
54.02
44.29
static int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }

def findSum ( n ) : ans = 0 temp = 0 for i in range ( 1 , n + 1 ) : if temp < n : temp = i - 1 num = 1 while temp < n : if temp + i <= n : ans += i * num else : ans += ( n - temp ) * num temp += i num += 1 return ans

def findSum ( n ) : ans = 0 , temp = 0 , num = 1 for i in range ( 1 , n ) : if ( temp + i <= n ) : ans += ( i * num ) temp += i num += 1 if ( temp + i <= n ) : ans += ( n - temp ) * num return ans

def findSum ( n ) : ans = 0 temp = 0 num = 1 while temp < n : if ( temp + i <= n ) : ans += ( i * num ) else : ans += ( ( n - temp ) * num ) temp += i num += 1 return ans

53.31
43.38
82.8
87.76
static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }

def countSetBits ( n ) : count = 0 while ( n ) : n &= ( n - 1 ) count += 1 return count

def countSetBits ( n ) : count = 0 for n in range ( 32 ) : n >>= 1 count += 1 return count

def countSetBits ( n ) : count = 0 while n > 0 : n &= ( n - 1 ) count += 1 return count

53.31
58.04
77.07
69.65
public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }

def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : d1 = d1 + arr [ i ] [ i ] d2 = d2 + arr [ i ] [ n - i - 1 ] return abs ( d1 - d2 )

def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( n ) : d1 += arr [ i ] [ i ] d2 += arr [ i ] [ n - i - 1 ] i = n - 1 d1 += arr [ i ] [ i ] d2 += arr [ i ] [ n - i - 1 ] return d1 - d2

def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( n ) : d1 += arr [ i ] [ i ] d2 += arr [ i ] [ n - i - 1 ] return abs ( d1 - d2 )

53.32
44.14
66.16
56.24
static void maximizecube ( int l , int b , int h ) { int side = gcd ( l , gcd ( b , h ) ) ; int num = l / side ; num = ( num * b / side ) ; num = ( num * h / side ) ; System . out . println ( side + " " + num ) ; }

def maximizecube ( l , b , h ) : side = gcd ( l , gcd ( b , h ) ) num = int ( l / side ) num = int ( num * b / side ) num = int ( num * h / side ) print ( side , num )

def maximizecube ( l , b , h ) : side = gcd ( l , b ) num = l / side num = ( num * b / side ) num = ( num * h / side ) side = ( num * b / side ) System . out . println ( side + " " + num ) return

def maximizecube ( l , b , h ) : side = gcd ( l , gcd ( b , h ) ) num = ( num * b / side ) num = ( num * h / side ) num = ( num * b / side ) num = ( num * h / side ) print ( side + " " + num )

53.33
38.9
85.31
61.78
static int countWays ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ; return DP [ n ] ; }

def countWays ( n ) : DP = [ 0 for i in range ( 0 , n + 1 ) ] DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 DP [ 3 ] = 2 for i in range ( 4 , n + 1 ) : DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] return DP [ n ]

def countWays ( n ) : DP = [ 0 for k in range ( n ) ] for i in range ( 4 , n ) : DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] return DP [ n ]

def countWays ( n ) : DP = [ 0 for k in range ( n ) ] DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 DP [ 3 ] = 2 for i in range ( 4 , n ) : DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] return DP [ n ]

53.35
77.44
59.87
56.59
static void findConsecutive ( int N ) { int start = 1 ; int end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= i ; j ++ ) System . out . print ( j + " " ) ; System . out . println ( ) ; break ; } if ( sum > N ) break ; } sum = 0 ; start ++ ; } }

def findConsecutive ( N ) : start = 1 end = ( N + 1 ) // 2 while ( start < end ) : Sum = 0 for i in range ( start , end + 1 ) : Sum = Sum + i if ( Sum == N ) : for j in range ( start , i + 1 ) : print ( j , end = "" ) print ( ) break if ( Sum > N ) : break Sum = 0 start += 1

def findConsecutive ( N ) : start = 1 end = ( N + 1 ) // 2 while start < end : sum = 0 for i in range ( start , end ) : sum = sum + i if ( sum == N ) : print ( j + " " ) break if ( sum > N ) : break print ( sum ) start += 1 end -= 1 sum = 0 for i in range ( start , end ) : sum = sum + i if ( sum ==

def findConsecutive ( N ) : start = 1 end = ( N + 1 ) / 2 while start < end : sum = 0 for i in range ( start , end ) : sum = sum + i if ( sum == N ) : for j in range ( start , i ) : print ( j + " " ) print ( ) break if ( sum > N ) : break sum = 0 start ++

53.47
36.44
80.56
76.25
static boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }

def isPath ( arr ) : arr [ 0 ] [ 0 ] = 1 for i in range ( 1 , row ) : if ( arr [ i ] [ 0 ] != - 1 ) : arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] for j in range ( 1 , col ) : if ( arr [ 0 ] [ j ] != - 1 ) : arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] for i in range ( 1 , row ) : for j in range ( 1 , col ) : if ( arr [ i ] [ j ] != - 1 ) : arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) return ( arr [ row - 1 ] [ col - 1 ] == 1 )

def isPath ( arr ) : arr [ 0 ] = 1 arr [ 0 ] [ 0 ] = 1 arr [ 0 ] [ 1 ] = 1 arr [ 0 ] [ 1 ] = arr [ 0 ] [ 1 ] for j in range ( 1 , 5 ) : if ( arr [ i ] [ j ] != - 1 ) : arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) else : return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 )

def isPath ( arr ) : arr [ 0 ] [ 0 ] = 1 for i in range ( 1 , 5 ) : arr [ 0 ] [ i ] = 1 for i in range ( 1 , 5 ) : if ( arr [ 0 ] [ i ] != - 1 ) : arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] for j in range ( 1 , 5 ) : if ( arr [ j ] [ 0 ] != - 1 ) : arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] for i in range ( 1 , 5 ) : if ( arr [ i ] [ j ] != - 1 ) : arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 )

53.5
46.19
71.75
53.93
int minDist ( int arr [ ] , int n , int x , int y ) { int i = 0 ; int min_dist = Integer . MAX_VALUE ; int prev = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) { min_dist = i - prev ; prev = i ; } else prev = i ; } } return min_dist ; }

def minDist ( arr , n , x , y ) : min_dist = sys . maxsize for i in range ( n ) : if arr [ i ] == x or arr [ i ] == y : prev = i break while i < n : if arr [ i ] == x or arr [ i ] == y : if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist : min_dist = i - prev prev = i else : prev = i i += 1 return min_dist

def minDist ( arr , n , x , y ) : min_dist = float ( 'inf' ) for i in range ( 0 , n ) : if ( arr [ i ] == x || arr [ i ] == y ) : min_dist = i - prev break if ( arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist ) : min_dist = i - prev prev = i if ( arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist ) : min_dist = i - prev return min_dist

def minDist ( arr , n , x , y ) : min_dist = float ( 'inf' ) prev = 0 for i in range ( 0 , n ) : if ( arr [ i ] == x or arr [ i ] == y ) : prev = i break if ( arr [ i ] == x or arr [ i ] == y ) : if ( arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist ) : min_dist = i - prev prev = i else : prev = i return min_dist

53.53
47.15
74.58
72.87
static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( "number is not" + " present!" ) ; return - 1 ; }

def search ( arr , n , x ) : i = 0 while ( i < n ) : if ( arr [ i ] == x ) : return i i = i + abs ( arr [ i ] - x ) print ( "numberisnotpresent!" ) return - 1

def search ( arr , n , x ) : i = 0 while ( i < n ) : if ( arr [ i ] == x ) : return i

def search ( arr , n , x ) : i = 0 while i < n : if ( arr [ i ] == x ) : return i i = i + Math . abs ( arr [ i ] - x ) print ( "number is not" + " present!" ) return - 1

53.54
46.61
79.66
77.46
static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( "Fits" ) ; else System . out . println ( "Doesn't Fit" ) ; }

def fitOrNotFit ( R , r , x , y , rad ) : val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) if ( val + rad <= R and val - rad >= R - r ) : print ( "Fits\n" ) else : print ( "Doesn'tFit" )

def fitOrNotFit ( R , r , x , y , rad ) : val = sqrt ( R + r ) if ( val + rad <= R && val - rad >= R - r ) : print ( "Fits" ) else : print ( "Doesn't Fit" )

def fitOrNotFit ( R , r , x , y , rad ) : val = sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) if val + rad <= R and val - rad >= R - r : print ( "Fits" ) else : print ( "Doesn't Fit" )

53.56
40.24
85.74
82.91
static int maxProd ( int n ) { if ( n == 0 || n == 1 ) return 0 ; int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ; return max_val ; }

def maxProd ( n ) : if ( n == 0 or n == 1 ) : return 0 max_val = 0 for i in range ( 1 , n - 1 ) : max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) return max_val

def maxProd ( n ) : if ( n == 0 ) : return 0 for i in range ( 1 , n ) : max_val = max ( max_val , maxProd ( n - i ) * i ) return max_val

def maxProd ( n ) : if n == 0 or n == 1 : return 0 max_val = 0 for i in range ( 1 , n ) : max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) return max_val

53.61
48.49
80.49
66.58
static int fib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; return fib ( n - 1 , b , a + b ) ; }

def fib ( n , a = 0 , b = 1 ) : if n == 0 : return a if n == 1 : return b return fib ( n - 1 , b , a + b ) ;

def fib ( n , a , b ) : if ( n == 0 ) : return a if ( n == 1 ) : return b return fib ( n - 1 , a , b + a )

def fib ( n , a , b ) : if n == 0 : return a if n == 1 : return b return fib ( n - 1 , b , a + b )

53.62
46.91
73.34
60.45
static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) { int T1 [ ] = new int [ NUM_STATION ] ; int T2 [ ] = new int [ NUM_STATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }

def carAssembly ( a , t , e , x ) : NUM_STATION = len ( a [ 0 ] ) T1 = [ 0 for i in range ( NUM_STATION ) ] T2 = [ 0 for i in range ( NUM_STATION ) ] T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] for i in range ( 1 , NUM_STATION ) : T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] )

def carAssembly ( a , t , e , x ) : T1 = [ NUM_STATION , NUM_STATION ] T2 = [ NUM_STATION , NUM_STATION ] for i in range ( 1 , NUM_STATION ) : T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] + x [ 0 ] ) return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] )

def carAssembly ( a , t , e , x ) : T1 = [ 0 for k in range ( NUM_STATION ) ] T2 = [ 0 for k in range ( NUM_STATION ) ] for i in range ( 1 , NUM_STATION ) : T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] )

53.65
42.31
40.49
32.29
static void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) != ' ' ) count [ ( int ) str . charAt ( i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str . charAt ( i ) ] == 1 ) System . out . print ( str . charAt ( i ) ) ; }

def printDistinct ( str ) : count = [ 0 ] * NO_OF_CHARS for i in range ( len ( str ) ) : if ( str [ i ] != '' ) : count [ ord ( str [ i ] ) ] += 1 n = i for i in range ( n ) : if ( count [ ord ( str [ i ] ) ] == 1 ) : print ( str [ i ] , end = "" )

def printDistinct ( str ) : count = [ 0 for i in range ( NO_OF_CHARS ) ] for i in range ( 0 , len ( str ) ) : if ( count [ ( int ) str . charAt ( i ) ] == 1 ) : print ( str [ i ] ) n = i for i in range ( 0 , n ) : if ( count [ ( int ) str . charAt ( i ) ] == 1 ) : print ( str [ i ] )

def printDistinct ( str ) : count = [ 0 for i in range ( NO_OF_CHARS ) ] n = i for i in range ( 0 , NO_OF_CHARS ) : if ( count [ ( int ) str [ i ] ] == 1 ) : print ( str [ i ] )

53.66
42.89
60.61
44.09
static int getRemainder ( int num , int divisor ) { if ( divisor == 0 ) { System . out . println ( "Error: divisor " + "can't be zero \n" ) ; return - 1 ; } if ( divisor < 0 ) divisor = - divisor ; if ( num < 0 ) num = - num ; int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i ++ ; } return num - ( product - divisor ) ; }

def getRemainder ( num , divisor ) : if ( divisor == 0 ) : return False if ( divisor < 0 ) : divisor = - divisor if ( num < 0 ) : num = - num i = 1 product = 0 while ( product <= num ) : product = divisor * i i += 1 return num - ( product - divisor )

def getRemainder ( num , divisor ) : if ( divisor == 0 ) : return - 1 else : product = 0 for i in range ( 1 , num ) : product = divisor * i if ( product <= num ) : product = divisor * i i ++ return num - ( product - divisor )

def getRemainder ( num , divisor ) : if divisor == 0 : print ( "Error: divisor " + "can't be zero \n" ) return - 1 if divisor < 0 : divisor = - divisor if num < 0 : num = - num i = 1 while ( product <= num ) : product = divisor * i i ++ return num - ( product - divisor )

53.67
39.32
47.08
39.66
static boolean ispalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }

def ispalindrome ( s ) : l = len ( s ) i = 0 j = l - 1 while i <= j : if ( s [ i ] != s [ j ] ) : return False i += 1 j -= 1 return True

def ispalindrome ( s ) : l = len ( s ) for i in range ( l ) : for j in range ( l - 1 , - 1 , - 1 ) : if ( s [ i ] != s [ j ] ) : return false

def ispalindrome ( s ) : l = s . length ( ) for i in range ( l ) : for j in range ( l - 1 , - 1 , - 1 ) : if ( s [ i ] != s [ j ] ) : return False return True

53.68
34.27
84.67
54.2
static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }

def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low if x > arr [ high ] : return - 1 mid = ( low + high ) / 2 if arr [ mid ] == x : return mid elif arr [ mid ] < x : if mid + 1 <= high and x <= arr [ mid + 1 ] : return mid + 1 else : return ceilSearch ( arr , mid + 1 , high , x ) else : if mid - 1 >= low and x > arr [ mid - 1 ] : return mid else : return ceilSearch ( arr , low , mid - 1 , x )

def ceilSearch ( arr , low , high , x ) : if low == high : return low if high == 0 : return - 1 mid = ( low + high ) // 2 if arr [ mid ] == x : return mid elif arr [ mid ] < x : if ( mid + 1 <= high and x <= arr [ mid + 1 ] ) : return mid + 1 else : return ceilSearch ( arr , mid + 1 , high , x )

def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low if x > arr [ high ] : return - 1 mid = ( low + high ) // 2 if arr [ mid ] == x : return mid elif arr [ mid ] < x : if mid + 1 <= high and x <= arr [ mid + 1 ] : return mid + 1 else : if mid - 1 >= low and x > arr [ mid - 1 ] : return mid else : if mid - 1 >= low and x > arr [ mid - 1 ] : return mid else : return ceilSearch ( arr , low , mid - 1 , x )

53.73
75.88
86.43
86.3
static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " " ) ; } }

def findMissing ( a , b , n , m ) : for i in range ( n ) : for j in range ( m ) : if ( a [ i ] == b [ j ] ) : break if ( j == m - 1 ) : print ( a [ i ] , end = "" )

def findMissing ( a , b , n , m ) : for i in range ( n ) : for j in range ( 0 , m ) : if ( a [ i ] == b [ j ] ) : break if ( j == m ) : print ( a [ i ] + " " ) return if ( j == m ) : print ( b [ j ] + " " ) return if ( j == m ) : print ( a [ i ] + " " )

def findMissing ( a , b , n , m ) : for i in range ( n ) : for j in range ( m ) : if ( a [ i ] == b [ j ] ) : break if ( j == m ) : print ( a [ i ] + " " )

53.79
58.27
66.51
55.01
void bubbleSort ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } }

def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : for j in range ( 0 , n - i - 1 ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ]

def bubbleSort ( arr ) : n = arr . length for i in range ( n ) : for j in range ( n - i - 1 , - 1 , - 1 ) : if ( arr [ j ] > arr [ j + 1 ] ) : arr [ j ] = arr [ j + 1 ] j += 1 temp = arr [ j ] arr [ j ] = arr [ j + 1 ] j += 1 if ( arr [ j ] < arr [ j +

def bubbleSort ( arr ) : n = arr . length for i in range ( n ) : for j in range ( n - 1 , - 1 , - 1 ) : if ( arr [ j ] > arr [ j + 1 ] ) : temp = arr [ j ] arr [ j ] = arr [ j + 1 ] arr [ j + 1 ] = temp

53.79
46.3
36.24
32.29
static int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }

def countFriendsPairings ( n ) : dp = [ - 1 ] * 100 if ( dp [ n ] != - 1 ) : return dp [ n ] if ( n > 2 ) : dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) return dp [ n ] else : dp [ n ] = n return dp [ n ]

def countFriendsPairings ( n ) : dp = [ - 1 for k in range ( n ) ] if ( n > 1 ) : return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) else : return dp [ n ] = n

def countFriendsPairings ( n ) : if n > 2 : return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) else : return dp [ n ] = n

53.82
37.38
89.75
89.53
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }

def countOnes ( arr , low , high ) : if high >= low : mid = low + ( high - low ) / 2 if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : return mid + 1 if arr [ mid ] == 1 : return countOnes ( arr , ( mid + 1 ) , high ) return countOnes ( arr , low , mid - 1 ) return 0

def countOnes ( arr , low , high ) : if low >= high : mid = low + ( high - low ) // 2 if arr [ mid ] == 1 : return countOnes ( arr , low , mid ) if arr [ mid ] == 1 : return countOnes ( arr , mid + 1 , high ) else : return countOnes ( arr , low , mid - 1 )

def countOnes ( arr , low , high ) : if high >= low : mid = low + ( high - low ) / 2 if ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) : return mid + 1 if ( arr [ mid ] == 1 ) : return countOnes ( arr , ( mid + 1 ) , high ) return countOnes ( arr , low , ( mid - 1 ) )

53.86
38.49
63.82
45.7
static long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; }

def calculate ( a , n ) : a . sort ( ) s = [ ] i = 0 j = n - 1 while ( i < j ) : s . append ( ( a [ i ] + a [ j ] ) ) i += 1 j -= 1 mini = min ( s ) maxi = max ( s ) return abs ( maxi - mini )

def calculate ( a , n ) : a . sort ( reverse = True ) s = list ( ) for i in range ( n ) : j = range ( n - 1 , - 1 , - 1 ) : s . add ( a [ i ] + a [ j ] ) mini = max ( s ) maxi = min ( s ) return Math . abs ( maxi - mini )

def calculate ( a , n ) : a . sort ( a ) s = list ( ) for i in range ( n ) : for j in range ( n - 1 , - 1 , - 1 ) : s . append ( ( a [ i ] + a [ j ] ) ) mini = min ( s ) maxi = max ( s ) return abs ( maxi - mini )

53.93
40.79
69.91
47.81
static int maxSum ( ) { int arrSum = 0 ; int currVal = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } int maxVal = currVal ; for ( int j = 1 ; j < arr . length ; j ++ ) { currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; }

def maxSum ( arr ) : arrSum = 0 currVal = 0 n = len ( arr ) for i in range ( 0 , n ) : arrSum = arrSum + arr [ i ] currVal = currVal + ( i * arr [ i ] ) maxVal = currVal for j in range ( 1 , n ) : currVal = currVal + arrSum - n * arr [ n - j ] if currVal > maxVal : maxVal = currVal return maxVal

def maxSum ( arr ) : arrSum = 0 currVal = 0 for i in range ( arr . length ) : arrSum = arrSum + arr [ i ] currVal = currVal + ( i * arr [ i ] ) arrSum = arrSum - arr . length * arr [ arr . length - j ] maxVal = currVal for j in range ( 1 , arr . length ) : currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] if ( currVal > maxVal ) : maxVal = currVal if ( currVal > maxVal ) : maxVal = currVal return maxVal

def maxSum ( arrSum ) : arrSum = 0 currVal = 0 for i in range ( len ( arr ) ) : arrSum = arrSum + arr [ i ] currVal = currVal + ( i * arr [ i ] ) maxVal = currVal for j in range ( 1 , arr . length ) : currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] if ( currVal > maxVal ) : maxVal = currVal return maxVal

53.93
55.26
66.59
63.49
int Circumference ( int a ) { return 4 * a ; }

def Circumference ( a ) : return ( 4 * a )

def Circumference ( a ) : return a

def Circumference ( a ) : return 4 * a

53.95
46.04
54.74
52.0
static int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }

def lenOfLongSubarr ( arr , n ) : um = { i : 0 for i in range ( 10 ) } sum = 0 maxLen = 0 for i in range ( n ) : if arr [ i ] == 0 : sum += - 1 else : sum += 1 if ( sum == 1 ) : maxLen = i + 1 elif ( sum not in um ) : um [ sum ] = i if ( ( sum - 1 ) in um ) : if ( maxLen < ( i - um [ sum - 1 ] ) ) : maxLen = i - um [ sum - 1 ] return maxLen

def lenOfLongSubarr ( arr , n ) : um = { } for i in range ( n ) : sum = 0 maxLen = 0 for i in range ( n ) : if ( arr [ i ] == 0 ) : maxLen = i + 1 else : if ( sum == 1 ) : maxLen = i + 1 else : if ( um [ sum ] != i ) : um [ sum ] = i if ( um [ sum - 1 ] != 0 ) : maxLen =

def lenOfLongSubarr ( arr , n ) : um = { } sum = 0 maxLen = 0 for i in range ( n ) : sum += arr [ i ] == 0 ? - 1 : 1 if ( sum == 1 ) : maxLen = i + 1 elif ( not um . containsKey ( sum ) ) : um . put ( sum , i ) if ( um . containsKey ( sum - 1 ) ) : if ( maxLen < ( i - um . get ( sum - 1 ) ) ) : maxLen = i - um . get ( sum - 1 ) ) : maxLen = i - um . get ( sum - 1 ) return maxLen

54.01
49.69
70.44
64.57
static int returnMaxSum ( int A [ ] , int B [ ] , int n ) { Set < Integer > mp = new HashSet < Integer > ( ) ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . contains ( A [ i ] ) ) { mp . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . add ( A [ i ] ) ; curr_sum += B [ i ] ; result = Integer . max ( result , curr_sum ) ; } return result ; }

def returnMaxSum ( A , B , n ) : mp = set ( ) result = 0 curr_sum = curr_begin = 0 for i in range ( 0 , n ) : while A [ i ] in mp : mp . remove ( A [ curr_begin ] ) curr_sum -= B [ curr_begin ] curr_begin += 1 mp . add ( A [ i ] ) curr_sum += B [ i ] result = max ( result , curr_sum ) return result

def returnMaxSum ( A , B , n ) : mp = set ( ) curr_sum = 0 curr_begin = 0 for i in range ( n ) : mp . add ( A [ i ] ) curr_sum -= B [ curr_begin ] curr_begin += 1 result = max ( result , curr_sum ) return result

def returnMaxSum ( A , B , n ) : mp = list ( ) result = 0 curr_sum = 0 curr_begin = 0 for i in range ( n ) : while ( mp . contains ( A [ i ] ) ) : mp . remove ( A [ curr_begin ] ) curr_sum -= B [ curr_begin ] curr_begin += B [ i ] result = Integer . max ( result , curr_sum ) return result

54.03
43.96
61.16
50.19
static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }

def eggDrop ( n , k ) : eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : eggFloor [ i ] [ 1 ] = 1 eggFloor [ i ] [ 0 ] = 0 for j in range ( 1 , k + 1 ) : eggFloor [ 1 ] [ j ] = j for i in range ( 2 , n + 1 ) : for j in range ( 2 , k + 1 ) : eggFloor [ i ] [ j ] = INT_MAX for x in range ( 1 , j + 1 ) : res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) if res < eggFloor [ i ] [ j ] : eggFloor [ i ] [ j ] = res return eggFloor [ n ] [ k ]

def eggDrop ( n , k ) : eggFloor = [ 1 , 2 , 3 ] for i in range ( 1 , n , k ) : eggFloor [ i ] = [ 1 , 2 , 3 ] for j in range ( 1 , k ) : res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) eggFloor [ i ] [ j ] = res if ( res < eggFloor [ i ] [ j ] ) : eggFloor [ i ] [ j ] = res if ( res < eggFloor [ i ] [ j ] ) : eggFloor [ i ] [ j ] = res return eggFloor [ n ] [ k ]

def eggDrop ( n , k ) : eggFloor [ ] = [ 0 for i in range ( n ) ] for j in range ( 1 , n , k ) : eggFloor [ i ] [ 1 ] = 1 eggFloor [ i ] [ 0 ] = 0 for i in range ( 2 , n ) : for j in range ( j , k ) : eggFloor [ i ] [ j ] = j res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) if ( res < eggFloor [ i ] [ j ] ) : eggFloor [ i ] [ j ] = res return eggFloor [ n ] [ k ]

54.04
44.82
70.64
54.44
static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }

def minCells ( mat , m , n ) : dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( m ) : for j in range ( n ) : if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : return dp [ m - 1 ] [ n - 1 ] return - 1

def minCells ( mat , m , n ) : dp = [ INT_MAX for i in range ( m , n ) ] for j in range ( 0 , n ) : if ( dp [ i ] [ j ] != float ( 'inf' ) ) : dp [ i ] [ j ] = float ( 'inf' ) if ( dp [ i ] [ j ] != float ( 'inf' ) ) : dp [ i ] [ j ] = dp [ i ] [ j ] + 1 if ( dp [ i ] [ j ] != float ( 'inf' ) : dp [ i ] [ j ] = dp [ i ] [ j ] if ( dp [ i ] [ j ] != float ( 'inf' ) ) : dp [ i ] [ j ] = dp [ i ] [ j ] + 1 if ( dp [ i ] [ j ] != float ( 'inf' ) < dp [ i ] [ j ] + 1 ] return dp [ m - 1 ] [ n - 1 ]

def minCells ( mat , m , n ) : dp [ 0 ] [ 0 ] = 1 for i in range ( m , n ) : for j in range ( 0 , n ) : if ( dp [ i ] [ j ] != Integer . MAX_VALUE and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j + mat [ i ] [ j ] ] ) ) : dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 if dp [ i ] [ j ] != Integer . MAX_VALUE and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] ) : dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 return dp [ m - 1 ] [ n - 1 ]

54.13
33.22
51.65
33.52
static void tower ( int n , char sourcePole , char destinationPole , char auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; System . out . printf ( "Move the disk %d from %c to %c\n" , n , sourcePole , destinationPole ) ; tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ; }

def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : if ( 0 == n ) : return tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) print ( "Movethedisk" , sourcePole , "from" , sourcePole , "to" , destinationPole ) tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole )

def tower ( n , sourcePole , destinationPole ) : tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) tower ( n - 1 , auxiliaryPole , sourcePole , destinationPole ) tower ( n - 1 , auxiliaryPole , destinationPole ) tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) tower ( n - 1 ,

def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : sourcePole , auxiliaryPole , destinationPole print ( "Move the disk %d from %c to %c\n" , n , sourcePole , destinationPole ) tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole )

54.14
47.36
77.23
63.46
static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }

def lcsOf3 ( X , Y , Z , m , n , o ) : L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : for k in range ( o + 1 ) : if ( i == 0 or j == 0 or k == 0 ) : L [ i ] [ j ] [ k ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 else : L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) return L [ m ] [ n ] [ o ]

def lcsOf3 ( X , Y , Z , m , n , o ) : L = [ INT_MAX for i in range ( m + 1 , n + 1 , o + 1 ) ] for j in range ( 0 , n , o ) : if ( X [ i ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : L [ i ] [ j ] [ k ] = 1 else : L [ i ] [ j ] [ k ] = max ( L [ i - 1 ] [ j ] [ k ] = max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k - 1 ] ) return L [ m ] [ n ] [ o ]

def lcsOf3 ( X , Y , Z , m , n , o ) : L = [ 0 for i in range ( m + 1 , n + 1 , o + 1 ) ] for i in range ( m + 1 , n + 1 , o ) : for j in range ( n , o ) : if ( i == 0 or j == 0 or k == 0 ) : L [ i ] [ j ] [ k ] = 0 else : if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) and X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) : L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 else : L [ i ] [ j ] [ k ] = max ( max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ) return L [ m ] [ n ] [ o ]

54.15
40.11
36.88
38.34
public static void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int [ ] [ ] arr = new int [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

def ZigZag ( rows , columns , numbers ) : k = 0 arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] for i in range ( rows ) : if ( i % 2 == 0 ) : j = 0 while j < columns and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j += 1 else : j = columns - 1 while j >= 0 and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j -= 1 for i in arr : for j in i : print ( j , end = "" ) print ( )

def ZigZag ( rows , columns , numbers ) : arr = [ [ 0 for i in range ( rows , columns ) ] for i in range ( 0 , rows , columns ) : if ( i % 2 == 0 ) : arr [ i ] = [ k + 1 , k + 1 ] if ( numbers [ k ] == 0 ) k += 1 else : for j in range ( columns - 1 , - 1 ) : arr [ i ] [ j ] = k + 1 if ( numbers [ k ] > 0 ) : arr [ i ] [ j ] = k + 1 if ( numbers [ k ] == 0 ) : k += 1 if ( numbers [ k ] == 0 ) : k -= 1 else : print ( arr [ i ] [ j ]

def ZigZag ( rows , columns , numbers ) : k = 0 for i in range ( rows ) : if i % 2 == 0 : for j in range ( columns ) : arr [ i ] [ j ] = k + 1 numbers [ k ] -- if ( numbers [ k ] == 0 ) k ++ for k in range ( columns ) : arr [ i ] [ j ] = k + 1 numbers [ k ] -- if ( numbers [ k ] == 0 ) k ++

54.17
38.76
58.79
44.11
public static int numberOfTriangles ( int n ) { int [ ] answer = new int [ n + 1 ] ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2 ; return answer [ n ] ; }

def numberOfTriangles ( n ) : answer = [ None ] * ( n + 1 ) answer [ 0 ] = 1 i = 1 while i <= n : answer [ i ] = answer [ i - 1 ] * 3 + 2 i = i + 1 return answer [ n ]

def numberOfTriangles ( n ) : answer = [ 1 for i in range ( n ) ] for i in range ( 1 , n + 1 ) : answer [ i ] = answer [ i - 1 ] * 3 + 2 return answer [ n ]

def numberOfTriangles ( n ) : answer = [ 1 for i in range ( n ) ] answer [ 0 ] = 1 for i in range ( 1 , n ) : answer [ i ] = answer [ i - 1 ] * 3 + 2 return answer [ n ]

54.18
40.25
66.83
51.67
public void decToBinary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n >> i ; if ( ( k & 1 ) > 0 ) System . out . print ( "1" ) ; else System . out . print ( "0" ) ; } }

def decToBinary ( n ) : for i in range ( 31 , - 1 , - 1 ) : k = n >> i if ( k & 1 ) : print ( "1" , end = "" ) else : print ( "0" , end = "" )

def decToBinary ( n ) : n = n << 1 for i in range ( 32 , - 1 , - 1 ) : if ( k & 1 ) > 0 : print ( "1" ) else : print ( "0" ) } return

def decToBinary ( n ) : n = n >> i for i in range ( 31 ) : k = n >> i if ( k & 1 ) > 0 : print ( 1 , end = "" ) else : print ( 0 , end = "" )

54.24
58.84
59.95
70.92
static int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 || cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }

def countStr ( n , bCount , cCount ) : if ( bCount < 0 or cCount < 0 ) : return 0 if ( n == 0 ) : return 1 if ( bCount == 0 and cCount == 0 ) : return 1 res = countStr ( n - 1 , bCount , cCount ) res += countStr ( n - 1 , bCount - 1 , cCount ) res += countStr ( n - 1 , bCount , cCount - 1 ) return res

def countStr ( n , bCount , cCount ) : if ( bCount < 0 ) : return 0 if ( cCount < 0 ) : return 1 res = countStr ( n - 1 , bCount , cCount ) res += countStr ( n - 1 , bCount - 1 , cCount ) return res

def countStr ( n , bCount , cCount ) : if bCount < 0 or cCount < 0 : return 0 if bCount == 0 and cCount == 0 : return 1 res = countStr ( n - 1 , bCount , cCount ) res += countStr ( n - 1 , bCount - 1 , cCount ) res += countStr ( n - 1 , bCount - 1 , cCount ) res += countStr ( n - 1 , bCount , cCount - 1 ) res += countStr ( n - 1 , bCount , cCount - 1 ) res += countStr ( n - 1 , bCount , cCount - 1 ) return res

54.24
46.44
82.29
80.15
static int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }

def countLattice ( r ) : if ( r <= 0 ) : return 0 result = 4 for x in range ( 1 , r ) : ySquare = r * r - x * x y = int ( math . sqrt ( ySquare ) ) if ( y * y == ySquare ) : result += 4 return result

def countLattice ( r ) : result = 0 for x in range ( 1 , r ) : ySquare = r * r - x * x if ( y * y == ySquare ) : result += 4 return result

def countLattice ( r ) : if r <= 0 : return 0 result = 4 for x in range ( 1 , r ) : ySquare = r * r - x * x y = ( int ) Math . sqrt ( ySquare ) if ( y * y == ySquare ) : result += 4 return result

54.24
42.43
50.67
38.28
static int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }

def findSubsequenceCount ( S , T ) : m = len ( T ) n = len ( S ) if m > n : return 0 mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] for i in range ( 1 , m + 1 ) : mat [ i ] [ 0 ] = 0 for j in range ( n + 1 ) : mat [ 0 ] [ j ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if T [ i - 1 ] != S [ j - 1 ] : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] else : mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) return mat [ m ] [ n ]

def findSubsequenceCount ( S , T ) : m = S . length ( ) n = m + 1 if ( m > n ) : return 0 mat = [ 0 for i in range ( 1 , m + 1 , n + 1 ) ] for j in range ( 1 , n ) : if ( T [ i - 1 ] != S [ j - 1 ] ) : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] if ( j - 1 ] != '' ) : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] return mat [ m ] [ n ]

def findSubsequenceCount ( S , T ) : m = T . length n = S . length ( ) mat [ ] [ ] = [ 0 for i in range ( 1 , m , - 1 ) : for j in range ( 1 , n ) : if ( T [ i - 1 ] != S [ j - 1 ] ) : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] else : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] return mat [ m ] [ n ]

54.26
46.7
55.9
51.44
static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }

def modInverse ( a , m ) : m0 = m y = 0 x = 1 if ( m == 1 ) : return 0 while ( a > 1 ) : q = a // m t = m m = a % m a = t t = y y = x - q * y x = t if ( x < 0 ) : x = x + m0 return x

def modInverse ( a , m ) : m0 = 1 x = 1 y = 0 for a in range ( m ) : m = a // m y = x - q * y x = t while ( a > 1 ) : q = a / m m = a % m a = t y = x - q * y y = x - q * y x = t if ( y < 0 ) y += m0 return x

def modInverse ( a , m ) : m0 = m y = 0 x = 1 while a > 1 : q = a / m m = a % m a = t t = m m = a % m a = t t = y y = x - q * y x = t

54.29
77.73
52.34
42.49
static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

def findElements ( arr , n ) : arr . sort ( ) for i in range ( 0 , n - 2 ) : print ( arr [ i ] , end = "" )

def findElements ( arr , n ) : arr . sort ( reverse = True ) for i in range ( 0 , n - 2 ) : print ( arr [ i ] , end = "" ) for i in range ( 0 , n - 2 ) : print ( arr [ i ] , end = "" ) return

def findElements ( arr , n ) : sort ( arr ) for i in range ( n ) : print ( arr [ i ] )

54.32
39.66
50.53
43.63
static boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }

def arekAnagrams ( str1 , str2 , k ) : n = len ( str1 ) if ( len ( str2 ) != n ) : return False count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR for i in range ( n ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 count = 0 for i in range ( MAX_CHAR ) : if ( count1 [ i ] > count2 [ i ] ) : count = count + abs ( count1 [ i ] - count2 [ i ] ) return ( count <= k )

def arekAnagrams ( str1 , str2 , k ) : n = len ( str1 ) if ( str2 ) != n : return false ; count1 = [ 0 for i in range ( n ) ] count2 = [ 0 for i in range ( n ) ] for i in range ( 0 , n ) : if ( count1 [ i ] > count2 [ i ] ) : count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) return ( count <= k ) : return ( count <= k )

def arekAnagrams ( str1 , str2 , k ) : n = str1 . length ( ) if ( str2 . length ( ) != n ) : return False count1 = [ 0 for i in range ( n ) ] count2 = [ 0 for i in range ( n ) ] count = 0 for i in range ( n ) : count1 [ str1 [ i ] - 'a' ] += for i in range ( n ) : count2 [ str2 [ i ] - 'a' ] += for i in range ( n ) : count1 [ str1 [ i ] - 'a' ] += for i in range ( n ) : count2 [ str2 [ i ] - 'a' ] += for i in range ( n ) : if count1 [ i ] > count2 [ i ] : count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) return ( count <= k )

54.38
39.02
73.35
62.76
static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }

def countRotations ( arr , low , high ) : if ( high < low ) : return 0 if ( high == low ) : return low mid = low + ( high - low ) / 2 mid = int ( mid ) if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : return ( mid + 1 ) if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : return mid if ( arr [ high ] > arr [ mid ] ) : return countRotations ( arr , low , mid - 1 ) return countRotations ( arr , mid + 1 , high )

def countRotations ( arr , low , high ) : if low == high : return 0 for low in range ( high ) : mid = low + ( high - low ) // 2 if mid < low and arr [ mid + 1 ] < arr [ mid ] : return mid + 1 if mid > high and arr [ mid ] > arr [ mid ] : return mid - 1 if arr [ low ] > arr [ mid ] : return countRotations ( arr , low , mid ) if arr [ mid ] > arr [ mid ] : return countRotations ( arr , mid + 1 , high )

def countRotations ( arr , low , high ) : if high < low : return 0 if high == low : return low mid = low + ( high - low ) / 2 if mid < high and arr [ mid + 1 ] < arr [ mid ] : return ( mid + 1 ) if mid > low and arr [ mid ] < arr [ mid - 1 ] : return mid if arr [ high ] > arr [ mid ] : return countRotations ( arr , low , mid - 1 ) return countRotations ( arr , mid + 1 , high )

54.38
39.62
58.84
44.82
static void recaman ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " ," ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + ", " ) ; } }

def recaman ( n ) : arr = [ 0 ] * n arr [ 0 ] = 0 print ( arr [ 0 ] , end = "," ) for i in range ( 1 , n ) : curr = arr [ i - 1 ] - i for j in range ( 0 , i ) : if ( ( arr [ j ] == curr ) or curr < 0 ) : curr = arr [ i - 1 ] + i break arr [ i ] = curr print ( arr [ i ] , end = "," )

def recaman ( n ) : arr = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : curr = arr [ i - 1 ] - i break if ( curr == 0 ) : curr = arr [ i - 1 ] + i break if ( arr [ j ] == curr ) : curr = arr [ i - 1 ] + i break if ( curr < 0 ) : curr = arr [ i - 1 ] + i break

def recaman ( n ) : arr = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : curr = arr [ i - 1 ] - i j = 0 for j in range ( i ) : if ( arr [ j ] == curr ) or curr < 0 : curr = arr [ i - 1 ] + i break arr [ i ] = curr

54.38
38.31
58.57
40.25
static int countNum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }

def countNum ( arr , n ) : s = dict ( ) count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 for i in range ( n ) : s [ arr [ i ] ] = 1 if ( arr [ i ] < minm ) : minm = arr [ i ] if ( arr [ i ] > maxm ) : maxm = arr [ i ] for i in range ( minm , maxm + 1 ) : if i not in s . keys ( ) : count += 1 return count

def countNum ( arr , n ) : s = set ( ) for i in range ( n ) : s . add ( arr [ i ] ) minm = float ( 'inf' ) maxm = float ( 'inf' ) for i in range ( minm , maxm ) : if ( arr [ i ] < minm ) : minm = arr [ i ] if ( arr [ i ] > maxm ) maxm = arr [ i ] count +=

def countNum ( arr , n ) : s = list ( ) count = 0 maxm = float ( 'inf' ) minm = float ( 'inf' ) maxm = float ( 'inf' ) for i in range ( minm , maxm ) : if ( arr [ i ] < minm ) : minm = arr [ i ] if ( arr [ i ] > maxm ) : maxm = arr [ i ] for i in range ( minm , maxm ) : if ( arr [ i ] > maxm ) : maxm = arr [ i ] return count

54.43
78.03
59.93
81.9
static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( "Sum of middle row = " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( "Sum of middle column = " + col_sum ) ; }

def middlesum ( mat , n ) : row_sum = 0 col_sum = 0 for i in range ( n ) : row_sum += mat [ n // 2 ] [ i ] print ( "Sumofmiddlerow=" , row_sum ) for i in range ( n ) : col_sum += mat [ i ] [ n // 2 ] print ( "Sumofmiddlecolumn=" , col_sum )

def middlesum ( mat , n ) : row_sum = 0 col_sum = 0 for i in range ( n ) : row_sum += mat [ i ] [ n / 2 ] col_sum += mat [ i ] [ n / 2 ] System . out . println ( "Sum of middle row = " + row_sum ) for i in range ( 0 , n ) : col_sum += mat [ i ] [ n / 2 ] System .

def middlesum ( mat , n ) : row_sum = 0 col_sum = 0 for i in range ( n ) : row_sum += mat [ n / 2 ] [ i ] col_sum += mat [ i ] [ n / 2 ] print ( "Sum of middle row = " + row_sum ) for i in range ( n ) : col_sum += mat [ i ] [ n / 2 ] print ( "Sum of middle column = " + col_sum )

54.43
45.58
65.84
54.28
static boolean canMakeAllSame ( String str ) { int zeros = 0 , ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '0' ) ++ zeros ; else ++ ones ; } return ( zeros == 1 || ones == 1 ) ; }

def canMakeAllSame ( str ) : zeros = 0 ones = 0 for i in range ( 0 , len ( str ) ) : ch = str [ i ] if ( ch == '0' ) : zeros = zeros + 1 else : ones = ones + 1 return ( zeros == 1 or ones == 1 )

def canMakeAllSame ( str ) : zeros = 0 ones = 0 for i in range ( len ( str ) ) : if ( ch == '0' ) : ++ zeros elif ( ch == '1' ) : ++ ones return ( zeros == 1 || ones == 1 )

def canMakeAllSame ( str ) : zeros = 0 ones = 0 for i in range ( len ( str ) ) : ch = str [ i ] if ch == '0' : ++ zeros else : yield from canMakeAllSame ( str [ i ] ) return ( zeros == 1 or ones == 1 )

54.53
44.8
67.29
53.42
static int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ ] [ ] = new int [ n ] [ n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }

def lenghtOfLongestAP ( set , n ) : if ( n <= 2 ) : return n L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] llap = 2 for i in range ( n ) : L [ i ] [ n - 1 ] = 2 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while ( i >= 0 and k <= n - 1 ) : if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : k += 1 elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : L [ i ] [ j ] = 2 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) i -= 1 k += 1 while ( i >= 0 ) : L [ i ] [ j ] = 2 i -= 1 return llap

def lenghtOfLongestAP ( set , n ) : L = [ 0 for i in range ( n ) ] for j in range ( n - 2 , - 1 , - 1 ) : if ( set [ i ] < 2 * set [ j ] ) : k += 1 else : if ( set [ i ] + set [ k ] > 2 * set [ j ] ) : L [ i ] [ j ] = 2 i -- k += 1 else : L [ i ] [ j ] = 1 llap = max ( llap , L [ i ] [ j ] + 1 ] llap = max ( llap , L [ i ] [ j ] + 1 ) llap = max ( llap , L [ i ] [ j ] + 1 ) i -= 1 llap = max ( llap , L [ i ] [ j ] ) return llap

def lenghtOfLongestAP ( set , n ) : L [ ] [ ] = [ 0 for k in range ( n ) ] llap = 2 for i in range ( n ) : L [ i ] [ n - 1 ] = 2 for j in range ( n - 2 , n - 1 ) : i = j - 1 , k = j + 1 while i >= 0 and k <= n - 1 : if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : k ++ else : L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) i -- k ++ for i in range ( n - 1 ) : L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) i -- k -- return llap

54.73
43.24
59.66
44.1
static void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " " ) ; }

def printDistSum ( arr , n ) : Sum = sum ( arr ) dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : dp [ i ] [ arr [ i - 1 ] ] = True for j in range ( 1 , Sum + 1 ) : if ( dp [ i - 1 ] [ j ] == True ) : dp [ i ] [ j ] = True dp [ i ] [ j + arr [ i - 1 ] ] = True for j in range ( Sum + 1 ) : if ( dp [ n ] [ j ] == True ) : print ( j , end = "" )

def printDistSum ( arr , n ) : sum = 0 dp = [ false for i in range ( n ) ] for i in range ( n + 1 , sum + 1 ) : dp [ i ] [ arr [ i - 1 ] ] = true dp [ i ] [ j ] = true dp [ i ] [ j + arr [ i - 1 ] ] = true for j in range ( 1 , sum ) : if ( dp [ i - 1 ] [ j ] == true ) : dp [ i ] [ j ] = true dp [ i ] [ j ] = true dp [ i ] [ j ] = true for j in range ( 0 , n + 1 , sum + 1 ) : if ( dp [ i ] [ j ] == true ) : dp [ i ] [ j ] = true dp [ i ] [ j + arr [ i - 1 ] = true print ( j + " " )

def printDistSum ( arr , n ) : sum = 0 for i in range ( n ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n ) : dp [ i ] [ arr [ i - 1 ] ] = True for i in range ( 1 , n ) : dp [ i ] [ arr [ i - 1 ] ] = True for i in range ( 1 , n ) : dp [ i ] [ arr [ i - 1 ] ] = True for j in range ( 1 , sum ) : if ( dp [ i - 1 ] [ j ] == True ) : dp [ i ] [ j + arr [ i - 1 ] ] = True

54.87
53.25
57.71
54.68
static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }

def find ( a , b , k , n1 , n2 ) : s = set ( ) for i in range ( n2 ) : s . add ( b [ i ] ) missing = 0 for i in range ( n1 ) : if a [ i ] not in s : missing += 1 if missing == k : return a [ i ] return - 1

def find ( a , b , k , n1 , n2 ) : s = set ( ) for i in range ( 0 , n1 , n2 ) : if ( ! s . contains ( a [ i ] ) ) : missing += 1 if ( missing == k ) : return a [ i ]

def find ( a , b , k , n1 , n2 ) : s = list ( ) for i in range ( n1 , n2 ) : if ( not s . contains ( a [ i ] ) ) : missing = 0 for i in range ( n1 ) : if ( not s . contains ( a [ i ] ) ) : missing += if ( missing == k ) : return a [ i ] return - 1

54.92
50.14
50.53
58.48
public static int findRepeatFirst ( String s ) { int p = - 1 , i , k ; int MAX_CHAR = 256 ; int hash [ ] = new int [ MAX_CHAR ] ; int pos [ ] = new int [ MAX_CHAR ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { k = ( int ) s . charAt ( i ) ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } else if ( hash [ k ] == 1 ) hash [ k ] ++ ; } for ( i = 0 ; i < MAX_CHAR ; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) p = pos [ i ] ; else if ( p > pos [ i ] ) p = pos [ i ] ; } } return p ; }

def findRepeatFirst ( s ) : p = - 1 hash = [ 0 for i in range ( MAX_CHAR ) ] pos = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( len ( s ) ) : k = ord ( s [ i ] ) if ( hash [ k ] == 0 ) : hash [ k ] += 1 pos [ k ] = i elif ( hash [ k ] == 1 ) : hash [ k ] += 1 for i in range ( MAX_CHAR ) : if ( hash [ i ] == 2 ) : if ( p == - 1 ) : p = pos [ i ] elif ( p > pos [ i ] ) : p = pos [ i ] return p

def findRepeatFirst ( s ) : p = - 1 hash = [ 0 for i in range ( len ( s ) ) ] pos = [ MAX_CHAR for i in range ( len ( s ) ) ] for k in range ( 0 , MAX_CHAR ) : if ( hash [ k ] == 0 ) : hash [ k ] ++ pos [ k ] = i else : hash [ k ] = 1 p = - 1 if ( p > pos [ i ] ) : p = pos [ i ] if ( p > pos [ i ] ) : p = pos [ i ] else : p = pos [ i ] if ( p == - 1 ) : p = pos [ i ] else : if ( p > pos [ i ] ) : p = pos [ i ] else : if ( p == - 1 ) : p = pos [ i ] return p

def findRepeatFirst ( s ) : p = - 1 hash = [ 0 for k in range ( MAX_CHAR ) ] pos = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( 0 , MAX_CHAR ) : k = ( int ) s [ i ] if ( hash [ k ] == 0 ) : hash [ k ] += 1 pos [ k ] = i elif ( hash [ k ] == 1 ) : hash [ k ] += 1 return p

54.97
57.12
38.47
33.3
static void printString ( String str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { System . out . println ( str ) ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ; else System . out . println ( "Empty string" ) ; }

def printString ( str , ch , count ) : occ , i = 0 , 0 if ( count == 0 ) : print ( str ) for i in range ( len ( str ) ) : if ( str [ i ] == ch ) : occ += 1 if ( occ == count ) : break if ( i < len ( str ) - 1 ) : print ( str [ i + 1 : len ( str ) - i + 2 ] ) else : print ( "Emptystring" )

def printString ( str , ch , count ) : occ = 0 for i in range ( len ( str ) ) : if ( str [ i ] == ch ) : occ += 1 if ( occ == count ) : break if ( i < len ( str ) - 1 ) : print ( str [ i + 1 : ] ) else : print ( "Empty string" ) return occ = 0 for i in range ( 0 , len ( str ) ) : if ( str [ i ] == ch ) : print ( str [ i ] ) : print ( str [ i + 1 ] ) : print ( str [ i + 1 ] ) else : print ( "Empty string" ) return occ

def printString ( str , ch , count ) : occ = 0 for i in range ( count ) : if str [ i ] == ch : occ += 1 if occ == count : break if i < str . length ( ) - 1 : print ( str [ i + 1 ] ) else : print ( "Empty string" )

55.0
41.3
74.63
69.72
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Hash . add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . contains ( product ) ) { result ++ ; } } } return result ; }

def countPairs ( arr , n ) : result = 0 Hash = set ( ) for i in range ( n ) : Hash . add ( arr [ i ] ) for i in range ( n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] if product in ( Hash ) : result += 1 return result

def countPairs ( arr , n ) : result = 0 for i in range ( 0 , n ) : Hash . add ( arr [ i ] ) result += 1 for j in range ( i + 1 , n ) : if ( Hash [ product ] ) : result += 1 elif ( Hash [ product ] ) : result += 1 else : return result

def countPairs ( arr , n ) : result = 0 for i in range ( n ) : Hash = list ( ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] if ( Hash . contains ( product ) ) : result += 1 return result

55.01
54.15
55.48
52.61
static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }

def divSum ( n ) : result = 0 for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : if ( n % i == 0 ) : if ( i == ( n / i ) ) : result = result + i else : result = result + ( i + n // i ) return ( result + n + 1 )

def divSum ( n ) : result = 0 for i in range ( 2 , Math . sqrt ( n ) ) : if ( n % i == 0 ) : result += i else : result += ( i + n / i ) return ( result + n + 1 )

def divSum ( n ) : result = 0 for i in range ( 2 , sqrt ( n ) ) : if n % i == 0 : if i == ( n / i ) : result += i else : result += ( i + n / i ) return ( result + n + 1 )

55.12
43.58
56.67
47.08
static boolean isProduct ( int arr [ ] , int n , int x ) { HashSet < Integer > hset = new HashSet < > ( ) ; if ( n < 2 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( hset . contains ( x / arr [ i ] ) ) return true ; hset . add ( arr [ i ] ) ; } } return false ; }

def isProduct ( arr , n , x ) : if n < 2 : return False s = set ( ) for i in range ( 0 , n ) : if arr [ i ] == 0 : if x == 0 : return True else : continue if x % arr [ i ] == 0 : if x // arr [ i ] in s : return True s . add ( arr [ i ] ) return False

def isProduct ( arr , n , x ) : hset = set ( ) for i in range ( 0 , n ) : if ( arr [ i ] == 0 ) : if ( x == 0 ) : return true else : if ( x % arr [ i ] == 0 ) : return true else : hset . add ( arr [ i ] ) return false

def isProduct ( arr , n , x ) : hset = list ( ) for i in range ( n ) : if ( arr [ i ] == 0 ) : if ( x == 0 ) : return True else : continue if ( x % arr [ i ] == 0 ) : if ( hset . contains ( x / arr [ i ] ) ) : return True ; hset . add ( arr [ i ] ) return False

55.17
51.82
57.02
61.51
static void printInSortedOrder ( String arr [ ] , int n ) { int index [ ] = new int [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) { min = j ; } } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ index [ i ] ] + " " ) ; } }

def printInSortedOrder ( arr , n ) : index = [ 0 ] * n for i in range ( n ) : index [ i ] = i for i in range ( n - 1 ) : min = i for j in range ( i + 1 , n ) : if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : min = j if ( min != i ) : index [ min ] , index [ i ] = index [ i ] , index [ min ] for i in range ( n ) : print ( arr [ index [ i ] ] , end = "" )

def printInSortedOrder ( arr , n ) : index = [ 0 for i in range ( n ) ] for i in range ( n - 1 , - 1 , - 1 ) : if ( arr [ index [ i ] ] . compareTo ( arr [ index [ i ] ] ) > 0 ) : min = i if ( min != i ) : index [ min ] = index [ i ] i = temp for j in range ( i + 1 , n ) : if ( arr [ index [ min ] ] = temp if ( arr [ index [ min ] != index [ i ] ) : index [ min ] = index [ i ] if ( min != i ) : index [ min ] = index [ i ] print ( arr [ index [ i ] ] )

def printInSortedOrder ( arr , n ) : index = [ 0 for i in range ( n ) ] for i in range ( 0 , n - 1 , - 1 ) : min = i for j in range ( i + 1 , n ) : if arr [ index [ min ] ] == arr [ index [ j ] ] : min = j if arr [ index [ min ] ] > 0 : min = j if arr [ index [ min ] ] == arr [ index [ j ] ] : min = i if min != i : int temp = index [ min ] index [ min ] = index [ i ] index [ i ] = temp

55.17
46.32
38.56
34.93
static void LeibnizHarmonicTriangle ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( "1/" + i * C [ i - 1 ] [ j - 1 ] + " " ) ; System . out . println ( ) ; } }

def LeibnizHarmonicTriangle ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , i + 1 ) : print ( "1/" , end = "" ) print ( i * C [ i - 1 ] [ j - 1 ] , end = "" ) print ( )

def LeibnizHarmonicTriangle ( n ) : C = [ INT_MAX for i in range ( n ) ] for j in range ( 0 , n ) : if ( j == 0 || j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = 0 C [ i ] [ j ] = 1 for i in range ( 1 , n ) : if ( j == 0 || j == i ) : C [ i ] [ j ] = C [ i - 1 ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j - 1 ] print ( "1/" + i * C [ i - 1 ] [ j - 1 ] print ( )

def LeibnizHarmonicTriangle ( n ) : C [ ] [ ] = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]

55.18
47.74
77.13
64.53
static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }

def findoptimal ( N ) : if ( N <= 6 ) : return N screen = [ 0 ] * N for n in range ( 1 , 7 ) : screen [ n - 1 ] = n for n in range ( 7 , N + 1 ) : screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) return screen [ N - 1 ]

def findoptimal ( N ) : N = int ( N ) for n in range ( 1 , N ) : screen [ n ] = n for n in range ( 1 , 7 , N ) : screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , 3 * screen [ n - 5 ] ) return screen [ N - 1 ]

def findoptimal ( N ) : if N <= 6 : screen = [ N for n in range ( 1 , 6 , - 1 ) ] for n in range ( 1 , 6 , - 1 ) : screen [ n - 1 ] = n for n in range ( 7 , N ) : screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) return screen [ N - 1 ]

55.25
51.22
65.22
54.3
static int minOperation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }

def minOperation ( arr ) : ans = 0 for i in range ( N - 1 , - 1 , - 1 ) : for j in range ( M - 1 , - 1 , - 1 ) : if ( arr [ i ] [ j ] == 0 ) : ans += 1 for k in range ( i + 1 ) : for h in range ( j + 1 ) : if ( arr [ k ] [ h ] == 1 ) : arr [ k ] [ h ] = 0 else : arr [ k ] [ h ] = 1 return ans

def minOperation ( arr ) : ans = 0 for i in range ( N , M ) : for j in range ( M - 1 , i >= 0 ) : if ( arr [ i ] [ j ] == true ) : arr [ i ] [ j ] = false ans += 1 for k in range ( 0 , i , j ) : if ( arr [ k ] [ h ] == true ) : arr [ k ] [ h ] = true else : arr [ k ] [ h ] = false ans += 1 if ( arr [ k ] [ h ] == true ) : arr [ k ] [ h ] = true ans += 1 return ans

def minOperation ( arr [ ] [ ] ) : ans = 0 for i in range ( N ) : for j in range ( M - 1 , - 1 , - 1 ) : if ( arr [ i ] [ j ] == false ) : ans += for ( k , h ) in enumerate ( range ( i , j ) ) : if ( arr [ k ] [ h ] == True ) : arr [ k ] [ h ] = False else : arr [ k ] [ h ] = True return ans

55.29
32.69
44.47
30.01
public static boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }

def isEven ( n ) : return ( not ( n & 1 ) )

def isEven ( n ) : if ( n & 1 ) == 0 : return true

def isEven ( n ) : if ( n & 1 ) == 0 : return True else : return False

55.31
44.81
63.96
53.66
static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }

def maximumChars ( str1 ) : n = len ( str1 ) res = - 1 firstInd = [ - 1 for i in range ( MAX_CHAR ) ] for i in range ( n ) : first_ind = firstInd [ ord ( str1 [ i ] ) ] if ( first_ind == - 1 ) : firstInd [ ord ( str1 [ i ] ) ] = i else : res = max ( res , abs ( i - first_ind - 1 ) ) return res

def maximumChars ( str ) : MAX_CHAR = 256 for i in range ( n ) : first_ind = - 1 for i in range ( n ) : first_ind = firstInd [ str [ i ] ] if ( first_ind == - 1 ) : firstInd [ str [ i ] ] = i res = max ( res , abs ( i - first_ind - 1 ) ) return res

def maximumChars ( str ) : res = - 1 firstInd = [ INT for i in range ( n ) ] for i in range ( 0 , MAX_CHAR ) : first_ind = firstInd [ str [ i ] ] if ( first_ind == - 1 ) : firstInd [ str [ i ] ] = i else : res = max ( res , abs ( i - first_ind - 1 ) ) return res

55.34
46.49
44.97
44.83
static int findPlatform ( int arr [ ] , int dep [ ] , int n ) { Arrays . sort ( arr ) ; Arrays . sort ( dep ) ; int plat_needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat_needed ++ ; i ++ ; if ( plat_needed > result ) result = plat_needed ; } else { plat_needed -- ; j ++ ; } } return result ; }

def findPlatform ( arr , dep , n ) : arr . sort ( ) dep . sort ( ) plat_needed = 1 result = 1 i = 1 j = 0 while ( i < n and j < n ) : if ( arr [ i ] < dep [ j ] ) : plat_needed += 1 i += 1 if ( plat_needed > result ) : result = plat_needed else : plat_needed -= 1 j += 1 return result

def findPlatform ( arr , dep , n ) : arr . sort ( ) dep . sort ( ) result = 1 plat_needed = 1 for i in range ( n ) : if ( arr [ i ] <= dep [ j ] ) : plat_needed += 1 j += 1 elif ( arr [ i ] <= dep [ j ] ) : plat_needed -= 1 result = plat_needed return result

def findPlatform ( arr , dep , n ) : plat_needed = 1 result = 1 for i in range ( n ) : if arr [ i ] <= dep [ j ] : plat_needed ++ i ++ if ( plat_needed > result ) : result = plat_needed elif ( dep [ i ] <= dep [ j ] ) : plat_needed = 1 result = 1 i = 1 j = 0 while i < n and j < n : if ( arr [ i ] <= dep [ j ] ) : plat_needed ++ i ++ if ( plat_needed > result ) : result = plat_needed else : plat_needed -- j ++ return result

55.35
57.25
53.02
56.14
public static boolean areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . length ; int m = arr2 . length ; if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }

def areEqual ( arr1 , arr2 , n , m ) : if ( n != m ) : return False ; arr1 . sort ( ) ; arr2 . sort ( ) ; for i in range ( 0 , n - 1 ) : if ( arr1 [ i ] != arr2 [ i ] ) : return False ; return True ;

def areEqual ( arr1 , arr2 ) : n = arr1 . length m = arr2 . length if ( n != m ) : return false ; for i in range ( 0 , n ) : if ( arr1 [ i ] != arr2 [ i ] ) : return false return true

def areEqual ( arr1 , arr2 ) : n = arr1 . length m = arr2 . length if n != m : return False sort ( arr1 ) sort ( arr2 ) for i in range ( 0 , n ) : if ( arr1 [ i ] != arr2 [ i ] ) : return False return True

55.36
47.42
51.05
45.27
static int maxcoefficientvalue ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }

def maxcoefficientvalue ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n + 1 ) : for j in range ( min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) maxvalue = 0 for i in range ( n + 1 ) : maxvalue = max ( maxvalue , C [ n ] [ i ] ) return maxvalue

def maxcoefficientvalue ( n ) : C = [ [ 0 for i in range ( n ) ] for i in range ( n + 1 , n + 1 ) ] for j in range ( 0 , n ) : if ( j == 0 || j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] return maxvalue

def maxcoefficientvalue ( n ) : C = [ INT_MAX for i in range ( n ) ] for i in range ( n ) : for j in range ( i , n ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] return maxvalue

55.39
52.83
83.96
73.3
static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == 'a' ) c1 ++ ; if ( s . charAt ( i ) == 'b' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }

def countOccurrences ( s , K ) : n = len ( s ) c1 = 0 c2 = 0 C = 0 for i in range ( n ) : if s [ i ] == 'a' : c1 += 1 if s [ i ] == 'b' : c2 += 1 C += c1 return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2

def countOccurrences ( s , K ) : C = 0 c1 = 0 c2 = 0 for i in range ( n ) : if ( s [ i ] == 'a' ) : c1 += 1 if ( s [ i ] == 'b' ) : c2 += 1 C += c1 C += c2 return C * K

def countOccurrences ( s , K ) : C = 0 c1 = 0 c2 = 0 for i in range ( n ) : if s [ i ] == 'a' : c1 += 1 if s [ i ] == 'b' : c2 += c1 C += c1 return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2

55.41
55.64
55.41
55.64
int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }

def findSmallest ( arr , n ) : res = 1 for i in range ( 0 , n ) : if arr [ i ] <= res : res = res + arr [ i ] else : break return res

def findSmallest ( arr , n ) : res = 1 for i in range ( n ) : res = res + arr [ i ] return res

def findSmallest ( arr , n ) : res = 1 for i in range ( n ) : res = res + arr [ i ] return res

55.44
51.52
65.53
54.61
static boolean isSubSeqDivisible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }

def isSubSeqDivisible ( st ) : l = len ( st ) arr = [ 0 ] * l for i in range ( 0 , l ) : for j in range ( i , l ) : for k in range ( j , l ) : if ( arr [ i ] % 8 == 0 ) : return True elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : return True elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : return True return False

def isSubSeqDivisible ( str ) : l = len ( str ) arr = [ 0 for i in range ( l ) ] for j in range ( i , l ) : for k in range ( j , l ) : if ( arr [ i ] % 8 == 0 ) : return true else : if ( arr [ i ] * 100 + arr [ j ] ) % 8 == 0 and i != j : return true else : if ( arr [ i ] * 10 + arr [ k ] ) % 8 == 0 and i != k : return true else : if ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k : return true else : if ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != k : return true

def isSubSeqDivisible ( str ) : arr = [ 0 for i in range ( l ) ] for j in range ( i , l ) : for k in range ( j , l ) : if ( arr [ i ] % 8 == 0 ) : return True elif ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 : i = j if ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 : i = j if ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 : i = j if ( i != j and j != k ) : return True return False

55.61
47.13
83.89
70.22
static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }

def maximumDifferenceSum ( arr , N ) : dp = [ [ 0 , 0 ] for i in range ( N ) ] for i in range ( N ) : dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 for i in range ( N - 1 ) : dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )

def maximumDifferenceSum ( arr , N ) : dp = [ INT_MAX for i in range ( N ) ] dp [ i ] = [ INT_MAX for i in range ( N ) ] for i in range ( N - 2 , - 1 , - 1 ) : dp [ i ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + Math . abs ( 1 - arr [ i ] ) return dp [ N - 1 ] [ 0 ]

def maximumDifferenceSum ( arr , N ) : dp = [ 0 for i in range ( N ) ] for i in range ( N - 1 ) : dp [ i + 1 ] [ 0 ] = dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )

55.66
41.69
52.09
42.64
static int sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; int i ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }

def sequence ( n ) : f = array . array ( 'i' , [ 0 , 1 , 1 ] ) for i in range ( 3 , n + 1 ) : r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] f . append ( r ) ; return r

def sequence ( n ) : f = [ 0 for i in range ( n ) ] for i in range ( 3 , n ) : f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] return f [ n ]

def sequence ( n ) : f = [ 0 , 1 , 1 , 2 ] f [ 0 ] = 0 f [ 1 ] = 1 f [ 2 ] = 1 i = 3 for i in range ( 3 , n ) : f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] return f [ n ]

55.69
51.6
58.12
51.1
static void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " " ) ; }

def alternateSubarray ( arr , n ) : len = [ ] for i in range ( n + 1 ) : len . append ( 0 ) len [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] ^ arr [ i + 1 ] == True ) : len [ i ] = len [ i + 1 ] + 1 else : len [ i ] = 1 for i in range ( n ) : print ( len [ i ] , "" , end = "" )

def alternateSubarray ( arr , n ) : len = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] ^ arr [ i + 1 ] == true ) : len [ i ] = len [ i + 1 ] + 1 else : len [ i ] = 1 for i in range ( 0 , n - 2 ) : if ( arr [ i ] ^ arr [ i + 1 ] == true ) : len [ i ] = len [ i + 1 ] + 1 ] = len [ i + 1 ] + 1 print ( len [ i ] ) for i in range ( 0 , n - 1 ) : print ( len [ i ] + " " )

def alternateSubarray ( arr , n ) : len = [ 1 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] ^ arr [ i + 1 ] == True ) : len [ i ] = len [ i + 1 ] + 1 else : len [ i ] = 1

55.72
44.76
53.38
48.36
static int CountPS ( char str [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; boolean P [ ] [ ] = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }

def CountPS ( str , n ) : dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] P = [ [ False for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : P [ i ] [ i ] = True for i in range ( n - 1 ) : if ( str [ i ] == str [ i + 1 ] ) : P [ i ] [ i + 1 ] = True dp [ i ] [ i + 1 ] = 1 for gap in range ( 2 , n ) : for i in range ( n - gap ) : j = gap + i ; if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : P [ i ] [ j ] = True if ( P [ i ] [ j ] == True ) : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) else : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) return dp [ 0 ] [ n - 1 ]

def CountPS ( str , n ) : dp = [ 0 for i in range ( n ) ] P = [ True for i in range ( n ) ] for i in range ( n ) : if ( str [ i ] == str [ i + 1 ] ) : P [ i ] [ i ] = true dp [ i ] [ i + 1 ] = 1 else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 - dp [ i + 1 ] [ j - 1 ] [ j ] = 1 if ( P [ i ] [ j ] == true ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j - 1 ] = dp [ i ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] return dp [ 0 ] [ n - 1 ]

def CountPS ( str , n ) : dp = [ INT_MAX for i in range ( n ) ] P = [ True for i in range ( n ) ] for i in range ( n ) : if ( str [ i ] == str [ i + 1 ] and P [ i + 1 ] [ j - 1 ] ) : P [ i ] [ j ] = True if ( P [ i ] [ j ] == True ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] return dp [ 0 ] [ n - 1 ]

55.76
45.51
42.18
34.81
static int findpos ( String n ) { int k = 0 , pos = 0 , i = 0 ; while ( k != n . length ( ) ) { switch ( n . charAt ( i ) ) { case '4' : pos = pos * 2 + 1 ; break ; case '7' : pos = pos * 2 + 2 ; break ; } i ++ ; k ++ ; } return pos ; }

def findpos ( n ) : i = 0 j = len ( n ) pos = 0 while ( i < j ) : if ( n [ i ] == '4' ) : pos = pos * 2 + 1 if ( n [ i ] == '7' ) : pos = pos * 2 + 2 i = i + 1 return pos

def findpos ( n ) : k = 0 pos = 0 i = 0 while k != n . length ( ) : switch ( n [ i ] ) : pos = pos * 2 + 1 break if ( n [ i ] == '4' ) : pos = pos * 2 + 1 break if ( n [ i ] == '7' ) : pos = pos * 2 + 2 break return pos

def findpos ( n ) : k = 0 pos = 0 i = 0 while k != n . length ( ) : switch ( n [ i ] ) : case '4' : pos = pos * 2 + 1 break case '7' : pos = pos * 2 + 2 break i += 1 return pos

55.78
45.88
40.73
39.39
static void computeTotient ( int n ) { long phi [ ] = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( "Totient of " + i + " is " + phi [ i ] ) ; }

def computeTotient ( n ) : phi = [ ] for i in range ( n + 2 ) : phi . append ( 0 ) for i in range ( 1 , n + 1 ) : phi [ i ] = i for p in range ( 2 , n + 1 ) : if ( phi [ p ] == p ) : phi [ p ] = p - 1 for i in range ( 2 * p , n + 1 , p ) : phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) for i in range ( 1 , n + 1 ) : print ( "Totientof" , i , "is" , phi [ i ] )

def computeTotient ( n ) : phi = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : phi [ i ] = i * ( p - 1 ) if ( phi [ p ] == p ) : phi [ p ] = p - 1 else : phi [ p ] = ( phi [ p ] / p ) * ( p - 1 ) for i in range ( 2 , n ) : if ( phi [ i ] == p ) : phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) : phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) return phi [ i ]

def computeTotient ( n ) : phi = [ INT_MAX for i in range ( n ) ] for p in range ( 2 , n ) : if ( phi [ p ] == p ) : phi [ p ] = p - 1 for i in range ( 2 * p , n ) : phi [ i ] = ( phi [ i ] / p ) * ( p - 1 )

55.82
48.48
40.08
40.32
static boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }

def check ( st ) : n = len ( st ) oddDigSum = 0 evenDigSum = 0 for i in range ( 0 , n ) : if ( i % 2 == 0 ) : oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) else : evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) return ( ( oddDigSum - evenDigSum ) % 11 == 0 )

def check ( str ) : n = len ( str ) oddDigSum = 0 evenDigSum = 0 for i in range ( n ) : if ( i % 2 == 0 ) : oddDigSum += ( str [ i ] - '0' ) else : evenDigSum += ( str [ i ] - '0' ) return ( ( oddDigSum - evenDigSum ) % 11 == 0 )

def check ( str ) : oddDigSum = 0 evenDigSum = 0 for i in range ( n ) : if i % 2 == 0 : oddDigSum += str [ i ] elif i % 2 == 1 : oddDigSum += str [ i ] elif i % 2 == 1 : evenDigSum += str [ i ] elif i % 2 == 1 : evenDigSum += str [ i ] return ( ( oddDigSum - evenDigSum ) % 11 == 0 )

55.83
46.64
77.16
65.14
static int binomialCoeffSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }

def binomialCoeffSum ( n ) : C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] sum = 0 for i in range ( 0 , n + 1 ) : sum += C [ n ] [ i ] return sum

def binomialCoeffSum ( n ) : C = [ INT_MAX for i in range ( n ) ] C [ n ] = [ INT_MAX for i in range ( 0 , n ) ] for j in range ( 0 , n ) : if ( j == 0 || j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] return sum

def binomialCoeffSum ( n ) : C [ ] = [ 0 for i in range ( n ) ] for i in range ( n + 1 , n + 1 ) : for j in range ( i , n ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] sum = 0 for i in range ( 0 , n ) : sum += C [ n ] [ i ] return sum

55.88
58.22
53.14
56.91
static int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }

def remainder ( st ) : ln = len ( st ) rem = 0 for i in range ( 0 , ln ) : num = rem * 10 + ( int ) ( st [ i ] ) rem = num % 11 return rem

def remainder ( str ) : len = str . length ( ) rem = 0 for i in range ( len ) : num = rem * 10 + ( str [ i ] - '0' ) rem = num % 11 return rem

def remainder ( str ) : len = str . length rem = 0 for i in range ( len ) : num = rem * 10 + ( str [ i ] - '0' ) rem = num % 11 return rem

55.92
62.99
96.26
83.23
static int maxTripletSum ( int arr [ ] , int n ) { int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }

def maxTripletSum ( arr , n ) : maxA = - 100000000 maxB = - 100000000 maxC = - 100000000 for i in range ( 0 , n ) : if ( arr [ i ] > maxA ) : maxC = maxB maxB = maxA maxA = arr [ i ] elif ( arr [ i ] > maxB ) : maxC = maxB maxB = arr [ i ] elif ( arr [ i ] > maxC ) : maxC = arr [ i ] return ( maxA + maxB + maxC )

def maxTripletSum ( arr , n ) : maxA = - 100000000 maxB = - 100000000 maxC = - 100000000 for i in range ( n ) : if ( arr [ i ] > maxA ) { maxC = maxB maxB = maxA maxA = arr [ i ] maxB = arr [ i ] maxC = maxB arr [ i ] = maxC maxC = maxA if ( arr [ i ] > maxB ) : maxB = arr [ i ] if ( arr [ i ] > maxC ) : maxC = maxB maxB = arr [ i ] if ( arr [ i ] > maxC ) : maxC = maxB maxB = maxA maxB = maxA maxB = maxB arr [ i ] maxB = arr [ i ] maxC = maxA return ( maxA + maxB + maxC )

def maxTripletSum ( arr , n ) : maxA = - 100000000 maxB = - 100000000 maxC = - 100000000 for i in range ( n ) : if ( arr [ i ] > maxA ) : maxC = maxB maxB = maxA maxA = arr [ i ] elif ( arr [ i ] > maxB ) : maxC = maxB maxB = arr [ i ] elif ( arr [ i ] > maxC ) : maxC = arr [ i ] return ( maxA + maxB + maxC )

55.95
53.81
38.91
39.32
static void findMinAvgSubarray ( int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } System . out . println ( "Subarray between [" + res_index + ", " + ( res_index + k - 1 ) + "] has minimum average" ) ; }

def findMinAvgSubarray ( arr , n , k ) : if ( n < k ) : return 0 res_index = 0 curr_sum = 0 for i in range ( k ) : curr_sum += arr [ i ] min_sum = curr_sum for i in range ( k , n ) : curr_sum += arr [ i ] - arr [ i - k ] if ( curr_sum < min_sum ) : min_sum = curr_sum res_index = ( i - k + 1 ) print ( "Subarraybetween[" , res_index , "," , ( res_index + k - 1 ) , "]hasminimumaverage" )

def findMinAvgSubarray ( arr , n , k ) : res_index = 0 curr_sum = 0 for i in range ( k , n ) : curr_sum += arr [ i ] - arr [ i - k ] min_sum = curr_sum for i in range ( k , n ) : curr_sum += arr [ i ] - arr [ i - k ] if ( curr_sum < min_sum ) : min_sum = curr_sum res_index = ( i - k + 1 ) if ( curr_sum < min_sum ) : min_sum = curr_sum if ( curr_sum < min_sum ) : min_sum = curr_sum res_index = ( i - k + 1 ) System . out . println ( "Subarray between [" + res_index + ", " + ( res_index + k - 1 ) + "] has minimum average" ) return

def findMinAvgSubarray ( n , k ) : res_index = 0 curr_sum = 0 for i in range ( k ) : curr_sum += arr [ i ] - arr [ i - k ] if ( curr_sum < min_sum ) : min_sum = curr_sum res_index = ( i - k + 1 )

56.04
52.39
65.15
50.59
static int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }

def optimalStrategyOfGame ( arr , n ) : table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for gap in range ( n ) : for j in range ( gap , n ) : i = j - gap x = 0 if ( ( i + 2 ) <= j ) : x = table [ i + 2 ] [ j ] y = 0 if ( ( i + 1 ) <= ( j - 1 ) ) : y = table [ i + 1 ] [ j - 1 ] z = 0 if ( i <= ( j - 2 ) ) : z = table [ i ] [ j - 2 ] table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) return table [ 0 ] [ n - 1 ]

def optimalStrategyOfGame ( arr , n ) : table = [ 0 for gap in range ( n ) ] for i in range ( 0 , n ) : for j in range ( gap , n ) : x = ( i + 2 ) <= j ) : table [ i + 2 ] [ j ] : 0 z = ( i <= ( j - 1 ) ) ? table [ i ] [ j - 1 ] : 0 table [ i ] [ j ] = max ( arr [ i ] + Math . min ( x , y ) : table [ i ] [ j ] = max ( arr [ i ] + Math . min ( x , y ) return table [ 0 ] [ n - 1 ]

def optimalStrategyOfGame ( arr , n ) : table = [ 0 for k in range ( n ) ] for gap in range ( 0 , n , - 1 ) : x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y ) ) return table [ 0 ] [ n - 1 ]

56.11
42.49
65.28
50.94
static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }

def breakSum ( n ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) return dp [ n ]

def breakSum ( n ) : dp = [ 0 for i in range ( n ) ] dp [ n ] = 0 for i in range ( 2 , n + 1 ) : dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) return dp [ n ]

def breakSum ( n ) : dp = [ 0 ] dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n ) : dp [ i ] = 0 for i in range ( 2 , n ) : dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) return dp [ n ]

56.22
40.6
52.55
39.82
static int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }

def calculate ( a ) : a . sort ( ) count = 1 answer = 0 for i in range ( 1 , len ( a ) ) : if a [ i ] == a [ i - 1 ] : count += 1 else : answer = answer + count * ( count - 1 ) // 2 count = 1 answer = answer + count * ( count - 1 ) // 2 return answer

def calculate ( a , n ) : a . sort ( reverse = True ) count = 1 answer = 0 for i in range ( 1 , n ) : if ( a [ i ] == a [ i - 1 ] ) : count += 1 answer = answer + ( count * ( count - 1 ) ) / 2 return answer

def calculate ( a , n ) : count = 1 answer = 0 for i in range ( n ) : if ( a [ i ] == a [ i - 1 ] ) : count += 1 else : answer = answer + ( count * ( count - 1 ) ) / 2 count = 1 return answer

56.24
50.66
57.01
52.65
static boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int curr_sum = sum - A [ i ] ; for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( s . contains ( curr_sum - A [ j ] ) && curr_sum - A [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( "Triplet is %d, %d, %d" , A [ i ] , A [ j ] , curr_sum - A [ j ] ) ; return true ; } s . add ( A [ j ] ) ; } } return false ; }

def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 1 ) : s = set ( ) curr_sum = sum - A [ i ] for j in range ( i + 1 , arr_size ) : if ( curr_sum - A [ j ] ) in s : print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , curr_sum - A [ j ] ) return True s . add ( A [ j ] ) return False

def find3Numbers ( A , arr_size , sum ) : s = set ( ) for i in range ( arr_size - 2 , - 1 , - 1 ) : if ( s . contains ( curr_sum - A [ j ] ) ) : return true else : curr_sum = sum - A [ i ] for j in range ( i + 1 , arr_size ) : if ( curr_sum - A [ j ] != ( int ) s .

def find3Numbers ( A , arr_size , sum ) : s = list ( ) for i in range ( arr_size - 2 , - 1 , - 1 ) : curr_sum = sum - A [ i ] for j in range ( i + 1 , arr_size ) : if ( s . contains ( curr_sum - A [ j ] ) and curr_sum - A [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) : print ( "Triplet is %d, %d, %d" , A [ i ] , A [ j ] , curr_sum - A [ j ] ) return True

56.27
43.6
65.18
52.03
static int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }

def pad ( n ) : pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 for i in range ( 3 , n + 1 ) : pNext = pPrevPrev + pPrev pPrevPrev = pPrev pPrev = pCurr pCurr = pNext return pNext ;

def pad ( n ) : pPrevPrev = 1 pPrev = 1 pCurr = 1 pNext = 1 for i in range ( 3 , n ) : pNext = pPrevPrev + pPrev pPrev = pCurr pCurr = pNext pNext = pPrevPrev + pPrev return pNext

def pad ( n ) : pPrevPrev = 1 pPrev = 1 pCurr = 1 pNext = 1 for i in range ( 3 , n ) : pNext = pPrevPrev + pPrev pPrevPrev = pPrev pPrev = pCurr pCurr = pNext return pNext

56.29
58.75
48.99
73.11
static int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( myMap . containsKey ( sum ) ) count += myMap . get ( sum ) ; if ( ! myMap . containsKey ( sum ) ) myMap . put ( sum , 1 ) ; else myMap . put ( sum , myMap . get ( sum ) + 1 ) ; } return count ; }

def countSubarrWithEqualZeroAndOne ( arr , n ) : mp = dict ( ) Sum = 0 count = 0 for i in range ( n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 Sum += arr [ i ] if ( Sum == 0 ) : count += 1 if ( Sum in mp . keys ( ) ) : count += mp [ Sum ] mp [ Sum ] = mp . get ( Sum , 0 ) + 1 return count

def countSubarrWithEqualZeroAndOne ( arr , n ) : myMap = Counter ( ) for i in range ( n ) : sum = 0 count = 0 for i in range ( n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 sum += arr [ i ] if ( sum == 0 ) : count += 1 if ( myMap . containsKey ( sum ) ) : myMap . put ( sum , 1 ) else : myMap .

def countSubarrWithEqualZeroAndOne ( arr , n ) : myMap = list ( ) sum = 0 count = 0 for i in range ( n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 sum += arr [ i ] if ( sum == 0 ) : count += if ( myMap . containsKey ( sum ) ) : count += myMap [ sum ] if ( not myMap . containsKey ( sum ) ) : myMap . put ( sum , 1 ) else : myMap . put ( sum , myMap . get ( sum ) + 1 ) return count

56.3
41.72
68.93
40.63
static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; int arr [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }

def isSubSeqDivisible ( str ) : n = len ( str ) dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] arr = [ 0 for i in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : arr [ i ] = int ( str [ i - 1 ] ) for i in range ( 1 , n + 1 ) : dp [ i ] [ arr [ i ] % 8 ] = 1 for j in range ( 8 ) : if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] for i in range ( 1 , n + 1 ) : if ( dp [ i ] [ 0 ] == 1 ) : return True return False

def isSubSeqDivisible ( str ) : dp = [ 0 for i in range ( n ) ] arr = [ 0 for i in range ( n + 1 , - 1 ) ] for i in range ( 1 , n ) : dp [ i ] [ arr [ i ] % 8 ] = 1 if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] if ( dp [ i ] [ j ] > dp [ i ] [ j ] > dp [ i ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = dp [ i ] [ j ] = dp [ i - 1 ] [ j ] if ( dp [ i ] [ j ] > dp [ i ] [ j ] [ j ] = dp [ i ] [ j ] [ j ] = dp [ i - 1 ] [ j ] [ j ] return true

def isSubSeqDivisible ( str ) : dp = [ 0 for i in range ( n ) ] arr = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : dp [ i ] [ arr [ i ] // 8 ] = 1 for i in range ( 1 , n ) : dp [ i ] [ arr [ i ] % 8 ] = 1 for j in range ( 8 ) : if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return True

56.34
50.72
80.21
62.55
void computeLPSArray ( String pat , int M , int lps [ ] ) { int len = 0 ; int i = 1 ; lps [ 0 ] = 0 ; while ( i < M ) { if ( pat . charAt ( i ) == pat . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = len ; i ++ ; } } } }

def computeLPSArray ( pat , M , lps ) : len = 0 lps [ 0 ] i = 1 while i < M : if pat [ i ] == pat [ len ] : len += 1 lps [ i ] = len i += 1 else : if len != 0 : len = lps [ len - 1 ] else : lps [ i ] = 0 i += 1

def computeLPSArray ( pat , M , lps ) : len = 0 i = 1 while i < M : if ( pat [ i ] == pat [ len ] ) : len = lps [ len - 1 ] if ( len != 0 ) : len = lps [ len - 1 ] if ( len != 0 ) : len = lps [ len - 1 ] if ( len != 0 ) : lps [ i ] = len i += 1 else :

def computeLPSArray ( pat , M , lps ) : len = 0 lps [ 0 ] = 0 while i < M : if pat [ i ] == pat [ len ] : len ++ lps [ i ] = len i += 1 else : if ( len != 0 ) : len = lps [ len - 1 ] else : lps [ i ] = len i += 1 return lps

56.37
43.78
59.5
52.29
static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( "No pairs exists" ) ; return ; } if ( n == 2 ) { System . out . println ( arr [ 0 ] + " " + arr [ 1 ] ) ; return ; } int posa = Integer . MIN_VALUE , posb = Integer . MIN_VALUE ; int nega = Integer . MIN_VALUE , negb = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) { posb = posa ; posa = arr [ i ] ; } else if ( arr [ i ] > posb ) posb = arr [ i ] ; if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( nega ) ) { negb = nega ; nega = arr [ i ] ; } else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( negb ) ) negb = arr [ i ] ; } if ( nega * negb > posa * posb ) System . out . println ( "Max product pair is { " + nega + ", " + negb + "}" ) ; else System . out . println ( "Max product pair is { " + posa + ", " + posb + "}" ) ; }

def maxProduct ( arr , n ) : if ( n < 2 ) : print ( "Nopairsexists" ) return if ( n == 2 ) : print ( arr [ 0 ] , "" , arr [ 1 ] ) return posa = 0 posb = 0 nega = 0 negb = 0 for i in range ( n ) : if ( arr [ i ] > posa ) : posb = posa posa = arr [ i ] elif ( arr [ i ] > posb ) : posb = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : negb = nega nega = arr [ i ] elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : negb = arr [ i ] if ( nega * negb > posa * posb ) : print ( "Maxproductpairis{" , nega , "," , negb , "}" ) else : print ( "Maxproductpairis{" , posa , "," , posb , "}" )

def maxProduct ( arr , n ) : if ( n == 0 ) : print ( arr [ 0 ] + " " + arr [ 1 ] ) return ; posa = Integer . MIN_VALUE posb = Integer . MIN_VALUE nega = Integer . MIN_VALUE negb = Integer . MIN_VALUE for i in range ( n ) : if ( arr [ i ] > posa ) : posa = posa nega = arr [ i ] posb = arr [ i ] if arr [ i ] > posb : posb = posa nega = negb = arr [ i ] if ( arr [ i ] < 0 and Math . abs ( arr [ i ] ) > Math . abs ( nega ) : nega = arr [ i ] negb = arr [ i ] if ( arr [ i ] < 0 ) : negb = nega if ( arr [ i ] > posb ) : negb = nega posb = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > negb : negb = negb

def maxProduct ( arr , n ) : posa = float ( 'inf' ) posb = float ( 'inf' ) nega = float ( 'inf' ) negb = float ( 'inf' ) for i in range ( n ) : if ( arr [ i ] > posa ) : posb = posa posa = arr [ i ] elif ( arr [ i ] > posb ) : posb = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : nega = nega nega = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : negb = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : negb = nega nega = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : negb = arr [ i ] if ( nega * negb > posa * posb ) : System . out . println ( "Max product pair is

56.38
70.09
19.77
34.26
public static int findPosition ( int k , int n ) { long f1 = 0 , f2 = 1 , f3 ; int i = 2 ; while ( i != 0 ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; }

def findPosition ( k , n ) : f1 = 0 f2 = 1 i = 2 while i != 0 : f3 = f1 + f2 f1 = f2 f2 = f3 if f2 % k == 0 : return n * i i += 1 return

def findPosition ( k , n ) : f1 = 0 f2 = 1 f3 = 0 for i in range ( 2 , k ) : f1 += f2 f2 = f3 f3 = f1 + f2 f1 = f2 f2 = f3 if ( f2 % k == 0 ) : return n * i

def findPosition ( k , n ) : f1 = 0 f2 = 1 f3 = f1 + f2 f1 = f2 f2 = f3 i = 2 while ( i != 0 ) : f3 = f1 + f2 f1 = f2 f2 = f3 f3 = f1 + f2 f1 = f2 f2 = f3 i = 2 while ( i != 0 ) : f3 = f1 + f2 f1 = f2 f2 = f3 f3 = f1 + f2 f1 = f2 f2 = f3 i = 2 while ( i != 0 ) : f3 = f1 + f2 f1 = f2 f2 = f3 i = 2 while ( i != 0 ) : f3 = f1 + f2 f1 = f2 f2 = f3 i = 2 while ( i != 0 ) : f3 = f1 + f2 f1 = f2 f2 = f3 return n * i

56.4
57.25
56.31
55.85
static void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }

def segregateElements ( arr , n ) : temp = [ 0 for k in range ( n ) ] j = 0 for i in range ( n ) : if ( arr [ i ] >= 0 ) : temp [ j ] = arr [ i ] j += 1 if ( j == n or j == 0 ) : return for i in range ( n ) : if ( arr [ i ] < 0 ) : temp [ j ] = arr [ i ] j += 1 for k in range ( n ) : arr [ k ] = temp [ k ]

def segregateElements ( arr , n ) : temp = [ 0 for k in range ( n ) ] for i in range ( n ) : if ( arr [ i ] >= 0 ) : temp [ j ++ ] = arr [ i ] if ( j == n || j == 0 ) : return arr [ i ] = temp [ i ] if ( j == n ) : return arr [ i ] = temp [ i ] if ( j == n ) : return arr

def segregateElements ( arr , n ) : temp = [ 0 for i in range ( n ) ] for i in range ( 0 , n ) : if arr [ i ] >= 0 : temp [ j ++ ] = arr [ i ] if j == n || j == 0 : return for i in range ( 0 , n ) : if arr [ i ] < 0 : temp [ j ++ ] = arr [ i ] for i in range ( 0 , n ) : arr [ i ] = temp [ i ]

56.44
45.32
66.49
50.59
public static int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }

def kthdigit ( a , b , k ) : p = a ** b count = 0 while ( p > 0 and count < k ) : rem = p % 10 count = count + 1 if ( count == k ) : return rem p = p / 10

def kthdigit ( a , b , k ) : p = ( int ) Math . pow ( a , b ) count = 0 while p > 0 and count < k : rem = p % 10 count += 1 if ( count == k ) : return rem p = p / 10 count = 0 while p > 0 and count < k : return rem

def kthdigit ( a , b , k ) : p = ( int ) Math . pow ( a , b ) count = 0 while p > 0 and count < k : rem = p % 10 count += 1 if ( count == k ) : return rem p = p / 10 return 0

56.46
50.52
79.64
76.09
static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start || longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; }

def minRemovalsDP ( arr , n ) : longest_start = - 1 longest_end = 0 for start in range ( n ) : min = sys . maxsize max = - sys . maxsize for end in range ( start , n ) : val = arr [ end ] if ( val < min ) : min = val if ( val > max ) : max = val if ( 2 * min <= max ) : break if ( end - start > longest_end - longest_start or longest_start == - 1 ) : longest_start = start longest_end = end if ( longest_start == - 1 ) : return n return ( n - ( longest_end - longest_start + 1 ) )

def minRemovalsDP ( arr , n ) : longest_start = - 1 longest_end = 0 for start in range ( n ) : for end in range ( start , n ) : if ( val < min ) : min = val max = val if ( val > max ) : max = val if ( min <= max ) : break if ( end - start > longest_end - longest_start || longest_start == - 1 ) : return n - ( longest_end -

def minRemovalsDP ( arr , n ) : longest_start = - 1 longest_end = 0 for start in range ( 0 , n ) : min = float ( 'inf' ) max = float ( 'inf' ) for end in range ( start , n ) : val = arr [ end ] if ( val < min ) : min = val if ( val > max ) : max = val if ( 2 * min <= max ) : break if ( end - start > longest_end - longest_start || longest_start == - 1 ) : longest_start = start longest_end = end return ( n - ( longest_end - longest_start + 1 ) )

56.51
66.02
86.17
82.28
public static void kLargest ( Integer [ ] arr , int k ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

def kLargest ( arr , k ) : arr . sort ( reverse = True ) for i in range ( k ) : print ( arr [ i ] , end = "" )

def kLargest ( arr , k ) : arr . sort ( reverse = True ) print ( arr [ k ] ) print ( end = "" ) for i in range ( 0 , k ) : print ( arr [ i ] ) print ( end = "" ) return

def kLargest ( arr , k ) : arr . sort ( reverse = True ) for i in range ( k ) : print ( arr [ i ] + " " )

56.6
38.26
81.51
58.87
static long squareRoot ( int n ) { int x = n ; int y = 1 ; while ( x > y ) { x = ( x + y ) / 2 ; y = n / x ; } return ( long ) x ; }

def squareRoot ( n ) : x = n y = 1 while ( x > y ) : x = ( x + y ) / 2 y = n / x return x

def squareRoot ( n ) : x = n // 2 while ( x > y ) : x = ( x + y ) // 2 y = n // x = (x + y) // 2 return ( long ) x

def squareRoot ( n ) : x = n y = 1 while x > y : x = ( x + y ) / 2 y = n / x return ( long ) x

56.61
47.12
37.77
34.08
static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; int maxArr [ ] [ ] = new int [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }

def findMaxValue ( mat ) : maxValue = - sys . maxsize - 1 maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] maxv = mat [ N - 1 ] [ N - 1 ] for j in range ( N - 2 , - 1 , - 1 ) : if ( mat [ N - 1 ] [ j ] > maxv ) : maxv = mat [ N - 1 ] [ j ] maxArr [ N - 1 ] [ j ] = maxv maxv = mat [ N - 1 ] [ N - 1 ] for i in range ( N - 2 , - 1 , - 1 ) : if ( mat [ i ] [ N - 1 ] > maxv ) : maxv = mat [ i ] [ N - 1 ] maxArr [ i ] [ N - 1 ] = maxv for i in range ( N - 2 , - 1 , - 1 ) : for j in range ( N - 2 , - 1 , - 1 ) : if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) return maxValue

def findMaxValue ( N , mat , maxArr ) : maxArr = [ INT_MAX for k in range ( N ) ] maxArr [ N - 1 ] = [ INT_MAX for k in range ( N ) ] for j in range ( N - 2 , - 1 , - 1 ) : if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] maxArr [ N - 1 ] [ j ] = maxv maxv = mat [ N - 1 ] [ N - 1 ] [ N - 1 ] [ N - 1 ] if ( maxv > mat [ N - 1 ] [ N - 1 ] > maxValue ) : maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] maxArr [ i ] [ j ] = maxv mat [ i ] [ j ] = maxv maxv = mat [ N - 1 ] [ N - 1 ] [ j ] = maxv i = N - 2 while i >= 0 : if ( mat [ i ] [ N - 1 ] [ j ] > maxValue ) : maxValue = maxArr [ i + 1 ] [ j + 1 ] [

def findMaxValue ( N , mat ) : maxValue = INT_MAX for i in range ( N ) : for j in range ( N ) : if maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue : maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] ) } maxv = mat [ N - 1 ] [ N - 1 ] for i in range ( N ) : for j in range ( N ) : if maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue : maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] ) return maxValue

56.66
54.2
70.64
67.18
static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }

def pairInSortedRotated ( arr , n , x ) : for i in range ( 0 , n - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : break l = ( i + 1 ) % n r = i while ( l != r ) : if ( arr [ l ] + arr [ r ] == x ) : return True if ( arr [ l ] + arr [ r ] < x ) : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return False

def pairInSortedRotated ( arr , n , x ) : i = 0 for i in range ( n ) : if ( arr [ i ] > arr [ i + 1 ] ) : break if ( arr [ i ] < arr [ i + 1 ] ) : l = ( i + 1 ) % n else : r = ( n + r - 1 ) % n while ( l != r ) : if ( arr [ l ] + arr [ r ] == x ) : return true if ( arr [ l ] + arr [ r ] < x ) : l = ( n + l - 1 ) % n else : r = ( n + r - 1 ) % n : break if ( arr [ l ] + arr [ r ] < x ) : r = ( n + r - 1 ) % n return false

def pairInSortedRotated ( arr , n , x ) : l = ( i + 1 ) % n r = i while ( l != r ) : if ( arr [ l ] + arr [ r ] == x ) : return True if ( arr [ l ] + arr [ r ] < x ) : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return False

56.71
46.99
61.32
47.06
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }

def countNegative ( M , n , m ) : count = 0 i = 0 j = m - 1 while j >= 0 and i < n : if M [ i ] [ j ] < 0 : count += ( j + 1 ) i += 1 else : j -= 1 return count

def countNegative ( M , n , m ) : count = 0 for i in range ( 0 , n , m ) : if ( M [ i ] [ j ] < 0 ) : count += j + 1 i += 1 else : j -= 1 return count

def countNegative ( M , n , m ) : count = 0 i = 0 for j in range ( m ) : if ( M [ i ] [ j ] < 0 ) : count += j + 1 i += 1 else : j -= 1 return count

56.78
54.97
84.19
69.08
static int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }

def smallestSumSubarr ( arr , n ) : min_ending_here = sys . maxsize min_so_far = sys . maxsize for i in range ( n ) : if ( min_ending_here > 0 ) : min_ending_here = arr [ i ] else : min_ending_here += arr [ i ] min_so_far = min ( min_so_far , min_ending_here ) return min_so_far

def smallestSumSubarr ( arr , n ) : min_ending_here = 2147483647 min_so_far = 2147483647 for i in range ( n ) : min_ending_here += arr [ i ] min_so_far = min ( min_so_far , min_ending_here ) if ( min_ending_here > 0 ) : min_ending_here = arr [ i ] min_so_far = min ( min_so_far , min_ending_here ) if ( min_ending_here > 0 ) : min_ending_here = 2147483647 min_so_far = min ( min_so_far , min_ending_here ) return min_so_far

def smallestSumSubarr ( arr , n ) : min_ending_here = 2147483647 min_so_far = 2147483647 for i in range ( n ) : if ( min_ending_here > 0 ) : min_ending_here = arr [ i ] else : min_ending_here += arr [ i ] min_so_far = min ( min_so_far , min_ending_here ) return min_so_far

56.8
44.68
68.15
50.32
static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int [ ] mark = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( mark [ i ] == 0 ) count ++ ; return count ; }

def countSink ( n , m , edgeFrom , edgeTo ) : mark = [ 0 ] * ( n + 1 ) for i in range ( m ) : mark [ edgeFrom [ i ] ] = 1 count = 0 for i in range ( 1 , n + 1 ) : if ( not mark [ i ] ) : count += 1 return count

def countSink ( n , m , edgeFrom , edgeTo ) : mark = [ 0 for i in range ( n , m ) ] for i in range ( 1 , n + 1 , m ) : if ( mark [ i ] == 0 ) : count += 1 return count

def countSink ( n , m , edgeFrom , edgeTo ) : mark = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : mark [ edgeFrom [ i ] ] = 1 count = 0 for i in range ( 1 , n ) : if ( mark [ i ] == 0 ) : count ++ return count

56.82
49.32
76.52
59.98
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }

def countPairs ( arr , n ) : result = 0 ; for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] ; for k in range ( 0 , n ) : if ( arr [ k ] == product ) : result = result + 1 ; break ; return result ;

def countPairs ( arr , n ) : result = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] == product ) : result ++ break if ( arr [ j ] == product ) : result ++ break if ( arr [ k ] == product ) : result ++ break if ( arr [ k ] == product ) : result ++ break return result

def countPairs ( arr , n ) : result = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] for k in range ( 0 , n ) : if ( arr [ k ] == product ) : result += 1 break return result

57.03
44.03
51.22
41.08
static int findMaxSegment ( String s , int k ) { int seg_len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_len ; i ++ ) res = res * 10 + ( s . charAt ( i ) - '0' ) ; int seg_len_pow = ( int ) Math . pow ( 10 , seg_len - 1 ) ; int curr_val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_len ) ; i ++ ) { curr_val = curr_val - ( s . charAt ( i - 1 ) - '0' ) * seg_len_pow ; curr_val = curr_val * 10 + ( s . charAt ( i + seg_len - 1 ) - '0' ) ; res = Math . max ( res , curr_val ) ; } return res ; }

def findMaxSegment ( s , k ) : seg_len = len ( s ) - k res = 0 for i in range ( seg_len ) : res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) seg_len_pow = pow ( 10 , seg_len - 1 ) curr_val = res for i in range ( 1 , len ( s ) - seg_len ) : curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) res = max ( res , curr_val ) return res

def findMaxSegment ( s , k ) : res = 0 for i in range ( k , seg_len ) : res = res * 10 + ( s [ i ] - '0' ) * seg_len_pow res = max ( res , curr_val ) for i in range ( 1 , len ( s ) - seg_len ) : curr_val = curr_val - ( s [ i - 1 ] - '0' ) * seg_len_pow = ( int ) ( s [ i + seg_len - 1 ) * seg_len_pow 10 , seg_len - 1 ) res = max ( res , curr_val ) seg_len_pow = ( 10 , seg_len - 1 ) return res

def findMaxSegment ( s , k ) : seg_len = len ( s ) seg_len_pow = ( int ) Math . pow ( 10 , seg_len - 1 ) curr_val = res for i in range ( 1 , ( len ( s ) - seg_len ) ) : curr_val = curr_val - ( s [ i - 1 ] - '0' ) * seg_len_pow curr_val = curr_val * 10 + ( s [ i + seg_len - 1 ] - '0' ) res = max ( res , curr_val ) return res

57.03
50.04
100.0
100.0
static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }

def transpose ( A , B ) : for i in range ( N ) : for j in range ( M ) : B [ i ] [ j ] = A [ j ] [ i ]

def transpose ( A , B , N , M ) : B . sort ( reverse = True ) for i in range ( 0 , N , M ) : B [ i ] [ j ] = A [ j ] [ i ]

def transpose ( A , B ) : for i in range ( N ) : for j in range ( M ) : B [ i ] [ j ] = A [ j ] [ i ]

57.06
49.54
58.59
48.64
static void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { System . out . print ( arr2 [ j ++ ] + " " ) ; i ++ ; } } }

def printIntersection ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and j < n : if arr1 [ i ] < arr2 [ j ] : i += 1 elif arr2 [ j ] < arr1 [ i ] : j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1

def printIntersection ( arr1 , arr2 , m , n ) : i = 0 j = 0 while i < m && j < n : if ( arr1 [ i ] < arr2 [ j ] ) : j += 1 else : print ( arr1 [ i ] + " " ) ; i += 1 elif ( arr2 [ j ] < arr1 [ i ] ) : j += 1 else : print ( arr2 [ j ] + " " ) ; j +=

def printIntersection ( arr1 , arr2 , m , n ) : i = 0 for i in range ( m , n ) : if ( arr1 [ i ] < arr2 [ j ] ) : i += 1 else : if ( arr2 [ j ] < arr1 [ i ] ) : j += 1 else : print ( arr2 [ j ++ ] + " " ) i += 1

57.08
44.49
68.76
53.55
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }

def findFirstMissing ( array , start , end ) : if ( start > end ) : return end + 1 if ( start != array [ start ] ) : return start mid = int ( ( start + end ) / 2 ) if ( array [ mid ] == mid ) : return findFirstMissing ( array , mid + 1 , end ) return findFirstMissing ( array , start , mid )

def findFirstMissing ( array , start , end ) : if ( start > end ) : return start + 1 if end != array [ start ] : return end mid = ( start + end ) // 2 if array [ mid ] == mid : return findFirstMissing ( array , mid + 1 , end )

def findFirstMissing ( array , start , end ) : if start > end : return end + 1 if start != array [ start ] : return start mid = ( start + end ) // 2 if array [ mid ] == mid : return findFirstMissing ( array , mid + 1 , end ) return findFirstMissing ( array , start , mid )

57.09
63.56
79.06
61.45
static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }

def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low i = low for i in range ( high ) : if arr [ i ] == x : return i if arr [ i ] < x and arr [ i + 1 ] >= x : return i + 1 return - 1

def ceilSearch ( arr , low , high , x ) : if ( x <= arr [ low ] ) : return low if ( x >= arr [ high ] ) : return high i = low while i < high : if ( arr [ i ] == x ) : return i if ( arr [ i ] < x and arr [ i + 1 ] >= x ) : return i + 1

def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low for i in range ( low , high ) : if ( arr [ i ] == x ) : return i if ( arr [ i ] < x and arr [ i + 1 ] >= x ) : return i + 1 return - 1

57.14
72.94
75.74
74.44
static void myCopy ( char s1 [ ] , char s2 [ ] , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1 . length - 1 ) { return ; } myCopy ( s1 , s2 , index + 1 ) ; }

def myCopy ( s1 , s2 , index ) : s2 [ index ] = s1 [ index ] if ( index == len ( s1 ) - 1 ) : return myCopy ( s1 , s2 , index + 1 )

def myCopy ( s1 , s2 , index ) : s2 [ index ] = s1 [ index ] if ( index == s1 . length - 1 ) : return myCopy ( s1 , s2 , index + 1 ) : return myCopy ( s1 , s2 , index + 1 ) : return myCopy ( s1 , s2 , index + 1 )

def myCopy ( s1 , s2 , index ) : s2 [ index ] = s1 [ index ] if index == s1 . length - 1 : return myCopy ( s1 , s2 , index + 1 )

57.2
43.23
61.39
41.25
static double findMod ( double a , double b ) { if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; double mod = a ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }

def findMod ( a , b ) : if ( a < 0 ) : a = - a if ( b < 0 ) : b = - b mod = a while ( mod >= b ) : mod = mod - b if ( a < 0 ) : return - mod return mod

def findMod ( a , b ) : a = - a b = - b if ( a < 0 ) : a = - a mod = a - b if ( b < 0 ) : return - mod return mod

def findMod ( a , b ) : if a < 0 : a = - a if b < 0 : b = - b mod = a while mod >= b : mod = mod - b if a < 0 : return - mod return mod

57.34
37.6
77.36
75.92
static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }

def fact ( n ) : if ( n == 0 ) : return 1 return n * fact ( n - 1 )

def fact ( n ) : if ( n == 1 ) : return fact ( n - 2 )

def fact ( n ) : if n == 0 : return 1 return n * fact ( n - 1 )

57.34
51.05
85.1
65.93
static boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }

def isSubsetSum ( arr , n , sum ) : subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] for i in range ( n + 1 ) : for j in range ( sum + 1 ) : if ( j == 0 ) : subset [ i % 2 ] [ j ] = True elif ( i == 0 ) : subset [ i % 2 ] [ j ] = False elif ( arr [ i - 1 ] <= j ) : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] else : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] return subset [ n % 2 ] [ sum ]

def isSubsetSum ( arr , n , sum ) : subset = [ False for i in range ( n ) ] for j in range ( sum ) : if ( arr [ i - 1 ] <= j ) : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] else : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] if ( arr [ i - 1 ] <= j ) : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] <= j ) : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] if ( arr [ i - 1 ] <= j ) : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ]

def isSubsetSum ( arr , n , sum ) : subset [ ] = [ True for i in range ( n ) ] for i in range ( n ) : for j in range ( sum ) : if ( j == 0 ) : subset [ i % 2 ] [ j ] = True elif ( i == 0 ) : subset [ i % 2 ] [ j ] = False else : if ( arr [ i - 1 ] <= j ) : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] else : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] return subset [ n % 2 ] [ sum ]

57.37
54.58
63.78
59.21
int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }

def countSubStr ( st , n ) : res = 0 for i in range ( 0 , n ) : if ( st [ i ] == '1' ) : for j in range ( i + 1 , n ) : if ( st [ j ] == '1' ) : res = res + 1 return res

def countSubStr ( str , n ) : res = 0 for i in range ( 0 , n ) : if ( str [ i ] == '1' ) : res ++ if ( str [ j ] == '1' ) : res ++ if ( str [ j ] == '1' ) : res ++ return res

def countSubStr ( str , n ) : res = 0 for i in range ( n ) : if ( str [ i ] == '1' ) : for j in range ( i + 1 , n ) : if ( str [ j ] == '1' ) : res += 1 if ( str [ j ] == '1' ) : res += 1 return res

57.37
41.22
65.49
43.87
static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + " " ) ; flag = true ; break ; } } if ( ! flag ) System . out . print ( "0" + " " ) ; } }

def printFirstNegativeInteger ( arr , n , k ) : for i in range ( 0 , ( n - k + 1 ) ) : flag = False for j in range ( 0 , k ) : if ( arr [ i + j ] < 0 ) : print ( arr [ i + j ] , end = "" ) flag = True break if ( not ( flag ) ) : print ( "0" , end = "" )

def printFirstNegativeInteger ( arr , n , k ) : flag = false for i in range ( 0 , n - k + 1 ) : if ( arr [ i + j ] < 0 ) : print ( arr [ i + j ] ) flag = true break if ( ! flag ) : print ( "0" + " " ) return for i in range ( 0 , n - k + 1 ) : print ( arr [ i + j ] ) flag = true break

def printFirstNegativeInteger ( arr , n , k ) : flag = False for i in range ( n - k + 1 ) : flag = False for j in range ( k ) : if ( arr [ i + j ] < 0 ) : print ( ( arr [ i + j ] ) + " " ) flag = True break if not flag : print ( "0" + " " )

57.37
66.19
74.63
66.05
static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }

def isHeap ( arr , n ) : for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : if arr [ 2 * i + 1 ] > arr [ i ] : return False if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : return False return True

def isHeap ( arr , n ) : for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ 2 * i + 1 ] > arr [ i ] ) : return false if ( 2 * i + 1 < n and arr [ 2 * i + 1 ] > arr [ i ] ) : return false if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : return false

def isHeap ( arr , n ) : for i in range ( n ) : if ( arr [ 2 * i + 1 ] > arr [ i ] ) : return False if ( 2 * i + 1 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : return False return True

57.42
52.86
64.18
58.43
static void modularEquation ( int a , int b ) { if ( a < b ) { System . out . println ( "No solution possible " ) ; return ; } if ( a == b ) { System . out . println ( "Infinite Solution possible " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; }

def modularEquation ( a , b ) : if ( a < b ) : print ( "Nosolutionpossible" ) return if ( a == b ) : print ( "InfiniteSolutionpossible" ) return count = 0 n = a - b y = ( int ) ( math . sqrt ( a - b ) ) for i in range ( 1 , y + 1 ) : if ( n % i == 0 ) : if ( n / i > b ) : count = count + 1 if ( i > b ) : count = count + 1 if ( y * y == n and y > b ) : count = count - 1 print ( count )

def modularEquation ( a , b ) : if ( a > b ) : print ( "No solution possible " ) ; return if ( a == b ) : print ( "Infinite Solution possible " ) ; return ; } n = a - b y = ( int ) Math . sqrt ( a - b ) for i in range ( 1 , y ) : if ( n % i == 0 ) : if ( n / i > b ) count ++ if ( i > b ) : count ++ if ( y > b ) : count += 1 if ( n % i > b ) : count += 1 if ( y > b ) : count -= 1 if ( y > b ) : print ( count ) return

def modularEquation ( a , b ) : if a < b : print ( "No solution possible" ) return if b == a : print ( "Infinite Solution possible" ) return count = 0 n = a - b y = ( int ) Math . sqrt ( a - b ) for i in range ( 1 , y ) : if ( n % i == 0 ) : if ( n / i > b ) : count ++ if ( i > b ) count ++ : } if ( y * y == n and y > b ) : count -- print ( count )

57.46
48.55
71.98
73.35
public static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 , sum = 0 , ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; while ( sum >= 180 ) { ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; sum -= arr [ l ] ; l ++ ; } ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; } return ans ; }

def findMinimumAngle ( arr , n ) : l = 0 _sum = 0 ans = 360 for i in range ( n ) : _sum += arr [ i ] while _sum >= 180 : ans = min ( ans , 2 * abs ( 180 - _sum ) ) _sum -= arr [ l ] l += 1 ans = min ( ans , 2 * abs ( 180 - _sum ) ) return ans

def findMinimumAngle ( arr , n ) : l = 0 sum = 0 for i in range ( n ) : sum += arr [ i ] ans = 360 while sum >= 180 : ans = min ( ans , 2 * Math . abs ( 180 - sum ) ) l += 1 sum -= arr [ l ] if ( sum >= 180 ) : ans = min ( ans , 2 * Math . abs ( 180 - sum ) ) return ans

def findMinimumAngle ( arr , n ) : l = 0 sum = 0 ans = 360 for i in range ( n ) : sum += arr [ i ] while sum >= 180 : ans = min ( ans , 2 * Math . abs ( 180 - sum ) ) sum -= arr [ l ] l += 1 ans = min ( ans , 2 * Math . abs ( 180 - sum ) ) return ans

57.63
44.68
67.84
53.93
static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }

def findMaxValue ( mat ) : maxValue = 0 for a in range ( N - 1 ) : for b in range ( N - 1 ) : for d in range ( a + 1 , N ) : for e in range ( b + 1 , N ) : if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; return maxValue ;

def findMaxValue ( N , mat ) : maxValue = float ( 'inf' ) for a in range ( 0 , N ) : for b in range ( a + 1 , N ) : if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) : maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] return maxValue

def findMaxValue ( N , mat ) : maxValue = INT_MAX for a in range ( N ) : for b in range ( 0 , N - 1 , - 1 ) : for d in range ( a + 1 , N ) : if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) : maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] return maxValue

57.67
34.11
55.44
35.96
public static int checkValidity ( int a , int b , int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ; else return 1 ; }

def checkValidity ( a , b , c ) : if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : return False else : return True

def checkValidity ( a , b , c ) : if ( a + b <= c || b + c <= a ) : return 0 else : return 1

def checkValidity ( a , b , c ) : if a + b <= c or a + c <= b or b + c <= a : return 0 else : return 1

57.72
38.47
67.0
44.32
static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 || unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }

def minRotation ( input , unlock_code ) : rotation = 0 while ( input > 0 or unlock_code > 0 ) : input_digit = input % 10 code_digit = unlock_code % 10 rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) input = int ( input / 10 ) unlock_code = int ( unlock_code / 10 ) return rotation

def minRotation ( input , unlock_code ) : rotation = 0 while input > 0 || unlock_code > 0 : input_digit = input % 10 code_digit = unlock_code % 10 rotation += min ( input_digit , 10 - Math . abs ( input_digit - code_digit ) ) unlock_code /= 10 rotation += min ( 10 - Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit -

def minRotation ( input , unlock_code ) : rotation = 0 while input > 0 or unlock_code > 0 : input_digit = input % 10 code_digit = unlock_code % 10 rotation += min ( abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) input /= 10 unlock_code /= 10 return rotation

57.72
46.55
61.06
63.76
static int findRotations ( String str ) { String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . substring ( i , str . length ( ) ) ; if ( str == substring ) return i ; } return n ; }

def findRotations ( str ) : tmp = str + str n = len ( str ) for i in range ( 1 , n + 1 ) : substring = tmp [ i : n ] if ( str == substring ) : return i return n

def findRotations ( str ) : tmp = str + str n = str . length ( ) for i in range ( 1 , n ) : if ( str == substring ) : return i

def findRotations ( str ) : tmp = str + str n = str . length for i in range ( 1 , n ) : for k in range ( 1 , n ) : substring = tmp [ i : i + str . length ( ) ] if ( str == substring ) : return i return n

57.76
48.36
78.8
60.33
static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }

def decimalToBinary ( N ) : B_Number = 0 cnt = 0 while ( N != 0 ) : rem = N % 2 c = pow ( 10 , cnt ) B_Number += rem * c N //= 2 cnt += 1 return B_Number

def decimalToBinary ( N ) : B_Number = 0 cnt = 0 while ( N != 0 ) : B_Number += rem * c N /= 2 cnt += 1 return B_Number

def decimalToBinary ( N ) : B_Number = 0 cnt = 0 while N != 0 : rem = N % 2 c = math . pow ( 10 , cnt ) B_Number += rem * c N /= 2 cnt += 1 return B_Number

57.78
50.35
85.22
75.37
static float slope ( float x1 , float y1 , float x2 , float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; }

def slope ( x1 , y1 , x2 , y2 ) : return ( float ) ( y2 - y1 ) / ( x2 - x1 )

def slope ( x1 , y1 , x2 , y2 ) : return ( y2 - y1 )

def slope ( x1 , y1 , x2 , y2 ) : return ( y2 - y1 ) / ( x2 - x1 )

57.81
60.25
82.23
79.76
public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }

def countSetBits ( n ) : if ( n == 0 ) : return 0 else : return 1 + countSetBits ( n & ( n - 1 ) )

def countSetBits ( n ) : if ( n == 0 ) : return 1 else : return countSetBits ( n >>> 1 )

def countSetBits ( n ) : if n == 0 : return 0 else : return 1 + countSetBits ( n & ( n - 1 ) )

57.88
43.51
61.76
46.89
static char getSecondMostFreq ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) ( count [ str . charAt ( i ) ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; }

def getSecondMostFreq ( str ) : NO_OF_CHARS = 256 count = [ 0 ] * NO_OF_CHARS for i in range ( len ( str ) ) : count [ ord ( str [ i ] ) ] += 1 first , second = 0 , 0 for i in range ( NO_OF_CHARS ) : if count [ i ] > count [ first ] : second = first first = i elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : second = i return chr ( second )

def getSecondMostFreq ( str ) : count = [ 0 for i in range ( NO_OF_CHARS ) ] for i in range ( 0 , NO_OF_CHARS ) : if ( count [ i ] > count [ first ] ) : first = i elif ( count [ i ] > count [ second ] ) : second = i else : if ( count [ i ] > count [ first ] ) : second = i else : if ( count [ i ] != count [ first ] ) : first = i else : return ( char ) second

def getSecondMostFreq ( str ) : count = [ 0 for i in range ( NO_OF_CHARS ) ] first = 0 second = 0 for i in range ( NO_OF_CHARS ) : if ( count [ i ] > count [ first ] ) : second = first first = i elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : second = i return ( char ) second

57.93
45.66
73.25
55.5
static int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }

def maxGameByWinner ( N ) : dp = [ 0 for i in range ( N ) ] dp [ 0 ] = 1 dp [ 1 ] = 2 i = 1 while dp [ i ] <= N : i = i + 1 dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return ( i - 1 )

def maxGameByWinner ( N ) : dp = [ 0 for k in range ( N ) ] i = 2 while ( dp [ i ] <= N ) : dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return ( i - 2 )

def maxGameByWinner ( N ) : dp = [ 1 for k in range ( N ) ] dp [ 0 ] = 1 dp [ 1 ] = 2 dp [ 2 ] = 2 i = 2 while ( dp [ i ] <= N ) : dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return ( i - 2 )

57.94
54.1
56.58
56.88
static void findDimen ( int H , int A ) { if ( H * H < 4 * A ) { System . out . println ( "Not Possible" ) ; return ; } double apb = Math . sqrt ( H * H + 4 * A ) ; double asb = Math . sqrt ( H * H - 4 * A ) ; System . out . println ( "P = " + Math . round ( ( ( apb - asb ) / 2.0 ) * 100.0 ) / 100.0 ) ; System . out . print ( "B = " + Math . round ( ( ( apb + asb ) / 2.0 ) * 100.0 ) / 100.0 ) ; }

def findDimen ( H , A ) : if H * H < 4 * A : print ( "NotPossible" ) return apb = sqrt ( H * H + 4 * A ) asb = sqrt ( H * H - 4 * A ) print ( "P=" , "%.2f" % ( ( apb - asb ) / 2.0 ) ) print ( "B=" , "%.2f" % ( ( apb + asb ) / 2.0 ) )

def findDimen ( H , A ) : if ( H * H < 4 * A ) : print ( "Not Possible" ) return ; } double apb = Math . sqrt ( H * H + 4 * A ) asb = Math . sqrt ( H * H - 4 * A ) print ( "A = " + round ( ( apb - asb ) / 2.0 ) * 100.0 ) / 100.0 ) print ( "P =

def findDimen ( H , A ) : apb = Math . sqrt ( H * H + 4 * A ) asb = Math . sqrt ( H * H - 4 * A ) print ( "P = " + round ( ( ( apb - asb ) / 2.0 ) * 100.0 ) / 100.0 ) print ( "B = " + round ( ( ( apb + asb ) / 2.0 ) * 100.0 ) / 100.0 )

57.95
52.13
70.84
67.7
static String evenlength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; }

def evenlength ( n ) : res = n for j in range ( len ( n ) - 1 , - 1 , - 1 ) : res += n [ j ] return res

def evenlength ( n ) : res = "" for j in range ( len ( n ) ) : res += n [ j ] if ( j >= 0 ) : res += n [ j ] return res

def evenlength ( n ) : res = n for j in range ( len ( n ) ) : res += n [ j ] return res

58.0
64.46
76.86
76.54
static boolean isRectangle ( int m [ ] [ ] ) { int rows = m . length ; if ( rows == 0 ) return false ; int columns = m [ 0 ] . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) for ( int x1 = 0 ; x1 < columns ; x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) for ( int x2 = x1 + 1 ; x2 < columns ; x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; return false ; }

def isRectangle ( m ) : rows = len ( m ) if ( rows == 0 ) : return False columns = len ( m [ 0 ] ) for y1 in range ( rows ) : for x1 in range ( columns ) : if ( m [ y1 ] [ x1 ] == 1 ) : for y2 in range ( y1 + 1 , rows ) : for x2 in range ( x1 + 1 , columns ) : if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : return True return False

def isRectangle ( m ) : rows = m . length columns = m [ 0 ] . length for y1 in range ( rows ) : for x1 in range ( 0 , columns ) : if ( m [ y1 ] [ x1 ] == 1 and m [ y2 ] [ x1 ] == 1 ) : return true else : for y2 in range ( y1 + 1 , rows , y2 ) : if ( m [ y1 ] [ x2 ] == 1 ) : if ( m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : return true

def isRectangle ( m ) : rows = m . length columns = m [ 0 ] . length for y1 in range ( rows ) : for x1 in range ( rows ) : if ( m [ y1 ] [ x1 ] == 1 ) : for y2 in range ( y1 + 1 , y2 < rows ) : if ( m [ y1 ] [ x1 ] == 1 ) : for x2 in range ( x1 + 1 , x2 ) : if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : return True return False

58.02
47.06
62.37
47.69
static void bestApproximate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; System . out . println ( "m = " + m ) ; System . out . println ( "c = " + c ) ; }

def bestApproximate ( x , y , n ) : sum_x = 0 sum_y = 0 sum_xy = 0 sum_x2 = 0 for i in range ( 0 , n ) : sum_x += x [ i ] sum_y += y [ i ] sum_xy += x [ i ] * y [ i ] sum_x2 += pow ( x [ i ] , 2 ) m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) c = ( float ) ( sum_y - m * sum_x ) / n print ( "m=" , m ) print ( "c=" , c )

def bestApproximate ( x , y ) : n = x . length sum_x = 0 sum_y = 0 sum_xy = 0 sum_x2 = 0 for i in range ( n ) : sum_x += x [ i ] sum_y += y [ i ] sum_xy += x [ i ] * y [ i ] sum_x2 += pow ( x [ i ] , 2 ) sum_x2 += pow ( x [ i ] , 2 ) sum_x = sum_x [ i ] if ( y [ i ] != 0 ) : c = ( sum_x - m * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) m = ( sum_xy - sum_x * sum_x ) / n * sum_x2 - pow ( sum_x , 2 ) ) print ( "m = " + m ) print ( "c = " + c )

def bestApproximate ( x , y ) : sum_x = 0 sum_y = 0 sum_xy = 0 sum_x2 = 0 for i in range ( n ) : sum_x += x [ i ] sum_y += y [ i ] sum_xy += x [ i ] * y [ i ] sum_x2 += pow ( x [ i ] , 2 ) sum_x2 += pow ( x [ i ] , 2 ) c = ( sum_y - m * sum_x ) / n m = ( sum_y - m * sum_x ) / n c = ( sum_y - m * sum_x ) / n return m , c

58.06
48.3
67.61
69.94
static int count ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n && i <= x ; i ++ ) { if ( x / i <= n && x % i == 0 ) count ++ ; } return count ; }

def count ( n , x ) : cnt = 0 for i in range ( 1 , n + 1 ) : if i <= x : if x // i <= n and x % i == 0 : cnt += 1 return cnt

def count ( n , x ) : count = 0 for i in range ( 1 , n , x ) : if ( x / i <= n and x % i == 0 ) : count += 1 return count

def count ( n , x ) : count = 0 for i in range ( 1 , n ) : if i <= n and x <= x : if x / i <= n and x % i == 0 : count += 1 return count

58.09
53.47
78.69
66.22
static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }

def findSum ( N , K ) : ans = 0 y = N / K x = N % K ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) return int ( ans )

def findSum ( N , K ) : ans = 0 for y in range ( N , K ) : ans += ( K * ( K - 1 ) ) * y + ( x * ( x + 1 ) ) / 2 return ans

def findSum ( N , K ) : ans = 0 y = N / K x = N % K ans = ( K * ( K - 1 ) * y + ( x * ( x + 1 ) ) / 2 return ans

58.09
52.84
69.96
61.9
static int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }

def isChangeable ( notes , n ) : fiveCount = 0 tenCount = 0 for i in range ( n ) : if ( notes [ i ] == 5 ) : fiveCount += 1 elif ( notes [ i ] == 10 ) : if ( fiveCount > 0 ) : fiveCount -= 1 tenCount += 1 else : return 0 else : if ( fiveCount > 0 and tenCount > 0 ) : fiveCount -= 1 tenCount -= 1 elif ( fiveCount >= 3 ) : fiveCount -= 3 else : return 0 return 1

def isChangeable ( notes , n ) : fiveCount = 0 tenCount = 0 for i in range ( n ) : if ( notes [ i ] == 5 ) fiveCount += 1 elif ( notes [ i ] == 10 ) : tenCount += 1 else : if ( notes [ i ] == 5 ) : fiveCount += 1 else : if ( notes [ i ] == 10 ) : tenCount -= 1 else : return 0

def isChangeable ( notes , n ) : fiveCount = 0 tenCount = 0 for i in range ( n ) : if ( notes [ i ] == 5 ) : fiveCount ++ elif ( notes [ i ] == 10 ) : if ( fiveCount > 0 and tenCount > 0 ) : fiveCount -- tenCount -- else : if ( fiveCount >= 3 ) : fiveCount -= 3 else : return 0 return 1

58.14
43.85
35.76
29.86
static void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int freq [ ] = new int [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - 'a' ] >= k ) { System . out . print ( str . charAt ( i ) ) ; } } }

def longestSubseqWithK ( str , k ) : n = len ( str ) freq = [ 0 ] * MAX_CHARS for i in range ( n ) : freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) : print ( str [ i ] , end = "" )

def longestSubseqWithK ( str , k ) : n = len ( str ) freq = [ 0 for i in range ( n ) ] for i in range ( 0 , n ) : if ( freq [ str [ i ] - 'a' ] >= k ) : print ( str [ i ] ) return freq [ str [ i ] - 'a' ] -= 1 else : print ( str [ i ] ) return freq [ str [ i ] - 'a' ]

def longestSubseqWithK ( str , k ) : freq = [ 0 for k in range ( MAX_CHARS ) ] for i in range ( 0 , n , MAX_CHARS ) : freq [ str [ i ] - 'a' ] += 1 if freq [ str [ i ] - 'a' ] >= k : print ( str [ i ] )

58.15
55.79
75.57
69.29
static int getMissingNo ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }

def getMissingNo ( a , n ) : i , total = 0 , 1 for i in range ( 2 , n + 2 ) : total += i total -= a [ i - 2 ] return total

def getMissingNo ( a , n ) : total = 1 for i in range ( 2 , n + 1 ) : total += i total -= a [ i - 2 ] if ( i <= ( n + 1 ) ) : total += i return total

def getMissingNo ( a , n ) : total = 1 for i in range ( 2 , n + 1 ) : total += i total -= a [ i - 2 ] return total

58.15
67.56
58.15
67.56
static String LexicographicalMaxString ( String str ) { String mx = "" ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ; }

def LexicographicalMaxString ( str ) : mx = "" for i in range ( len ( str ) ) : mx = max ( mx , str [ i : ] ) return mx

def LexicographicalMaxString ( str ) : mx = "" for i in range ( len ( str ) ) : if ( mx . compareTo ( str [ i ] ) <= 0 ) : mx = str [ i ] return mx

def LexicographicalMaxString ( str ) : mx = "" for i in range ( len ( str ) ) : if ( mx . compareTo ( str [ i ] ) <= 0 ) : mx = str [ i ] return mx

58.2
56.39
63.45
50.18
static int solve ( int a [ ] , int b [ ] , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }

def solve ( a , b , n ) : s = 0 for i in range ( 0 , n ) : s += a [ i ] + b [ i ] if n == 1 : return a [ 0 ] + b [ 0 ] if s % n != 0 : return - 1 x = s // n for i in range ( 0 , n ) : if a [ i ] > x : return - 1 if i > 0 : a [ i ] += b [ i - 1 ] b [ i - 1 ] = 0 if a [ i ] == x : continue y = a [ i ] + b [ i ] if i + 1 < n : y += b [ i + 1 ] if y == x : a [ i ] = y b [ i ] = 0 if i + 1 < n : b [ i + 1 ] = 0 continue if a [ i ] + b [ i ] == x : a [ i ] += b [ i ] b [ i ] = 0 continue if i + 1 < n and a [ i ] + b [ i + 1 ] == x : a [ i ] += b [ i + 1 ] b [ i + 1 ] = 0 continue return - 1 for i in range ( 0 , n ) : if b [ i ] != 0 : return - 1 return x

def solve ( a , b , n ) : s = 0 for i in range ( n ) : s += ( a [ i ] + b [ i ] ) if ( s % n != 0 ) : return - 1 x = s % n for i in range ( 0 , n ) : if ( a [ i ] > x ) : a [ i ] += b [ i - 1 ] b [ i - 1 ] = 0 continue if ( a [ i ] == x ) : a [ i ] = 0 if ( b [ i ] == x ) : a [ i ] = y = a [ i ] + b [ i ] if ( y == x ) : a [ i ] += b [ i + 1 ] = 0 continue if ( i + 1 < n ) : a [ i ] += b [ i + 1 ] == x : a [ i ] = y continue if ( a [ i ] == x ) : a [ i ] = y continue if ( a [ i ] + b [ i ] == x ) : a [ i ] = 0 continue if ( y == x ) : a [ i ] = y continue if ( a [ i ] == x ) : a [ i ] = 0 continue

def solve ( a , b , n ) : s = 0 for i in range ( n ) : if b [ i ] != 0 : s += a [ i ] + b [ i ] if i + 1 < n and a [ i ] + b [ i + 1 ] == x : a [ i ] = y b [ i ] = 0 continue if a [ i ] + b [ i ] == x : a [ i ] = y b [ i ] = 0 continue if i + 1 < n and a [ i ] + b [ i + 1 ] == x : a [ i ] += b [ i ] b [ i ] = 0 continue if i + 1 < n and a [ i ] + b [ i + 1 ] == x : a [ i ] += b [ i ] b [ i + 1 ] = 0 continue if i + 1 < n and a [ i ] + b [ i + 1 ] == x : a [ i ] += b [ i ] b [ i + 1 ] = 0 continue return - 1

58.24
40.62
70.36
54.9
static void bonacciseries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) for ( int j = i - n ; j < i ; j ++ ) a [ i ] += a [ j ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

def bonacciseries ( n , m ) : a = [ 0 ] * m a [ n - 1 ] = 1 for i in range ( n , m ) : for j in range ( i - n , i ) : a [ i ] = a [ i ] + a [ j ] for i in range ( 0 , m ) : print ( a [ i ] , end = "" )

def bonacciseries ( n , m ) : a = [ 1 for k in range ( n , m ) ] for i in range ( n , m ) : a [ i ] += a [ j ] for i in range ( n , m ) : if ( j < i ) : print ( a [ i ] + " " ) else : print ( a [ i ] + " " )

def bonacciseries ( n , m ) : a = [ 1 for i in range ( n ) ] for i in range ( n , m ) : for j in range ( i - n , i ) : a [ i ] += a [ j ] for i in range ( 0 , m ) : print ( a [ i ] + " " )

58.24
53.24
52.97
48.46
static Boolean divisibleBy20 ( String num ) { int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }

def divisibleBy20 ( num ) : lastTwoDigits = int ( num [ - 2 : ] ) return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) )

def divisibleBy20 ( num ) : lastTwoDigits = num [ lastTwoDigits - 2 : lastTwoDigits + 2 ] return ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) )

def divisibleBy20 ( num ) : lastTwoDigits = int ( num . substring ( num . length ( ) - 2 , num . length ( ) ) return ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) )

58.26
54.78
95.17
92.22
static int abFree ( char [ ] s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ s . length - i - 1 ] == 'a' ) { res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } else { b_count += 1 ; } } return res ; }

def abFree ( s ) : b_count = 0 res = 0 for i in range ( len ( s ) ) : if s [ ~ i ] == 'a' : res = ( res + b_count ) b_count = ( b_count * 2 ) else : b_count += 1 return res

def abFree ( s ) : b_count = 0 for i in range ( len ( s ) ) : if ( s [ i ] == 'a' ) : res = ( res + b_count ) b_count = ( b_count * 2 ) elif ( s [ i ] == 'a' ) : res = ( res + b_count ) b_count += 1 else : res += 1 return res

def abFree ( s ) : b_count = 0 res = 0 for i in range ( len ( s ) ) : if s [ i ] == 'a' : res = ( res + b_count ) b_count = ( b_count * 2 ) else : b_count += 1 return res

58.29
51.97
69.0
60.08
static void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_last = 0 , size = 0 ; for ( char ch = 'z' ; ch >= 'a' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_last = i ; } } last = new_last ; } } t [ size ] = '\0' ; }

def subsequence ( s , t , n , k ) : last = 0 cnt = 0 new_last = 0 size = 0 string = 'zyxwvutsrqponmlkjihgfedcba' for ch in string : cnt = 0 for i in range ( last , n ) : if s [ i ] == ch : cnt += 1 if cnt >= k : for i in range ( last , n ) : if s [ i ] == ch : t [ size ] = ch new_last = i size += 1 last = new_last

def subsequence ( s , t , n , k ) : last = 0 cnt = 0 for ch in range ( 'a' , 'z' ) : if ( s [ i ] == ch ) : cnt += 1 if ( cnt >= k ) : for i in range ( last , n ) : if ( s [ i ] == ch ) : t [ size ++ ] = ch new_last = i else : last = new_last if ( cnt >= k ) : t

def subsequence ( s , t , n , k ) : last = 0 cnt = 0 for ch in range ( 'z' , 'a' , - 1 , - 1 ) : cnt = 0 for i in range ( last , n ) : if ( s [ i ] == ch ) : cnt += 1 if cnt >= k : for i in range ( last , n ) : if ( s [ i ] == ch ) : t [ size ++ ] = ch new_last = i break last = new_last

58.36
49.77
72.24
69.56
static int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }

def getRemainder ( num , divisor ) : while ( num >= divisor ) : num -= divisor return num

def getRemainder ( num , divisor ) : num -= divisor return num

def getRemainder ( num , divisor ) : while num >= divisor : num -= divisor return num

58.38
42.79
53.56
39.5
static int minXOR ( int arr [ ] , int n ) { int min_xor = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ; return min_xor ; }

def minXOR ( arr , n ) : arr . sort ( ) min_xor = 999999 val = 0 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n - 1 ) : val = arr [ i ] ^ arr [ j ] min_xor = min ( min_xor , val ) return min_xor

def minXOR ( arr , n ) : min_xor = float ( 'inf' ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) return min_xor

def minXOR ( arr , n ) : min_xor = float ( 'inf' ) for i in range ( n ) : for j in range ( i + 1 , n ) : min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) return min_xor

58.38
50.13
69.98
56.07
static long count_of_ways ( long n ) { long count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) count ++ ; return count ; }

def count_of_ways ( n ) : count = 0 for i in range ( 0 , n + 1 ) : for j in range ( 0 , n + 1 ) : for k in range ( 0 , n + 1 ) : if ( i + j + k == n ) : count = count + 1 return count

def count_of_ways ( n ) : count = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i + j + k == n ) : count += 1 return count

def count_of_ways ( n ) : count = 0 for i in range ( n ) : for j in range ( 0 , n ) : for k in range ( 0 , n ) : if ( i + j + k == n ) : count += 1 return count

58.42
50.59
38.22
39.94
public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }

def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : max = arr1 [ 0 ] min = arr2 [ 0 ] i = 1 while ( i < n1 and i < n2 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 while ( i < n1 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] i += 1 while ( i < n2 ) : if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 return max * min

def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : max = arr1 [ 0 ] min = arr2 [ 0 ] for i in range ( 1 , n1 , n2 ) : if ( arr1 [ i ] > max ) max = arr1 [ i ] if ( arr2 [ i ] < min ) min = arr2 [ i ] i ++ if ( i < n1 ) : if ( arr1 [ i ] > max ) max = arr1 [ i ] if ( arr2 [ i ] < min ) : min = arr2 [ i ] if ( arr2 [ i ] > max ) max = arr2 [ i ] if ( arr2 [ i ] < min ) min = arr2 [ i ] if ( arr2 [ i ] > min ) min = arr2 [ i ] return max * min

def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : max = arr1 [ 0 ] min = arr2 [ 0 ] for i in range ( 1 , n1 , n2 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] if ( arr2 [ i ] < min ) : min = arr2 [ i ] return max * min

58.42
51.86
79.03
67.23
public static int shortestDist ( int [ ] [ ] graph ) { int [ ] dist = new int [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { dist [ i ] = INF ; for ( int j = i ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) { continue ; } dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }

def shortestDist ( graph ) : global INF dist = [ 0 ] * N dist [ N - 1 ] = 0 for i in range ( N - 2 , - 1 , - 1 ) : dist [ i ] = INF for j in range ( N ) : if graph [ i ] [ j ] == INF : continue dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) return dist [ 0 ]

def shortestDist ( N , graph ) : dist = [ INT_MAX for i in range ( N ) ] for j in range ( i + 1 , N ) : if ( graph [ i ] [ j ] == INF ) : continue dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) return dist [ 0 ]

def shortestDist ( graph ) : dist = [ INF for i in range ( N ) ] for i in range ( N - 2 , - 1 , - 1 ) : dist [ i ] = INF for j in range ( i , N ) : if ( graph [ i ] [ j ] == INF ) : continue dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) return dist [ 0 ]

58.48
52.9
39.8
40.66
static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + " " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }

def printknapSack ( W , wt , val , n ) : K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] res = K [ n ] [ W ] print ( res ) w = W for i in range ( n , 0 , - 1 ) : if res <= 0 : break if res == K [ i - 1 ] [ w ] : continue else : print ( wt [ i - 1 ] ) res = res - val [ i - 1 ] w = w - wt [ i - 1 ]

def printknapSack ( W , wt , val , n ) : K = [ 0 for i in range ( n ) ] for w in range ( W ) : if ( i == 0 || w == 0 ) : K [ i ] [ w ] = 0 else : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) if ( wt [ i - 1 ] <= w ) : K [ i ] [ w ] = max ( K [ n ] [ w ] ) for i in range ( n ) : if ( res == K [ i - 1 ] [ w ] : res = res - val [ i - 1 ] w = w - wt [ i - 1 ]

def printknapSack ( W , wt , val , n ) : K [ ] [ ] = [ 0 for i in range ( n + 1 , W + 1 ) ] for w in range ( W , n ) : if ( i == 0 or w == 0 ) : K [ i ] [ w ] = 0 else : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ]

58.66
55.69
80.12
71.03
static int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }

def countSeq ( n ) : nCr = 1 res = 1 for r in range ( 1 , n + 1 ) : nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; return res ;

def countSeq ( n ) : nCr = 1 res = 1 for r in range ( 1 , n ) : nCr = ( nCr * n ) / r res += nCr * nCr

def countSeq ( n ) : nCr = 1 res = 1 for r in range ( 1 , n ) : nCr = ( nCr * ( n + 1 - r ) ) / r res += nCr * nCr return res

58.69
45.6
79.89
67.44
static int countSub ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }

def countSub ( arr , n ) : count = [ 0 for i in range ( 10 ) ] for i in range ( n ) : for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : count [ arr [ i ] ] += count [ j ] count [ arr [ i ] ] += 1 result = 0 for i in range ( 10 ) : result += count [ i ] return result

def countSub ( arr , n ) : count = [ 0 for i in range ( n ) ] for i in range ( n ) : count [ arr [ i ] ] += count [ j ] for j in range ( i + 1 , n ) : if ( j >= 0 ) : count [ arr [ i ] ] += count [ j ] return result

def countSub ( arr , n ) : count = [ 0 for i in range ( 10 ) ] for i in range ( 0 , n ) : for j in arr [ i ] - 1 : count [ arr [ i ] ] += count [ j ] count [ arr [ i ] ] += count [ j ] result = 0 for i in range ( 0 , 10 ) : result += count [ i ] return result

58.7
48.34
79.15
61.33
static int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }

def bellNumber ( n ) : bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] bell [ 0 ] [ 0 ] = 1 for i in range ( 1 , n + 1 ) : bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] for j in range ( 1 , i + 1 ) : bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] return bell [ n ] [ 0 ]

def bellNumber ( n ) : bell = [ [ 1 ] [ n + 1 ] ] bell [ 0 ] [ 0 ] = 1 bell [ n ] [ 0 ] = bell [ n - 1 ] [ n - 1 ] for i in range ( 1 , n ) : bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] + bell [ i ] [ j - 1 ] return bell [ n ] [ 0 ]

def bellNumber ( n ) : bell = [ 1 for i in range ( n ) ] for i in range ( 1 , n ) : bell [ i ] [ 0 ] = 1 for i in range ( 1 , n ) : bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] for j in range ( 1 , i ) : bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] return bell [ n ] [ 0 ]

58.72
53.31
72.02
57.33
public static double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }

def maxAverageOfPath ( cost , N ) : dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , N ) : dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] for i in range ( 1 , N ) : for j in range ( 1 , N ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )

def maxAverageOfPath ( cost , N ) : dp = [ N + 1 ] * N + 1 dp [ 0 ] = [ 0 for k in range ( N ) ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , N ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] + cost [ i ] [ j ] return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )

def maxAverageOfPath ( cost [ ] , N ) : dp [ ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , N + 1 , - 1 ) : dp [ i ] [ 0 ] = cost [ 0 ] [ 0 ] for j in range ( 1 , N ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + cost [ i ] [ j ] for i in range ( 1 , N ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )

58.79
48.59
67.86
48.64
public static void sortSquares ( int arr [ ] ) { int n = arr . length ; int k ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] >= 0 ) break ; } int i = k - 1 ; int j = k ; int ind = 0 ; int [ ] temp = new int [ n ] ; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; } ind ++ ; } while ( i >= 0 ) { temp [ ind ++ ] = arr [ i ] * arr [ i ] ; i -- ; } while ( j < n ) { temp [ ind ++ ] = arr [ j ] * arr [ j ] ; j ++ ; } for ( int x = 0 ; x < n ; x ++ ) arr [ x ] = temp [ x ] ; }

def sortSquares ( arr , n ) : K = 0 for K in range ( n ) : if ( arr [ K ] >= 0 ) : break i = K - 1 j = K ind = 0 temp = [ 0 ] * n while ( i >= 0 and j < n ) : if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 else : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 while ( i >= 0 ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 ind += 1 while ( j < n ) : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 for i in range ( n ) : arr [ i ] = temp [ i ]

def sortSquares ( arr ) : n = arr . length for k in range ( n ) : if ( arr [ k ] >= 0 ) : break for k in range ( k - 1 , n ) : if ( arr [ k ] < arr [ i ] * arr [ j ] ) : temp [ ind ] = arr [ i ] * arr [ i ] j -= 1 else : temp [ ind ] = arr [ j ] * arr [ j ] i -= 1 if ( i >= 0 ) : temp [ ind ] = arr [ i ] * arr [ i ] if ( j < n ) : temp [ ind ] = arr [ j ] * arr [ j ] i -= 1 if ( i >= 0 ) : temp [ ind ] = arr [ i ] * arr [ i ] j += 1 else : temp [ ind ] = arr [ j ] * arr [ j ] i -= 1 else : temp [ ind ] = arr [ j ] * arr [ j ] i -= 1 if ( j < n ) : temp [ ind ] = arr [ i ] * arr [ j ] = 0

def sortSquares ( arr ) : i = k - 1 j = k ind = 0 for i in range ( n ) : if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : temp [ ind ] = arr [ i ] * arr [ i ] i -- elif ( arr [ j ] * arr [ j ] ) : temp [ ind ] = arr [ j ] * arr [ j ] j ++ ind ++ for i in range ( n ) : if ( i >= 0 and j < n ) : if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : temp [ ind ] = arr [ i ] * arr [ i ] i -- else : temp [ ind ] = arr [ j ] * arr [ j ] j ++ ind += 1 for x in range ( 0 , n ) : arr [ x ] = temp [ x ] return

58.83
46.37
66.14
45.16
public static long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }

def minPerimeter ( n ) : l = math . sqrt ( n ) sq = l * l if ( sq == n ) : return l * 4 else : row = n / l perimeter = 2 * ( l + row ) if ( n % l != 0 ) : perimeter += 2 return perimeter

def minPerimeter ( n ) : l = 2 ** 32 - 1 n = int ( n ) sq = l * l if ( sq == n ) : return l * 4 else : perimeter = 2 * ( l + row ) return perimeter

def minPerimeter ( n ) : l = ( float ( n ) ) sq = l * l if sq == n : return l * 4 else : long row = n // l perimeter = 2 * ( l + row ) if n % l != 0 : perimeter += 2 return perimeter

58.91
48.44
73.48
54.91
static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }

def MatrixChainOrder ( p , n ) : m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] for i in range ( 1 , n ) : m [ i ] [ i ] = 0 for L in range ( 2 , n ) : for i in range ( 1 , n - L + 1 ) : j = i + L - 1 m [ i ] [ j ] = sys . maxint for k in range ( i , j ) : q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] if q < m [ i ] [ j ] : m [ i ] [ j ] = q return m [ 1 ] [ n - 1 ]

def MatrixChainOrder ( p , n ) : m = [ [ 0 for i in range ( n ) ] for i in range ( n ) : for j in range ( 1 , n - L + 1 ) : if ( j == n ) : continue m [ i ] [ j ] = float ( 'inf' ) elif ( k <= j - 1 ) : q = m [ i ] [ k ] + m [ k + 1 ] [ j ] if ( q < m [ i ] [ j ] ) : m [ i ] [ j ] ) : m [ i ] [ j ] = q if ( q < m [ i ] [ j ] ) : m [ i ] [ j ] = q if ( q < m [ i ] [ j ] ) : m [ i ] [ j ] = q return m [ 1 ] [ n - 1 ] [ n - 1 ]

def MatrixChainOrder ( p , n ) : m [ ] [ ] = [ 0 for k in range ( n ) ] for L in range ( 2 , n ) : for i in range ( 1 , n ) : j = i + L - 1 if ( j == n ) : continue m [ i ] [ j ] = float ( 'inf' ) for k in range ( i , j - 1 ) : q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] if ( q < m [ i ] [ j ] ) : m [ i ] [ j ] = q return m [ 1 ] [ n - 1 ]

58.92
41.0
90.96
56.6
static int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }

def findRepeatingElement ( arr , low , high ) : if low > high : return - 1 mid = ( low + high ) / 2 if ( arr [ mid ] != mid + 1 ) : if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : return mid return findRepeatingElement ( arr , low , mid - 1 ) return findRepeatingElement ( arr , mid + 1 , high )

def findRepeatingElement ( arr , low , high ) : if low > high : return - 1 mid = ( low + high ) // 2 if arr [ mid ] != mid - 1 : return findRepeatingElement ( arr , low , mid - 1 ) else : return findRepeatingElement ( arr , mid + 1 , high )

def findRepeatingElement ( arr , low , high ) : if low > high : return - 1 mid = ( low + high ) // 2 if arr [ mid ] != mid + 1 : if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : return mid return findRepeatingElement ( arr , low , mid - 1 ) return findRepeatingElement ( arr , mid + 1 , high )

58.94
47.28
78.98
67.43
static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }

def productAtKthLevel ( tree , k ) : level = - 1 product = 1 n = len ( tree ) for i in range ( 0 , n ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 else : if ( level == k ) : product *= ( int ( tree [ i ] ) - int ( '0' ) ) return product

def productAtKthLevel ( tree , k ) : level = - 1 product = 1 for i in range ( n ) : if ( tree [ i ] == '(' ) level += 1 elif ( tree [ i ] == ')' ) level -= 1 if ( level == k ) product *= ( tree [ i ] - '0' ) return product

def productAtKthLevel ( tree , k ) : level = - 1 product = 1 n = tree . length ( ) for i in range ( 0 , n ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 if ( level == k ) : product *= ( tree [ i ] - '0' ) return product

58.96
46.73
57.64
41.12
static void printHosoya ( int n ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( dp [ i ] [ j ] + "" ) ; System . out . println ( "" ) ; } }

def printHosoya ( n ) : dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 for i in range ( 2 , n ) : for j in range ( n ) : if ( i > j ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) for i in range ( n ) : for j in range ( i + 1 ) : print ( dp [ i ] [ j ] , end = '' ) print ( )

def printHosoya ( N ) : dp = [ 2 , 2 , 1 ] dp [ 0 ] = [ 1 , 1 ] dp [ 1 ] = [ 1 , 1 ] for i in range ( 2 , n ) : for j in range ( 0 , n ) : if ( i > j ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] dp [ i ] [ j ] = dp [ i ] [ j ] print ( "" ) for i in range ( 0 , n ) : print ( dp [ i ] [ j ] = dp [ i ] [ j ] + "" ) print ( "" ) print ( dp [ i ] [ j ]

def printHosoya ( n ) : dp [ ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 dp [ 1 ] [ 1 ] = 1 for i in range ( 2 , n ) : for j in range ( 2 , n ) : if i > j : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ]

59.0
50.93
67.22
67.49
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }

def PowerOFPINnfactorial ( n , p ) : ans = 0 temp = p while ( temp <= n ) : ans += n / temp temp = temp * p return int ( ans )

def PowerOFPINnfactorial ( n , p ) : ans = 0 for temp in range ( 1 , n ) : ans += n / temp p = temp * p return ans

def PowerOFPINnfactorial ( n , p ) : ans = 0 for temp in range ( n ) : ans += n / temp temp = p while ( temp <= n ) : ans += n / temp temp = temp * p return ans

59.1
46.27
52.96
45.08
static int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }

def findMinSum ( num ) : sum = 0 i = 2 while ( i * i <= num ) : while ( num % i == 0 ) : sum += i num /= i i += 1 sum += num return sum

def findMinSum ( num ) : sum = 0 for i in range ( 2 , num ) : while ( num % i == 0 ) : sum += i num /= i return sum

def findMinSum ( num ) : sum = 0 for i in range ( 2 , num ) : while num % i == 0 : sum += i num /= i sum += num return sum

59.11
35.32
86.55
83.45
static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }

def numberOfPaths ( m , n ) : if ( m == 1 or n == 1 ) : return 1 return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 )

def numberOfPaths ( m , n ) : if ( m == 1 || n == 1 ) : return numberOfPaths ( m - 1 , n )

def numberOfPaths ( m , n ) : if m == 1 or n == 1 : return 1 return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 )

59.21
51.44
53.82
46.94
public static long findWays ( int m , int n , int x ) { long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }

def findWays ( m , n , x ) : table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] for j in range ( 1 , min ( m + 1 , x + 1 ) ) : table [ 1 ] [ j ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 1 , x + 1 ) : for k in range ( 1 , min ( m + 1 , j ) ) : table [ i ] [ j ] += table [ i - 1 ] [ j - k ] return table [ - 1 ] [ - 1 ]

def findWays ( m , n , x ) : table = [ 0 for i in range ( n + 1 , x + 1 ) ] for j in range ( 1 , n , x ) : table [ i ] [ j ] = 1 table [ 1 ] [ j ] = 1 for i in range ( 2 , n , x ) : if ( j <= m and k <= x ) : table [ i ] [ j ] += table [ i - 1 ] [ j - k ] if ( k <= m ) : table [ i ] [ j ] += table [ i - 1 ] [ j - k ] return table [ n ] [ x ]

def findWays ( m , n , x ) : table = [ 0 for k in range ( n ) ] for j in range ( 1 , m , x ) : table [ 1 ] [ j ] = 1 for i in range ( 2 , n ) : for j in range ( 1 , x ) : table [ i ] [ j ] += table [ i - 1 ] [ j - k ] return table [ n ] [ x ]

59.26
45.05
63.57
56.73
static int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }

def sumofsquare ( n ) : C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) sum = 0 for i in range ( 0 , n + 1 ) : sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) return sum

def sumofsquare ( n ) : C = [ [ 0 for i in range ( n ) ] for i in range ( n + 1 , n ) : if ( i == 0 || j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = 0 C [ i ] [ j ] = 1 for i in range ( 0 , n ) : if ( j == 0 || j == i ) : C [ i ] [ j ] = C [ i - 1 ] [ j ] = C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] return sum

def sumofsquare ( n ) : C = [ INT_MAX for i in range ( n ) ] for j in range ( 0 , n ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] sum = 0 for i in range ( 0 , n ) : sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) return sum

59.37
52.76
72.83
53.32
static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }

def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 for i in range ( 0 , n ) : area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return abs ( area // 2.0 )

def polygonArea ( X , Y , n ) : area = 0.0 for i in range ( n ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) return area

def polygonArea ( X , Y , n ) : area = 0.0 for i in range ( n ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return abs ( area / 2.0 )

59.39
48.11
78.86
64.13
static int countIslands ( int mat [ ] [ ] , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 'X' ) { if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) count ++ ; } } } return count ; }

def countIslands ( mat ) : count = 0 for i in range ( 0 , M ) : for j in range ( 0 , N ) : if ( mat [ i ] [ j ] == 'X' ) : if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) and ( j == 0 or mat [ i ] [ j - 1 ] == 'O' ) ) : count = count + 1 return count

def countIslands ( mat , m , n ) : count = 0 for i in range ( 0 , m , n ) : if ( mat [ i ] [ j ] == 'X' ) : if ( mat [ i ] [ j ] == 'O' ) : count += 1 elif ( mat [ i ] [ j ] == 'X' ) : if ( j == 0 || mat [ i - 1 ] [ j ] == 'O' ) : count +=

def countIslands ( mat , m , n ) : count = 0 for i in range ( m ) : for j in range ( n ) : if ( mat [ i ] [ j ] == 'X' ) : if ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) and ( j == 0 or mat [ i ] [ j - 1 ] == 'O' ) : count += 1 return count

59.43
54.42
57.6
55.05
static int doublefactorial ( int n ) { int res = 1 ; for ( int i = n ; i >= 0 ; i = i - 2 ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }

def doublefactorial ( n ) : res = 1 for i in range ( n , - 1 , - 2 ) : if ( i == 0 or i == 1 ) : return res else : res *= i

def doublefactorial ( n ) : res = 1 for i in range ( n ) : if ( i == 0 || i == 1 ) : return res

def doublefactorial ( n ) : res = 1 for i in range ( n ) : if i == 0 or i == 1 : return res res *= i return res

59.43
35.73
87.24
58.8
static int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }

def countPaths ( n , m ) : if ( n == 0 or m == 0 ) : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )

def countPaths ( n , m ) : if ( n == 0 || m == 0 ) : return 1 return countPaths ( n - 1 , m )

def countPaths ( n , m ) : if n == 0 or m == 0 : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )

59.44
41.48
60.96
41.37
static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }

def countOfSubstringWithKOnes ( s , K ) : N = len ( s ) res = 0 countOfOne = 0 freq = [ 0 for i in range ( N + 1 ) ] freq [ 0 ] = 1 for i in range ( 0 , N , 1 ) : countOfOne += ord ( s [ i ] ) - ord ( '0' ) if ( countOfOne >= K ) : res += freq [ countOfOne - K ] freq [ countOfOne ] += 1 return res

def countOfSubstringWithKOnes ( s , K ) : N = len ( s ) countOfOne = 0 freq = [ 0 for i in range ( N ) ] for i in range ( N ) : countOfOne += ( s [ i ] - '0' ) freq [ countOfOne ] += 1 if ( countOfOne >= K ) : res += freq [ countOfOne - K ] return res

def countOfSubstringWithKOnes ( s , K ) : res = 0 countOfOne = 0 freq = [ N + 1 ] freq [ 0 ] = 1 for i in range ( 0 , N ) : countOfOne += ( s [ i ] - '0' ) if ( countOfOne >= K ) : res += freq [ countOfOne - K ] freq [ countOfOne ] ++ return res

59.46
46.7
55.88
48.81
static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }

def exponential ( n , x ) : sum = 1.0 for i in range ( n , 0 , - 1 ) : sum = 1 + x * sum / i print ( "e^x=" , sum )

def exponential ( n , x ) : sum = 1 for i in range ( n ) : sum = 1 + x * sum / i return sum

def exponential ( n , x ) : sum = 1 for i in range ( n ) : sum = 1 for i in range ( n - 1 , - 1 , - 1 ) : sum = 1 + x * sum / i return sum

59.47
50.95
30.4
30.72
static void findSmallest ( int m , int s ) { if ( s == 0 ) { System . out . print ( m == 1 ? "Smallest number is 0" : "Not possible" ) ; return ; } if ( s > 9 * m ) { System . out . println ( "Not possible" ) ; return ; } int [ ] res = new int [ m ] ; s -= 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( s > 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; System . out . print ( "Smallest number is " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; }

def findSmallest ( m , s ) : if ( s == 0 ) : if ( m == 1 ) : print ( "Smallestnumberis0" ) else : print ( "Notpossible" ) return if ( s > 9 * m ) : print ( "Notpossible" ) return res = [ 0 for i in range ( m + 1 ) ] s -= 1 for i in range ( m - 1 , 0 , - 1 ) : if ( s > 9 ) : res [ i ] = 9 s -= 9 else : res [ i ] = s s = 0 res [ 0 ] = s + 1 print ( "Smallestnumberis" , end = "" ) for i in range ( m ) : print ( res [ i ] , end = "" )

def findSmallest ( m , s ) : if ( s == 0 ) : print ( m == 1 ? "Smallest number is 0" : "Not possible" ) return if ( s > 9 * m ) : print ( "Not possible" ) return res = [ 0 for i in range ( m ) ] for i in range ( m - 1 , - 1 , - 1 ) : res [ i ] = 9 s -= 9 for i in range ( 0 , m ) : if ( i > 0 ) : res [ i ] = s + 1 if ( s > 9 ) : print ( res [ i ] ) s -= 9 print ( "Not possible" ) return if ( s > 9 * m ) : print ( "Not possible" ) return res [ 0 ] = s + 1 print ( res [ 0 ] ) return res [ 0 ]

def findSmallest ( m , s ) : res = [ 0 for i in range ( m ) ] s -= 1 for i in range ( m - 1 , - 1 , - 1 ) : if ( s > 9 ) : res [ i ] = 9 , s -= 9 else : res [ i ] = s s = 0 return res

59.47
49.23
56.86
47.71
static int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }

def maxSum ( arr , n ) : res = - sys . maxsize for i in range ( 0 , n ) : curr_sum = 0 for j in range ( 0 , n ) : index = int ( ( i + j ) % n ) curr_sum += j * arr [ index ] res = max ( res , curr_sum ) return res

def maxSum ( arr , n ) : res = float ( 'inf' ) for i in range ( 0 , n ) : curr_sum = float ( 'inf' ) for j in range ( 0 , n ) : curr_sum += arr [ index ] i = ( i + j ) % n res = max ( res , curr_sum ) if ( res != float ( 'inf' ) ) : return res

def maxSum ( arr , n ) : res = INT_MIN_VALUE for i in range ( n ) : curr_sum = 0 for j in range ( n ) : curr_sum += j * arr [ index ] res = max ( res , curr_sum ) return res

59.48
55.29
83.67
86.05
static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( ( b & 1 ) != 0 ) res = res + a ; a = a << 1 ; b = b >> 1 ; } return res ; }

def russianPeasant ( a , b ) : res = 0 while ( b > 0 ) : if ( b & 1 ) : res = res + a a = a << 1 b = b >> 1 return res

def russianPeasant ( a , b ) : res = 0 for a in range ( a , b ) : if ( a & 1 ) != 0 : res = res + a a = a << 1 b = b >> 1 res = res + a

def russianPeasant ( a , b ) : res = 0 while b > 0 : if ( b & 1 ) != 0 : res = res + a a = a << 1 b = b >> 1 return res

59.64
42.46
75.23
57.43
static boolean checkCount ( int [ ] arr , int n , int k ) { int count ; for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++ ; if ( count > 2 * k ) return false ; } } return true ; }

def checkCount ( arr , n , k ) : for i in range ( n ) : count = 0 for j in range ( n ) : if arr [ j ] == arr [ i ] : count += 1 if count > 2 * k : return False return True

def checkCount ( arr , n , k ) : count = 0 for i in range ( 0 , n , k ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count > 2 * k ) : return false return true

def checkCount ( arr , n , k ) : count = 0 for i in range ( n ) : count = 0 for j in range ( n ) : if ( arr [ j ] == arr [ i ] ) : count += 1 if ( count > 2 * k ) : return False return True

59.64
58.89
72.49
59.57
public static int sumoflength ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }

def sumoflength ( arr , n ) : s = [ ] j = 0 ans = 0 for i in range ( n ) : while ( j < n and ( arr [ j ] not in s ) ) : s . append ( arr [ j ] ) j += 1 ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 s . remove ( arr [ i ] ) return ans

def sumoflength ( arr , n ) : s = set ( ) for i in range ( n ) : while ( j < n && ! s . contains ( arr [ j ] ) ) : s . add ( arr [ j ] ) j += 1 ans += ( j - i ) * ( j - i + 1 ) ) / 2 s . remove ( arr [ i ] ) ans += ( j - i ) * ( j - i + 1 ) s . remove ( arr [ j ] ) return ans

def sumoflength ( arr , n ) : s = list ( ) for i in range ( n ) : while j < n and not s . contains ( arr [ j ] ) : s . add ( arr [ i ] ) j += 1 ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 s . remove ( arr [ i ] ) return ans

59.65
46.87
81.14
62.52
static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }

def findMaxAverage ( arr , n , k ) : if k > n : return - 1 csum = [ 0 ] * n csum [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : csum [ i ] = csum [ i - 1 ] + arr [ i ] max_sum = csum [ k - 1 ] max_end = k - 1 for i in range ( k , n ) : curr_sum = csum [ i ] - csum [ i - k ] if curr_sum > max_sum : max_sum = curr_sum max_end = i return max_end - k + 1

def findMaxAverage ( arr , n , k ) : csum = [ 0 for k in range ( n ) ] for i in range ( k ) : csum [ i ] = arr [ i ] csum [ k - 1 ] = csum [ i - 1 ] + arr [ i ] max_sum = 0 for i in range ( k , n ) : if ( curr_sum > max_sum ) : max_sum = curr_sum max_end = i if ( curr_sum > max_sum ) : max_sum = curr_sum max_end = k - 1 if ( max_sum > max_sum ) : max_sum = curr_sum max_end = i return max_end - k + 1

def findMaxAverage ( arr , n , k ) : csum = [ 0 for k in range ( n ) ] csum [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : csum [ i ] = csum [ i - 1 ] + arr [ i ] max_sum = csum [ k - 1 ] , max_end = k - 1 for i in range ( k ) : curr_sum = csum [ i ] - csum [ i - k ] if ( curr_sum > max_sum ) : max_sum = curr_sum max_end = i return max_end - k + 1

59.66
45.39
70.08
48.54
static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }

def LCSubStr ( X , Y , m , n ) : LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] result = 0 for i in range ( m + 1 ) : for j in range ( n + 1 ) : if ( i == 0 or j == 0 ) : LCSuff [ i ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 result = max ( result , LCSuff [ i ] [ j ] ) else : LCSuff [ i ] [ j ] = 0 return result

def LCSubStr ( X , Y , m , n ) : LCStuff = [ 0 for i in range ( m + 1 , n + 1 ) ] for j in range ( n + 1 ) : if ( X [ i ] == Y [ j - 1 ] ) : LCStuff [ i ] [ j ] = 1 else : LCStuff [ i ] [ j ] = 0 LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] [ j - 1 ] [ j - 1 ] + 1 result = max ( result , LCStuff [ i ] [ j ] ) return result

def LCSubStr ( X , Y , m , n ) : LCStuff [ ] [ ] = [ 0 for i in range ( m + 1 , n + 1 ) ] result = 0 for i in range ( m + 1 , n ) : if ( i == 0 or j == 0 ) : LCStuff [ i ] [ j ] = 0 else : if ( X [ i - 1 ] == Y [ j - 1 ] ) : LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 result = Integer . max ( result , LCStuff [ i ] [ j ] ) else : LCStuff [ i ] [ j ] = 0 return result

59.84
36.56
65.59
43.35
boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { for ( int i = 0 ; i < set1 . length ; i ++ ) { for ( int j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }

def areDisjoint ( set1 , set2 , m , n ) : for i in range ( 0 , m ) : for j in range ( 0 , n ) : if ( set1 [ i ] == set2 [ j ] ) : return False return True

def aredisjoint ( set1 , set2 ) : for i in range ( set1 . length ) : for j in range ( set2 . length ) : if ( set1 [ i ] == set2 [ j ] ) : return false } return true

def aredisjoint ( set1 , set2 ) : for i in range ( set1 . length ) : for j in range ( set2 . length ) : if ( set1 [ i ] == set2 [ j ] ) : return False return True

59.91
44.18
62.43
49.75
static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = "" ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } String reverse = "" ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) { reverse = reverse + res . charAt ( k ) ; } return reverse ; }

def longestRepeatedSubSeq ( str ) : n = len ( str ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) res = '' i = n j = n while ( i > 0 and j > 0 ) : if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : res += str [ i - 1 ] i -= 1 j -= 1 elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : i -= 1 else : j -= 1 res = '' . join ( reversed ( res ) ) return res

def longestRepeatedSubSeq ( str ) : dp = [ 0 for i in range ( n + 1 , - 1 , - 1 ) ] for j in range ( n + 1 , - 1 ) : if ( str [ i ] [ j ] == str [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = max ( dp [ i ] [ j ] = max ( dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] for i in range ( n + 1 , - 1 ) : if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] + 1 ) : res = res + str [ i - 1 ] j -= 1 else : res = reverse + res [ k ] return res

def longestRepeatedSubSeq ( str ) : dp = [ 0 for i in range ( n ) ] for i in range ( n ) : dp [ i ] [ j ] = 0 for j in range ( 1 , n ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) i -= 1 else : j -= 1 while i > 0 and j > 0 : if dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 : res = res + str [ i - 1 ] i -= 1 j -= 1 else : j -= 1 return res

59.91
55.72
64.1
67.38
static int findRepeating ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) return arr [ i ] ; s . add ( arr [ i ] ) ; } return - 1 ; }

def findRepeating ( arr , n ) : s = set ( ) for i in range ( n ) : if arr [ i ] in s : return arr [ i ] s . add ( arr [ i ] ) rteurn - 1

def findRepeating ( arr , n ) : s = new HashSet < Integer > ( ) for i in range ( 0 , n ) : if ( s . contains ( arr [ i ] ) ) : return arr [ i ] s . add ( arr [ i ] ) return - 1

def findRepeating ( arr , n ) : s = list ( ) for i in range ( n ) : if ( s . contains ( arr [ i ] ) ) : return arr [ i ] , s [ i ] s . add ( arr [ i ] ) return - 1

59.93
52.97
93.1
91.21
static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ Math . abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; break ; } arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; } return Math . abs ( missingElement ) ; }

def findRepeating ( arr , n ) : missingElement = 0 for i in range ( 0 , n ) : element = arr [ abs ( arr [ i ] ) ] if ( element < 0 ) : missingElement = arr [ i ] break arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] return abs ( missingElement )

def findRepeating ( arr , n ) : missingElement = 0 for i in range ( n ) : element = arr [ Math . abs ( arr [ i ] ) ] missingElement = arr [ i ] if ( element < 0 ) : missingElement = arr [ i ] break if ( missingElement == 0 ) : return - 1

def findRepeating ( arr , n ) : missingElement = 0 for i in range ( n ) : element = arr [ abs ( arr [ i ] ) ] if ( element < 0 ) : missingElement = arr [ i ] break arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] return Math . abs ( missingElement )

59.94
51.88
63.65
49.87
void find3largest ( int [ ] arr ) { Arrays . sort ( arr ) ; int n = arr . length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } }

def find3largest ( arr , n ) : arr = sorted ( arr ) check = 0 count = 1 for i in range ( 1 , n + 1 ) : if ( count < 4 ) : if ( check != arr [ n - i ] ) : print ( arr [ n - i ] , end = "" ) check = arr [ n - i ] count += 1 else : break

def find3largest ( arr ) : arr . sort ( reverse = True ) count = 1 for i in range ( 1 , n ) : if ( check != arr [ n - i ] ) : check = arr [ n - i ] count += 1 elif ( count < 4 ) : if ( check != arr [ n - i ] ) : print ( arr [ n - i ] + " " ) ; check = arr [ n - i ] count += 1 else : break

def find3largest ( arr ) : n = arr . length check = 0 count = 1 for i in range ( 1 , n ) : if ( count < 4 ) : if ( check != arr [ n - i ] ) : check = arr [ n - i ] count += 1 else : break return check

59.98
48.07
69.79
56.79
static int calcMaxValue ( String str ) { int res = str . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' ) ; else res *= ( str . charAt ( i ) - '0' ) ; } return res ; }

def calcMaxValue ( str ) : res = ord ( str [ 0 ] ) - 48 for i in range ( 1 , len ( str ) ) : if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : res += ord ( str [ i ] ) - 48 else : res *= ord ( str [ i ] ) - 48 return res

def calcMaxValue ( str ) : res = str [ 0 ] for i in range ( 1 , len ( str ) ) : if ( str [ i ] == '0' ) : res += ( str [ i ] - '0' ) elif ( str [ i ] == '1' ) : res *= ( str [ i ] - '0' ) return res

def calcMaxValue ( str ) : res = str . charAt ( 0 ) for i in range ( 1 , len ( str ) ) : if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : res += ( str [ i ] - '0' ) else : res *= ( str [ i ] - '0' ) return res

59.99
45.48
59.81
58.14
static void findTriplets ( int [ ] arr , int n ) { boolean found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { System . out . print ( arr [ i ] ) ; System . out . print ( " " ) ; System . out . print ( arr [ j ] ) ; System . out . print ( " " ) ; System . out . print ( arr [ k ] ) ; System . out . print ( "\n" ) ; found = true ; } } } } if ( found == false ) System . out . println ( " not exist " ) ; }

def findTriplets ( arr , n ) : found = True for i in range ( 0 , n - 2 ) : for j in range ( i + 1 , n - 1 ) : for k in range ( j + 1 , n ) : if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : print ( arr [ i ] , arr [ j ] , arr [ k ] ) found = True if ( found == False ) : print ( "notexist" )

def findTriplets ( arr , n ) : found = false for i in range ( 0 , n - 2 , - 1 ) : for j in range ( 0 , n - 1 , - 1 ) : if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : found = true print ( arr [ i ] , j , k ) else : print ( arr [ i ] , j , k ) found = true print ( "\n" )

def findTriplets ( arr , n ) : found = True for i in range ( n ) : for j in range ( i + 1 , n - 2 , - 1 ) : for k in range ( j + 1 , n ) : if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : System . out . print ( arr [ i ] ) System . out . print ( " " ) System . out . print ( arr [ j ] ) System . out . print ( " " ) System . out . print ( arr [ k ] ) found = True if found == false : print ( " not exist " )

60.04
56.81
55.08
51.51
static int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) == 0 ) result |= x ; } return result ; }

def getSingle ( arr , n ) : result = 0 for i in range ( 0 , INT_SIZE ) : sm = 0 x = ( 1 << i ) for j in range ( 0 , n ) : if ( arr [ j ] & x ) : sm = sm + 1 if ( sm % 3 ) : result = result | x return result

def getSingle ( arr , n ) : result = 0 for i in range ( INT_SIZE , n ) : sum = 0 x = ( 1 << i ) for j in range ( n ) : if ( arr [ j ] & x ) == 0 : sum += ( arr [ j ] & x ) == 0 : result |= x i -= 1 return result

def getSingle ( arr , n ) : result = 0 sum = 0 x = 0 for i in range ( INT_SIZE ) : sum = 0 x = ( 1 << i ) for j in range ( n ) : if ( arr [ j ] & x ) == 0 : sum += ( ( arr [ j ] & x ) ) if ( sum % 3 ) == 0 : result |= x return result

60.05
65.66
34.14
37.87
static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }

def search ( arr , l , h , key ) : if l > h : return - 1 mid = ( l + h ) // 2 if arr [ mid ] == key : return mid if arr [ l ] <= arr [ mid ] : if key >= arr [ l ] and key <= arr [ mid ] : return search ( arr , l , mid - 1 , key ) return search ( arr , mid + 1 , h , key ) if key >= arr [ mid ] and key <= arr [ h ] : return search ( a , mid + 1 , h , key ) return search ( arr , l , mid - 1 , key )

def search ( arr , l , h ) : if ( l == h ) : return - 1 mid = ( l + h ) // 2 if arr [ l ] <= arr [ mid ] : if ( key >= arr [ l ] and key <= arr [ mid ] ) : return search ( arr , l , mid - 1 , key ) return search ( arr , mid + 1 , h , key ) return search ( arr , l , mid - 1 , key )

def search ( arr , l , h , key ) : if arr [ l ] <= arr [ mid ] : if key >= arr [ l ] and key <= arr [ mid ] : return search ( arr , l , mid - 1 , key ) return search ( arr , mid + 1 , h , key )

60.11
49.25
68.99
65.62
static int longestSubsequenceCommonSegment ( int k , String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }

def longestSubsequenceCommonSegment ( k , s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , m + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 if ( cnt [ i ] [ j ] >= k ) : for a in range ( k , cnt [ i ] [ j ] + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) return lcs [ n ] [ m ]

def longestSubsequenceCommonSegment ( k , s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) lcs = [ INT_MAX for i in range ( 1 , n ) ] cnt = [ INT_MAX for j in range ( 1 , m ) : if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] + 1 ) if ( cnt [ i ] [ j ] >= k ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) return lcs [ n ] [ m ] [ j ]

def longestSubsequenceCommonSegment ( k , s1 , s2 ) : n = s1 . length m = s2 . length lcs [ ] = [ 0 for i in range ( 1 , n ) ] cnt = [ 0 for i in range ( 1 , n ) ] for i in range ( 1 , n ) : for j in range ( 1 , m ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) : cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 if cnt [ i ] [ j ] >= k : for a in range ( k , cnt [ i ] [ j ] ) : lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) return lcs [ n ] [ m ]

60.14
55.75
63.47
61.34
static void printAllAPTriplets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }

def printAllAPTriplets ( arr , n ) : s = [ ] for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : diff = arr [ j ] - arr [ i ] if ( ( arr [ i ] - diff ) in arr ) : print ( "{}{}{}" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = "\n" ) s . append ( arr [ i ] )

def printAllAPTriplets ( arr , n ) : s = new ArrayList < Integer > ( ) for i in range ( 0 , n - 1 , - 1 ) : for j in range ( i + 1 , n ) : if ( arr [ i ] - diff ) : print ( arr [ i ] - diff + " " + arr [ j ] ) s . add ( arr [ i ] ) if ( exists ) : print ( arr [ i ] - diff )

def printAllAPTriplets ( arr , n ) : s = list ( ) for i in range ( n ) : for j in range ( i + 1 , n ) : diff = arr [ j ] - arr [ i ] exists = s . contains ( arr [ i ] - diff ) if ( exists ) : print ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] ) s . add ( arr [ i ] )

60.15
53.87
52.65
43.43
public static void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Stack < Integer > stk = new Stack < Integer > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { System . out . print ( stk . peek ( ) + " " ) ; stk . pop ( ) ; } }

def antiSpiralTraversal ( m , n , a ) : k = 0 l = 0 stk = [ ] while ( k <= m and l <= n ) : for i in range ( l , n + 1 ) : stk . append ( a [ k ] [ i ] ) k += 1 for i in range ( k , m + 1 ) : stk . append ( a [ i ] [ n ] ) n -= 1 if ( k <= m ) : for i in range ( n , l - 1 , - 1 ) : stk . append ( a [ m ] [ i ] ) m -= 1 if ( l <= n ) : for i in range ( m , k - 1 , - 1 ) : stk . append ( a [ i ] [ l ] ) l += 1 while len ( stk ) != 0 : print ( str ( stk [ - 1 ] ) , end = "" ) stk . pop ( )

def antiSpiralTraversal ( m , n , a ) : stk = list ( ) for k in range ( m , n ) : for i in range ( l , n ) : stk . append ( a [ k ] [ i ] ) k += 1 if ( k <= m ) : for i in range ( n , k ) : stk . push ( a [ k ] [ i ] ) n -= 1 if ( l <= n ) : for i in stk . push ( a [ i ] [ l ] ) : stk . push ( a [ m ] [ n ] ) : stk . append ( a [ i ] [ l ] ) l += 1 if ( k <= m ) : for ( i = n ; i >= k : stk . push ( a [ m ] [ i ] ) m -= 1 stk . pop ( )

def antiSpiralTraversal ( m , n , a ) : stk = list ( ) while k <= m and l <= n : for i in range ( k , m , n ) : stk . append ( a [ k ] [ i ] ) k ++ for i in range ( k , m , n ) : stk . push ( a [ i ] [ n ] ) n -- if k <= m : for i in range ( n , l ) : stk . push ( a [ i ] [ n ] ) m -- if l <= n : for i in range ( m , k , l ) : stk . push ( a [ i ] [ l ] ) l += 1 while not stk . empty ( ) : print ( stk . peek ( ) + " " ) stk . pop ( )

60.18
59.31
66.31
56.74
static void findPair ( int [ ] arr , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + " " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) System . out . println ( "Not exist" ) ; }

def findPair ( arr , n ) : found = False for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : for k in range ( 0 , n ) : if ( arr [ i ] + arr [ j ] == arr [ k ] ) : print ( arr [ i ] , arr [ j ] ) found = True if ( found == False ) : print ( "Notexist" )

def findPair ( arr , n ) : found = false for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] + arr [ j ] == arr [ k ] ) : found = true break if ( found == false ) : print ( "Not exist" ) return

def findPair ( arr , n ) : found = False for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] + arr [ j ] == arr [ k ] ) : found = True if ( arr [ i ] + arr [ j ] == arr [ k ] ) : print ( arr [ i ] + " " + arr [ j ] ) found = True if found == false : print ( "Not exist" )

60.19
49.07
59.0
48.9
static int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }

def countPS ( str ) : N = len ( str ) cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] for i in range ( N ) : cps [ i ] [ i ] = 1 for L in range ( 2 , N + 1 ) : for i in range ( N ) : k = L + i - 1 if ( k < N ) : if ( str [ i ] == str [ k ] ) : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) else : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) return cps [ 0 ] [ N - 1 ]

def countPS ( str ) : N = len ( str ) cps = [ N + 1 ] [ N + 1 ] for L in range ( 2 , N ) : for i in range ( 2 , N ) : if ( str [ i ] == str [ k ] ) : cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 else : cps [ i ] [ k ] = cps [ i + 1 ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k - 1 ] return cps [ 0 ] [ N - 1 ]

def countPS ( str ) : cps = [ 1 for i in range ( N ) ] for L in range ( 2 , L , - 1 ) : for i in range ( N ) : if ( str [ i ] == str [ k ] ) : cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 else : cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k - 1 ] - cps [ i + 1 ] [ k - 1 ] return cps [ 0 ] [ N - 1 ]

60.29
52.64
88.2
73.47
static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }

def minInsertionStepToSortArray ( arr , N ) : lis = [ 0 ] * N for i in range ( N ) : lis [ i ] = 1 for i in range ( 1 , N ) : for j in range ( i ) : if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 max = 0 for i in range ( N ) : if ( max < lis [ i ] ) : max = lis [ i ] return ( N - max )

def minInsertionStepToSortArray ( arr , N ) : lis = [ 1 for i in range ( N ) ] for i in range ( 1 , N ) : if ( arr [ i ] >= arr [ j ] ) : lis [ i ] = 1 else : max = 0 for i in range ( 1 , N ) : if ( max < lis [ i ] ) : max = lis [ i ] return ( N - max )

def minInsertionStepToSortArray ( arr , N ) : lis = [ 1 for i in range ( N ) ] for i in range ( 1 , N ) : lis [ i ] = 1 for i in range ( 1 , N ) : if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 max = 0 for i in range ( 0 , N ) : if ( max < lis [ i ] ) : max = lis [ i ] return ( N - max )

60.32
43.96
72.1
57.34
static int countFibs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) result ++ ; f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }

def countFibs ( low , high ) : f1 , f2 , f3 = 0 , 1 , 1 result = 0 while ( f1 <= high ) : if ( f1 >= low ) : result += 1 f1 = f2 f2 = f3 f3 = f1 + f2 return result

def countFibs ( low , high ) : f1 = low f2 = 1 f3 = 1 f1 += f2 result = 0 for f1 in range ( low , high ) : if ( f1 >= low ) : result ++ f1 = f2 f2 = f3 f3 = f1 + f2 return result

def countFibs ( low , high ) : f1 = 0 f2 = 1 f3 = 1 result = 0 while f1 <= high : if ( f1 >= low ) : result += 1 f1 = f2 f2 = f3 f3 = f1 + f2 return result

60.34
50.57
64.47
45.5
static int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }

def minCoins ( coins , m , V ) : if ( V == 0 ) : return 0 res = sys . maxsize for i in range ( 0 , m ) : if ( coins [ i ] <= V ) : sub_res = minCoins ( coins , m , V - coins [ i ] ) if ( sub_res != sys . maxsize and sub_res + 1 < res ) : res = sub_res + 1 return res

def minCoins ( coins , m , V ) : if ( V == 0 ) : return 0 res = float ( 'inf' ) for i in range ( m ) : if ( coins [ i ] <= V ) : res = sub_res + 1 else : res = float ( 'inf' ) for i in range ( m ) : if ( coins [ i ] <= V ) : res = sub_res + 1 return res

def minCoins ( coins , m , V ) : res = 0 for i in range ( m ) : if coins [ i ] <= V : sub_res = minCoins ( coins , m , V - coins [ i ] ) if ( sub_res != float ( 'inf' ) and sub_res + 1 < res ) : res = sub_res + 1 return res

60.34
46.95
75.41
64.41
static void pairSum ( int mat [ ] [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( mat [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { System . out . print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } } } }

def pairSum ( mat , n , sum ) : for i in range ( n ) : mat [ i ] . sort ( ) for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : left = 0 right = n - 1 while ( left < n and right >= 0 ) : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : print ( "(" , mat [ i ] [ left ] , "," , mat [ j ] [ right ] , ")," , end = "" ) left += 1 right -= 1 else : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : left += 1 else : right -= 1

def pairSum ( mat , n , sum ) : for i in range ( n ) : sort ( mat [ i ] ) for j in range ( i + 1 , n ) : if ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum : print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) left += 1 right -= 1 elif ( mat [ i ] [ left ] [ left ] + mat [ j ] [ right ] ) < sum ) : left += 1 else : print ( "(" + mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : left += 1 else : if ( mat [ i ] [ left ] + mat [ j ] [ right ] )

def pairSum ( mat , n , sum ) : mat . sort ( mat ) for i in range ( n ) : for j in range ( i + 1 , n ) : left = 0 , right = n - 1 while left < n and right >= 0 : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) left += 1 right -= 1 else : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : left += 1 else : right -= 1 print ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) )

60.37
50.92
66.46
51.95
static int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }

def minCost ( coin , n , k ) : coin . sort ( ) coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) ans = 0 for i in range ( coins_needed - 1 + 1 ) : ans += coin [ i ] return ans

def minCost ( coin , n , k ) : coin . sort ( reverse = True ) ans = 0 for i in range ( 0 , coins_needed ) : ans += coin [ i ] if ( i <= coins_needed - 1 ) : ans += coin [ i ] return ans

def minCost ( coin , n , k ) : coins_needed = ( 1.0 * n / ( k + 1 ) ) ans = 0 for i in range ( 0 , coins_needed - 1 , - 1 ) : ans += coin [ i ] return ans

60.39
41.23
71.96
55.87
public static int [ ] fix ( int [ ] A ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ] ; while ( A [ x ] != - 1 && A [ x ] != x ) { int y = A [ x ] ; A [ x ] = x ; x = y ; } A [ x ] = x ; if ( A [ i ] != i ) { A [ i ] = - 1 ; } } } return A ; }

def fix ( A , len ) : for i in range ( 0 , len ) : if ( A [ i ] != - 1 and A [ i ] != i ) : x = A [ i ] while ( A [ x ] != - 1 and A [ x ] != x ) : y = A [ x ] A [ x ] = x x = y A [ x ] = x if ( A [ i ] != i ) : A [ i ] = - 1

def fix ( A ) : A . sort ( reverse = True ) for i in range ( A . length ) : if ( A [ i ] != - 1 ) : A [ i ] = - 1 if ( A [ i ] != i ) : A [ i ] = - 1 else : x = A [ i ] if ( A [ x ] != - 1 ) : A [ x ] = x if ( A [ i ] != i ) : A [ i ] = y

def fix ( A ) : A . sort ( reverse = True ) return A for i in range ( len ( A ) ) : if ( A [ i ] != - 1 and A [ i ] != i ) : if ( A [ i ] != - 1 ) : x = A [ i ] while ( A [ x ] != - 1 and A [ x ] != x ) : y = A [ x ] A [ x ] = x x = y if ( A [ i ] != i ) : A [ i ] = - 1 return A

60.42
69.7
74.95
66.57
static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }

def sumBetweenTwoKth ( arr , n , k1 , k2 ) : arr . sort ( ) result = 0 for i in range ( k1 , k2 - 1 ) : result += arr [ i ] return result

def sumBetweenTwoKth ( arr , k1 , k2 ) : arr . sort ( reverse = True ) result = 0 for i in range ( k1 , k2 - 1 ) : result += arr [ i ] for i in range ( k1 , k2 - 1 ) : result += arr [ i ] return result

def sumBetweenTwoKth ( arr , k1 , k2 ) : result = 0 for i in range ( k1 , k2 - 1 ) : result += arr [ i ] return result

60.43
54.42
75.91
74.77
static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }

def findVolume ( l , b , h ) : return ( ( l * b * h ) / 2 )

def findVolume ( l , b , h ) : volume = ( l * b ) / 2

def findVolume ( l , b , h ) : volume = ( l * b * h ) / 2 return volume

60.51
47.13
96.31
76.47
static int countStrings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }

def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return a [ n - 1 ] + b [ n - 1 ]

def countStrings ( n ) : a = [ 0 for k in range ( n ) ] b = [ 0 for k in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 a [ n ] = a [ n - 1 ] + b [ n - 1 ] return a [ n - 1 ] + b [ n - 1 ]

def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( 1 , n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return a [ n - 1 ] + b [ n - 1 ]

60.62
48.34
88.23
70.31
static int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }

def countDer ( n ) : der = [ 0 for i in range ( n + 1 ) ] der [ 0 ] = 1 der [ 1 ] = 0 der [ 2 ] = 1 for i in range ( 3 , n + 1 ) : der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) return der [ n ]

def countDer ( n ) : der = [ 0 for k in range ( n ) ] for i in range ( 3 , n ) : der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) return der [ n ]

def countDer ( n ) : der = [ 1 for i in range ( n ) ] der [ 0 ] = 1 der [ 1 ] = 0 der [ 2 ] = 1 for i in range ( 3 , n ) : der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) return der [ n ]

60.65
46.83
100.0
100.0
public static int kthgroupsum ( int k ) { return k * k * k ; }

def kthgroupsum ( k ) : return k * k * k

def kthgroupsum ( k ) : return k

def kthgroupsum ( k ) : return k * k * k

60.65
62.08
88.66
82.46
static int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }

def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24

def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 )

def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 * n + 1 ) / 24

60.67
49.25
75.59
63.49
static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Integer . MAX_VALUE ; }

def ksmallest ( arr , n , k ) : b = [ 0 ] * MAX for i in range ( n ) : b [ arr [ i ] ] = 1 for j in range ( 1 , MAX ) : if ( b [ j ] != 1 ) : k -= 1 if ( k is not 1 ) : return j

def ksmallest ( arr , n , k ) : b = [ 0 for i in range ( n ) ] for i in range ( n ) : b [ arr [ i ] ] = 1 if ( b [ arr [ i ] ] != 1 ) : k -= 1 return j

def ksmallest ( arr , n , k ) : b = [ INT_MAX for i in range ( n ) ] for i in range ( n ) : b [ arr [ i ] ] = 1 for j in range ( 1 , MAX ) : if ( b [ j ] != 1 ) : k -- if ( k != 1 ) : return j return INT_MAX

60.68
54.69
66.26
54.61
public static void prefixSum2D ( int a [ ] [ ] ) { int R = a . length ; int C = a [ 0 ] . length ; int psa [ ] [ ] = new int [ R ] [ C ] ; psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ; for ( int i = 1 ; i < C ; i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ; for ( int i = 1 ; i < R ; i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( psa [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

def prefixSum2D ( a ) : global C , R psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] for i in range ( 1 , C ) : psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) for i in range ( 0 , R ) : psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) for i in range ( 1 , R ) : for j in range ( 1 , C ) : psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) for i in range ( 0 , R ) : for j in range ( 0 , C ) : print ( psa [ i ] [ j ] , end = "" ) print ( )

def prefixSum2D ( a , out ) : psa = [ 0 for k in range ( R , C ) ] psa [ 0 ] = [ 0 for k in range ( R , C ) ] psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] for i in range ( 1 , R , C ) : psa [ i ] [ i ] = psa [ i - 1 ] [ i ] + psa [ i ] [ j - 1 ] [ j ] [ j ] [ j ] [ 0 ] = psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] print ( " " ) for j in range ( 0 , R , C ) : print ( psa [ i ] [ j ] + " " ) for i in range ( 1 , R ) : print ( psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + a [ i ] [ j ]

def prefixSum2D ( a , psa ) : psa [ ] [ ] = [ 0 for k in range ( R , C ) ] psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] for i in range ( 1 , R ) : psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] for i in range ( 1 , R ) : psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + psa [ i ] [ i - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] for i in range ( 1 , R ) : for j in range ( 1 , C ) : psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ]

60.83
53.89
80.59
71.2
static int getNumStrictMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; }

def getNumStrictMonotone ( ln ) : DP = [ [ 0 ] * DP_s for _ in range ( ln ) ] for i in range ( DP_s ) : DP [ 0 ] [ i ] = i + 1 for i in range ( 1 , ln ) : for j in range ( 1 , DP_s ) : DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] return DP [ ln - 1 ] [ DP_s - 1 ]

def getNumStrictMonotone ( len ) : DP = [ 0 for i in range ( len ) ] DP_s = len - 1 DP = [ 0 for i in range ( len ) ] for j in range ( 1 , len , DP_s ) : DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] return DP [ len - 1 ] [ DP_s - 1 ]

def getNumStrictMonotone ( len ) : DP = [ 0 for i in range ( len ) ] for i in range ( 0 , len , DP_s ) : DP [ 0 ] [ i ] = i + 1 for i in range ( 1 , len ) : for j in range ( 1 , DP_s ) : DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] return DP [ len - 1 ] [ DP_s - 1 ]

60.83
46.93
69.72
53.52
static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }

def minStepToDeleteString ( str ) : N = len ( str ) dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] for l in range ( 1 , N + 1 ) : i = 0 j = l - 1 while j < N : if ( l == 1 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] if ( str [ i ] == str [ i + 1 ] ) : dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) for K in range ( i + 2 , j + 1 ) : if ( str [ i ] == str [ K ] ) : dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) i += 1 j += 1 return dp [ 0 ] [ N - 1 ]

def minStepToDeleteString ( str ) : dp = [ INT_MAX for i in range ( N + 1 , N + 1 ) ] for j in range ( 1 , N ) : if ( str [ i ] == str . charAt ( i + 1 ) ) : dp [ i ] [ j ] = min ( 1 , dp [ i + 1 ] [ j ] ) else : dp [ i ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i + 2 ] [ j ] ) if ( str [ i ] == str [ i + 1 ] ) : dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) return dp [ 0 ] [ N - 1 ] [ N - 1 ] [ j ]

def minStepToDeleteString ( str ) : dp = [ 0 for i in range ( N ) ] for j in range ( 1 , N ) : if ( len == 1 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] if ( str [ i ] == str [ i + 1 ] ) : dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) for K in i + 2 : if ( str [ i ] == str [ K ] ) : dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) return dp [ 0 ] [ N - 1 ]

60.84
51.92
71.07
60.94
public static int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }

def nobleInteger ( arr ) : arr . sort ( ) n = len ( arr ) for i in range ( n - 1 ) : if arr [ i ] == arr [ i + 1 ] : continue if arr [ i ] == n - i - 1 : return arr [ i ] if arr [ n - 1 ] == 0 : return arr [ n - 1 ] return - 1

def nobleInteger ( arr ) : arr . sort ( reverse = True ) n = arr . length for i in range ( 0 , n ) : if ( arr [ i ] == arr [ i + 1 ] ) : return arr [ i ] if ( arr [ i ] == n - i - 1 ) : return arr [ n - 1 ]

def nobleInteger ( arr ) : arr . sort ( reverse = True ) n = arr . length for i in range ( 0 , n - 1 , - 1 ) : if ( arr [ i ] == arr [ i + 1 ] ) : continue if ( arr [ i ] == n - i - 1 ) : return arr [ i ] if arr [ n - 1 ] == 0 : return arr [ n - 1 ] return - 1

60.88
50.13
72.86
57.22
static int minCost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }

def minCost ( a , n , k ) : dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : for m in range ( i - 1 , - 1 , - 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) return dp [ n ] [ k ]

def minCost ( a , n , k ) : dp = [ 0 for i in range ( n + 1 , k + 1 ) ] for j in range ( 1 , n , k ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) return dp [ n ] [ k ]

def minCost ( a , n , k ) : dp = [ inf for i in range ( n ) ] for k in range ( n + 1 , k + 1 ) : dp [ i ] [ k ] = inf for i in range ( 1 , n ) : for j in range ( k ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) return dp [ n ] [ k ]

60.89
51.18
76.23
59.67
static int lps ( String s ) { int n = s . length ( ) ; int a [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int back_up = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) a [ j ] = 1 ; else if ( s . charAt ( i ) == s . charAt ( j ) ) { int temp = a [ j ] ; a [ j ] = back_up + 2 ; back_up = temp ; } else { back_up = a [ j ] ; a [ j ] = Math . max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }

def lps ( s ) : n = len ( s ) a = [ 0 ] * n for i in range ( n - 1 , - 1 , - 1 ) : back_up = 0 for j in range ( i , n ) : if j == i : a [ j ] = 1 elif s [ i ] == s [ j ] : temp = a [ j ] a [ j ] = back_up + 2 back_up = temp else : back_up = a [ j ] a [ j ] = max ( a [ j - 1 ] , a [ j ] ) return a [ n - 1 ]

def lps ( s ) : n = len ( s ) a = [ 0 for i in range ( n ) ] for j in range ( i + 1 , n ) : if ( s [ i ] == s [ j ] ) : a [ j ] = 1 back_up = a [ j ] if ( j == i ) : a [ j ] = back_up + 2 else : back_up = a [ j ] if ( j == i ) : a [ j ] = back_up = a [ j ] if ( s [ i ] == s [ j ] ) : a [ j ] = max ( a [ j - 1 ] , a [ j ] ) return a [ n - 1 ]

def lps ( s ) : a = [ 1 for i in range ( n ) ] for i in range ( n ) : back_up = 0 for j in range ( i , n ) : if ( j == i ) : a [ j ] = 1 else : if ( s [ i ] == s [ j ] ) : temp = a [ j ] a [ j ] = back_up + 2 back_up = temp else : back_up = a [ j ] a [ j ] = max ( a [ j - 1 ] , a [ j ] ) return a [ n - 1 ]

60.9
36.88
84.39
52.89
static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }

def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : for i in range ( 0 , n1 ) : for j in range ( 0 , n2 ) : for k in range ( 0 , n3 ) : if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : return True return False

def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 ) : for i in range ( 0 , n1 , n2 , n3 ) : if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : return true

def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : for i in range ( 0 , n1 , n2 , n3 ) : for j in range ( 0 , n2 , n3 ) : if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : return True return False

60.98
52.85
63.95
56.3
static int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }

def findMaxSum ( arr , n ) : res = - sys . maxsize - 1 for i in range ( n ) : prefix_sum = arr [ i ] for j in range ( i ) : prefix_sum += arr [ j ] suffix_sum = arr [ i ] j = n - 1 while ( j > i ) : suffix_sum += arr [ j ] j -= 1 if ( prefix_sum == suffix_sum ) : res = max ( res , prefix_sum ) return res

def findMaxSum ( arr , n ) : res = Integer . MIN_VALUE for i in range ( 0 , n ) : prefix_sum = arr [ i ] for j in range ( 0 , n - 1 ) : prefix_sum += arr [ j ] suffix_sum = arr [ i ] if ( prefix_sum == suffix_sum ) : res = max ( res , prefix_sum ) return res

def findMaxSum ( arr , n ) : res = INT_MIN_VALUE for i in range ( n ) : prefix_sum = arr [ i ] for j in range ( i , n ) : prefix_sum += arr [ j ] j = n - 1 if j > i : suffix_sum += arr [ j ] if prefix_sum == suffix_sum : res = max ( res , prefix_sum ) return res

61.0
78.2
83.76
82.84
static void squareRoot ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) { System . out . println ( "Square " + "root is " + x ) ; return ; } } System . out . println ( "Square root " + "doesn't exist" ) ; }

def squareRoot ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( ( x * x ) % p == n ) : print ( "Squarerootis" , x ) return print ( "Squarerootdoesn'texist" )

def squareRoot ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( ( x * x ) % p == n ) : print ( "Square root " + "is " + x ) return print ( "Square root " + "doesn't exist" ) return print ( "Square root " + "doesn't exist" ) return

def squareRoot ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( ( x * x ) % p == n ) : print ( "Square root is " + x ) return

61.08
49.24
66.24
63.68
public static int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }

def findLength ( string , n ) : current_sum = 0 max_sum = 0 for i in range ( n ) : current_sum += ( 1 if string [ i ] == '0' else - 1 ) if current_sum < 0 : current_sum = 0 max_sum = max ( current_sum , max_sum ) return max_sum if max_sum else 0

def findLength ( str , n ) : current_sum = 0 max_sum = 0 for i in range ( n ) : current_sum += ( str [ i ] == '0' ? 1 : - 1 ) max_sum = max ( current_sum , max_sum ) return max_sum == 0 ? - 1 : max_sum

def findLength ( str , n ) : current_sum = 0 max_sum = 0 for i in range ( n ) : current_sum += ( str [ i ] == '0' ? 1 : - 1 ) if ( current_sum < 0 ) : current_sum = 0 max_sum = max ( current_sum , max_sum ) return max_sum == 0 ? - 1 : max_sum

61.15
40.59
45.19
27.17
static int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }

def linearSearch ( arr , n ) : for i in range ( n ) : if arr [ i ] is i : return i return - 1

def linearSearch ( arr , n ) : i = 0 for i in range ( n ) : if ( arr [ i ] == i ) : return i

def linearSearch ( arr , n ) : if len ( arr ) == n : return i return - 1

61.16
52.39
46.04
44.46
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; } else { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }

def KnapSack ( val , wt , n , W ) : mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ] i = 0 while i < n : j = 0 if i % 2 == 0 : while j < W : j += 1 if wt [ i ] <= j : mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) else : mat [ 1 ] [ j ] = mat [ 0 ] [ j ] else : while j < W : j += 1 if wt [ i ] <= j : mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) else : mat [ 0 ] [ j ] = mat [ 1 ] [ j ] i += 1 if n % 2 == 0 : return mat [ 0 ] [ W ] else : return mat [ 1 ] [ W ]

def KnapSack ( val , wt , n , W ) : mat = [ 0 for i in range ( n ) ] for i in range ( n ) : while ( ++ j <= W ) : if ( wt [ i ] <= j ) : mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) else : mat [ 0 ] [ j ] = mat [ 1 ] [ j ] = mat [ 0 ] [ j ] = mat [ 1 ] [ j ] if ( n % 2 != 0 ) : mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ) : mat [ 1 ] [ j ] = mat [ 1 ] [ j ] return mat [ 0 ] [ W ]

def KnapSack ( val , wt , n , W ) : mat [ ] [ ] = [ 0 for k in range ( 2 , W + 1 ) ] i = 0 while i < n : j = 0 if i % 2 != 0 : while ( ++ j <= W ) : if ( wt [ i ] <= j ) : mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) else : mat [ 1 ] [ j ] = mat [ 0 ] [ j ] i ++ return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ]

61.16
46.67
50.65
41.72
static void sortString ( String str ) { int charCount [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { charCount [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { System . out . print ( ( char ) ( 'a' + i ) ) ; } } }

def sortString ( str ) : charCount = [ 0 ] * MAX_CHAR for i in range ( len ( str ) ) : charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : for j in range ( charCount [ i ] ) : print ( chr ( 97 + i ) , end = "" )

def sortString ( str ) : charCount = [ 0 for i in range ( len ( str ) ) ] for i in range ( MAX_CHAR ) : charCount [ str [ i ] - 'a' ] ++ for j in range ( charCount [ i ] ) : print ( ( char ) ( 'a' + i ) ) print ( j ) for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : print ( ( char )

def sortString ( str ) : charCount = [ MAX_CHAR for i in range ( MAX_CHAR ) ] for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : for j in range ( charCount [ i ] ) : print ( ( char ) ( 'a' + i ) )

61.2
47.57
79.15
65.06
static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }

def maximumChars ( str ) : n = len ( str ) res = - 1 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if ( str [ i ] == str [ j ] ) : res = max ( res , abs ( j - i - 1 ) ) return res

def maximumChars ( str ) : n = len ( str ) for i in range ( n - 1 , - 1 , - 1 ) : if ( str [ i ] == str [ j ] ) : res = max ( res , j - i - 1 ) return res

def maximumChars ( str ) : res = - 1 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( str [ i ] == str [ j ] ) : res = max ( res , abs ( j - i - 1 ) ) return res

61.25
46.67
45.63
39.28
static int countTransformation ( String a , String b ) { int n = a . length ( ) , m = b . length ( ) ; if ( m == 0 ) { return 1 ; } int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) { dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( i ) ) ? 1 : 0 ; } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }

def countTransformation ( a , b ) : n = len ( a ) m = len ( b ) if m == 0 : return 1 dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] for i in range ( m ) : for j in range ( i , n ) : if i == 0 : if j == 0 : if a [ j ] == b [ i ] : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 0 elif a [ j ] == b [ i ] : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] else : if a [ j ] == b [ i ] : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] return dp [ m - 1 ] [ n - 1 ]

def countTransformation ( a , b ) : n = a . length ( ) , m = b . length ( ) dp = [ 1 ] * n for i in range ( 0 , m , n ) : if ( a [ j ] == b . charAt ( i ) ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] [ j - 1 ] if ( a [ j ] == b [ i ] ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] dp [ i ] [ j - 1 ] = dp [ i ] [ j - 1 ] [ j - 1 ] return dp [ m - 1 ] [ n - 1 ]

def countTransformation ( a , b ) : n = m , m m = b . length ( ) for i in range ( m ) : for j in range ( i , n ) : if ( i == 0 ) : if ( j == 0 ) : dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 : elif ( a [ j ] == b [ i ] ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] return dp [ m - 1 ] [ n - 1 ]

61.28
38.34
67.96
46.66
static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }

def lastPosition ( n , m , k ) : if ( m <= n - k + 1 ) : return m + k - 1 m = m - ( n - k + 1 ) if ( m % n == 0 ) : return n else : return m % n

def lastPosition ( n , m , k ) : m = m - ( n - k + 1 ) if ( m <= n - k + 1 ) : return m + k - 1

def lastPosition ( n , m , k ) : if m <= n - k + 1 : return m + k - 1 m = m - ( n - k + 1 ) return ( m % n == 0 )

61.31
61.55
90.97
88.93
static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }

def minRevolutions ( r , x1 , y1 , x2 , y2 ) : d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) return math . ceil ( d // ( 2 * r ) )

def minRevolutions ( r , x1 , y1 , x2 , y2 ) : d = ( r * r ) + ( x1 - x2 ) * ( y1 - y2 ) ) return Math . ceil ( d / ( 2 * r ) )

def minRevolutions ( r , x1 , y1 , x2 , y2 ) : d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) return Math . ceil ( d / ( 2 * r ) )

61.32
50.08
70.21
55.94
static long countStrs ( int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < 27 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i <= 25 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) { sum = ( sum + dp [ n ] [ i ] ) ; } return sum ; }

def countStrs ( n ) : dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ] for i in range ( 0 , 26 ) : dp [ 1 ] [ i ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 0 , 26 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) sum = 0 for i in range ( 0 , 26 ) : sum = sum + dp [ n ] [ i ] return sum

def countStrs ( n ) : dp = [ 0 for i in range ( n + 1 , 27 ) ] for i in range ( n + 1 , 27 ) : dp [ i ] = [ 0 for i in range ( n + 1 , 27 ) ] for j in range ( 0 , 25 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] if ( j == 1 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] return sum

def countStrs ( n ) : dp = [ 0 for i in range ( n ) ] for i in range ( n + 1 , 27 ) : dp [ 1 ] [ i ] = 1 dp [ 2 ] [ i ] = 1 for i in range ( 2 , n ) : for j in range ( 0 , 25 , i ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) return sum

61.41
43.95
64.08
45.94
public static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }

def kthgroupsum ( k ) : cur = int ( ( k * ( k - 1 ) ) + 1 ) sum = 0 while k : sum += cur cur += 2 k = k - 1 return sum

def kthgroupsum ( k ) : cur = ( k * ( k - 1 ) ) + 1 sum = 0 for k in range ( k ) : sum += cur cur += 2 return sum

def kthgroupsum ( k ) : cur = ( k * ( k - 1 ) ) + 1 sum = 0 while k > 0 : sum += cur cur += 2 return sum

61.43
54.48
100.0
100.0
public static double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }

def numberOfTriangles ( n ) : ans = 2 * ( pow ( 3 , n ) ) - 1 return ans

def numberOfTriangles ( n ) : ans = 2 * pow ( 3 , n )

def numberOfTriangles ( n ) : ans = 2 * ( pow ( 3 , n ) ) - 1 return ans

61.44
65.3
71.4
75.88
static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ; }

def midpoint ( x1 , x2 , y1 , y2 ) : print ( ( x1 + x2 ) // 2 , "," , ( y1 + y2 ) // 2 )

def midpoint ( x1 , x2 , y1 , y2 ) : print ( x1 + x2 ) / 2 + " , " + y1 + y2 )

def midpoint ( x1 , x2 , y1 , y2 ) : print ( ( x1 + x2 ) / 2 , " " + ( y1 + y2 ) / 2 )

61.46
63.42
43.6
63.08
public static int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; }

def getFirstSetBitPos ( n ) : return math . log2 ( n & - n ) + 1

def getFirstSetBitPos ( n ) : return ( int ) ( n & - n )

def getFirstSetBitPos ( n ) : return ( int ( ( log10 ( n & - n ) ) / math . log10 ( 2 ) ) + 1

61.57
50.8
65.03
65.12
static String printSequence ( String arr [ ] , String input ) { String output = "" ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ' ) output = output + "0" ; else { int position = input . charAt ( i ) - 'A' ; output = output + arr [ position ] ; } } return output ; }

def printSequence ( arr , input ) : n = len ( input ) output = "" for i in range ( n ) : if ( input [ i ] == '' ) : output = output + "0" else : position = ord ( input [ i ] ) - ord ( 'A' ) output = output + arr [ position ] return output

def printSequence ( arr , input ) : output = "" n = len ( arr ) for i in range ( n ) : if ( input [ i ] == ' ' ) : output = output + "1" else : position = input [ i ] - 'A' output = output + arr [ position ]

def printSequence ( arr , input ) : output = "" n = input . length ( ) for i in range ( n ) : if ( input [ i ] == ' ' ) : output = output + "0" else : int position = input [ i ] - 'A' output = output + arr [ position ] return output

61.81
47.4
73.4
59.76
static int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }

def printCountDP ( dist ) : count = [ 0 ] * ( dist + 1 ) count [ 0 ] = 1 count [ 1 ] = 1 count [ 2 ] = 2 for i in range ( 3 , dist + 1 ) : count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) return count [ dist ]

def printCountDP ( dist ) : count = [ 0 for i in range ( dist + 1 , 4 ) ] for i in range ( 3 , dist + 1 ) : count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] return count [ dist ]

def printCountDP ( dist ) : count = [ 1 , 1 , 1 , 2 , 3 ] for i in range ( 3 , dist + 1 ) : count [ 0 ] = 1 count [ 1 ] = 1 count [ 2 ] = 2 for i in range ( 3 , dist ) : count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] return count [ dist ]

61.85
51.41
84.08
68.06
static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }

def maxLength ( s , n ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n - 1 ) : if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) : dp [ i ] [ i + 1 ] = 2 for l in range ( 2 , n ) : i = - 1 for j in range ( l , n ) : i += 1 if ( s [ i ] == '(' and s [ j ] == ')' ) : dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] for k in range ( i , j ) : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) return dp [ 0 ] [ n - 1 ]

def maxLength ( s , n ) : dp = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) : dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] [ k + 1 ] [ j ] ) if ( s [ i ] [ k ] + dp [ k + 1 ] [ j ] ) return dp [ 0 ] [ n - 1 ]

def maxLength ( s , n ) : dp [ ] = [ 0 for i in range ( n ) ] for i in range ( n - 1 , n ) : if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) : dp [ i ] [ i + 1 ] = 2 + dp [ i + 1 ] [ j - 1 ] for j in range ( l , n ) : if ( s [ i ] == '(' and s [ j ] == ')' ) : dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] for k in range ( i , j + 1 ) : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) return dp [ 0 ] [ n - 1 ]

61.89
51.57
57.76
50.03
static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }

def isTriangular ( num ) : if ( num < 0 ) : return False sum , n = 0 , 1 while ( sum <= num ) : sum = sum + n if ( sum == num ) : return True n += 1 return False

def isTriangular ( num ) : if ( num < 0 ) : return false sum = 0 for n in range ( 1 , num ) : sum = sum + n if ( sum == num ) : return true

def isTriangular ( num ) : if num < 0 : return False sum = 0 for n in range ( 1 , len ( num ) ) : sum = sum + n if ( sum == num ) : return True return False

61.94
55.07
70.78
63.19
static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }

def divisorSum ( n ) : sum = 0 for i in range ( 1 , n + 1 ) : sum += int ( n / i ) * i return int ( sum )

def divisorSum ( n ) : sum = 0 for i in range ( n ) : sum += ( n / i ) * i return sum

def divisorSum ( n ) : sum = 0 for i in range ( 1 , n ) : sum += ( n / i ) * i return sum

61.96
50.45
76.58
57.58
public static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }

def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 for i in range ( 0 , n ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return int ( abs ( area / 2.0 ) )

def polygonArea ( X , Y , n ) : area = 0.0 for i in range ( n ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) return area

def polygonArea ( X , Y , n ) : area = 0.0 for i in range ( n ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return abs ( area / 2.0 )

61.98
68.74
81.17
82.18
static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }

def countDigits ( a , b ) : count = 0 p = abs ( a * b ) if ( p == 0 ) : return 1 while ( p > 0 ) : count = count + 1 p = p // 10 return count

def countDigits ( a , b ) : count = 0 p = a * b while ( p > 0 ) : count ++ ; p = p / 10 if ( p == 0 ) : return 1

def countDigits ( a , b ) : count = 0 p = Math . abs ( a * b ) if ( p == 0 ) : return 1 while ( p > 0 ) : count += 1 p = p / 10 return count

62.02
50.92
100.0
100.0
static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits | odd_bits ) ; }

def swapBits ( x ) : even_bits = x & 0xAAAAAAAA odd_bits = x & 0x55555555 even_bits >>= 1 odd_bits <<= 1 return ( even_bits | odd_bits )

def swapBits ( x ) : even_bits = x & 0xAAAAAAAA odd_bits = x & 0x55555555 return ( even_bits ^ odd_bits )

def swapBits ( x ) : even_bits = x & 0xAAAAAAAA odd_bits = x & 0x55555555 even_bits >>= 1 odd_bits <<= 1 return ( even_bits | odd_bits )

62.03
53.89
66.54
57.47
static void rearrange ( int arr [ ] , int n ) { int i = - 1 , temp = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) { i ++ ; temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { temp = arr [ neg ] ; arr [ neg ] = arr [ pos ] ; arr [ pos ] = temp ; pos ++ ; neg += 2 ; } }

def rearrange ( arr , n ) : i = - 1 for j in range ( n ) : if ( arr [ j ] < 0 ) : i += 1 arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] pos , neg = i + 1 , 0 while ( pos < n and neg < pos and arr [ neg ] < 0 ) : arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] pos += 1 neg += 2

def rearrange ( arr , n ) : i = - 1 for j in range ( n ) : if ( arr [ j ] < 0 ) : temp = arr [ i ] arr [ i ] = arr [ j ] arr [ j ] = temp pos = i + 1 neg = 0 while ( pos < n && neg < pos ) : temp = arr [ neg ] arr [ neg ] = arr [ pos ] arr [ pos ] = temp pos += 2 neg +=

def rearrange ( arr , n ) : i = - 1 for j in range ( n ) : if arr [ j ] < 0 : i ++ temp = arr [ i ] arr [ i ] = arr [ j ] arr [ j ] = temp pos = i + 1 while pos < n and neg < pos and arr [ neg ] < 0 : temp = arr [ neg ] arr [ neg ] = arr [ pos ] arr [ pos ] = temp pos += 1 neg += 2

62.07
49.68
91.17
88.48
static int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }

def modFact ( n , p ) : if n >= p : return 0 result = 1 for i in range ( 1 , n + 1 ) : result = ( result * i ) % p return result

def modFact ( n , p ) : result = 1 for i in range ( n , p ) : result = ( result * i ) % p return result

def modFact ( n , p ) : if n >= p : return 0 result = 1 for i in range ( 1 , n ) : result = ( result * i ) % p return result

62.16
49.08
68.11
57.86
static int maxProfit ( int [ ] price , int n , int k ) { int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_so_far = 0 ; for ( int m = 0 ; m < j ; m ++ ) max_so_far = Math . max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , max_so_far ) ; } } return profit [ k ] [ n - 1 ] ; }

def maxProfit ( prices , n , k ) : profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , k + 1 ) : max_so_far = 0 for l in range ( i ) : max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) return profit [ n - 1 ] [ k ]

def maxProfit ( price , n , k ) : profit = [ 0 for i in range ( k + 1 , n + 1 ) ] for j in range ( 1 , n ) : max_so_far = max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , max_so_far ) if ( j == n ) : profit [ 0 ] [ j ] = max ( profit [ 0 ] [ j - 1 ] ) return profit [ k ] [ n - 1 ]

def maxProfit ( price , n , k ) : profit = [ 0 for i in range ( k ) ] for j in range ( n ) : profit [ i ] [ 0 ] = 0 for i in range ( 1 , k ) : for j in range ( n ) : max_so_far = 0 for m in range ( j ) : max_so_far = max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , max_so_far ) return profit [ k ] [ n - 1 ]

62.17
44.71
82.84
81.04
static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + " " ) ; fact = fact * x ; x ++ ; } }

def printFactorialNums ( n ) : fact = 1 x = 2 while fact <= n : print ( fact , end = "" ) fact = fact * x x += 1

def printFactorialNums ( n ) : fact = 1 x = 2 while ( fact <= n ) : fact = fact * x x += 2 printFactorialNums ( n - fact )

def printFactorialNums ( n ) : fact = 1 x = 2 while fact <= n : print ( fact + " " ) fact = fact * x x += 1

62.2
48.66
67.42
48.96
static int countPaths ( int maze [ ] [ ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; }

def countPaths ( maze ) : if ( maze [ 0 ] [ 0 ] == - 1 ) : return 0 for i in range ( R ) : if ( maze [ i ] [ 0 ] == 0 ) : maze [ i ] [ 0 ] = 1 else : break for i in range ( 1 , C , 1 ) : if ( maze [ 0 ] [ i ] == 0 ) : maze [ 0 ] [ i ] = 1 else : break for i in range ( 1 , R , 1 ) : for j in range ( 1 , C , 1 ) : if ( maze [ i ] [ j ] == - 1 ) : continue if ( maze [ i - 1 ] [ j ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) if ( maze [ i ] [ j - 1 ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : return maze [ R - 1 ] [ C - 1 ] else : return 0

def countPaths ( maze ) : maze = [ 0 for i in range ( len ( maze ) ) ] for i in range ( 1 , R ) : if ( maze [ i ] [ 0 ] == 0 ) : maze [ i ] [ 0 ] = 1 else : for j in range ( 1 , C ) : if ( maze [ i ] [ j ] == - 1 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) return ( maze [ R - 1 ] [ C - 1 ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) return ( 0

def countPaths ( maze [ 0 ] [ 0 ] ) : if ( maze [ 0 ] [ 0 ] == 0 ) : maze [ 0 ] [ 0 ] = 1 else : break for i in range ( 1 , R ) : if ( maze [ i ] [ i ] == - 1 ) continue if ( maze [ i - 1 ] [ j ] == - 1 ) continue if ( maze [ i ] [ j ] == 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) if ( maze [ i ] [ j - 1 ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0

62.21
57.92
100.0
100.0
static boolean check ( int n ) { return 1162261467 % n == 0 ; }

def check ( n ) : return 1162261467 % n == 0

def check ( n ) : return n == 1162261467

def check ( n ) : return 1162261467 % n == 0

62.25
41.03
88.91
61.96
static int CountSubstring ( char str [ ] , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == 'a' ) { a_index = i + 1 ; ans -= Math . min ( b_index , c_index ) ; } else if ( str [ i ] == 'b' ) { b_index = i + 1 ; ans -= Math . min ( a_index , c_index ) ; } else { c_index = i + 1 ; ans -= Math . min ( a_index , b_index ) ; } } return ans ; }

def CountSubString ( Str , n ) : ans = ( n * ( n + 1 ) ) // 2 a_index = 0 b_index = 0 c_index = 0 for i in range ( n ) : if ( Str [ i ] == 'a' ) : a_index = i + 1 ans -= min ( b_index , c_index ) elif ( Str [ i ] == 'b' ) : b_index = i + 1 ans -= min ( a_index , c_index ) else : c_index = i + 1 ans -= min ( a_index , b_index ) return ans

def CountSubstring ( str , n ) : ans = ( n * n + 1 ) / 2 a_index = 0 b_index = 0 c_index = 0 for i in range ( n ) : if ( str [ i ] == 'a' ) : a_index = i + 1 ans -= min ( b_index , c_index ) else : c_index = i + 1 ans -= min ( a_index , b_index ) return ans

def CountSubstring ( str , n ) : ans = ( n * ( n + 1 ) ) / 2 a_index = 0 b_index = 0 c_index = 0 for i in range ( n ) : if ( str [ i ] == 'a' ) : a_index = i + 1 ans -= min ( b_index , c_index ) elif ( str [ i ] == 'b' ) : b_index = i + 1 ans -= min ( a_index , c_index ) else : c_index = i + 1 ans -= min ( a_index , b_index ) return ans

62.35
47.59
90.01
69.77
static int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }

def coutSubSeq ( A , N , M ) : sum = 0 ans = 0 for i in range ( 0 , N ) : for j in range ( i + 1 , N ) : for k in range ( j + 1 , N ) : sum = A [ i ] + A [ j ] + A [ k ] if ( sum % M == 0 ) : ans = ans + 1 return ans

def coutSubSeq ( A , N , M ) : sum = 0 for i in range ( 0 , N , M ) : sum = A [ i ] + A [ j ] + A [ k ] ans = 0 for i in range ( 0 , N , M ) : if ( sum % M == 0 ) : ans += 1 return ans

def coutSubSeq ( A , N , M ) : sum = 0 ans = 0 for i in range ( N ) : for j in range ( i + 1 , N ) : for k in range ( j + 1 , N ) : sum = A [ i ] + A [ j ] + A [ k ] if ( sum % M == 0 ) : ans += 1 return ans

62.38
59.41
80.36
68.57
static int countDecodingDP ( char digits [ ] , int n ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; if ( digits [ 0 ] == '0' ) return 0 ; for ( int i = 2 ; i <= n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }

def countDecodingDP ( digits , n ) : count = [ 0 ] * ( n + 1 ) count [ 0 ] = 1 count [ 1 ] = 1 for i in range ( 2 , n + 1 ) : count [ i ] = 0 if ( digits [ i - 1 ] > '0' ) : count [ i ] = count [ i - 1 ] if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : count [ i ] += count [ i - 2 ] return count [ n ]

def countDecodingDP ( digits , n ) : count = [ 0 for k in range ( n ) ] for i in range ( 2 , n ) : if ( digits [ i ] == '0' ) : count [ i ] = count [ i - 1 ] if ( digits [ i - 1 ] > '0' ) : count [ i ] = count [ i - 1 ] if ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) : count [ i ] += count [ i - 2 ] : count [ i ] += count [ i - 2 ] if ( digits [ i - 1 ] < '7' ) : count [ i ] += count [ i - 2 ] return count [ n ]

def countDecodingDP ( digits , n ) : count = [ 0 for i in range ( n ) ] for i in range ( 2 , n ) : count [ i ] = 0 if ( digits [ i - 1 ] > '0' ) : count [ i ] = count [ i - 1 ] if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : count [ i ] += count [ i - 2 ] return count [ n ]

62.41
55.45
54.48
64.5
static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { s . add ( a1 [ i ] ) ; } ArrayList < Integer > al = new ArrayList < > ( s ) ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al . get ( al . size ( ) - 1 ) ) { return true ; } } } return false ; }

def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : s = set ( ) for i in range ( n1 ) : s . add ( a1 [ i ] ) for i in range ( n2 ) : for j in range ( n3 ) : if sum - a2 [ i ] - a3 [ j ] in s : return True return False

def findTriplet ( a1 , a2 , a3 , sum ) : s = set ( ) for i in range ( 0 , n1 ) : s . add ( a1 [ i ] ) for j in range ( 0 , n2 ) : if ( al . contains ( sum - a1 [ i ] - a3 [ j ] ) != al [ 0 ] ) : return true

def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : s = list ( ) for i in range ( n1 , n2 , n3 ) : s . add ( a1 [ i ] ) for j in range ( n3 ) : if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . contains ( sum - a2 [ i ] - a3 [ j ] ) != al . get ( al . size ( ) - 1 ) ) : return True return False

62.47
50.7
76.87
58.19
static int findNumberOfTriangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; }

def findnumberofTriangles ( arr ) : n = len ( arr ) arr . sort ( ) count = 0 for i in range ( 0 , n - 2 ) : k = i + 2 for j in range ( i + 1 , n ) : while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : k += 1 if ( k > j ) : count += k - j - 1 return count

def findNumberOfTriangles ( arr ) : n = arr . length sort ( reverse = True ) count = 0 for i in range ( 0 , n - 2 , - 1 ) : for j in range ( i + 1 , n - 2 ) : if ( arr [ i ] + arr [ j ] > arr [ k ] ) : count += k - j - 1 else : count += k - j - 1 return count

def findNumberOfTriangles ( arr ) : n = arr . length count = 0 for i in range ( n - 2 , - 1 , - 1 ) : k = i + 2 for j in range ( i + 1 , n ) : while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : ++ k if ( k > j ) : count += k - j - 1 return count

62.49
49.04
67.43
63.4
static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }

def LCIS ( arr1 , n , arr2 , m ) : table = [ 0 ] * m for j in range ( m ) : table [ j ] = 0 for i in range ( n ) : current = 0 for j in range ( m ) : if ( arr1 [ i ] == arr2 [ j ] ) : if ( current + 1 > table [ j ] ) : table [ j ] = current + 1 if ( arr1 [ i ] > arr2 [ j ] ) : if ( table [ j ] > current ) : current = table [ j ] result = 0 for i in range ( m ) : if ( table [ i ] > result ) : result = table [ i ] return result

def LCIS ( arr1 , n , arr2 , m ) : table = [ 0 for j in range ( m ) ] for i in range ( 0 , n ) : if ( arr1 [ i ] == arr2 [ j ] ) : current = 1 if ( arr1 [ i ] > arr2 [ j ] ) : current = table [ j ] if ( table [ j ] > current ) : current = table [ j ] if ( arr1 [ i ] > arr2 [ j ] ) : result = table [ i ] > result ) : result = table [ i ] return result

def LCIS ( arr1 , n , arr2 , m ) : table = [ 0 for k in range ( m ) ] for j in range ( m ) : if ( arr1 [ i ] == arr2 [ j ] ) : if ( current + 1 > table [ j ] ) : table [ j ] = current + 1 if ( arr1 [ i ] > arr2 [ j ] ) : current = table [ j ] if ( arr1 [ i ] > arr2 [ j ] ) : if ( table [ j ] > current ) : current = table [ j ] return result

62.55
48.81
78.51
69.07
static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( s . contains ( x ) ) { System . out . printf ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) ; found = true ; } else { s . add ( arr [ j ] ) ; } } } if ( found == false ) { System . out . printf ( " No Triplet Found\n" ) ; } }

def findTriplets ( arr , n ) : found = False for i in range ( n - 1 ) : s = set ( ) for j in range ( i + 1 , n ) : x = - ( arr [ i ] + arr [ j ] ) if x in s : print ( x , arr [ i ] , arr [ j ] ) found = True else : s . add ( arr [ j ] ) if found == False : print ( "NoTripletFound" )

def findTriplets ( arr , n ) : found = false for i in range ( 0 , n - 1 , - 1 ) : s = set ( arr [ i ] + arr [ j ] ) for j in range ( i + 1 , n ) : if ( s . contains ( x ) ) : found = true else : print ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) found = true print ( )

def findTriplets ( arr , n ) : found = False for i in range ( n ) : s = list ( ) for j in range ( i + 1 , n ) : x = - ( arr [ i ] + arr [ j ] ) if ( s . contains ( x ) ) : print ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) found = True else : s . add ( arr [ j ] )

62.55
50.03
49.83
48.23
void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( "0" ) ; return ; } int i , temp = 1 ; int prod [ ] = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) prod [ j ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " " ) ; return ; }

def productArray ( arr , n ) : if n == 1 : print ( 0 ) return i , temp = 1 , 1 prod = [ 1 for i in range ( n ) ] for i in range ( n ) : prod [ i ] = temp temp *= arr [ i ] temp = 1 for i in range ( n - 1 , - 1 , - 1 ) : prod [ i ] *= temp temp *= arr [ i ] for i in range ( n ) : print ( prod [ i ] , end = "" ) return

def productArray ( arr , n ) : if ( n == 0 ) : print ( "0" ) return ; else : prod = [ 1 for j in range ( 0 , n ) ] for i in range ( n ) : prod [ i ] = temp temp = 1 for i in range ( n - 1 , - 1 ) : prod [ i ] *= temp temp = 1 for i in range ( n - 1 , - 1 ) : prod [ i ] *= temp if ( arr [ i ] ) : prod [ i ] *= arr [ i ] : print ( prod [ i ] + " " ) return

def productArray ( arr , n ) : prod = [ 1 for j in range ( n ) ] for i in range ( n ) : prod [ i ] = 1 for j in range ( n ) : prod [ j ] = 1 for i in range ( n ) : prod [ i ] = temp temp *= arr [ i ] i -= 1 temp *= arr [ i ]

62.57
52.76
82.68
67.97
int minDist ( int arr [ ] , int n , int x , int y ) { int i , j ; int min_dist = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) min_dist = Math . abs ( i - j ) ; } } return min_dist ; }

def minDist ( arr , n , x , y ) : min_dist = 99999999 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) : min_dist = abs ( i - j ) return min_dist

def minDist ( arr , n , x , y ) : min_dist = float ( 'inf' ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( x == arr [ i ] && y == arr [ j ] ) : min_dist = abs ( i - j ) return min_dist

def minDist ( arr , n , x , y ) : min_dist = float ( 'inf' ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > Math . abs ( i - j ) : min_dist = Math . abs ( i - j ) return min_dist

62.57
61.11
61.56
56.02
static boolean isMinHeap ( int [ ] level ) { int n = level . length - 1 ; for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }

def isMinHeap ( level , n ) : for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : if level [ i ] > level [ 2 * i + 1 ] : return False if 2 * i + 2 < n : if level [ i ] > level [ 2 * i + 2 ] : return False return True

def isMinHeap ( level ) : n = level . length for i in range ( n / 2 , - 1 , - 1 ) : if ( level [ i ] > level [ 2 * i + 1 ] ) : return false if ( 2 * i + 2 < n ) : if ( level [ i ] > level [ 2 * i + 2 ] ) : return false return true

def isMinHeap ( level ) : n = level . length - 1 for i in range ( n ) : if ( level [ i ] > level [ 2 * i + 1 ] ) : return False if ( 2 * i + 2 < n ) : if ( level [ i ] > level [ 2 * i + 2 ] ) : return False return True

62.64
62.04
50.53
56.64
static boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ; }

def isCornerPresent ( str , corner ) : n = len ( str ) cl = len ( corner ) if ( n < cl ) : return False return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) )

def isCornerPresent ( str , corner ) : n = len ( str ) cl = corner . length ( ) if ( n < cl ) : return false return ( str [ 0 , cl ) . equals ( corner ) and str [ n - cl : n ] == corner )

def isCornerPresent ( str , corner ) : n = len ( corner ) cl = corner . length ( ) if n < cl : return False return ( str [ 0 , cl ] . equals ( corner ) and str [ n - cl , n ] . equals ( corner ) )

62.7
54.78
60.83
53.34
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < > ( ) ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; }

def countNumber ( n ) : result = 0 for i in range ( 1 , 10 ) : s = [ ] if ( i <= n ) : s . append ( i ) result += 1 while len ( s ) != 0 : tp = s [ - 1 ] s . pop ( ) for j in range ( tp % 10 , 10 ) : x = tp * 10 + j if ( x <= n ) : s . append ( x ) result += 1 return result

def countNumber ( n ) : result = 0 for i in range ( 1 , 9 ) : s = list ( ) for i in range ( 1 , 10 , 9 ) : s . append ( i ) result += 1 tp = s [ - 1 ] for j in range ( 1 , 9 ) : if ( x <= n ) : s . push ( x ) result += 1 else : s . pop ( ) tp = tp * 10 + j return result

def countNumber ( n ) : result = 0 for i in range ( 1 , 9 ) : s = list ( ) for i in range ( 1 , 9 ) : if ( i <= n ) : s . append ( i ) result += 1 while ( not s . empty ( ) ) : tp = s . pop ( ) s . pop ( ) for j in tp % 10 : if ( j <= 9 ) : s . append ( x ) result += 1 return result

62.76
63.38
64.65
72.38
static void printPrevSmaller ( int arr [ ] , int n ) { Stack < Integer > S = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . peek ( ) >= arr [ i ] ) { S . pop ( ) ; } if ( S . empty ( ) ) { System . out . print ( "_, " ) ; } else { System . out . print ( S . peek ( ) + ", " ) ; } S . push ( arr [ i ] ) ; } }

def printPrevSmaller ( arr , n ) : S = list ( ) for i in range ( n ) : while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : S . pop ( ) if ( len ( S ) == 0 ) : print ( "_," , end = "" ) else : print ( S [ - 1 ] , end = "," ) S . append ( arr [ i ] )

def printPrevSmaller ( arr , n ) : S = list ( ) for i in range ( n ) : if ( arr [ i ] >= S [ - 1 ] ) : print ( "_, " ) else : print ( arr [ i ] , end = "" ) S . append ( arr [ i ] ) print ( end = "" ) S . pop ( ) for i in range ( n ) : if ( S [ - 1 ] >= arr [ i ] ) : S .

def printPrevSmaller ( arr , n ) : S = list ( ) for i in range ( n ) : while not S . empty ( ) and S [ - 1 ] >= arr [ i ] : S . pop ( ) if ( S [ - 1 ] == arr [ i ] ) : print ( "_, " ) else : print ( S [ - 1 ] + ", " ) S . push ( arr [ i ] )

62.76
45.49
72.99
52.77
static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }

def findSum ( n ) : multiTerms = n * ( n + 1 ) // 2 sm = multiTerms for i in range ( 2 , n + 1 ) : multiTerms = multiTerms - ( i - 1 ) sm = sm + multiTerms * i return sm

def findSum ( n ) : multiTerms = n * n / 2 sum = multiTerms for i in range ( 2 , n ) : multiTerms = multiTerms - ( i - 1 ) sum = sum + multiTerms * i return sum

def findSum ( n ) : multiTerms = n * ( n + 1 ) / 2 sum = multiTerms for i in range ( 2 , n ) : multiTerms = multiTerms - ( i - 1 ) sum = sum + multiTerms * i return sum

62.92
45.04
61.43
44.57
static int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 }; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }

def findArea ( arr , n ) : arr . sort ( reverse = True ) dimension = [ 0 , 0 ] i = 0 j = 0 while ( i < n - 1 and j < 2 ) : if ( arr [ i ] == arr [ i + 1 ] ) : dimension [ j ] = arr [ i ] j += 1 i += 1 i += 1 return ( dimension [ 0 ] * dimension [ 1 ] )

def findArea ( arr , n ) : arr . sort ( reverse = True ) dimension = { 0 , 0 } for i in range ( n - 1 , - 1 , - 1 ) : if ( arr [ i ] == arr [ i + 1 ] ) : dimension [ j ++ ] = arr [ i ] if ( dimension [ 0 ] == dimension [ 1 ] ) : return ( dimension [ 0 ] * dimension [ 1 ] )

def findArea ( arr , n ) : arr . sort ( reverse = True ) dimension = { 0 , 0 } for i in range ( 0 , n - 1 , - 1 ) : if ( arr [ i ] == arr [ i + 1 ] ) : dimension [ j ++ ] = arr [ i ++ ] return ( dimension [ 0 ] * dimension [ 1 ] )

62.93
51.07
66.49
51.54
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }

def countPairs ( arr1 , arr2 , m , n , x ) : count , l , r = 0 , 0 , n - 1 while ( l < m and r >= 0 ) : if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : l += 1 r -= 1 count += 1 elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : l += 1 else : r -= 1 return count

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for l in range ( m , n ) : if ( arr1 [ l ] + arr2 [ r ] ) == x : l += 1 else : r -= 1 count += 1 if ( arr1 [ l ] + arr2 [ r ] ) > x : l += 1 else : r -= 1 if ( arr1 [ l ] + arr2 [ r ] ) < x ) : return count

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for l in range ( m , n ) : if ( arr1 [ l ] + arr2 [ r ] ) == x : l += 1 r -= 1 count += 1 elif ( arr1 [ l ] + arr2 [ r ] ) < x : l += 1 else : r -= 1 return count

62.94
51.68
58.36
44.85
static void removeDuplicates ( char [ ] S ) { int n = S . length ; if ( n < 2 ) { return ; } int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } System . out . println ( Arrays . copyOfRange ( S , 0 , j + 1 ) ) ; }

def removeDuplicates ( S ) : n = len ( S ) if ( n < 2 ) : return j = 0 for i in range ( n ) : if ( S [ j ] != S [ i ] ) : j += 1 S [ j ] = S [ i ] j += 1 S = S [ : j ] return S

def removeDuplicates ( S ) : n = len ( S ) for i in range ( 1 , n ) : if ( S [ j ] != S [ i ] ) : j ++ S [ j ] = S [ i ] if ( S [ j ] != S [ i ] ) : S [ j ] = S [ i ] j += 1 return

def removeDuplicates ( S ) : n = S . length j = 0 for i in range ( n ) : if ( S [ j ] != S [ i ] ) : j += 1 S [ j ] = S [ i ]

62.95
57.37
89.01
95.22
static String firstLetterWord ( String str ) { String result = "" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ' ) { v = true ; } else if ( str . charAt ( i ) != ' ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; }

def firstLetterWord ( str ) : result = "" v = True for i in range ( len ( str ) ) : if ( str [ i ] == '' ) : v = True elif ( str [ i ] != '' and v == True ) : result += ( str [ i ] ) v = False return result

def firstLetterWord ( str ) : result = "" v = true for i in range ( len ( str ) ) : if ( str [ i ] == ' ' ) : v = true result += ( str [ i ] ) v = false if ( str [ i ] != ' ' ) : result += ( str [ i ] ) v = false return result

def firstLetterWord ( str ) : result = "" v = True for i in range ( len ( str ) ) : if ( str [ i ] == ' ' ) : v = True elif ( str [ i ] != ' ' and v == True ) : result += ( str [ i ] ) v = False return result

62.99
63.7
81.83
75.93
static int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }

def findLastIndex ( str , x ) : index = - 1 for i in range ( 0 , len ( str ) ) : if str [ i ] == x : index = i return index

def findLastIndex ( str , x ) : index = - 1 for i in range ( len ( str ) ) : if ( str [ i ] == x ) : index = i break if ( index == - 1 ) : return index

def findLastIndex ( str , x ) : index = - 1 for i in range ( len ( str ) ) : if ( str [ i ] == x ) : index = i return index

63.04
49.64
72.35
55.72
static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }

def nonDecNums ( n ) : a = np . zeros ( ( n + 1 , 10 ) ) for i in range ( 10 ) : a [ 0 ] [ i ] = 1 for i in range ( 1 , n + 1 ) : a [ i ] [ 9 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( 8 , - 1 , - 1 ) : a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] return int ( a [ n ] [ 0 ] )

def nonDecNums ( n ) : a = [ 0 for i in range ( n + 1 , 10 ) ] for i in range ( 1 , n ) : a [ 0 ] [ i ] = 1 a [ 1 ] [ 9 ] = 1 for i in range ( 1 , n ) : a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] return a [ n ] [ 0 ]

def nonDecNums ( n ) : a = [ 0 for i in range ( n ) ] for i in range ( 9 , n ) : a [ 0 ] [ i ] = 1 for i in range ( 1 , n ) : a [ i ] [ 9 ] = 1 for i in range ( 1 , n ) : for j in range ( 8 , 8 ) : a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] return a [ n ] [ 0 ]

63.13
54.11
78.06
60.73
static int largestSubset ( int [ ] a , int n ) { Arrays . sort ( a ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; }

def largestSubset ( a , n ) : a . sort ( ) dp = [ 0 for i in range ( n ) ] dp [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : mxm = 0 for j in range ( i + 1 , n ) : if a [ j ] % a [ i ] == 0 : mxm = max ( mxm , dp [ j ] ) dp [ i ] = 1 + mxm return max ( dp )

def largestSubset ( a , n ) : dp = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( a [ i ] % a [ i ] == 0 ) : mxm = max ( mxm , dp [ i ] ) dp [ i ] = 1 + mxm for j in range ( i + 1 , n ) : if ( a [ j ] % a [ i ] == 0 ) : mxm = max ( mxm , dp [ j ] ) : mxm = max ( mxm , dp [ j ] ) return dp [ n - 1 ]

def largestSubset ( a , n ) : dp = [ 1 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : mxm = 0 for j in range ( i + 1 , n ) : if ( a [ j ] % a [ i ] == 0 ) : mxm = max ( mxm , dp [ j ] ) dp [ i ] = 1 + mxm return arrays . stream ( dp ) . max ( ) . getAsInt ( )

63.13
57.14
78.57
81.93
static boolean flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }

def flipsPossible ( a , n ) : count_odd = 0 count_even = 0 for i in range ( n ) : if ( a [ i ] & 1 ) : count_odd += 1 else : count_even += 1 if ( count_odd % 2 and count_even % 2 ) : return False else : return True

def flipsPossible ( a , n ) : count_odd = 0 count_even = 0 for i in range ( n ) : if ( a [ i ] & 1 ) == 1 : count_odd += 1 if ( a [ i ] & 1 ) == 1 : count_even += 1 if ( count_odd % 2 == 1 and count_even % 2 == 1 ) : return false else : return true

def flipsPossible ( a , n ) : count_odd = 0 count_even = 0 for i in range ( n ) : if ( ( a [ i ] & 1 ) == 1 ) : count_odd += 1 else : count_even += 1 if count_odd % 2 == 1 and count_even % 2 == 1 : return False else : return True

63.15
40.57
66.56
50.69
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( "Triplet is " + A [ i ] + ", " + A [ j ] + ", " + A [ k ] ) ; return true ; } } } } return false ; }

def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 2 ) : for j in range ( i + 1 , arr_size - 1 ) : for k in range ( j + 1 , arr_size ) : if A [ i ] + A [ j ] + A [ k ] == sum : print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , A [ k ] ) return True return False

def find3Numbers ( A , arr_size , sum ) : l = 0 for i in range ( arr_size - 2 , - 1 , - 1 ) : for j in range ( i + 1 , arr_size - 1 ) : if ( A [ i ] + A [ j ] + A [ k ] == sum ) : print ( "Triplet is " + A [ i ] , ", " + A [ j ] , ", " + A [ k ] ) return true

def find3Numbers ( A , arr_size , sum ) : l = 0 for i in range ( arr_size - 2 , arr_size - 1 , - 1 ) : for j in range ( i + 1 , arr_size - 1 ) : for k in range ( j + 1 , arr_size ) : if ( A [ i ] + A [ j ] + A [ k ] == sum ) : print ( "Triplet is " + A [ i ] + ", " + A [ j ] + ", " + A [ k ] ) return True return False

63.2
53.37
54.84
44.48
static int lps ( String seq ) { int n = seq . length ( ) ; int i , j , cl ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }

def lps ( str ) : n = len ( str ) L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] for i in range ( n ) : L [ i ] [ i ] = 1 for cl in range ( 2 , n + 1 ) : for i in range ( n - cl + 1 ) : j = i + cl - 1 if str [ i ] == str [ j ] and cl == 2 : L [ i ] [ j ] = 2 elif str [ i ] == str [ j ] : L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 else : L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; return L [ 0 ] [ n - 1 ]

def lps ( seq ) : L = [ 0 for i in range ( n ) ] for i in range ( n ) : for j in range ( n - cl + 1 , - 1 , - 1 ) : if ( seq [ i ] == seq [ j ] ) : L [ i ] [ j ] = 2 elif ( seq [ i ] == seq [ j ] and cl == 2 ) : L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j - 1 ] + 2 ) else : L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) return L [ 0 ] [ n - 1 ]

def lps ( seq ) : n = seq . length ( ) L [ ] [ ] = [ 1 for cl in range ( 2 , n ) : for i in range ( n ) : j = i + cl - 1 if ( seq [ i ] == seq [ j ] and cl == 2 ) : L [ i ] [ j ] = 2 elif ( seq [ i ] == seq [ j ] and cl == 2 ) : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) return L [ 0 ] [ n - 1 ]

63.22
51.17
68.43
52.9
static int find_difference ( int arr [ ] , int n , int m ) { int max = 0 , min = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 , j = n - 1 ; i < m ; i ++ , j -- ) { min += arr [ i ] ; max += arr [ j ] ; } return ( max - min ) ; }

def find_difference ( arr , n , m ) : max = 0 min = 0 arr . sort ( ) j = n - 1 for i in range ( m ) : min += arr [ i ] max += arr [ j ] j = j - 1 return ( max - min )

def find_difference ( arr , n , m ) : max = 0 min = 0 for i in range ( n , m ) : min += arr [ i ] max += arr [ j ] return ( max - min )

def find_difference ( arr , n , m ) : max = 0 min = 0 for i in range ( n ) : for j in range ( n - 1 , m ) : min += arr [ i ] max += arr [ j ] return ( max - min )

63.25
71.08
72.02
74.29
static int MaximumHeight ( int a [ ] , int n ) { return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; }

def MaximumHeight ( a , n ) : return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2

def MaximumHeight ( a , n ) : return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) )

def MaximumHeight ( a , n ) : return ( - 1 + Math . floor ( ( - 1 + math . sqrt ( 1 + ( 8 * n ) ) )

63.3
55.08
68.58
63.36
public static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( arr1 [ i ] , 0 ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . containsKey ( x - arr2 [ j ] ) ) System . out . println ( x - arr2 [ j ] + " " + arr2 [ j ] ) ; }

def findPairs ( arr1 , arr2 , n , m , x ) : s = set ( ) for i in range ( 0 , n ) : s . add ( arr1 [ i ] ) for j in range ( 0 , m ) : if ( ( x - arr2 [ j ] ) in s ) : print ( ( x - arr2 [ j ] ) , '' , arr2 [ j ] )

def findPairs ( arr1 , arr2 , n , m , x ) : s = new HashMap < Integer , Integer > ( ) for i in range ( 0 , n , m ) : s . put ( arr1 [ i ] , 0 ) for j in range ( 0 , n , m ) : if ( s [ x - arr2 [ j ] ] != 0 ) : print ( x - arr2 [ j ] ) print ( arr2 [ j ] )

def findPairs ( arr1 , arr2 , n , m , x ) : s = list ( ) for i in range ( n ) : s . append ( arr1 [ i ] ) for j in range ( m ) : if ( s . containsKey ( x - arr2 [ j ] ) ) : print ( x - arr2 [ j ] + " " + arr2 [ j ] )

63.31
55.35
78.19
57.92
static int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }

def findMinZero ( p ) : first = 1 second = 1 number = 2 next = 1 while ( next ) : next = ( first + second ) % p first = second second = next number = number + 1 return number

def findMinZero ( p ) : first = 1 second = 1 number = 2 while ( next > 0 ) : next = ( first + second ) % p number += 1 if ( next > 0 ) : first = second second = next number += 1 return number

def findMinZero ( p ) : first = 1 second = 1 number = 2 next = 1 while next > 0 : next = ( first + second ) % p first = second second = next number ++ return number

63.39
47.3
69.72
54.31
static int countWays ( int N ) { int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; }

def countWays ( arr , m , N ) : count = [ 0 for i in range ( N + 1 ) ] count [ 0 ] = 1 for i in range ( 1 , N + 1 ) : for j in range ( m ) : if ( i >= arr [ j ] ) : count [ i ] += count [ i - arr [ j ] ] return count [ N ]

def countWays ( arr , N ) : count = [ 1 for i in range ( 1 , N ) ] for j in range ( 0 , arr . length ) : if ( i >= arr [ j ] ) : count [ i ] += count [ i - arr [ j ] ] return count [ N ]

def countWays ( N ) : count = [ 1 for i in range ( N ) ] for i in range ( 1 , N ) : for j in range ( 1 , N ) : if ( i >= arr [ j ] ) : count [ i ] += count [ i - arr [ j ] ] return count [ N ]

63.4
61.32
51.34
57.66
public static float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }

def volumeOfEllipsoid ( r1 , r2 , r3 ) : return 1.33 * math . pi * r1 * r2 * r3

def volumeOfEllipsoid ( r1 , r2 , r3 ) : pi = ( float ) 3.14 return 1.33 * pi * r1 * r2 * r3

def volumeOfEllipsoid ( r1 , r2 , r3 ) : pi = ( float ) 3.14 return ( float ( 1.33 * pi * r1 * r2 * r3 ) )

63.4
45.6
80.91
65.49
static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }

def findIndex ( n ) : if ( n <= 1 ) : return n a = 0 b = 1 c = 1 res = 1 while ( c < n ) : c = a + b res = res + 1 a = b b = c return res

def findIndex ( n ) : n = n - 1 a = 0 b = 1 c = 1 res = 1 while ( c < n ) : c = a + b b = c res += 1 a = b c = 1 b = c res = 1 return res

def findIndex ( n ) : if n <= 1 : return n a = 0 b = 1 c = 1 res = 1 while ( c < n ) : c = a + b res += 1 a = b b = c return res

63.45
73.91
69.76
77.1
static int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 0 ) return 1 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }

def countDer ( n ) : if ( n == 1 ) : return 0 if ( n == 0 ) : return 1 if ( n == 2 ) : return 1 return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )

def countDer ( n ) : if ( n == 1 ) : return countDer ( n - 1 ) if ( n == 2 ) : return countDer ( n - 1 ) + countDer ( n - 2 ) return ( n - 1 ) * countDer ( n - 1 ) + countDer ( n - 2 )

def countDer ( n ) : if n == 1 : return 0 if n == 0 : return 1 if n == 1 : return 1 if n == 2 : return 1 return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )

63.5
53.99
64.22
55.01
static int minOperations ( String str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 || firstLower == - 1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { countLower ++ ; } } return Math . min ( countLower , countUpper ) ; }

def minOperations ( str , n ) : lastUpper = - 1 firstLower = - 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( str [ i ] . isupper ( ) ) : lastUpper = i break for i in range ( n ) : if ( str [ i ] . islower ( ) ) : firstLower = i break if ( lastUpper == - 1 or firstLower == - 1 ) : return 0 countUpper = 0 for i in range ( firstLower , n ) : if ( str [ i ] . isupper ( ) ) : countUpper += 1 countLower = 0 for i in range ( lastUpper ) : if ( str [ i ] . islower ( ) ) : countLower += 1 return min ( countLower , countUpper )

def minOperations ( str , n ) : lastUpper = - 1 firstLower = - 1 for i in range ( n ) : if ( Character . isUpperCase ( str [ i ] ) ) : lastUpper = i break if ( firstLower == - 1 ) : firstLower = i break if ( lastUpper == - 1 or firstLower == - 1 ) : return 0 countUpper = 0 for i in range ( firstUpper , n ) : if ( Character . isLowerCase ( str [ i ] ) : countUpper = countLower = i if ( Character . isUpperCase ( str [ i ] ) : countUpper += 1 if ( Character . isUpperCase ( str [ i ] ) ) : countLower += 1 return min ( countUpper , countLower )

def minOperations ( str , n ) : lastUpper = - 1 firstLower = - 1 for i in range ( n ) : if ( Character . isUpperCase ( str [ i ] ) ) : lastUpper = i firstLower = i break if ( lastUpper == - 1 or firstLower == - 1 ) : return 0 countUpper = 0 for i in range ( firstLower , n ) : if ( Character . isLowerCase ( str [ i ] ) ) : countUpper ++ countLower = 0 for i in range ( firstLower , n ) : if ( Character . isUpperCase ( str [ i ] ) ) : countLower += 1 return min ( countLower , countUpper )

63.6
68.9
73.33
59.34
static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( "No" ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( "Yes " + days ) ; } }

def survival ( S , N , M ) : if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : print ( "No" ) else : days = ( M * S ) / N if ( ( ( M * S ) % N ) != 0 ) : days += 1 print ( "Yes" ) , print ( days )

def survival ( S , N , M ) : if ( S < 6 ) || ( N * 6 ) < ( M * 7 ) and S > 6 ) : System . out . println ( "No" ) else : days = ( M * S ) / N if ( ( M * S ) % N ) != 0 ) : days += 1 if ( ( M * S ) % N ) != 0 ) : days += 1 else : days += 1 print ( "

def survival ( S , N , M ) : if ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N : print ( "No" ) else : days = ( M * S ) // N if ( ( ( M * S ) % N ) != 0 ) : days += ( ( ( M * S ) % N ) != 0 ) days += ( "Yes " + days )

63.6
45.07
64.03
42.12
static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }

def calculateSum ( n ) : if ( n <= 0 ) : return 0 fibo = [ 0 ] * ( n + 1 ) fibo [ 1 ] = 1 sm = fibo [ 0 ] + fibo [ 1 ] for i in range ( 2 , n + 1 ) : fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] sm = sm + fibo [ i ] return sm

def calculateSum ( n ) : fibo = [ 0 for k in range ( n ) ] fibo [ 0 ] = 1 fibo [ 1 ] = 1 sum = fibo [ 0 ] + fibo [ 1 ] for i in range ( 2 , n ) : fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] sum += fibo [ i ] if ( i <=

def calculateSum ( n ) : fibo = [ 0 for k in range ( n ) ] fibo [ 0 ] = 0 fibo [ 1 ] = 1 sum = fibo [ 0 ] + fibo [ 1 ] for i in range ( 2 , n ) : fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] sum += fibo [ i ] return sum

63.9
62.98
63.17
64.31
static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }

def HalfDiagonalSums ( mat , n ) : diag1_left = 0 diag1_right = 0 diag2_left = 0 diag2_right = 0 i = 0 j = n - 1 while i < n : if ( i < n // 2 ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ j ] [ i ] elif ( i > n // 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] i += 1 j -= 1 return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )

def HalfDiagonalSums ( mat , n ) : diag1_left = 0 diag1_right = 0 diag2_left = 0 diag2_right = 0 for i in range ( n ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ j ] [ i ] if ( i < n / 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] if ( i > n / 2 ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ n / 2 ] [ n / 2 ] return diag1_left == diag2_right and diag1_right == diag2_left and diag2_right == mat [ n / 2 ] [ n / 2 ]

def halfDiagonalSums ( mat , n ) : diag1_left = 0 diag1_right = 0 diag2_left = 0 diag2_right = 0 for i in range ( n ) : if ( i < n / 2 ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ j ] [ i ] elif ( i > n / 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] elif ( i > n / 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_right and diag2_right == mat [ n / 2 ] [ n / 2 ] )

63.93
57.98
71.15
69.25
public static int nobleInteger ( int arr [ ] ) { int size = arr . length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }

def nobleInteger ( arr , size ) : for i in range ( 0 , size ) : count = 0 for j in range ( 0 , size ) : if ( arr [ i ] < arr [ j ] ) : count += 1 if ( count == arr [ i ] ) : return arr [ i ] return - 1

def nobleInteger ( arr ) : size = arr . length for i in range ( 0 , size ) : if ( arr [ i ] < arr [ j ] ) : count = 0 if ( count == arr [ i ] ) : return arr [ i ]

def nobleInteger ( arr ) : size = arr . length for i in range ( size ) : count = 0 for j in range ( 0 , size ) : if ( arr [ i ] < arr [ j ] ) : count += ( arr [ i ] - arr [ j ] ) if ( count == arr [ i ] ) : return arr [ i ] return - 1

63.93
51.84
58.12
49.11
static void modularInverse ( int n , int prime ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }

def modularInverse ( n , prime ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime for i in range ( 1 , n + 1 ) : print ( dp [ i ] , end = "" )

def modularInverse ( n , prime ) : dp = [ 1 for k in range ( n ) ] dp [ 0 ] = dp [ 1 ] = prime for i in range ( 2 , n ) : dp [ i ] = dp [ prime % i ] * prime - prime / i ] dp [ i ] = 1 print ( dp [ 0 ] , end = "" ) for i in range ( 1 , n ) : print ( dp [ i ] , end = "" )

def modularInverse ( n , prime ) : dp = [ 1 for i in range ( n ) ] for i in range ( 2 , n ) : dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime for i in range ( 1 , n ) : dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime for i in range ( 1 , n ) : print ( dp [ i ] )

64.04
47.81
68.42
54.58
static int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; vis [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; }

def solve ( A , n ) : cnt = 0 parent = [ None ] * ( n + 1 ) vis = [ None ] * ( n + 1 ) for i in range ( 0 , n + 1 ) : parent [ i ] = - 1 vis [ i ] = 0 for i in range ( 0 , n ) : j = i if ( parent [ j ] == - 1 ) : while ( parent [ j ] == - 1 ) : parent [ j ] = i j = ( j + A [ j ] + 1 ) % n if ( parent [ j ] == i ) : while ( vis [ j ] == 0 ) : vis [ j ] = 1 cnt = cnt + 1 j = ( j + A [ j ] + 1 ) % n return cnt

def solve ( A , n ) : cnt = 0 for i in range ( n ) : parent = [ - 1 for i in range ( n + 1 ) ] vis = [ 0 for i in range ( n + 1 ) ] for j in range ( 0 , n + 1 ) : if ( parent [ j ] == - 1 ) : parent [ j ] = i cnt ++ j = ( j + A [ j ] + n ) % n if ( vis [ j ] == 0 ) : vis [ j ] = 1 else : parent [ j ] = 1 while ( vis [ j ] == 0 ) : vis [ j ] = 1 cnt += 1 j = ( j + A [ j ] + n ) % n return cnt

def solve ( A , n ) : cnt = 0 parent = [ - 1 for k in range ( n ) ] vis = [ 0 for k in range ( n ) ] for i in range ( n ) : j = i if ( parent [ j ] == - 1 ) : parent [ j ] = i j = ( j + A [ j ] + 1 ) % n if ( parent [ j ] == i ) : while ( vis [ j ] == 0 ) : vis [ j ] = 1 cnt ++ j = ( j + A [ j ] + 1 ) % n if ( parent [ j ] == i ) : while ( vis [ j ] == 0 ) : vis [ j ] = 1 cnt ++ j = ( j + A [ j ] + 1 ) % n return cnt

64.11
40.65
86.91
82.72
static Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }

def pythagorean_quadruple ( a , b , c , d ) : sum = a * a + b * b + c * c if ( d * d == sum ) : return True else : return False

def pythagorean_quadruple ( a , b , c , d ) : sum = a * a + b * b + c * c + d * d return false

def pythagorean_quadruple ( a , b , c , d ) : sum = a * a + b * b + c * c if d * d == sum : return True else : return False

64.13
70.23
69.8
75.69
static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }

def count ( S , m , n ) : if ( n == 0 ) : return 1 if ( n < 0 ) : return 0 if ( m <= 0 and n >= 1 ) : return 0 return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] )

def count ( S , m , n ) : if ( m == 0 ) : return count ( S , m , n ) if ( n == 1 ) : return count ( S , m - 1 , n ) return count ( S , m - 1 , n - S [ m - 1 ] )

def count ( S , m , n ) : if n == 0 : return 1 if m <= 0 and n >= 1 : return 0 return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] )

64.15
55.04
86.49
78.76
static int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }

def minCost ( cost ) : dist = [ 0 for i in range ( N ) ] for i in range ( N ) : dist [ i ] = INF dist [ 0 ] = 0 for i in range ( N ) : for j in range ( i + 1 , N ) : if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]

def minCost ( cost , N ) : dist = [ 0 for i in range ( N ) ] for i in range ( 0 , N ) : if ( cost [ i ] [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]

def minCost ( cost [ ] [ ] ) : dist = [ INF for i in range ( N ) ] for i in range ( 0 , N ) : dist [ i ] = INF dist [ 0 ] = 0 for i in range ( 0 , N ) : for j in range ( i + 1 , N ) : if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]

64.23
49.36
41.91
43.28
static long arrangeBraces ( int n , int pos [ ] , int k ) { boolean h [ ] = new boolean [ N ] ; int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } else if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }

def arrangeBraces ( n , pos , k ) : h = [ False for i in range ( N ) ] dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] for i in range ( k ) : h [ pos [ i ] ] = 1 dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , 2 * n + 1 ) : for j in range ( 2 * n + 1 ) : if ( h [ i ] ) : if ( j != 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 0 else : if ( j != 0 ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) else : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] return dp [ 2 * n ] [ 0 ]

def arrangeBraces ( N , pos , k ) : h = [ false for i in range ( k ) ] dp = [ [ 0 for i in range ( n ) ] for j in range ( 0 , 2 * n ) : if ( h [ i ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] else : dp [ i ] [ j ] = 0 if ( j != 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] dp [ i ] [ j ] = 0 for i in range ( 1 , 2 * n ) : if ( j != 0 ) : dp [ i ] [ j ] = dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] dp [ i ] [ j + 1 ] dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = dp [ i - 1 ] [ j ] = dp [ i - 1 ] [ j + 1 ] dp [ i ] = 0 return dp [ 2 * n ] [ 0 ]

def arrangeBraces ( n , pos , k ) : h = [ True for k in range ( k ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , 2 * n ) : for j in range ( 1 , 2 * n ) : if ( h [ i ] ) : if ( j != 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] else : dp [ i ] [ j ] = 0 return dp [ 2 * n ] [ 0 ]

64.24
49.71
79.73
58.38
static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }

def countWays ( n , m ) : count = [ ] for i in range ( n + 2 ) : count . append ( 0 ) count [ 0 ] = 0 for i in range ( 1 , n + 1 ) : if ( i > m ) : count [ i ] = count [ i - 1 ] + count [ i - m ] elif ( i < m ) : count [ i ] = 1 else : count [ i ] = 2 return count [ n ]

def countWays ( n , m ) : count = [ 0 for i in range ( n , m ) ] for i in range ( 1 , n + 1 , - 1 ) : if ( i > m ) : count [ i ] = count [ i - 1 ] + count [ i - m ] else : count [ i ] = 2 return count [ n ]

def countWays ( n , m ) : count = [ 0 for i in range ( n ) ] count [ 0 ] = 0 for i in range ( 1 , n ) : if ( i > m ) : count [ i ] = count [ i - 1 ] + count [ i - m ] else : if ( i < m ) : count [ i ] = 1 else : count [ i ] = 2 return count [ n ]

64.26
60.8
80.36
89.96
static int Calculate ( int A , int B , int C , int M ) { int res , ans ; res = power ( B , C , M - 1 ) ; ans = power ( A , res , M ) ; return ans ; }

def calculate ( A , B , C , M ) : res = pow ( B , C , M - 1 ) ans = pow ( A , res , M ) return ans

def Calculate ( A , B , C , M ) : res = power ( A , B , C ) ans = power ( A , res , M - 1 ) return ans

def Calculate ( A , B , C , M ) : res = power ( B , C , M - 1 ) ans = power ( A , res , M ) return ans

64.28
62.11
70.29
64.9
static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( "No Majority Element" ) ; }

def findMajority ( arr , n ) : maxCount = 0 ; index = - 1 for i in range ( n ) : count = 0 for j in range ( n ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count > maxCount ) : maxCount = count index = i if ( maxCount > n // 2 ) : print ( arr [ index ] ) else : print ( "NoMajorityElement" )

def findMajority ( arr , n ) : maxCount = 0 for i in range ( n ) : if ( arr [ i ] == arr [ j ] ) : maxCount = count for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : maxCount = count if ( maxCount > n / 2 ) : print ( arr [ index ] ) else : print ( "No Majority Element" ) index =

def findMajority ( arr , n ) : maxCount = 0 index = - 1 for i in range ( n ) : for j in range ( n ) : if ( arr [ i ] == arr [ j ] ) : count = 0 for i in range ( n ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count > maxCount ) : maxCount = count index = i if maxCount > n / 2 : print ( arr [ index ] ) else : print ( "No Majority Element" )

64.31
51.31
78.73
78.57
static int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }

def nonFibonacci ( n ) : prevPrev = 1 prev = 2 curr = 3 while n > 0 : prevPrev = prev prev = curr curr = prevPrev + prev n = n - ( curr - prev - 1 ) n = n + ( curr - prev - 1 ) return prev + n

def nonFibonacci ( n ) : prevPrev = 1 prev = 2 curr = 3 while ( n > 0 ) : prevPrev = prev prev = prev + prev n = n - ( curr - prev - 1 ) return prev + n

def nonFibonacci ( n ) : prevPrev = 1 prev = 2 curr = 3 while n > 0 : prevPrev = prev prev = curr curr = prevPrev + prev n = n - ( curr - prev - 1 ) return prev + n

64.38
45.61
82.23
54.17
public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }

def countSetBits ( n ) : if ( n == 0 ) : return 0 else : return ( n & 1 ) + countSetBits ( n >> 1 )

def countSetBits ( n ) : if ( n == 0 ) : return 1 else : return countSetBits ( n >> 1 )

def countSetBits ( n ) : if n == 0 : return 0 else : return ( n & 1 ) + countSetBits ( n >> 1 )

64.5
54.55
57.84
49.85
int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }

def shortestPath ( graph , u , v , k ) : V = 4 INF = 999999999999 if k == 0 and u == v : return 0 if k == 1 and graph [ u ] [ v ] != INF : return graph [ u ] [ v ] if k <= 0 : return INF res = INF for i in range ( V ) : if graph [ u ] [ i ] != INF and u != i and v != i : rec_res = shortestPath ( graph , i , v , k - 1 ) if rec_res != INF : res = min ( res , graph [ u ] [ i ] + rec_res ) return res

def shortestPath ( graph , u , v , k ) : if ( u == v ) : return 0 if ( k == 1 and graph [ u ] [ v ] != INF : return graph [ u ] [ v ] if ( k <= 0 ) : return INF res = INF for i in range ( 0 , V ) : if ( graph [ u ] [ i ] != INF and u != i ) : res = min ( res , graph [ u ] [ i ] + rec_res ) if ( v != i ) : res = shortestPath ( graph , i , v , k - 1 ) : if ( rec_res != INF ) : res = min ( res , graph [ u ] [ i ] + rec_res ) return res

def shortestPath ( graph , u , v , k ) : if k <= 0 : return INF res = INF for i in range ( 0 , V , - 1 ) : if ( graph [ u ] [ i ] != INF and u != i and v != i ) : rec_res = shortestPath ( graph , i , v , k - 1 ) if ( rec_res != INF ) : res = min ( res , graph [ u ] [ i ] + rec_res ) return res

64.6
53.42
69.1
76.51
static int countSubsets ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < > ( ) ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ; even_count = us . size ( ) ; return ( int ) ( Math . pow ( 2 , even_count ) - 1 ) ; }

def countSubSets ( arr , n ) : us = set ( ) even_count = 0 for i in range ( n ) : if arr [ i ] % 2 == 0 : us . add ( arr [ i ] ) for i in us : even_count += 1 return pow ( 2 , even_count ) - 1

def countSubsets ( arr , n ) : us = set ( ) for i in range ( n ) : if ( arr [ i ] % 2 == 0 ) : us . add ( arr [ i ] ) even_count = us . size ( ) return ( int ) ( Math . pow ( 2 , even_count ) - 1 )

def countSubsets ( arr , n ) : us = list ( ) even_count = 0 for i in range ( n ) : if arr [ i ] % 2 == 0 : us . add ( arr [ i ] ) even_count = us . size ( ) return ( int ( math . pow ( 2 , even_count ) - 1 ) )

64.64
57.41
68.22
75.47
private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( "n Found at " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( "n Element not found" ) ; return ; }

def search ( mat , n , x ) : i = 0 j = n - 1 while ( i < n and j >= 0 ) : if ( mat [ i ] [ j ] == x ) : print ( "nFoundat" , i , "," , j ) return 1 if ( mat [ i ] [ j ] > x ) : j -= 1 else : i += 1 print ( "Elementnotfound" ) return 0

def search ( mat , n , x ) : i = 0 j = n - 1 while ( i < n && j >= 0 ) : if ( mat [ i ] [ j ] == x ) : j += 1 else : i += 1 if ( mat [ i ] [ j ] > x ) : j -= 1 else : i += 1 if ( mat [ i ] [ j ] < x ) : j -= 1 else : print ( "n Element not found" )

def search ( mat , n , x ) : i = 0 j = n - 1 while i < n and j >= 0 : if ( mat [ i ] [ j ] == x ) : if ( mat [ i ] [ j ] == x ) : return if ( mat [ i ] [ j ] > x ) : j -- i += 1 print ( "n Element not found" ) return

64.65
48.93
73.3
58.68
public static int lcs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }

def lcs ( X , Y ) : m = len ( X ) n = len ( Y ) L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] bi = bool for i in range ( m ) : bi = i & 1 for j in range ( n + 1 ) : if ( i == 0 or j == 0 ) : L [ bi ] [ j ] = 0 elif ( X [ i ] == Y [ j - 1 ] ) : L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 else : L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) return L [ bi ] [ n ]

def lcs ( X , Y ) : m , n = X . length ( ) , len = Y . length ( ) L = [ 2 ] [ n + 1 ] for i in range ( 0 , m , n ) : bi = i & 1 if ( X [ i ] == Y [ j - 1 ] ) : L [ bi ] [ j ] = L [ 1 - bi ] [ j ] + 1 else : L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ] L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j - 1 ] , L [ bi ] [ j - 1 ] ) return L [ bi ] [ n ]

def lcs ( X , Y ) : m = X . length n = Y . length bi = 0 for i in range ( m ) : bi = i & 1 for j in range ( 0 , n ) : if ( i == 0 or j == 0 ) : L [ bi ] [ j ] = 0 else : if ( X [ i - 1 ] == Y [ j - 1 ] ) : L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 else : L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) return L [ bi ] [ n ]

64.65
70.61
67.79
69.16
static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }

def countSubstrs ( str , i , j , n ) : if ( n == 1 ) : return 1 if ( n <= 0 ) : return 0 res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) if ( str [ i ] == str [ j ] ) : res += 1 return res

def countSubstrs ( str , i , j , n ) : if ( n == 0 ) : return 1 res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i + 1 , j - 1 , n - 2 ) if ( str [ i ] == str [ j ] ) : res += 1 return res

def countSubstrs ( str , i , j , n ) : res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i + 1 , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) if str [ i ] == str [ j ] : res += 1 return res

64.67
51.43
67.54
53.52
static int nCrModp ( int n , int r , int p ) { int C [ ] = new int [ r + 1 ] ; Arrays . fill ( C , 0 ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }

def nCrModp ( n , r , p ) : C = [ 0 for i in range ( r + 1 ) ] C [ 0 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( min ( i , r ) , 0 , - 1 ) : C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p return C [ r ]

def nCrModp ( n , r , p ) : C = [ 0 for k in range ( r ) ] for i in range ( 1 , n ) : for j in range ( 1 , r ) : C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p return C [ r ]

def nCrModp ( n , r , p ) : C = [ 0 for i in range ( 1 , n ) ] for i in range ( 1 , n ) : for j in range ( 1 , r ) : C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p return C [ r ]

64.68
51.13
76.87
58.97
public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }

def subset ( ar , n ) : res = 0 ar . sort ( ) for i in range ( 0 , n ) : count = 1 for i in range ( n - 1 ) : if ar [ i ] == ar [ i + 1 ] : count += 1 else : break res = max ( res , count ) return res

def subset ( ar , n ) : res = 0 for i in range ( 0 , n ) : if ( ar [ i ] == ar [ i + 1 ] ) : count = 1 else : break if ( ar [ i ] == ar [ i + 1 ] ) : count = 1 res = max ( res , count ) return res

def subset ( ar , n ) : res = 0 for i in range ( n ) : count = 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( ar [ i ] == ar [ i + 1 ] ) : count += 1 else : res = max ( res , count ) return res

64.7
53.49
100.0
100.0
public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }

def numberOfSquares ( base ) : base = ( base - 2 ) base = base / 2 return base * ( base + 1 ) / 2

def numberOfSquares ( base ) : base = ( base - 1 ) // 2 return base * ( base + 1 )

def numberOfSquares ( base ) : base = ( base - 2 ) base = base / 2 return base * ( base + 1 ) / 2

64.71
53.09
79.71
63.41
static int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }

def firstNonRepeating ( arr , n ) : for i in range ( n ) : j = 0 while ( j < n ) : if ( i != j and arr [ i ] == arr [ j ] ) : break j += 1 if ( j == n ) : return arr [ i ] return - 1

def firstNonRepeating ( arr , n ) : for i in range ( n ) : for j in range ( 0 , n ) : if ( arr [ i ] == arr [ j ] ) : break if ( j == n ) : return arr [ i ]

def firstNonRepeating ( arr , n ) : for i in range ( n ) : for j in range ( 0 , n ) : if ( i != j and arr [ i ] == arr [ j ] ) : break if ( j == n ) : return arr [ i ] return - 1

64.8
54.72
85.57
64.76
static int superSeq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

def superSeq ( X , Y , m , n ) : dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if ( not i ) : dp [ i ] [ j ] = j elif ( not j ) : dp [ i ] [ j ] = i elif ( X [ i - 1 ] == Y [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) return dp [ m ] [ n ]

def superSeq ( X , Y , m , n ) : dp = [ INT_MAX for i in range ( m + 1 , n + 1 ) ] for j in range ( 0 , n ) : if ( X [ i ] == Y [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j ] if ( j == 0 ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] if ( i == 0 ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) return dp [ m ] [ n ]

def superSeq ( X , Y , m , n ) : dp = [ 0 for i in range ( m + 1 , n + 1 ) ] for i in range ( m + 1 , n + 1 ) : for j in range ( n ) : if ( i == 0 ) : dp [ i ] [ j ] = j elif ( j == 0 ) : dp [ i ] [ j ] = i elif ( X [ i - 1 ] == Y [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) return dp [ m ] [ n ]

65.0
50.8
72.4
58.25
static int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }

def findMinDiff ( arr , n ) : arr = sorted ( arr ) diff = 10 ** 20 for i in range ( n - 1 ) : if arr [ i + 1 ] - arr [ i ] < diff : diff = arr [ i + 1 ] - arr [ i ] return diff

def findMinDiff ( arr , n ) : arr . sort ( reverse = True ) diff = float ( 'inf' ) for i in range ( 0 , n ) : if ( arr [ i + 1 ] - arr [ i ] < diff ) : diff = arr [ i + 1 ] - arr [ i ] return diff

def findMinDiff ( arr , n ) : diff = INT_MAX for i in range ( n ) : if arr [ i + 1 ] - arr [ i ] < diff : diff = arr [ i + 1 ] - arr [ i ] return diff

65.03
40.2
28.95
22.48
static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ; return true ; }

def isNumber ( s ) : for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) != True : return False return True

def isNumber ( s ) : for i in range ( len ( s ) ) : if ( s [ i ] == ' ' ) : return false return true

def isNumber ( s ) : if len ( s ) == 0 : return False return True

65.04
48.88
70.26
56.5
static void minheapify ( int [ ] a , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { int t = a [ small ] ; a [ small ] = a [ index ] ; a [ index ] = t ; minheapify ( a , small ) ; } }

def minheapify ( a , index ) : small = index l = 2 * index + 1 r = 2 * index + 2 if ( l < n and a [ l ] < a [ small ] ) : small = l if ( r < n and a [ r ] < a [ small ] ) : small = r if ( small != index ) : ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) minheapify ( a , small )

def minheapify ( a , index ) : n = len ( a ) small = index if ( l < n and a [ l ] < a [ small ] ) : small = l if ( r < n and a [ r ] < a [ small ] ) : small = r if ( l != index ) : t = a [ small ] a [ small ] = a [ index ] minheapify ( a , index ) else : a [ index ] = t min

def minheapify ( a , index ) : small = index l = 2 * index + 1 r = 2 * index + 2 if l < n and a [ l ] < a [ small ] : small = l if r < n and a [ r ] < a [ small ] : small = r if small != index : t = a [ small ] a [ small ] = a [ index ] a [ index ] = t minheapify ( a , small )

65.04
46.38
82.53
55.74
static long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }

def countWays ( n , k ) : total = k mod = 1000000007 same , diff = 0 , k for i in range ( 2 , n + 1 ) : same = diff diff = total * ( k - 1 ) diff = diff % mod total = ( same + diff ) % mod return total

def countWays ( n , k ) : total = k mod = 1000000007 for i in range ( 2 , n ) : same = diff diff = ( int ) total * ( k - 1 ) total = ( same + diff ) % mod return total

def countWays ( n , k ) : total = k mod = 1000000007 same = 0 diff = k for i in range ( 2 , n ) : same = diff diff = ( int ) total * ( k - 1 ) diff = diff % mod total = ( same + diff ) % mod return total

65.07
67.92
67.61
73.45
static int findLongestRepeatingSubSeq ( char X [ ] , int m , int n ) { if ( dp [ m ] [ n ] != - 1 ) { return dp [ m ] [ n ] ; } if ( m == 0 || n == 0 ) { return dp [ m ] [ n ] = 0 ; } if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) { return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ; } return dp [ m ] [ n ] = Math . max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) ; }

def findLongestRepeatingSubSeq ( X , m , n ) : if ( dp [ m ] [ n ] != - 1 ) : return dp [ m ] [ n ] if ( m == 0 or n == 0 ) : dp [ m ] [ n ] = 0 return dp [ m ] [ n ] if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 return dp [ m ] [ n ] dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) return dp [ m ] [ n ]

def findLongestRepeatingSubSeq ( dp , m , n ) : if dp [ m ] [ n ] != - 1 : return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m , n - 1 ) if dp [ m ] [ n ] != 0 : return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m , n - 1 ) if dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) + 1 else : return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 return dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 )

def findLongestRepeatingSubSeq ( X , m , n ) : if m == 0 or n == 0 : return dp [ m ] [ n ] = - 1 if m == 0 or n == 0 : return dp [ m ] [ n ] = 0 if X [ m - 1 ] == X [ n - 1 ] and m != n : return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 return dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) )

65.15
48.87
70.2
60.94
static int MaximumPath ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }

def MaximumPath ( Mat ) : result = 0 dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] for i in range ( N ) : for j in range ( 1 , N + 1 ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \ Mat [ i ] [ j - 1 ] for i in range ( N + 1 ) : result = max ( result , dp [ N - 1 ] [ i ] ) return result

def MaximumPath ( N , Mat ) : dp = [ 0 for row in range ( N ) ] for row in dp : rows = [ 0 for row in range ( N ) ] for row in range ( N ) : dp [ 0 ] [ i ] = max ( dp [ 0 ] [ i ] , dp [ i - 1 ] [ j - 1 ] ) + Mat [ i ] [ j + 1 ] dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] for j in range ( 1 , N ) : result = max ( result , dp [ N - 1 ] [ i ] ) return result

def MaximumPath ( Mat [ ] [ ] ) : dp = [ 0 for i in range ( N ) ] for rows in dp : for i in range ( 1 , N ) : dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] for i in range ( 1 , N ) : dp [ i ] [ j + 1 ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] for i in range ( 0 , N ) : result = max ( result , dp [ N - 1 ] [ i ] ) return result

65.21
47.86
81.92
64.02
static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }

def count ( n ) : if n < 3 : return n elif n >= 3 and n < 10 : return n - 1 po = 1 while n / po > 9 : po = po * 10 msd = n / po if msd != 3 : return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) else : return count ( msd * po - 1 )

def count ( n ) : if ( n < 2 ) : return n + 1 po = 1 while n >= 3 and n < 10 : po *= 10 n -= 1 msd = n / po if ( msd != 3 ) : return count ( msd ) * count ( po - 1 ) + count ( n % po ) else : return count ( msd ) * count ( po - 1 ) + count ( n % po )

def count ( n ) : if n < 3 : return n - 1 po = 1 while n > 9 : po = po * 10 msd = n / po if msd != 3 : return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) else : return count ( msd * po - 1 )

65.29
61.9
91.39
86.29
static boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }

def squareRootExists ( n , p ) : n = n % p for x in range ( 2 , p , 1 ) : if ( ( x * x ) % p == n ) : return True return False

def squareRootExists ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( n * n ) % p == n : return true

def squareRootExists ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( ( x * x ) % p == n ) : return True return False

65.36
61.59
62.38
53.08
static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }

def minDiff ( arr , n , k ) : result = + 2147483647 arr . sort ( ) for i in range ( n - k + 1 ) : result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) return result

def minDiff ( arr , n , k ) : result = float ( 'inf' ) for i in range ( 0 , n , k ) : result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) return result

def minDiff ( arr , n , k ) : result = INT_MAX for i in range ( n ) : result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) return result

65.36
49.63
63.86
55.31
static void groupElements ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { System . out . print ( arr [ i ] + " " ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { System . out . print ( arr [ i ] + " " ) ; visited [ j ] = true ; } } } } }

def groupElements ( arr , n ) : visited = [ False ] * n for i in range ( 0 , n ) : visited [ i ] = False for i in range ( 0 , n ) : if ( visited [ i ] == False ) : print ( arr [ i ] , end = "" ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] , end = "" ) visited [ j ] = True

def groupElements ( arr , n ) : visited = [ false for i in range ( n ) ] for i in range ( 0 , n ) : if ( arr [ i ] == arr [ j ] ) : visited [ j ] = true else : print ( arr [ i ] + " " ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : visited [ j ] = true else : print ( arr

def groupElements ( arr , n ) : visited = [ False for i in range ( n ) ] for i in range ( 0 , n ) : if not visited [ i ] : print ( arr [ i ] ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : visited [ j ] = True if not visited [ i ] : print ( arr [ i ] ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : visited [ j ] = True

65.37
57.63
35.3
22.8
static void sortit ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } }

def sortit ( arr , n ) : for i in range ( n ) : arr [ i ] = i + 1

def sortit ( arr , n ) : arr . sort ( reverse = True ) for i in range ( n ) : arr [ i ] = i + 1 return arr

def sortit ( arr , n ) : arr . sort ( reverse = True )

65.42
49.27
74.93
57.9
static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }

def maxProduct ( arr , n ) : if n < 3 : return - 1 max_product = - ( sys . maxsize - 1 ) for i in range ( 0 , n - 2 ) : for j in range ( i + 1 , n - 1 ) : for k in range ( j + 1 , n ) : max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) return max_product

def maxProduct ( arr , n ) : if ( n < 2 ) : return - 1 max_product = float ( 'inf' ) for i in range ( 0 , n - 2 , - 1 ) : for j in range ( 0 , n - 1 , - 1 ) : if ( arr [ i ] == arr [ j ] ) : max_product = max ( max_product , arr [ i ] * arr [ k ] ) return max_product

def maxProduct ( arr , n ) : max_product = float ( 'inf' ) for i in range ( n - 2 , - 1 , - 1 ) : for j in range ( i + 1 , n - 1 ) : for k in range ( j + 1 , n - 1 ) : max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) return max_product

65.45
60.46
61.45
63.18
static boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ; isPairFound = true ; } } } return isPairFound ; }

def printPairs ( arr , n , k ) : isPairFound = True for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i != j and arr [ i ] % arr [ j ] == k ) : print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , sep = "" , end = "" ) isPairFound = True return isPairFound

def printPairs ( arr , n , k ) : isPairFound = false for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( arr [ i ] % arr [ j ] == k ) : isPairFound = true break if ( arr [ i ] % arr [ j ] == k ) : print ( arr [ i ] , arr [ j ] ) isPairFound = true return isPairFound

def printPairs ( arr , n , k ) : isPairFound = True for i in range ( n ) : for j in range ( n ) : if i != j and arr [ i ] % arr [ j ] == k : print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" ) isPairFound = True return isPairFound

65.47
56.67
78.12
63.69
static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }

def findDiff ( arr , n ) : arr . sort ( ) count = 0 max_count = 0 min_count = n for i in range ( 0 , ( n - 1 ) ) : if arr [ i ] == arr [ i + 1 ] : count += 1 continue else : max_count = max ( max_count , count ) min_count = min ( min_count , count ) count = 0 return max_count - min_count

def findDiff ( arr , n ) : count = 0 max_count = 0 min_count = n for i in range ( n ) : if ( arr [ i ] == arr [ i + 1 ] ) : count += 1 continue if ( arr [ i ] == arr [ i + 1 ] ) : max_count = max ( max_count , count ) min_count = min ( min_count , count ) return ( max_count - min_count )

def findDiff ( arr , n ) : count = 0 max_count = 0 min_count = n for i in range ( n - 1 , - 1 , - 1 ) : if ( arr [ i ] == arr [ i + 1 ] ) : count += 1 continue else : max_count = max ( max_count , count ) min_count = min ( min_count , count ) count = 0 return ( max_count - min_count )

65.5
66.33
91.6
89.83
static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }

def printCountRec ( dist ) : if dist < 0 : return 0 if dist == 0 : return 1 return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) )

def printCountRec ( dist ) : if ( dist == 0 ) : return 0 return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 )

def printCountRec ( dist ) : if dist < 0 : return 0 if dist == 0 : return 1 return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 )

65.63
56.03
63.79
58.45
static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) S . add ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; ans = Math . max ( ans , j - arr [ i ] ) ; } } return ans ; }

def findLongestConseqSubseq ( arr , n ) : S = set ( ) for i in range ( n ) : S . add ( arr [ i ] ) ans = 0 for i in range ( n ) : if S . __contains__ ( arr [ i ] ) : j = arr [ i ] while ( S . __contains__ ( j ) ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans

def findLongestConseqSubseq ( arr , n ) : S = set ( ) for i in range ( 0 , n ) : if ( S . contains ( arr [ i ] ) ) : j = arr [ i ] while ( S . contains ( j ) ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans

def findLongestConseqSubseq ( arr , n ) : S = list ( ) for i in range ( n ) : if ( S . contains ( arr [ i ] ) ) : j = arr [ i ] while ( S . contains ( j ) ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans

65.69
56.39
77.18
73.6
static boolean isReversible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }

def isReversible ( str ) : i = 0 j = len ( str ) - 1 while ( i < j ) : if ( str [ i ] != str [ j ] ) : return False i += 1 j -= 1 return True

def isReversible ( str ) : i = 0 j = str . length ( ) - 1 while i < j : if ( str [ i ] != str [ j ] ) : return false i ++ j -= 1 return true

def isReversible ( str ) : i = 0 j = str . length - 1 while i < j : if ( str [ i ] != str [ j ] ) : return False i += 1 j -= 1 return True

65.71
66.7
63.79
68.31
static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }

def minSum ( n ) : sum = 0 while ( n > 0 ) : sum += ( n % 10 ) n //= 10 if ( sum == 1 ) : return 10 return sum

def minSum ( n ) : sum = 0 while ( n > 0 ) : sum += ( n % 10 ) n /= 10 return sum

def minSum ( n ) : sum = 0 while n > 0 : sum += ( n % 10 ) n /= 10 if sum == 1 : return 10 return sum

65.77
61.83
90.25
94.98
static int getAbs ( int n ) { int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ; return ( ( n + mask ) ^ mask ) ; }

def getAbs ( n ) : mask = n >> ( SIZE_INT * CHARBIT - 1 ) return ( ( n + mask ) ^ mask )

def getAbs ( n ) : mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) return ( n ^ mask )

def getAbs ( n ) : mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) return ( ( n + mask ) ^ mask )

65.91
71.12
65.11
69.5
static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }

def isTriangular ( num ) : if ( num < 0 ) : return False c = ( - 2 * num ) b , a = 1 , 1 d = ( b * b ) - ( 4 * a * c ) if ( d < 0 ) : return False root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) if ( root1 > 0 and math . floor ( root1 ) == root1 ) : return True if ( root2 > 0 and math . floor ( root2 ) == root2 ) : return True return False

def isTriangular ( num ) : num = float ( num ) b = 1 a = 1 d = ( b * b ) - ( 4 * a * c ) if ( d < 0 ) : return false root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) if ( root1 > 0 and Math . floor ( root1 ) == root1 ) : return true if ( root2 ) == root2 ) : return true else : return false

def isTriangular ( num ) : c = ( - 2 * num ) d = ( b * b ) - ( 4 * a * c ) if d < 0 : return False root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) if root1 > 0 and Math . floor ( root1 ) == root1 : return True if root2 > 0 and Math . floor ( root2 ) == root2 : return True return False

65.93
60.93
69.22
55.99
static int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }

def minElements ( arr , n ) : halfSum = 0 for i in range ( n ) : halfSum = halfSum + arr [ i ] halfSum = int ( halfSum / 2 ) arr . sort ( reverse = True ) res = 0 curr_sum = 0 for i in range ( n ) : curr_sum += arr [ i ] res += 1 if curr_sum > halfSum : return res return res

def minElements ( arr , n ) : halfSum = 0 for i in range ( n ) : halfSum = halfSum + arr [ i ] for i in range ( n ) : curr_sum = 0 res = 0 for i in range ( n - 1 , - 1 , - 1 ) : curr_sum += arr [ i ] res += curr_sum if ( curr_sum > halfSum ) : return res

def minElements ( arr , n ) : halfSum = 0 for i in range ( n ) : halfSum = halfSum + arr [ i ] halfSum = halfSum / 2 res = 0 , curr_sum = 0 for i in range ( n ) : curr_sum += arr [ i ] res += if ( curr_sum > halfSum ) : return res

66.04
50.44
71.44
53.53
static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind ; int val ; int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] == 1 ) { return val ; } } return - 1 ; }

def findMaxVal ( arr , n , num , maxLimit ) : ind = - 1 val = - 1 dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] for ind in range ( n ) : for val in range ( maxLimit + 1 ) : if ( ind == 0 ) : if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : dp [ ind ] [ val ] = 1 else : dp [ ind ] [ val ] = 0 else : if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : dp [ ind ] [ val ] = 1 elif ( val - arr [ ind ] >= 0 ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] elif ( val + arr [ ind ] <= maxLimit ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] else : dp [ ind ] [ val ] = 0 for val in range ( maxLimit , - 1 , - 1 ) : if ( dp [ n - 1 ] [ val ] == 1 ) : return val return - 1

def findMaxVal ( arr , n , num , maxLimit ) : dp = [ 0 for ind in range ( n ) ] for val in range ( 0 , maxLimit + 1 ) : if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) : dp [ ind ] [ val ] = 1 else : dp [ ind ] [ val ] = 0 if ( val - arr [ ind ] >= 0 and val + arr [ ind ] >= maxLimit ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] >= 0 : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : dp [ ind ] [ val ] = 1 else : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] <= maxLimit ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val ] = dp [ ind - 1 ] [ val ] = dp [ ind - 1 ] [ val ] = dp [ ind - 1 ] [ val + arr

def findMaxVal ( arr , n , num , maxLimit ) : dp = [ 0 for k in range ( n ) ] for ind in range ( n ) : if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : dp [ ind ] [ val ] = 1 elif ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : dp [ ind ] [ val ] = 1 elif ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : dp [ ind ] [ val ] = 1 else : if ( val - arr [ ind ] >= 0 ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] = else if ( val + arr [ ind ] <= maxLimit ) : dp [

66.09
50.44
69.15
49.27
static int compute ( int [ ] graph , int N ) { int count = 0 ; for ( int i = 1 ; i < 7 ; i ++ ) { if ( graph [ i ] == 0 ) count ++ ; } return count ; }

def compute ( graph , N ) : count = 0 for i in range ( 1 , N + 1 ) : if ( len ( graph [ i ] ) == 0 ) : count += 1 return count

def compute ( graph , N ) : count = 0 for i in range ( 1 , 7 ) : if ( graph [ i ] == 0 ) : count ++ return count

def compute ( graph , N ) : count = 0 for i in range ( 7 ) : if ( graph [ i ] == 0 ) : count += 1 return count

66.13
59.47
88.41
66.9
static double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }

def vol_of_dodecahedron ( side ) : return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) )

def vol_of_dodecahedron ( side ) : return ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( side ) )

def vol_of_dodecahedron ( side ) : return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) / 4 ) * ( Math pow ( side , 3 ) ) )

66.17
67.43
79.17
78.76
static int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }

def superSeq ( X , Y , m , n ) : if ( not m ) : return n if ( not n ) : return m if ( X [ m - 1 ] == Y [ n - 1 ] ) : return 1 + superSeq ( X , Y , m - 1 , n - 1 ) return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) )

def superSeq ( X , Y , m , n ) : if ( m == 0 ) : return n superSeq ( X , Y , m , n ) if ( Y [ m - 1 ] == X [ n - 1 ] ) : return 1 + superSeq ( X , Y , m - 1 , n ) return 1 + superSeq ( X , Y , m - 1 , n )

def superSeq ( X , Y , m , n ) : if m == 0 : return n if n == 0 : return m if X [ m - 1 ] == Y [ n - 1 ] : return 1 + superSeq ( X , Y , m - 1 , n ) return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) )

66.3
56.26
79.38
62.88
static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }

def pushZerosToEnd ( arr , n ) : count = 0 for i in range ( n ) : if arr [ i ] != 0 : arr [ count ] = arr [ i ] count += 1 while count < n : arr [ count ] = 0 count += 1

def pushZerosToEnd ( arr , n ) : count = 0 for i in range ( n ) : if ( arr [ i ] != 0 ) : arr [ count ++ ] = arr [ i ] while ( count < n ) arr [ count ++ ] = 0 return

def pushZerosToEnd ( arr , n ) : count = 0 for i in range ( n ) : if arr [ i ] != 0 : arr [ count ++ ] = arr [ i ] while count < n : arr [ count ++ ] = 0

66.33
49.05
81.06
60.97
static int countTrees ( int n ) { int BT [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BT [ i ] = 0 ; BT [ 0 ] = BT [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ; return BT [ n ] ; }

def countTrees ( n ) : BT = [ 0 ] * ( n + 1 ) BT [ 0 ] = BT [ 1 ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( i ) : BT [ i ] += BT [ j ] * BT [ i - j - 1 ] return BT [ n ]

def countTrees ( n ) : BT = [ 0 for i in range ( n ) ] for i in range ( 2 , n ) : BT [ i ] = 0 for j in range ( 0 , i + 1 , n ) : BT [ i ] += BT [ j ] * BT [ i - j - 1 ] return BT [ n ]

def countTrees ( n ) : BT = [ 0 for i in range ( n ) ] BT [ 0 ] = BT [ 1 ] = 1 for i in range ( 2 , n ) : for j in range ( i , 2 ) : BT [ i ] += BT [ j ] * BT [ i - j - 1 ] return BT [ n ]

66.35
48.46
12.13
17.09
static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }

def maxOnesIndex ( arr , n ) : max_count = 0 max_index = 0 prev_zero = - 1 prev_prev_zero = - 1 for curr in range ( n ) : if ( arr [ curr ] == 0 ) : if ( curr - prev_prev_zero > max_count ) : max_count = curr - prev_prev_zero max_index = prev_zero prev_prev_zero = prev_zero prev_zero = curr if ( n - prev_prev_zero > max_count ) : max_index = prev_zero return max_index

def maxOnesIndex ( arr , n ) : max_count = 0 max_index = 0 prev_zero = - 1 for curr in range ( n ) : if ( arr [ curr ] == 0 ) : max_count = curr - prev_prev_zero max_index = prev_zero prev_zero = curr elif ( arr [ curr ] == 0 ) : max_count = curr - prev_prev_zero > max_count : max_count =

def maxOnesIndex ( arr , n ) : max_count = 0 max_index = 0 prev_zero = - 1 prev_prev_zero = curr prev_zero = curr return max_index

66.4
51.38
100.0
100.0
static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }

def swapBits ( x , p1 , p2 , n ) : set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) xor = ( set1 ^ set2 ) xor = ( xor << p1 ) | ( xor << p2 ) result = x ^ xor return result

def swapBits ( x , p1 , p2 , n ) : set1 = ( x >> p1 ) & ( 1 << n ) - 1 set2 = ( x >> p2 ) & ( 1 << n ) - 1 xor = ( set1 ^ set2 ) result = x ^ xor return result

def swapBits ( x , p1 , p2 , n ) : set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) xor = ( set1 ^ set2 ) xor = ( xor << p1 ) | ( xor << p2 ) result = x ^ xor return result

66.4
50.13
71.67
51.96
static String decodeMedianString ( String s ) { int l = s . length ( ) ; String s1 = "" ; boolean isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }

def decodeMedianString ( s ) : l = len ( s ) s1 = "" if ( l % 2 == 0 ) : isEven = True else : isEven = False for i in range ( 0 , l , 2 ) : if ( isEven ) : s1 = s [ i ] + s1 s1 += s [ i + 1 ] else : if ( l - i > 1 ) : s1 += s [ i ] s1 = s [ i + 1 ] + s1 else : s1 += s [ i ] return s1

def decodeMedianString ( s ) : l = len ( s ) s1 = "" for i in range ( 0 , l ) : if ( l - i > 1 ) : s1 += s [ i ] s1 = s [ i + 1 ] else : s1 += s [ i ] s1 = s [ i + 1 ] if ( l - i > 1 ) : s1 = s [ i ] + s1 s1 = s [ i +

def decodeMedianString ( s ) : s1 = "" isEven = ( l % 2 == 0 ) for i in range ( 0 , l ) : if isEven : s1 = s [ i ] + s1 s1 += s [ i + 1 ] else : if ( l - i > 1 ) : s1 += s [ i ] s1 = s [ i + 1 ] + s1 else : s1 += s [ i ] return s1

66.43
56.93
85.17
83.66
static int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }

def binomialCoeff ( n , k ) : if k == 0 or k == n : return 1 return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k )

def binomialCoeff ( n , k ) : if ( k == 0 ) : return binomialCoeff ( n - 1 , k - 1 ) return binomialCoeff ( n - 1 , k - 1 )

def binomialCoeff ( n , k ) : if k == 0 : return 1 return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k )

66.45
50.33
62.29
51.55
static void reorder ( ) { for ( int i = 0 ; i < arr . length ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = ( char ) arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }

def reorder ( arr , index , n ) : for i in range ( 0 , n ) : while ( index [ i ] != i ) : oldTargetI = index [ index [ i ] ] oldTargetE = arr [ index [ i ] ] arr [ index [ i ] ] = arr [ i ] index [ index [ i ] ] = index [ i ] index [ i ] = oldTargetI arr [ i ] = oldTargetE

def reorder ( ) : index = [ 0 for i in range ( len ( arr ) ) ] for i in range ( len ( arr ) ) : while ( index [ i ] != i ) : oldTargetI = index [ index [ i ] ] oldTargetE = index [ i ] arr [ index [ i ] ] = index [ i ] index [ i ] = oldTargetI arr [ i ] = oldTargetE index [ i ] = i oldTargetI =

def reorder ( arr ) : for i in range ( len ( arr ) ) : while index [ i ] != i : while index [ i ] != i : oldTargetI = index [ index [ i ] ] ; char oldTargetE = ( char ) arr [ index [ i ] ] arr [ index [ i ] ] = arr [ i ] index [ i ] = index [ i ] index [ i ] = oldTargetI arr [ i ] = oldTargetE index [ i ] = oldTargetI arr [ i ] = oldTargetE

66.5
51.1
78.18
48.66
void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int prod [ ] = new int [ n ] ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) prod [ i ] = left [ i ] * right [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " " ) ; return ; }

def productArray ( arr , n ) : if ( n == 1 ) : print ( 0 ) return left = [ 0 ] * n right = [ 0 ] * n prod = [ 0 ] * n left [ 0 ] = 1 right [ n - 1 ] = 1 for i in range ( 1 , n ) : left [ i ] = arr [ i - 1 ] * left [ i - 1 ] for j in range ( n - 2 , - 1 , - 1 ) : right [ j ] = arr [ j + 1 ] * right [ j + 1 ] for i in range ( n ) : prod [ i ] = left [ i ] * right [ i ] for i in range ( n ) : print ( prod [ i ] , end = '' )

def productArray ( arr , n ) : n = arr . length left = [ 0 for k in range ( n ) ] right = [ 0 for k in range ( n ) ] prod = [ 0 for k in range ( n ) ] for i in range ( n ) : left [ i ] = arr [ i - 1 ] * left [ i - 1 ] for j in range ( n - 2 , - 1 , - 1 ) : right [ j ] = arr [ j + 1 ] * right [ j + 1 ] if ( i == n ) : print ( prod [ i ] + " " ) return ; } for i in range ( 0 , n ) : prod [ i ] = left [ i ] * right [ i ] for i in range ( 0 , n ) : print ( prod [ i ] + " " ) return

def productArray ( arr , n ) : left = [ 1 for i in range ( n ) ] right = [ 1 for i in range ( n ) ] prod = [ 1 for i in range ( n ) ] left [ 0 ] = 1 right [ n - 1 ] = 1 for i in range ( 1 , n ) : left [ i ] = arr [ i - 1 ] * left [ i - 1 ] for j in range ( n - 2 , - 1 ) : right [ j ] = arr [ j + 1 ] * right [ j + 1 ] for i in range ( 0 , n ) : prod [ i ] = left [ i ] * right [ i ] for i in range ( 0 , n ) : print ( prod [ i ] )

66.53
44.22
61.87
37.17
static int findLastIndex ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }

def findLastIndex ( str , x ) : for i in range ( len ( str ) - 1 , - 1 , - 1 ) : if ( str [ i ] == x ) : return i return - 1

def findLastIndex ( str , x ) : for i in range ( len ( str ) ) : if ( str [ i ] == x ) : return i

def findLastIndex ( str , x ) : for i in range ( len ( str ) ) : if str [ i ] == x : return i return - 1

66.59
63.49
100.0
100.0
static int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }

def binomialCoeffSum ( n ) : return ( 1 << n )

def binomialCoeffSum ( n ) : return 1 << n

def binomialCoeffSum ( n ) : return ( 1 << n )

66.61
61.34
59.67
47.82
static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; }

def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 digits = 0 for i in range ( 2 , n + 1 ) : digits += math . log10 ( i ) return math . floor ( digits ) + 1

def findDigits ( n ) : if ( n == 0 ) : return 0 if n <= 1 : return 1 digits = 0 for i in range ( 2 , n ) : digits += Math . log10 ( i ) return ( int ) ( digits ) + 1

def findDigits ( n ) : if n < 0 : return 0 if n <= 1 : return 1 digits = 0 for i in range ( 2 , n ) : digits += log10 ( i ) return ( int ( floor ( digits ) ) + 1

66.63
60.58
100.0
100.0
static int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }

def MaximumHeight ( a , n ) : result = 1 for i in range ( 1 , n ) : y = ( i * ( i + 1 ) ) / 2 if ( y < n ) : result = i else : break return result

def MaximumHeight ( a , n ) : result = 1 for i in range ( 1 , n ) : if ( y < n ) : result = i else : break return result

def MaximumHeight ( a , n ) : result = 1 for i in range ( 1 , n ) : y = ( i * ( i + 1 ) ) / 2 if ( y < n ) : result = i else : break return result

66.65
62.55
75.53
70.87
static int numofAP ( int a [ ] , int n ) { int minarr = + 2147483647 ; int maxarr = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { minarr = Math . min ( minarr , a [ i ] ) ; maxarr = Math . max ( maxarr , a [ i ] ) ; } int dp [ ] = new int [ n ] ; int sum [ ] = new int [ MAX ] ; int ans = n + 1 ; for ( int d = ( minarr - maxarr ) ; d <= ( maxarr - minarr ) ; d ++ ) { Arrays . fill ( sum , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } } return ans ; }

def numofAP ( a , n ) : minarr = + 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( minarr , a [ i ] ) maxarr = max ( maxarr , a [ i ] ) dp = [ 0 for i in range ( n + 1 ) ] ans = n + 1 for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : sum = [ 0 for i in range ( MAX + 1 ) ] for i in range ( n ) : dp [ i ] = 1 if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : dp [ i ] += sum [ a [ i ] - d ] ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] return ans

def numofAP ( a , n ) : minarr = - 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( a [ i ] , n ) maxarr = max ( a [ i ] , n ) dp = [ 1 for i in range ( n ) ] sum = [ 0 for i in range ( minarr , maxarr ) ] for d in range ( minarr - maxarr ) : dp [ i ] += sum [ a [ i ] - d ] if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 : sum [ a [ i ] - d ] += sum [ a [ i ] - d ] ans = n + 1 ans += dp [ i ] - 1 ans += dp [ i ] sum [ a [ i ] - d ] return ans

def numofAP ( a , n ) : minarr = + 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( minarr , a [ i ] ) maxarr = max ( maxarr , a [ i ] ) dp = [ 1 for i in range ( n ) ] sum = [ MAX ] ans = n + 1 for d in ( minarr - maxarr ) : dp [ i ] = 1 if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : dp [ i ] += sum [ a [ i ] - d ] ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] return ans

66.73
53.57
66.67
52.72
static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }

def numberofways ( n , m ) : dp = np . zeros ( ( n + 2 , n + 2 ) ) dp [ 0 ] [ n + 1 ] = 1 for k in range ( n , m - 1 , - 1 ) : for i in range ( n + 1 ) : dp [ i ] [ k ] = dp [ i ] [ k + 1 ] if ( i - k >= 0 ) : dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) return dp [ n ] [ m ]

def numberofways ( n , m ) : dp = [ 0 for k in range ( n , m ) ] dp [ 0 ] [ n + 1 ] = dp [ 0 ] [ n + 1 ] for k in range ( n , m ) : dp [ i ] [ k ] = dp [ i ] [ k + 1 ] dp [ i ] [ k ] = dp [ i ] [ k + 1 ] if ( i - k >= 0 ) : dp [ i ] [ k ] = ( dp [ i ] [ k ] = dp [ i ] [ k ] + dp [ i - k ] [ k ] ) return dp [ n ] [ m ]

def numberofways ( n , m ) : dp [ ] = [ 1 for k in range ( n ) ] for k in range ( n , m ) : for i in range ( n , m ) : dp [ i ] [ k ] = dp [ i ] [ k + 1 ] if i - k >= 0 : dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) return dp [ n ] [ m ]

66.83
50.62
40.26
31.5
static void swapUpperToLower ( int arr [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

def swapUpperToLower ( arr ) : n = 4 ; for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; for i in range ( 0 , n ) : for j in range ( 0 , n ) : print ( arr [ i ] [ j ] , end = "" ) ; print ( "" ) ;

def swapUpperToLower ( arr , n ) : arr . sort ( reverse = True ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : arr [ i ] [ j ] = arr [ j ] [ i ] print ( arr [ i ] [ j ] , end = "" ) for i in range ( 0 , n ) : print ( arr [ i ] [ j ] , end = "" ) for j in range

def swapUpperToLower ( arr , [ ] ) : for i in range ( n ) : for j in range ( i + 1 , n ) : temp = arr [ i ] [ j ] arr [ i ] [ j ] = arr [ j ] [ i ] arr [ j ] [ i ] = temp

66.98
49.11
73.17
77.1
static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }

def evenFib ( n ) : if ( n < 1 ) : return n if ( n == 1 ) : return 2 return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )

def evenFib ( n ) : if ( n == 0 ) : return 2 return ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )

def evenFib ( n ) : if n < 1 : return n if n == 1 : return 2 return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 )

67.01
61.68
71.41
59.19
static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } System . out . println ( "Principal Diagonal:" + principal ) ; System . out . println ( "Secondary Diagonal:" + secondary ) ; }

def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i == j ) : principal += mat [ i ] [ j ] if ( ( i + j ) == ( n - 1 ) ) : secondary += mat [ i ] [ j ] print ( "PrincipalDiagonal:" , principal ) print ( "SecondaryDiagonal:" , secondary )

def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : if ( i == j ) : principal += mat [ i ] [ j ] if ( i + j ) == ( n - 1 ) : secondary += mat [ i ] [ j ] if ( i + j ) == ( n - 1 ) : secondary += mat [ i ] [ j ] if ( i + j ) == ( n -

def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( n ) : for j in range ( n ) : if ( i == j ) : principal += mat [ i ] [ j ] if ( i + j ) == ( n - 1 ) : secondary += mat [ i ] [ j ]

67.17
52.84
70.52
61.99
static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }

def numberOfPaths ( m , n ) : count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] for i in range ( m ) : count [ i ] [ 0 ] = 1 ; for j in range ( n ) : count [ 0 ] [ j ] = 1 ; for i in range ( 1 , m ) : for j in range ( n ) : count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] return count [ m - 1 ] [ n - 1 ]

def numberOfPaths ( m , n ) : count = [ 1 for i in range ( m , n ) ] for j in range ( 0 , n ) : count [ i ] [ j ] = 1 count [ 0 ] [ j ] = 1 for i in range ( 1 , m , n ) : count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] return count [ m - 1 ] [ n - 1 ]

def numberOfPaths ( m , n ) : count = [ 0 for i in range ( m ) ] for j in range ( 0 , n ) : count [ i ] [ 0 ] = 1 for i in range ( 1 , m ) : for j in range ( n ) : count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] return count [ m - 1 ] [ n - 1 ]

67.22
44.16
91.01
89.73
static int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }

def sequence ( n ) : if n == 1 or n == 2 : return 1 else : return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;

def sequence ( n ) : if ( n == 1 ) : return sequence ( n - 1 ) else : return sequence ( n - 1 ) + sequence ( n - sequence ( n - 1 ) )

def sequence ( n ) : if n == 1 or n == 2 : return 1 else : return sequence ( sequence ( n - sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) )

67.24
64.39
47.71
59.78
static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; System . out . print ( arr [ i ] + " " ) ; } }

def printDistinct ( arr , n ) : arr . sort ( ) for i in range ( n ) : if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : i += 1 else : print ( arr [ i ] , end = "" )

def printDistinct ( arr , n ) : arr . sort ( reverse = True ) i = 0 for i in range ( 0 , n ) : if ( arr [ i ] == arr [ i + 1 ] ) : i += 1 print ( arr [ i ] , end = "" ) if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : i += 1 print ( arr [ i ] , end = "" )

def printDistinct ( arr , n ) : arr . sort ( reverse = True ) for i in range ( n ) : while i < n - 1 and arr [ i ] == arr [ i + 1 ] : i += 1 print ( arr [ i ] )

67.41
44.4
100.0
75.0
static boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }

def isIdentity ( mat , N ) : for row in range ( N ) : for col in range ( N ) : if ( row == col and mat [ row ] [ col ] != 1 ) : return False elif ( row != col and mat [ row ] [ col ] != 0 ) : return False return True

def isIdentity ( mat , N ) : mat . sort ( reverse = True ) for row in range ( 0 , N ) : if ( row == col and mat [ row ] [ col ] != 1 ) : return false else : if ( row != col and mat [ row ] [ col ] != 0 ) : return false else : return true

def isIdentity ( mat , N ) : for row in range ( N ) : for col in range ( N ) : if ( row == col and mat [ row ] [ col ] != 1 ) : return False elif ( row != col and mat [ row ] [ col ] != 0 ) : return False return True

67.42
61.31
76.96
66.13
static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == t . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }

def maxPrefix ( s , t ) : count = 0 for i in range ( 0 , len ( t ) ) : if ( count == len ( s ) ) : break if ( t [ i ] == s [ count ] ) : count = count + 1 return count

def maxPrefix ( s , t ) : count = 0 for i in range ( len ( s ) ) : if ( t [ i ] == s [ count ] ) : count += 1 if ( t [ i ] == s [ count ] ) : count += 1 return count

def maxPrefix ( s , t ) : count = 0 for i in range ( len ( t ) ) : if ( count == t . length ( ) ) : break if ( t [ i ] == s [ count ] ) : count += 1 return count

67.59
68.33
100.0
100.0
static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }

def multiply ( A , B , C ) : for i in range ( N ) : for j in range ( N ) : C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]

def multiply ( N , A , B , C ) : C . sort ( reverse = True ) for i in range ( N ) : for j in range ( 0 , N ) : C [ i ] [ j ] *= A [ i ] [ j ] - B [ i ] [ j ] return

def multiply ( A , B , C ) : for i in range ( N ) : for j in range ( N ) : C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]

67.64
62.25
83.39
83.72
static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }

def minimumflip ( mat , n ) : flip = 0 for i in range ( n ) : for j in range ( i ) : if mat [ i ] [ j ] != mat [ j ] [ i ] : flip += 1 return flip

def minimumflip ( mat , n ) : flip = 0 for i in range ( 0 , n ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : flip ++ return flip

def minimumflip ( mat , n ) : flip = 0 for i in range ( n ) : for j in range ( i , n ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : flip += 1 return flip

67.76
51.56
73.39
55.4
static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for i in range ( m ) : for j in range ( n ) : if arr1 [ i ] + arr2 [ j ] == x : count = count + 1 return count

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for i in range ( 0 , m , n ) : if ( arr1 [ i ] + arr2 [ j ] ) == x : count += 1 return count

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for i in range ( m , n ) : for j in range ( 0 , n ) : if ( arr1 [ i ] + arr2 [ j ] ) == x : count += 1 return count

67.85
50.91
49.54
41.92
static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }

def findMaxAverage ( arr , n , k ) : if ( k > n ) : return - 1 sum = arr [ 0 ] for i in range ( 1 , k ) : sum += arr [ i ] max_sum = sum max_end = k - 1 for i in range ( k , n ) : sum = sum + arr [ i ] - arr [ i - k ] if ( sum > max_sum ) : max_sum = sum max_end = i return max_end - k + 1

def findMaxAverage ( arr , n , k ) : sum = 0 for i in range ( k , n ) : sum += arr [ i ] for i in range ( k , n ) : sum = sum + arr [ i ] - arr [ i - k ] max_sum = sum max_end = k - 1 if ( max_sum > max_sum ) : max_sum = sum max_end = i return - 1

def findMaxAverage ( arr , n , k ) : sum = arr [ 0 ] for i in range ( k ) : sum += arr [ i ] - arr [ i - k ] if ( sum > max_sum ) : max_sum = sum max_end = i return max_end - k + 1

67.95
47.67
81.63
59.65
static int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }

def countStrings ( n , k ) : dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] dp [ 1 ] [ 0 ] [ 0 ] = 1 dp [ 1 ] [ 0 ] [ 1 ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( k + 1 ) : dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] if j >= 1 : dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]

def countStrings ( n , k ) : dp = [ 2 , 1 ] * ( n + 1 ) + ( k + 1 ) dp [ 0 ] = 1 dp [ 1 ] [ 0 ] = 1 dp [ 1 ] [ 0 ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] dp [ i ] [ j ] [ 0 ] += dp [ i - 1 ] [ j ] [ 1 ] if ( j - 1 >= 0 ) : dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 1 ] dp [ n ] [ k ] [ 0 ] += dp [ n ] [ k ] [ 1 ] return dp [ n ] [ k ] [ 0 ]

def countStrings ( n , k ) : dp [ ] [ ] = [ 0 for i in range ( n ) ] dp [ 1 ] [ 0 ] [ 0 ] = 1 dp [ 1 ] [ 0 ] [ 1 ] = 1 for i in range ( 2 , n ) : for j in range ( i , k + 1 ) : dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] if j - 1 >= 0 : dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]

67.97
59.36
89.79
84.86
static int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }

def offeringNumber ( n , templeHeight ) : sum = 0 for i in range ( n ) : left = 0 right = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : left += 1 else : break for j in range ( i + 1 , n ) : if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : right += 1 else : break sum += max ( right , left ) + 1 return sum

def offeringNumber ( n , templeHeight ) : sum = 0 for i in range ( 0 , n ) : left = 0 right = 0 for j in range ( i + 1 , n ) : if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : ++ left else : break if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : ++ right sum += max ( right , left ) + 1 return sum

def offeringNumber ( n , templeHeight ) : sum = 0 for i in range ( n ) : left = 0 right = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : ++ left else : break for j in range ( i + 1 , n ) : if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : ++ right ; else : sum += max ( right , left ) + 1 return sum

68.02
54.95
67.0
49.51
static int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }

def chordCnt ( A ) : n = 2 * A dpArray = [ 0 ] * ( n + 1 ) dpArray [ 0 ] = 1 dpArray [ 2 ] = 1 for i in range ( 4 , n + 1 , 2 ) : for j in range ( 0 , i - 1 , 2 ) : dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) return int ( dpArray [ n ] )

def chordCnt ( A ) : n = 2 * A dpArray = [ 0 for i in range ( n ) ] for i in range ( 4 , n ) : dpArray [ i ] = 1 dpArray [ 2 ] = 1 for j in range ( i - 1 , n ) : dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) return dpArray [ n ]

def chordCnt ( A ) : dpArray = [ 1 for i in range ( n ) ] dpArray [ 0 ] = 1 dpArray [ 2 ] = 1 for i in range ( 4 , n , 2 ) : for j in range ( i - 1 , n ) : dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) return dpArray [ n ]

68.18
58.9
70.56
59.85
static int largest ( ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < arr . length ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }

def largest ( arr , n ) : max = arr [ 0 ] for i in range ( 1 , n ) : if arr [ i ] > max : max = arr [ i ] return max

def largest ( arr ) : max = arr [ 0 ] for i in range ( arr . length ) : if ( arr [ i ] > max ) max = arr [ i ] return max

def largest ( arr ) : max = arr [ 0 ] for i in range ( 1 , len ( arr ) ) : if ( arr [ i ] > max ) : max = arr [ i ] return max

68.19
59.36
71.08
58.72
static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }

def maxSum ( arr , n ) : cum_sum = 0 for i in range ( 0 , n ) : cum_sum += arr [ i ] curr_val = 0 for i in range ( 0 , n ) : curr_val += i * arr [ i ] res = curr_val for i in range ( 1 , n ) : next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) curr_val = next_val res = max ( res , next_val ) return res

def maxSum ( arr , n ) : cum_sum = 0 for i in range ( n ) : cum_sum += arr [ i ] curr_val = 0 for i in range ( n ) : curr_val += i * arr [ i ] cum_sum = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) res = max ( res , curr_val ) for i in range

def maxSum ( arr , n ) : cum_sum = 0 for i in range ( n ) : cum_sum += arr [ i ] curr_val = 0 res = curr_val for i in range ( 1 , n ) : next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) curr_val = next_val res = max ( res , next_val ) return res

68.3
54.96
84.12
63.84
static long countWays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }

def countWays ( n ) : dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] dp [ 0 ] [ 1 ] = 1 dp [ 1 ] [ 1 ] = 2 for i in range ( 2 , n + 1 ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]

def countWays ( n ) : dp = [ 0 , 1 ] * n dp [ 1 ] = [ 0 for i in range ( n ) ] for i in range ( 2 , n + 1 ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] return dp [ 0 ] [ n ]

def countWays ( n ) : dp = [ 1 for i in range ( 2 , n ) ] dp [ 0 ] [ 1 ] = 1 dp [ 1 ] [ 1 ] = 2 for i in range ( 2 , n ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]

68.33
53.02
77.33
61.58
static void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { System . out . println ( "Overflow" ) ; } else { System . out . println ( "Not in overflow state" ) ; } }

def overflow ( H , r , h , N , R ) : tank_cap = 3.14 * r * r * H water_vol = 3.14 * r * r * h balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R vol = water_vol + balls_vol if vol > tank_cap : print ( "Overflow" ) else : print ( "Notinoverflowstate" )

def overflow ( H , r , h , N , R ) : tank_cap = 3.14 * r * r * H water_vol = 3.14 * r * r * h * N * 3.14 * R * R * R R = N * ( 4 / 3 ) * 3.14 * R * R * R * R if ( vol > tank_cap ) : print ( "Overflow" ) ; else : print ( "Not in

def overflow ( H , r , h , N , R ) : water_vol = 3.14 * r * r * h balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R vol = water_vol + balls_vol if ( vol > tank_cap ) : print ( "Overflow" ) else : print ( "Not in overflow state" )

68.37
47.07
66.47
71.52
static boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }

def isSubsetSum ( set , n , sum ) : if ( sum == 0 ) : return True if ( n == 0 and sum != 0 ) : return False if ( set [ n - 1 ] > sum ) : return isSubsetSum ( set , n - 1 , sum ) return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] )

def isSubsetSum ( set , n , sum ) : if ( set [ n ] == sum ) : return isSubsetSum ( set , n - 1 , sum ) if ( set [ n - 1 ] < sum ) : return isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) else : return isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] )

def isSubsetSum ( set , n , sum ) : if sum == 0 : return True if n == 0 and sum != 0 : return False if set [ n - 1 ] > sum : return isSubsetSum ( set , n - 1 , sum ) return isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] )

68.4
41.49
100.0
75.0
static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }

def isSymmetric ( mat , N ) : for i in range ( N ) : for j in range ( N ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : return False return True

def isSymmetric ( mat , N ) : mat . sort ( reverse = True ) for i in range ( 0 , N ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : return false return true

def isSymmetric ( mat , N ) : for i in range ( N ) : for j in range ( N ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : return False return True

68.47
55.72
73.13
49.44
public static int calculateSum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = Integer . parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = Integer . parseInt ( s ) ; char operation = arr [ i - 1 ] . charAt ( 0 ) ; if ( operation == '+' ) sum += value ; else sum -= value ; } return sum ; }

def calculateSum ( arr , n ) : if ( n == 0 ) : return 0 s = arr [ 0 ] value = int ( s ) sum = value for i in range ( 2 , n , 2 ) : s = arr [ i ] value = int ( s ) operation = arr [ i - 1 ] [ 0 ] if ( operation == '+' ) : sum += value else : sum -= value return sum

def calculateSum ( arr , n ) : if ( n == 0 ) : return 0 for i in range ( 2 , n ) : s = arr [ i ] value = Integer . parseInt ( s ) operation = arr [ i - 1 ] [ 0 ] if ( operation == '+' ) sum += value else : sum -= value return sum

def calculateSum ( arr , n ) : s = arr [ 0 ] value = float ( s ) sum = value for i in range ( 2 , n + 2 ) : s = arr [ i ] value = float ( s ) operation = arr [ i ] [ 0 ] if ( operation == '+' ) : sum += value else : sum -= value return sum

68.51
52.86
64.33
55.04
static int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }

def maxDiff ( arr , n ) : result = 0 arr . sort ( ) for i in range ( n - 1 ) : if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : result += abs ( arr [ i ] ) else : pass if ( arr [ n - 2 ] != arr [ n - 1 ] ) : result += abs ( arr [ n - 1 ] ) return result

def maxDiff ( arr , n ) : result = 0 for i in range ( 0 , n ) : if ( arr [ i ] != arr [ i + 1 ] ) : result += Math . abs ( arr [ i ] ) else : i += 1 if ( arr [ n - 2 ] != arr [ n - 1 ] ) : result += Math . abs ( arr [ n - 1 ] ) : return result

def maxDiff ( arr , n ) : result = 0 for i in range ( n ) : if arr [ i ] != arr [ i + 1 ] : result += abs ( arr [ i ] ) else : i += 1 if arr [ n - 2 ] != arr [ n - 1 ] : result += abs ( arr [ n - 1 ] ) return result

68.55
54.07
77.89
66.07
static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }

def countFriendsPairings ( n ) : dp = [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) : if ( i <= 2 ) : dp [ i ] = i else : dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] return dp [ n ]

def countFriendsPairings ( n ) : dp = [ 0 for i in range ( n ) ] for i in range ( 0 , n + 1 ) : dp [ i ] = i if ( i <= 2 ) : dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] else : dp [ i ] = dp [ i - 1 ] + dp [ i - 1 ]

def countFriendsPairings ( n ) : dp = [ INT_MAX for i in range ( n ) ] for i in range ( n + 1 , - 1 , - 1 ) : if ( i <= 2 ) : dp [ i ] = i elif ( i <= 3 ) : dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] return dp [ n ]

68.56
73.49
72.38
57.21
static String lexsmallest ( String a [ ] , int n ) { sort ( a , n ) ; String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }

def lexSmallest ( a , n ) : a . sort ( reverse = True ) answer = "" for i in range ( n ) : answer += a [ i ] return answer

def lexsmallest ( a , n ) : a . sort ( reverse = True ) answer = "" for i in range ( 0 , n ) : answer += a [ i ] if ( answer != "" ) : return answer

def lexsmallest ( a , n ) : sort ( a , n ) answer = "" for i in range ( n ) : answer += a [ i ] return answer

68.62
60.11
72.01
75.6
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 us = set ( ) for i in range ( m ) : us . add ( arr1 [ i ] ) for j in range ( n ) : if x - arr2 [ j ] in us : count += 1 return count

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for i in range ( 0 , m , n ) : us . add ( arr1 [ i ] ) for j in range ( 0 , n ) : if ( us . contains ( x - arr2 [ j ] ) ) : count += 1 return count

def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 us = list ( ) for i in range ( m , n ) : us . add ( arr1 [ i ] ) for j in range ( 0 , n ) : if ( us . contains ( x - arr2 [ j ] ) ) : count += 1 return count

68.7
55.69
82.3
57.94
static int editDistDP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

def editDistDP ( str1 , str2 , m , n ) : dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if i == 0 : dp [ i ] [ j ] = j elif j == 0 : dp [ i ] [ j ] = i elif str1 [ i - 1 ] == str2 [ j - 1 ] : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) return dp [ m ] [ n ]

def editDistDP ( str1 , str2 , m , n ) : dp = [ INT_MAX for i in range ( m + 1 , n + 1 ) ] for j in range ( 0 , n ) : if ( i == 0 ) : dp [ i ] [ j ] = j elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] = min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j - 1 ] ) return dp [ m ] [ n ]

def editDistDP ( str1 , str2 , m , n ) : dp [ ] [ ] = [ 0 for i in range ( m + 1 , n + 1 ) ] for i in range ( m + 1 , n + 1 ) : if ( i == 0 ) : dp [ i ] [ j ] = j elif ( j == 0 ) : dp [ i ] [ j ] = i elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) return dp [ m ] [ n ]

68.77
58.45
77.82
66.08
static int countP ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }

def countP ( n , k ) : dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( k + 1 ) : dp [ 0 ] [ k ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : if ( j == 1 or i == j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) return dp [ n ] [ k ]

def countP ( n , k ) : dp = [ INT_MAX for i in range ( n + 1 , k + 1 ) ] for i in range ( 1 , n + 1 , k + 1 ) : dp [ i ] = [ INT_MAX for j in range ( 1 , k ) ] for i in range ( 1 , n ) : if ( j == 1 || i == j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] return dp [ n ] [ k ]

def countP ( n , k ) : dp = [ 0 for i in range ( n ) ] for k in range ( n + 1 , k + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( 0 , n ) : dp [ i ] [ k ] = 0 for i in range ( 1 , n ) : for j in range ( 1 , k ) : if ( j == 1 or i == j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] return dp [ n ] [ k ]

68.86
59.81
58.29
56.56
public static void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( "Count of pairs is %d" , count ) ; }

def getPairsCount ( arr , n , sum ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if arr [ i ] + arr [ j ] == sum : count += 1 return count

def getPairsCount ( arr , sum ) : count = 0 for i in range ( len ( arr ) ) : for j in range ( i + 1 , len ( arr ) ) : if ( arr [ i ] + arr [ j ] ) == sum : count += 1 return

def getPairsCount ( arr , sum ) : count = 0 for i in range ( len ( arr ) ) : for j in range ( i + 1 , len ( arr ) ) : if ( arr [ i ] + arr [ j ] ) == sum : count += 1 print ( "Count of pairs is %d" , count )

68.9
56.18
64.09
52.35
static int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }

def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 res = 0 sum = 0 for i in range ( position , length ) : sum = sum + int ( num [ i ] ) if ( sum >= previous_sum ) : res = res + countGroups ( i + 1 , sum , length , num ) return res

def countGroups ( position , previous_sum , length , num ) : res = 0 sum = 0 for i in range ( position , length ) : sum += ( num [ i ] - '0' ) if ( sum >= previous_sum ) : res += countGroups ( i + 1 , sum , length , num ) return res

def countGroups ( position , previous_sum , length , num ) : sum = 0 for i in range ( position , length ) : sum += ( num [ i ] - '0' ) if ( sum >= previous_sum ) : res += countGroups ( i + 1 , sum , length , num ) return res

69.24
54.97
77.52
61.73
static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }

def count ( n ) : table = [ 0 for i in range ( n + 1 ) ] table [ 0 ] = 1 for i in range ( 3 , n + 1 ) : table [ i ] += table [ i - 3 ] for i in range ( 5 , n + 1 ) : table [ i ] += table [ i - 5 ] for i in range ( 10 , n + 1 ) : table [ i ] += table [ i - 10 ] return table [ n ]

def count ( n ) : table = [ 0 for k in range ( n ) ] for i in range ( n + 1 , 10 ) : table [ i ] = table [ i - 1 ] for i in range ( 3 , n ) : table [ i ] += table [ i - 3 ] for i in range ( 5 , n ) : table [ i ] += table [ i - 5 ] return table [ n ]

def count ( n ) : table = [ 0 for i in range ( n ) ] for i in range ( 3 , n ) : table [ i ] += table [ i - 3 ] for i in range ( 5 , n ) : table [ i ] += table [ i - 5 ] for i in range ( 10 , n ) : table [ i ] += table [ i - 10 ] return table [ n ]

69.4
57.8
93.28
75.58
static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; }

def Dragon_Curve_Sequence ( n ) : s = "1" for i in range ( 2 , n + 1 ) : temp = "1" prev = '1' zero = '0' one = '1' for j in range ( len ( s ) ) : temp += s [ j ] if ( prev == '0' ) : temp += one prev = one else : temp += zero prev = zero s = temp return s

def Dragon_Curve_Sequence ( n ) : s = "1" for i in range ( 2 , n ) : s += s [ i ] prev = '1' one = '1' for j in range ( 2 , n ) : temp = "1" prev = '1' for j in range ( 0 , len ( s ) ) : temp += s [ j ] if ( prev == '0' ) : temp += one prev = zero s =

def Dragon_Curve_Sequence ( n ) : s = "1" for i in range ( 2 , n ) : temp = "1" prev = '1' zero = '0' one = '1' for j in range ( 0 , len ( s ) ) : temp += s [ j ] if ( prev == '0' ) : temp += one prev = one else : temp += zero prev = zero s = temp return s

69.42
77.29
95.81
83.97
static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }

def constructArr ( arr , pair , n ) : arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 for i in range ( 1 , n ) : arr [ i ] = pair [ i - 1 ] - arr [ 0 ]

def constructArr ( arr , pair , n ) : arr [ 0 ] = pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 for i in range ( 1 , n ) : arr [ i ] = pair [ i - 1 ] - arr [ 0 ] return arr

def constructArr ( arr , pair , n ) : arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 for i in range ( 1 , n ) : arr [ i ] = pair [ i - 1 ] - arr [ 0 ]

69.46
64.89
63.49
72.59
static void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case 'G' : cntG ++ ; result += C ; break ; case 'F' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; }

def countSubsequence ( s , n ) : cntG = 0 cntF = 0 result = 0 C = 0 for i in range ( n ) : if ( s [ i ] == 'G' ) : cntG += 1 result += C continue if ( s [ i ] == 'F' ) : cntF += 1 C += cntG continue else : continue print ( result )

def countSubsequence ( s , n ) : cntG = 0 cntF = 0 result = 0 C = 0 for i in range ( n ) : switch ( s [ i ] ) : case 'G' : cntG += 1 result += C break if ( s [ i ] == 'F' ) : cntF += 1 C += cntG break if ( s [ i ] == 'G' ) : cntG += 1 result += cntF break if ( s

def countSubsequence ( s , n ) : cntG = 0 cntF = 0 result = 0 C = 0 for i in range ( n ) : switch ( s [ i ] ) : case 'G' : cntG += 1 result += C break case 'F' : cntF += 1 C += cntG break else : continue

69.46
53.38
64.58
52.54
static int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; }

def maxSubsequenceSubstring ( x , y , n , m ) : dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if ( x [ j - 1 ] == y [ i - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ans = 0 for i in range ( 1 , m + 1 ) : ans = max ( ans , dp [ i ] [ n ] ) return ans

def maxSubsequenceSubstring ( x , y , n , m ) : dp = [ 0 for i in range ( len ( x ) ) ] for j in range ( 0 , n , m ) : if ( x [ j - 1 ] == y [ i - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] if ( x [ j - 1 ] == y [ i - 1 ] == x [ j - 1 ] ) : ans = max ( ans , dp [ i ] [ n ] ) return ans

def maxSubsequenceSubstring ( x , y , n , m ) : dp = [ MAX ] [ MAX ] for i in range ( 1 , m , - 1 ) : dp [ i ] [ j ] = 0 for i in range ( 1 , m , - 1 ) : if ( x [ j - 1 ] == y [ i - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] return ans

69.6
50.23
73.29
74.4
public static void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }

def rearrange ( arr , n ) : max_idx = n - 1 min_idx = 0 max_elem = arr [ n - 1 ] + 1 for i in range ( 0 , n ) : if i % 2 == 0 : arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem max_idx -= 1 else : arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem min_idx += 1 for i in range ( 0 , n ) : arr [ i ] = arr [ i ] / max_elem

def rearrange ( arr , n ) : max_idx = n - 2 min_idx = 0 max_elem = arr [ n - 1 ] + 1 arr [ max_idx ] = arr [ max_idx ] / max_elem max_idx -= 1 for i in range ( 0 , n ) : arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem min_idx += 1 arr [ i ] = arr [ i ] / max_elem if ( i % 2 == 0 ) : arr [ i ] = arr [ i ] / max_elem return arr [ n - 1 ]

def rearrange ( arr , n ) : max_idx = n - 1 min_idx = 0 max_elem = arr [ n - 1 ] + 1 for i in range ( n ) : if i % 2 == 0 : arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem max_idx -= 1 else : arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem min_idx += 1

69.7
58.97
68.59
54.21
static int xorZero ( String s ) { int one_count = 0 , zero_count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }

def xorZero ( str ) : one_count = 0 zero_count = 0 n = len ( str ) for i in range ( 0 , n , 1 ) : if ( str [ i ] == '1' ) : one_count += 1 else : zero_count += 1 if ( one_count % 2 == 0 ) : return zero_count return one_count

def xorZero ( s ) : one_count = 0 zero_count = 0 for i in range ( n ) : if ( str [ i ] == '1' ) : one_count += 1 elif ( str [ i ] == '0' ) : zero_count += 1 if ( one_count % 2 == 0 ) : return zero_count return one_count

def xorZero ( s ) : one_count = 0 zero_count = 0 str = list ( ) n = str . length for i in range ( 0 , n ) : if ( str [ i ] == '1' ) : one_count += 1 else : zero_count += ( one_count // 2 ) if ( one_count % 2 == 0 ) : return zero_count return one_count

69.81
48.82
81.28
86.78
static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }

def countSetBits ( n ) : count = 0 while ( n ) : count += n & 1 n >>= 1 return count

def countSetBits ( n ) : count = 0 n >>= 1 while ( n > 0 ) : count += n & 1

def countSetBits ( n ) : count = 0 while n > 0 : count += n & 1 n >>= 1 return count

69.82
55.17
60.96
54.24
static int MinOperation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }

def MinOperation ( a , b , n ) : a . sort ( reverse = False ) b . sort ( reverse = False ) result = 0 for i in range ( 0 , n , 1 ) : if ( a [ i ] > b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) elif ( a [ i ] < b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) return result

def MinOperation ( a , b , n ) : a . sort ( ) b . sort ( ) result = 0 for i in range ( 0 , n ) : if ( a [ i ] > b [ i ] ) : result = result + Math . abs ( a [ i ] - b [ i ] ) else : result = result + Math . abs ( a [ i ] - b [ i ] ) return result

def MinOperation ( a , b , n ) : a . sort ( a ) b . sort ( ) result = 0 for i in range ( n ) : if ( a [ i ] > b [ i ] ) : result = result + Math . abs ( a [ i ] - b [ i ] ) else : if ( a [ i ] < b [ i ] ) : result = result + Math . abs ( a [ i ] - b [ i ] ) else : if ( a [ i ] > b [ i ] ) : result = result + Math . abs ( a [ i ] - b [ i ] ) return result

69.87
54.92
72.77
69.96
static int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int ans = 1 ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }

def maxLevel ( boxes , n ) : boxes . sort ( ) ans = 1 prev_width = boxes [ 0 ] prev_count = 1 curr_count = 0 curr_width = 0 for i in range ( 1 , n ) : curr_width += boxes [ i ] curr_count += 1 if ( curr_width > prev_width and curr_count > prev_count ) : prev_width = curr_width prev_count = curr_count curr_count = 0 curr_width = 0 ans += 1 return ans

def maxLevel ( boxes , n ) : ans = 1 prev_width = 0 prev_count = 1 curr_count = 0 curr_width = 0 for i in range ( n ) : curr_width += boxes [ i ] curr_count += 1 if ( curr_width > prev_width && curr_count > prev_count ) : prev_width = curr_width prev_count = curr_count curr_width = 0 ans += 1 return ans

def maxLevel ( boxes , n ) : ans = 1 prev_width = boxes [ 0 ] prev_count = 1 curr_count = 1 curr_width = 0 for i in range ( 1 , n ) : curr_width += boxes [ i ] curr_count += 1 if ( curr_width > prev_width and curr_count > prev_count ) : prev_width = curr_width prev_count = curr_count curr_count = 0 ans += 1 if ( curr_width > prev_width and curr_count > prev_count ) : prev_width = curr_width prev_count = curr_count curr_width = 0 ans += 1 return ans

69.94
57.94
65.02
57.28
static int minOps ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }

def minOps ( arr , n , k ) : max1 = max ( arr ) res = 0 for i in range ( 0 , n ) : if ( ( max1 - arr [ i ] ) % k != 0 ) : return - 1 else : res += ( max1 - arr [ i ] ) / k return int ( res )

def minOps ( arr , n , k ) : arr . sort ( reverse = True ) res = 0 for i in range ( 0 , n , k ) : if ( max - arr [ i ] ) % k != 0 : return - 1 else : res += ( max - arr [ i ] ) / k return res

def minOps ( arr , n , k ) : max = arr [ arr . length - 1 ] res = 0 for i in range ( n ) : if ( max - arr [ i ] ) % k != 0 : return - 1 else : res += ( max - arr [ i ] ) / k return res

69.99
57.86
76.9
62.07
public static int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }

def eulerian ( n , m ) : dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 0 , m + 1 ) : if ( i > j ) : if ( j == 0 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) return dp [ n ] [ m ]

def eulerian ( n , m ) : dp = [ 0 for i in range ( n , m ) ] for j in range ( 1 , n + 1 , m + 1 ) : if ( i > j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) return dp [ n ] [ m ]

def eulerian ( n , m ) : dp = [ 1 for i in range ( n ) ] for i in range ( 1 , n , m ) : for j in range ( 1 , m ) : if ( i > j ) : if ( j == 0 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) return dp [ n ] [ m ]

70.01
64.9
80.91
73.04
public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }

def checkcircle ( r , R , r1 , x1 , y1 ) : dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) return ( dis - r1 >= R and dis + r1 <= r )

def checkcircle ( r , R , r1 , x1 , y1 ) : dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) return dis >= R && dis + r1 <= r )

def checkcircle ( r , R , r1 , x1 , y1 ) : dis = ( float ( R ) ) * ( x1 * x1 + y1 * y1 ) return ( dis - r1 >= R and dis + r1 <= r )

70.17
57.31
82.15
67.99
public static long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }

def findWays ( f , d , s ) : mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] mem [ 0 ] [ 0 ] = 1 for i in range ( 1 , d + 1 ) : for j in range ( 1 , s + 1 ) : mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] if j - f - 1 >= 0 : mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] return mem [ d ] [ s ]

def findWays ( f , d , s ) : mem = [ 1 for i in range ( 1 , d , s ) ] for j in range ( 1 , d , s ) : mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] if ( j - f - 1 >= 0 ) : mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] if ( j - f - 1 >= 0 ) : mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] return mem [ d ] [ s ]

def findWays ( f , d , s ) : mem = [ 0 for i in range ( 1 , d + 1 , s ) ] mem [ 0 ] [ 0 ] = 1 for i in range ( 1 , d , s ) : for j in range ( i , s ) : mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] if ( j - f - 1 >= 0 ) : mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] return mem [ d ] [ s ]

70.19
58.32
64.6
54.17
static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }

def maxRevenue ( m , x , revenue , n , t ) : maxRev = [ 0 ] * ( m + 1 ) nxtbb = 0 for i in range ( 1 , m + 1 ) : if ( nxtbb < n ) : if ( x [ nxtbb ] != i ) : maxRev [ i ] = maxRev [ i - 1 ] else : if ( i <= t ) : maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) else : maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) nxtbb += 1 else : maxRev [ i ] = maxRev [ i - 1 ] return maxRev [ m ]

def maxRevenue ( m , x , revenue , n , t ) : maxRev = [ 0 for i in range ( m + 1 , n ) ] for i in range ( 1 , m + 1 , n ) : if ( x [ nxtbb ] != i ) : maxRev [ i ] = maxRev [ i - 1 ] else : maxRev [ i ] = maxRev [ i - 1 ] nxtbb = 0 for i in range ( 1 , n ) : if ( x [ nxtbb ] != i ) : if ( x [ nxtbb ] != i ) : maxRev [ i ] = maxRev [ i - 1 ] else : maxRev [ i ] = maxRev [ i - 1 ] + revenue [ nxtbb ] maxRev [ i ] = max ( maxRev [ i - 1 ] return maxRev [ m ]

def maxRevenue ( m , x , revenue , n , t ) : maxRev = [ 0 for i in range ( m + 1 , - 1 , - 1 ) ] nxtbb = 0 for i in range ( 1 , m + 1 ) : if ( nxtbb < n ) : if ( x [ nxtbb ] != i ) : maxRev [ i ] = maxRev [ i - 1 ] else : maxRev [ i ] = max ( maxRev [ i - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) nxtbb += 1 return maxRev [ m ]

70.26
59.96
75.06
65.06
static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }

def largestGCDSubsequence ( arr , n ) : ans = 0 maxele = max ( arr ) for i in range ( 2 , maxele + 1 ) : count = 0 for j in range ( n ) : if ( arr [ j ] % i == 0 ) : count += 1 ans = max ( ans , count ) return ans

def largestGCDSubsequence ( arr , n ) : ans = 0 for i in range ( 2 , n ) : if ( arr [ i ] % i == 0 ) : count = 0 for j in range ( n ) : if ( arr [ j ] % i == 0 ) : count = max ( count , count ) return ans

def largestGCDSubsequence ( arr , n ) : ans = 0 maxele = arrays . stream ( arr ) . max ( ) . getAsInt ( ) for i in range ( 2 , maxele ) : count = 0 for j in range ( n ) : if ( arr [ j ] % i == 0 ) : ++ count ans = max ( ans , count ) return ans

70.29
60.26
77.52
49.3
static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }

def maxSum ( arr , n ) : sum = 0 arr . sort ( ) for i in range ( 0 , int ( n / 2 ) ) : sum -= ( 2 * arr [ i ] ) sum += ( 2 * arr [ n - i - 1 ] ) return sum

def maxSum ( arr , n ) : sum = 0 for i in range ( n ) : sum -= ( 2 * arr [ i ] ) sum += ( 2 * arr [ n - i - 1 ] ) return sum

def maxSum ( arr , n ) : sum = 0 arrays . sort ( arr ) for i in range ( n // 2 ) : sum -= ( 2 * arr [ i ] ) sum += ( 2 * arr [ n - i - 1 ] ) return sum

70.3
65.37
73.47
52.24
public static int calculateEnergy ( int mat [ ] [ ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }

def calculateEnergy ( mat , n ) : tot_energy = 0 for i in range ( n ) : for j in range ( n ) : q = mat [ i ] [ j ] // n i_des = q j_des = mat [ i ] [ j ] - ( n * q ) tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) return tot_energy

def calculateEnergy ( mat , n ) : tot_energy = 0 for i in range ( n ) : for j in range ( n ) : q = mat [ i ] [ j ] / n i_des = q j_des = q tot_energy += abs ( i_des - i ) + abs ( j_des - j ) return tot_energy

def calculateEnergy ( mat , n ) : i_des , j_des , q tot_energy = 0 for i in range ( 0 , n ) : q = mat [ i ] [ j ] / n i_des = q j_des = mat [ i ] [ j ] - ( n * q ) tot_energy += abs ( i_des - i ) + Math . abs ( j_des - j ) return tot_energy

70.38
67.95
100.0
100.0
static int Circumference ( int l , int w ) { return ( 2 * ( l + w ) ) ; }

def Circumference ( l , w ) : return ( 2 * ( l + w ) )

def Circumference ( l , w ) : return ( l + w )

def Circumference ( l , w ) : return ( 2 * ( l + w ) )

70.51
69.86
81.76
73.7
static int maxTripletSum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }

def maxTripletSum ( arr , n ) : sm = - 1000000 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : for k in range ( j + 1 , n ) : if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : sm = arr [ i ] + arr [ j ] + arr [ k ] return sm

def maxTripletSum ( arr , n ) : sum = - 1000000 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) : sum = arr [ i ] + arr [ j ] + arr [ k ] : sum = arr [ i ] + arr [ j ] + arr [ k ] return sum

def maxTripletSum ( arr , n ) : sum = - 1000000 for i in range ( n ) : for j in range ( i + 1 , n ) : for k in range ( j + 1 , n ) : if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) : sum = arr [ i ] + arr [ j ] + arr [ k ] return sum

70.55
63.53
74.21
66.0
static int maxLen ( int arr [ ] , int n ) { int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ; } } return max_len ; }

def maxLen ( arr ) : max_len = 0 for i in range ( len ( arr ) ) : curr_sum = 0 for j in range ( i , len ( arr ) ) : curr_sum += arr [ j ] if curr_sum == 0 : max_len = max ( max_len , j - i + 1 ) return max_len

def maxLen ( arr , n ) : max_len = 0 for i in range ( 0 , n ) : curr_sum = 0 for j in range ( i + 1 , n ) : curr_sum += arr [ j ] if ( curr_sum == 0 ) : max_len = max ( max_len , j - i + 1 ) return max_len

def maxLen ( arr , n ) : max_len = 0 for i in range ( n ) : curr_sum = 0 for j in range ( i , n ) : curr_sum += arr [ j ] if ( curr_sum == 0 ) : max_len = max ( max_len , j - i + 1 ) return max_len

70.6
56.52
72.11
54.77
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " Invalid Input " ) ; return ; } int first = arr [ 0 ] , second = Integer . MIN_VALUE , third = Integer . MIN_VALUE ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } System . out . printf ( "The third Largest element is %d\n" , third ) ; }

def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( "InvalidInput" ) return first = arr [ 0 ] second = - sys . maxsize third = - sys . maxsize for i in range ( 1 , arr_size ) : if ( arr [ i ] > first ) : third = second second = first first = arr [ i ] elif ( arr [ i ] > second ) : third = second second = arr [ i ] elif ( arr [ i ] > third ) : third = arr [ i ] print ( "ThethirdLargest" , "elementis" , third )

def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( "Invalid Input " ) ; return ; } first = arr [ 0 ] second = arr [ 0 ] third = Integer . MIN_VALUE for i in range ( 1 , arr_size ) : if ( arr [ i ] > second ) : third = second second = first first = arr [ i ] else : third = arr [ i ] if ( arr [ i ] > third ) : third = arr [ i ] if ( arr [ i ] > third ) : third = third

def thirdLargest ( arr , arr_size ) : first = arr [ 0 ] second = float ( 'inf' ) third = float ( 'inf' ) for i in range ( 1 , arr_size ) : if ( arr [ i ] > first ) : third = second second = first first = arr [ i ] elif ( arr [ i ] > second ) : third = second second = arr [ i ] elif ( arr [ i ] > third ) : third = third second = arr [ i ] else : raise ValueError ( "Invalid input" ) print ( "The third Largest element is %d\n" , third )

70.74
68.14
76.95
75.62
public static int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }

def countP ( n , k ) : if ( n == 0 or k == 0 or k > n ) : return 0 if ( k == 1 or k == n ) : return 1 return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) )

def countP ( n , k ) : if ( n == 0 || k == 0 ) : return 0 if k == 1 : return 1 return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) )

def countP ( n , k ) : if n == 0 or k == 0 or k > n : return 0 if k == 1 or k == n : return 1 return ( k * countP ( n , k ) + countP ( n - 1 , k - 1 ) )

70.77
55.58
63.75
62.98
static void bonacciseries ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = 0 ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

def bonacciseries ( n , m ) : a = [ 0 for i in range ( m ) ] a [ n - 1 ] = 1 a [ n ] = 1 for i in range ( n + 1 , m ) : a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] for i in range ( 0 , m ) : print ( a [ i ] , end = "" )

def bonacciseries ( n , m ) : a = [ 0 for i in range ( n , m ) ] for i in range ( n , m ) : a [ i ] = 0 a [ n - 1 ] = 1 a [ n ] = 1 a [ n + 1 ] = 1 a [ n ] = 1 a [ n + 1 ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] for i in range

def bonacciseries ( n , m ) : a = [ 0 for k in range ( m ) ] for i in range ( n + 1 , m ) : a [ i ] = 0 a [ n - 1 ] = 1 a [ n ] = 1 for i in range ( n + 1 , m ) : a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] for i in range ( n + 1 , m ) : a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]

70.77
52.84
51.11
58.25
static int floorSearch ( int arr [ ] , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid - 1 , x ) ; return floorSearch ( arr , mid + 1 , high , x ) ; }

def floorSearch ( arr , low , high , x ) : if ( low > high ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )

def floorSearch ( arr , low , high , x ) : if low > high : return - 1 if x >= arr [ high ] : return high mid = ( low + high ) // 2 if arr [ mid ] == x : return mid if arr [ mid - 1 ] <= x and x < arr [ mid ] : return mid + 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x ) if ( x < arr [ mid ] ) : return floorSearch ( arr , mid + 1 , high , x )

def floorSearch ( arr , low , high , x ) : if low > high : return - 1 if high > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] : return mid - 1 if x < arr [ mid ] : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )

71.07
53.75
82.22
61.8
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

def knapSack ( W , wt , val , n ) : K = [ 0 for i in range ( n ) ] for w in range ( W ) : if ( i == 0 || w == 0 ) : K [ i ] [ w ] = 0 else : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) if ( wt [ i - 1 ] <= w ) : K [ i ] [ w ] = max ( K [ i - 1 ] [ w ] ) return K [ n ] [ W ]

def knapSack ( W , wt , val , n ) : K [ ] [ ] = [ 0 for i in range ( n + 1 , W + 1 ) ] for i in range ( n ) : for w in range ( W ) : if ( i == 0 or w == 0 ) : K [ i ] [ w ] = 0 else : if ( wt [ i - 1 ] <= w ) : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

71.07
53.75
82.22
61.8
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

def knapSack ( W , wt , val , n ) : K = [ 0 for i in range ( n ) ] for w in range ( W ) : if ( i == 0 || w == 0 ) : K [ i ] [ w ] = 0 else : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) if ( wt [ i - 1 ] <= w ) : K [ i ] [ w ] = max ( K [ i - 1 ] [ w ] ) return K [ n ] [ W ]

def knapSack ( W , wt , val , n ) : K [ ] [ ] = [ 0 for i in range ( n + 1 , W + 1 ) ] for i in range ( n ) : for w in range ( W ) : if ( i == 0 or w == 0 ) : K [ i ] [ w ] = 0 else : if ( wt [ i - 1 ] <= w ) : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

71.07
53.75
82.22
61.8
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

def knapSack ( W , wt , val , n ) : K = [ 0 for i in range ( n ) ] for w in range ( W ) : if ( i == 0 || w == 0 ) : K [ i ] [ w ] = 0 else : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) if ( wt [ i - 1 ] <= w ) : K [ i ] [ w ] = max ( K [ i - 1 ] [ w ] ) return K [ n ] [ W ]

def knapSack ( W , wt , val , n ) : K [ ] [ ] = [ 0 for i in range ( n + 1 , W + 1 ) ] for i in range ( n ) : for w in range ( W ) : if ( i == 0 or w == 0 ) : K [ i ] [ w ] = 0 else : if ( wt [ i - 1 ] <= w ) : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

71.09
53.93
49.25
39.11
static int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }

def numberOfPermWithKInversion ( N , K ) : if ( N == 0 ) : return 0 if ( K == 0 ) : return 1 if ( memo [ N ] [ K ] != 0 ) : return memo [ N ] [ K ] sum = 0 for i in range ( K + 1 ) : if ( i <= N - 1 ) : sum += numberOfPermWithKInversion ( N - 1 , K - i ) memo [ N ] [ K ] = sum return sum

def numberOfPermWithKInversion ( N , K ) : if ( N == 0 ) : return 0 if ( K == 0 ) : return 1 memo [ N ] [ K ] = 0 sum = 0 for i in range ( 0 , N ) : if ( i <= K ) : sum += numberOfPermWithKInversion ( N - 1 , K - i ) memo [ N ] [ K ] = sum return sum

def numberOfPermWithKInversion ( N , K ) : if N == 0 : return 1 if K == 0 : return 1 sum = 0 for i in range ( 0 , N , - 1 ) : if i <= K : sum += numberOfPermWithKInversion ( N - 1 , K - i ) memo [ N ] [ K ] = sum return sum

71.28
71.3
72.26
71.83
static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }

def areSumSame ( a , n , m ) : sum1 = 0 sum2 = 0 for i in range ( 0 , n ) : sum1 = 0 sum2 = 0 for j in range ( 0 , m ) : sum1 += a [ i ] [ j ] sum2 += a [ j ] [ i ] if ( sum1 == sum2 ) : return 1 return 0

def areSumSame ( a , n , m ) : sum1 = 0 sum2 = 0 for i in range ( 0 , n , m ) : sum1 += a [ i ] [ j ] sum2 += a [ j ] [ i ] if ( sum1 == sum2 ) : return true

def areSumSame ( a , n , m ) : sum1 = 0 sum2 = 0 for i in range ( 0 , n , m ) : sum1 += a [ i ] [ j ] sum2 += a [ j ] [ i ] if ( sum1 == sum2 ) : return True return False

71.28
66.93
82.86
79.7
static boolean isInorder ( int [ ] arr , int n ) { if ( n == 0 || n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }

def isInorder ( arr , n ) : if ( n == 0 or n == 1 ) : return True for i in range ( 1 , n , 1 ) : if ( arr [ i - 1 ] > arr [ i ] ) : return False return True

def isInorder ( arr , n ) : if ( n == 0 ) : return false for i in range ( 1 , n ) : if ( arr [ i - 1 ] > arr [ i ] ) : return false return true

def isInorder ( arr , n ) : if n == 0 or n == 1 : return True for i in range ( 1 , n ) : if ( arr [ i - 1 ] > arr [ i ] ) : return False return True

71.37
65.81
81.57
79.93
static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }

def fib ( n ) : if ( n <= 1 ) : return n return fib ( n - 1 ) + fib ( n - 2 )

def fib ( n ) : if ( n <= 2 ) : return fib ( n - 1 ) + fib ( n - 2 ) return fib ( n - 1 )

def fib ( n ) : if n <= 1 : return n return fib ( n - 1 ) + fib ( n - 2 )

71.4
68.24
68.37
60.19
static int assignValue ( int a , int b , int x ) { int arr [ ] = { a , b }; return ( arr [ x ] ) ; }

def assignValue ( a , b , x ) : arr = [ a , b ] return ( arr [ x ] )

def assignValue ( a , b , x ) : arr = { a , b , x } return ( arr [ x ] )

def assignValue ( a , b , x ) : arr . append ( a ) return ( arr [ x ] )

71.4
67.99
70.44
43.03
static char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }

def first ( str ) : for i in range ( 0 , len ( str ) ) : if ( str [ i ] . istitle ( ) ) : return str [ i ] return 0

def first ( str ) : for i in range ( len ( str ) ) : if ( Character . isUpperCase ( str [ i ] ) ) : return str [ i ]

def first ( str ) : for i in range ( len ( str ) ) : if isupper ( str [ i ] ) : return str [ i ] return 0

71.43
56.3
69.54
50.58
static int minXOR ( int arr [ ] , int n ) { Arrays . parallelSort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }

def minXOR ( arr , n ) : arr . sort ( ) minXor = int ( sys . float_info . max ) val = 0 for i in range ( 0 , n - 1 ) : val = arr [ i ] ^ arr [ i + 1 ] minXor = min ( minXor , val ) return minXor

def minXOR ( arr , n ) : arr . sort ( reverse = True ) minXor = float ( 'inf' ) for i in range ( 0 , n ) : val = arr [ i ] ^ arr [ i + 1 ] minXor = min ( minXor , val ) return minXor

def minXOR ( arr , n ) : minXor = float ( 'inf' ) val = 0 for i in range ( n - 1 , - 1 , - 1 ) : val = arr [ i ] ^ arr [ i + 1 ] minXor = min ( minXor , val ) return minXor

71.57
71.56
77.58
70.18
static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }

def add ( A , B , C ) : for i in range ( N ) : for j in range ( N ) : C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]

def add ( N , A , B , C ) : C . sort ( reverse = True ) for i in range ( N ) : for j in range ( 0 , N ) : C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] return

def add ( A , B , C ) : A . sort ( reverse = True ) for i in range ( N ) : for j in range ( 0 , N ) : C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]

71.71
61.72
71.71
61.72
static int maxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cummulative_sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cummulative_sum ) { count ++ ; cummulative_sum += arr [ i ] ; } } return count ; }

def maxRemoval ( arr , n ) : count = 0 cummulative_sum = 0 arr . sort ( ) for i in range ( n ) : if arr [ i ] >= cummulative_sum : count += 1 cummulative_sum += arr [ i ] return count

def maxRemoval ( arr , n ) : count = 0 cummulative_sum = 0 for i in range ( n ) : if ( arr [ i ] >= cummulative_sum ) : count ++ cummulative_sum += arr [ i ] return count

def maxRemoval ( arr , n ) : count = 0 cummulative_sum = 0 for i in range ( n ) : if ( arr [ i ] >= cummulative_sum ) : count ++ cummulative_sum += arr [ i ] return count

71.87
59.83
70.54
60.42
static String findString ( int n , int k ) { String res = "" ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( 'a' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( 'a' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }

def findString ( n , k ) : res = "" for i in range ( k ) : res = res + chr ( ord ( 'a' ) + i ) count = 0 for i in range ( n - k ) : res = res + chr ( ord ( 'a' ) + count ) count += 1 if ( count == k ) : count = 0 ; return res

def findString ( n , k ) : res = "" for i in range ( 0 , n - k ) : res = res + ( char ) ( 'a' + i ) count = 0 for i in range ( 0 , n - k ) : res = res + ( char ) ( 'a' + count ) count += 1 if ( count == k ) : count = 0 return res

def findString ( n , k ) : res = "" for i in range ( k ) : res = res + ( 'a' + i ) count = 0 for i in range ( 0 , n - k ) : res = res + ( 'a' + count ) count ++ if ( count == k ) : count = 0 return res

71.91
72.4
87.89
88.48
static int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }

def longestCommonSum ( arr1 , arr2 , n ) : maxLen = 0 for i in range ( 0 , n ) : sum1 = 0 sum2 = 0 for j in range ( i , n ) : sum1 += arr1 [ j ] sum2 += arr2 [ j ] if ( sum1 == sum2 ) : len = j - i + 1 if ( len > maxLen ) : maxLen = len return maxLen

def longestCommonSum ( n ) : maxLen = 0 for i in range ( 0 , n ) : sum1 = 0 sum2 = 0 for j in range ( i , n ) : sum1 += arr1 [ j ] sum2 += arr2 [ j ] if ( sum1 == sum2 ) : maxLen = len ( arr1 ) return maxLen

def longestCommonSum ( n ) : maxLen = 0 for i in range ( n ) : sum1 = 0 sum2 = 0 for j in range ( i , n ) : sum1 += arr1 [ j ] sum2 += arr2 [ j ] if ( sum1 == sum2 ) : len = j - i + 1 if ( len > maxLen ) : maxLen = len return maxLen

71.95
56.58
87.06
86.1
static int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }

def answerQuery ( a , n , l , r ) : count = 0 l = l - 1 for i in range ( l , r , 1 ) : element = a [ i ] divisors = 0 for j in range ( l , r , 1 ) : if ( a [ j ] % a [ i ] == 0 ) : divisors += 1 else : break if ( divisors == ( r - l ) ) : count += 1 return count

def answerQuery ( a , n , l , r ) : count = 0 for i in range ( l , r ) : if ( a [ i ] % a [ i ] == 0 ) : divisors = 0 for j in range ( l , r ) : if ( a [ j ] % a [ i ] == 0 ) : count += 1 elif ( divisors == ( r - l ) ) : count += 1 return count

def answerQuery ( a , n , l , r ) : count = 0 l = l - 1 for i in range ( l , r ) : element = a [ i ] divisors = 0 for j in range ( l , r ) : if ( a [ j ] % a [ i ] == 0 ) : divisors += 1 else : break if divisors == ( r - l ) : count += 1 return count

71.95
61.41
89.67
87.09
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }

def countNegative ( M , n , m ) : count = 0 for i in range ( n ) : for j in range ( m ) : if M [ i ] [ j ] < 0 : count += 1 else : break return count

def countNegative ( M , n , m ) : count = 0 for i in range ( 0 , n , m ) : if ( M [ i ] [ j ] < 0 ) : count += 1 else : break } return count

def countNegative ( M , n , m ) : count = 0 for i in range ( n ) : for j in range ( m ) : if ( M [ i ] [ j ] < 0 ) : count += 1 else : break return count

72.0
61.37
76.78
64.83
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }

def KnapSack ( val , wt , n , W ) : dp = [ 0 ] * ( W + 1 ) for i in range ( n ) : for j in range ( W , wt [ i ] , - 1 ) : dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) return dp [ W ]

def KnapSack ( val , wt , n , W ) : dp = [ 0 for i in range ( 0 , n , W ) ] for j in range ( W ) : dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) return dp [ W ]

def KnapSack ( val , wt , n , W ) : dp = [ W + 1 ] for i in range ( n ) : for j in range ( W ) : dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) return dp [ W ]

72.05
68.75
100.0
100.0
public static boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }

def isEven ( n ) : return ( n % 2 == 0 )

def isEven ( n ) : return n % 2 == 0

def isEven ( n ) : return ( n % 2 == 0 )

72.08
65.65
78.8
79.89
static int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }

def zigzag ( n , k ) : if ( n == 0 and k == 0 ) : return 1 if ( k == 0 ) : return 0 return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k )

def zigzag ( n , k ) : if ( n == 0 && k == 0 ) : return 1 return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k )

def zigzag ( n , k ) : if n == 0 and k == 0 : return 1 if k == 0 : return 0 return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k )

72.1
73.41
82.1
83.41
static float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }

def area_of_segment ( radius , angle ) : area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) area_of_triangle = 1 / 2 * ( radius * radius ) * math . sin ( ( angle * pi ) / 180 ) return area_of_sector - area_of_triangle ;

def area_of_segment ( radius , angle ) : area_of_sector = pi * radius * radius * ( angle / 360 ) area_of_triangle = 1 / 2 * ( radius * radius ) * ( float ) sin ( angle * pi ) / 180 return area_of_sector + area_of_triangle

def area_of_segment ( radius , angle ) : area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) return area_of_sector - area_of_triangle

72.12
62.38
100.0
100.0
static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }

def countObtuseAngles ( a , b , k ) : c1 = ( b - a ) - 1 c2 = ( k - b ) + ( a - 1 ) if ( c1 == c2 ) : return 0 return min ( c1 , c2 )

def countObtuseAngles ( a , b , k ) : c1 = ( b - a ) + ( a - 1 ) c2 = ( k - b ) + ( a - 1 ) return min ( c1 , c2 )

def countObtuseAngles ( a , b , k ) : c1 = ( b - a ) - 1 c2 = ( k - b ) + ( a - 1 ) if ( c1 == c2 ) : return 0 return min ( c1 , c2 )

72.15
64.32
86.73
76.45
static int findRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ; res = res ^ arr [ n - 1 ] ; return res ; }

def findRepeating ( arr , n ) : res = 0 for i in range ( 0 , n - 1 ) : res = res ^ ( i + 1 ) ^ arr [ i ] res = res ^ arr [ n - 1 ] return res

def findRepeating ( arr , n ) : res = 0 for i in range ( 0 , n ) : res = res ^ arr [ i ] res = res ^ arr [ n - 2 ] return res

def findRepeating ( arr , n ) : res = 0 for i in range ( n ) : res = res ^ ( i + 1 ) ^ arr [ i ] res = res ^ arr [ n - 1 ] return res

72.21
57.72
89.15
67.79
static int getOddOccurrence ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }

def getOddOccurrence ( arr , arr_size ) : for i in range ( 0 , arr_size ) : count = 0 for j in range ( 0 , arr_size ) : if arr [ i ] == arr [ j ] : count += 1 if ( count % 2 != 0 ) : return arr [ i ] return - 1

def getOddOccurrence ( arr , arr_size ) : count = 0 for i in range ( 0 , arr_size ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count % 2 != 0 ) : return arr [ i ]

def getOddOccurrence ( arr , arr_size ) : for i in range ( arr_size ) : count = 0 for j in range ( 0 , arr_size ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count % 2 != 0 ) : return arr [ i ] return - 1

72.22
70.11
100.0
100.0
public static void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }

def rearrange ( arr , n ) : max_ele = arr [ n - 1 ] min_ele = arr [ 0 ] for i in range ( n ) : if i % 2 == 0 : arr [ i ] = max_ele max_ele -= 1 else : arr [ i ] = min_ele min_ele += 1

def rearrange ( arr , n ) : arr . sort ( reverse = True ) min_ele = arr [ n - 1 ] max_ele = arr [ 0 ] for i in range ( n ) : if ( i % 2 == 0 ) : arr [ i ] = max_ele max_ele -= 1 else : arr [ i ] = min_ele min_ele += 1 } return arr

def rearrange ( arr , n ) : max_ele = arr [ n - 1 ] min_ele = arr [ 0 ] for i in range ( n ) : if i % 2 == 0 : arr [ i ] = max_ele max_ele -= 1 else : arr [ i ] = min_ele min_ele += 1

72.33
59.03
72.33
59.03
static int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }

def maxSum ( arr , n ) : arr . sort ( ) sum = 0 for i in range ( n ) : sum += arr [ i ] * i return sum

def maxSum ( arr , n ) : sum = 0 for i in range ( n ) : sum += ( arr [ i ] * i ) return sum

def maxSum ( arr , n ) : sum = 0 for i in range ( n ) : sum += ( arr [ i ] * i ) return sum

72.47
71.03
64.71
44.89
static void printPrevSmaller ( int [ ] arr , int n ) { System . out . print ( "_, " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { System . out . print ( arr [ j ] + ", " ) ; break ; } } if ( j == - 1 ) System . out . print ( "_, " ) ; } }

def printPrevSmaller ( arr , n ) : print ( "_," , end = "" ) for i in range ( 1 , n ) : for j in range ( i - 1 , - 2 , - 1 ) : if ( arr [ j ] < arr [ i ] ) : print ( arr [ j ] , "," , end = "" ) break if ( j == - 1 ) : print ( "_," , end = "" )

def printPrevSmaller ( arr , n ) : print ( arr [ 0 ] , end = "" ) for i in range ( n ) : for j in range ( i - 1 , - 1 ) : if ( arr [ j ] < arr [ i ] ) : print ( arr [ j ] , end = "" ) break if ( j == - 1 ) : print ( "_, " ) break if ( j == - 1 ) : print ( "_, " ) break

def printPrevSmaller ( arr , n ) : for i in range ( n ) : for j in range ( i - 1 , - 1 , - 1 ) : if ( arr [ j ] < arr [ i ] ) : print ( arr [ j ] + ", " ) break if ( j == - 1 ) : print ( "_, " )

72.5
75.13
100.0
100.0
static int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }

def swapNibbles ( x ) : return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )

def swapNibbles ( x ) : return ( x & 0xF ) << 4 | ( x & 0x0F ) >> 4

def swapNibbles ( x ) : return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )

72.64
57.16
79.35
64.94
static float find_prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }

def find_prob ( N , P ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 1 dp [ 1 ] = 0 dp [ 2 ] = P dp [ 3 ] = 1 - P for i in range ( 4 , N + 1 ) : dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] return dp [ N ]

def find_prob ( N , P ) : dp = [ 1.0 for i in range ( N ) ] dp [ 0 ] = 1 dp [ 1 ] = 0 dp [ 2 ] = 1 - P for i in range ( 4 , N ) : dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) dp [ i ] = ( 1 - P ) * dp [ i - 3 ] return ( ( float ) ( dp [ N ] )

def find_prob ( N , P ) : dp = [ 1 for i in range ( N ) ] dp [ 0 ] = 1 dp [ 1 ] = 0 dp [ 2 ] = P dp [ 3 ] = 1 - P for i in range ( 4 , N ) : dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] return ( ( float ) ( dp [ N ] ) )

72.67
55.37
80.53
67.31
static int minSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }

def minSum ( a , n ) : a = sorted ( a ) num1 , num2 = 0 , 0 for i in range ( n ) : if i % 2 == 0 : num1 = num1 * 10 + a [ i ] else : num2 = num2 * 10 + a [ i ] return num2 + num1

def minSum ( a , n ) : a . sort ( reverse = True ) num1 = 0 num2 = 0 for i in range ( n ) : if ( i % 2 == 0 ) : num1 = num1 * 10 + a [ i ] else : num2 = num2 * 10 + a [ i ] return num1

def minSum ( a , n ) : num1 = 0 num2 = 0 for i in range ( n ) : if i % 2 == 0 : num1 = num1 * 10 + a [ i ] else : num2 = num2 * 10 + a [ i ] return num2 + num1

72.89
50.56
84.6
55.9
public static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }

def middleOfThree ( a , b , c ) : x = a - b y = b - c z = a - c if x * y > 0 : return b elif ( x * z > 0 ) : return else : return a

def middleOfThree ( a , b , c ) : x = a - b y = b - c z = a - c if ( x * y > 0 ) : return a else : return b

def middleOfThree ( a , b , c ) : x = a - b y = b - c z = a - c if x * y > 0 : return b , else if ( x * z > 0 ) : return c else : a

73.1
48.5
70.22
52.81
static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }

def MatrixChainOrder ( p , i , j ) : if i == j : return 0 _min = sys . maxsize for k in range ( i , j ) : count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) if count < _min : _min = count return _min

def MatrixChainOrder ( p , i , j ) : if ( i == j ) : return 0 for k in range ( i , j ) : count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] min = count return min

def MatrixChainOrder ( p , i , j ) : min = INT_MAX for k in range ( i , j ) : count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] if ( count < min ) : min = count return min

73.13
59.58
65.34
55.5
static boolean isSparse ( int array [ ] [ ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; }

def isSparse ( array , m , n ) : counter = 0 for i in range ( 0 , m ) : for j in range ( 0 , n ) : if ( array [ i ] [ j ] == 0 ) : counter = counter + 1 return ( counter > ( ( m * n ) // 2 ) )

def isSparse ( array , m , n ) : counter = 0 for i in range ( 0 , m , n ) : if ( array [ i ] [ j ] == 0 ) : counter += 1 return ( counter > ( ( m * n ) / 2 ) )

def isSparse ( array , m , n ) : counter = 0 for i in range ( m , n ) : if ( array [ i ] [ j ] == 0 ) : ++ counter return ( counter > ( ( m * n ) / 2 ) )

73.16
45.7
77.6
47.91
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }

def findExtra ( arr1 , arr2 , n ) : index = n left = 0 right = n - 1 while ( left <= right ) : mid = ( int ) ( ( left + right ) / 2 ) if ( arr2 [ mid ] == arr1 [ mid ] ) : left = mid + 1 else : index = mid right = mid - 1 return index

def findExtra ( arr1 , arr2 , n ) : index = n left = 0 right = n - 1 while left <= right : mid = ( left + right ) // 2 if ( arr2 [ mid ] == arr1 [ mid ] ) : left = mid + 1 else : right = mid - 1 index = mid return index

def findExtra ( arr1 , arr2 , n ) : index = n left = 0 right = n - 1 while left <= right : mid = ( left + right ) // 2 if ( arr2 [ mid ] == arr1 [ mid ] ) : left = mid + 1 else : index = mid - 1 right = mid - 1 return index

73.21
56.38
68.1
57.47
static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }

def lcs ( dp , arr1 , n , arr2 , m , k ) : if k < 0 : return - ( 10 ** 7 ) if n < 0 or m < 0 : return 0 ans = dp [ n ] [ m ] [ k ] if ans != - 1 : return ans ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) if arr1 [ n - 1 ] == arr2 [ m - 1 ] : ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) return ans

def lcs ( dp , arr1 , n , arr2 , k ) : if ( k < 0 ) : return - 10000000 if n < 0 or m < 0 : return 0 if n == 0 : return - 1 ans = dp [ n ] [ m ] [ k ] = lcs ( dp , arr1 , n , arr2 , m , k ) if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : ans = max ( ans , 1 + lcs ( dp , arr1 , n , arr2 , m - 1 , k ) : ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 ) : ans = max ( ans , 1 + lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) return ans

def lcs ( dp , arr1 , n , arr2 , m , k ) : if arr1 [ n - 1 ] == arr2 [ m - 1 ] : ans = max ( lcs ( dp , arr1 , n , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m , k ) ) if arr1 [ n - 1 ] == arr2 [ m - 1 ] : ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) return ans

73.25
55.61
77.39
61.18
static int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }

def minDifferenceAmongMaxMin ( arr , N , K ) : arr . sort ( ) res = 2147483647 for i in range ( ( N - K ) + 1 ) : curSeqDiff = arr [ i + K - 1 ] - arr [ i ] res = min ( res , curSeqDiff ) return res

def minDifferenceAmongMaxMin ( arr , N , K ) : arr . sort ( reverse = True ) res = 2147483647 for i in range ( 0 , N , K ) : curSeqDiff = arr [ i ] - arr [ i ] res = min ( res , curSeqDiff ) return res

def minDifferenceAmongMaxMin ( arr , N , K ) : res = 2147483647 for i in range ( N - K ) : curSeqDiff = arr [ i + K - 1 ] - arr [ i ] res = min ( res , curSeqDiff ) return res

73.29
64.48
83.99
63.62
static int findCommon ( int mat [ ] [ ] ) { int column [ ] = new int [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return - 1 ; }

def findCommon ( mat ) : column = [ N - 1 ] * M min_row = 0 while ( column [ min_row ] >= 0 ) : for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : min_row = i eq_count = 0 for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) : if ( column [ i ] == 0 ) : return - 1 column [ i ] -= 1 else : eq_count += 1 if ( eq_count == M ) : return mat [ min_row ] [ column [ min_row ] ] return - 1

def findCommon ( mat , column ) : column = [ 0 for i in range ( M ) ] min_row = 0 for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : min_row = i if ( column [ i ] == 0 ) : return - 1 else : eq_count = 0 for i in range ( 0 , M ) : if ( mat [ i ] [ column [ i ] > mat [ min_row ] [ column [ min_row ] ] : if ( column [ i ] == 0 ) : return - 1 else : return mat [ min_row ] [ column [ min_row ] ]

def findCommon ( mat ) : column = [ N - 1 for i in range ( M ) ] while column [ min_row ] >= 0 : for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : min_row = i eq_count = 0 for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) : if ( column [ i ] == 0 ) : return - 1 ; column [ i ] -= 1 else : eq_count ++ if eq_count == M : return mat [ min_row ] [ column [ min_row ] ]

73.35
59.59
77.8
62.02
static int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }

def pre_compute ( a , n , index , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n ) : if a [ i ] > a [ 0 ] : dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] else : dp [ 0 ] [ i ] = a [ i ] for i in range ( 1 , n ) : for j in range ( n ) : if a [ j ] > a [ i ] and j > i : if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return dp [ index ] [ k ]

def pre_compute ( a , n , index , k ) : dp = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : if ( a [ i ] > a [ 0 ] ) : dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] dp [ 0 ] [ j ] = dp [ i - 1 ] [ i ] if ( dp [ i - 1 ] [ i ] > dp [ i - 1 ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] = dp [ i - 1 ] [ i ] + a [ j ] dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return dp [ index ] [ k ]

def pre_compute ( a , n , index , k ) : dp [ ] [ ] = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : if ( a [ i ] > a [ 0 ] ) : dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] else : dp [ 0 ] [ i ] = a [ i ] for i in range ( 1 , n ) : if ( a [ j ] > a [ i ] and j > i ) : if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return dp [ index ] [ k ]

73.46
58.24
77.15
65.94
static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }

def findLongestRepeatingSubSeq ( str ) : n = len ( str ) dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ n ] [ n ]

def findLongestRepeatingSubSeq ( str ) : n = len ( str ) dp = [ 1 ] [ n + 1 ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( str [ i - 1 ] == str [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] elif ( str [ i - 1 ] == str [ j - 1 ] ) : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ n ] [ n ]

def findLongestRepeatingSubSeq ( str ) : dp = [ 0 for k in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ n ] [ n ]

73.47
58.75
74.5
58.68
static int countNum ( int [ ] arr , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }

def countNum ( arr , n ) : count = 0 arr . sort ( ) for i in range ( 0 , n - 1 ) : if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : count += arr [ i + 1 ] - arr [ i ] - 1 return count

def countNum ( arr , n ) : count = 0 for i in range ( n ) : if ( arr [ i ] != arr [ i + 1 ] ) : count += arr [ i ] - arr [ i + 1 ] if ( arr [ i ] != arr [ i + 1 ] - 1 ) : count += arr [ i + 1 ] - arr [ i ] - 1 return count

def countNum ( arr , n ) : count = 0 for i in range ( n ) : if arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 : count += arr [ i + 1 ] - arr [ i ] - 1 return count

73.64
75.73
75.04
63.94
static int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }

def divisible ( num ) : n = len ( num ) sum = 0 for i in range ( n ) : sum += int ( num [ i ] ) if ( sum % 3 == 0 ) : return 0 if ( n == 1 ) : return - 1 for i in range ( n ) : if ( sum % 3 == int ( num [ i ] ) % 3 ) : return 1 if ( n == 2 ) : return - 1 return 2

def divisible ( num ) : n = len ( num ) sum = 0 for i in range ( n ) : sum += ( int ) ( num [ i ] - '0' ) % 3 if ( n == 0 ) : return 0 if ( n == 1 ) : return 1 else : for i in range ( 0 , n ) : if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) : return 1 if ( n == 2 ) : return 2

def divisible ( num ) : sum = 0 for i in range ( n ) : sum += ( num [ i ] - '0' ) if ( sum % 3 == 0 ) : return 0 , if ( n == 1 ) : return - 1 , for i in range ( n ) : if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) : return 1 , if ( n == 2 ) : return - 1 , 2 return 2

73.66
59.03
95.75
89.98
static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }

def maxPathSum ( tri , m , n ) : for i in range ( m - 1 , - 1 , - 1 ) : for j in range ( i + 1 ) : if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : tri [ i ] [ j ] += tri [ i + 1 ] [ j ] else : tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] return tri [ 0 ] [ 0 ]

def maxPathSum ( tri , m , n ) : tri . sort ( reverse = True ) for i in range ( m , n ) : if ( tri [ i ] [ j ] > tri [ i + 1 ] [ j ] ) : tri [ i ] [ j ] += tri [ i + 1 ] [ j ] else : tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] return tri [ 0 ] [ 0 ]

def maxPathSum ( tri , m , n ) : for i in range ( m ) : for j in range ( m - 1 , - 1 , - 1 ) : if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : tri [ i ] [ j ] += tri [ i + 1 ] [ j ] else : tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] return tri [ 0 ] [ 0 ]

73.67
70.16
57.63
59.2
public static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }

def middleOfThree ( a , b , c ) : if a > b : if ( b > c ) : return b elif ( a > c ) : return c else : return a else : if ( a > c ) : return a elif ( b > c ) : return c else : return b

def middleOfThree ( a , b , c ) : if ( a > b ) : return a else : if ( b > c ) : return b else : if ( a > c ) : return a else : if ( b > c ) : return c else : return a

def middleOfThree ( a , b , c ) : if a > b : if b > c : return b else : if a > c : return c else : if b > c : return a else : if a > c : return b else : if b > c : return c else : return b

73.7
64.68
88.16
74.99
static int mostFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }

def mostFrequent ( arr , n ) : arr . sort ( ) max_count = 1 res = arr [ 0 ] curr_count = 1 for i in range ( 1 , n ) : if ( arr [ i ] == arr [ i - 1 ] ) : curr_count += 1 else : if ( curr_count > max_count ) : max_count = curr_count res = arr [ i - 1 ] curr_count = 1 if ( curr_count > max_count ) : max_count = curr_count res = arr [ n - 1 ] return res

def mostFrequent ( arr , n ) : max_count = 1 res = arr [ 0 ] curr_count = 1 for i in range ( 1 , n ) : if ( arr [ i ] == arr [ i - 1 ] ) : max_count = curr_count res = arr [ i - 1 ] curr_count = 1 else : if ( curr_count > max_count ) : max_count = curr_count res = arr [ i -

def mostFrequent ( arr , n ) : max_count = 1 res = arr [ 0 ] curr_count = 1 for i in range ( 1 , n ) : if ( arr [ i ] == arr [ i - 1 ] ) : curr_count += 1 else : if ( curr_count > max_count ) : max_count = curr_count res = arr [ i - 1 ] curr_count = 1 if curr_count > max_count : max_count = curr_count res = arr [ n - 1 ] return res

73.76
53.18
80.16
66.69
static int countStrings ( int n ) { int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }

def countStrings ( n ) : a = [ 0 ] * n b = [ 0 ] * n a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]

def countStrings ( n ) : a = [ 0 for k in range ( n ) ] b = [ 0 for k in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] return 1 << n - a [ n - 1 ] - b [ n - 1 ]

def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( 1 , n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]

73.79
48.27
85.79
58.47
static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ; }

def leonardo ( n ) : if ( n == 0 or n == 1 ) : return 1 return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )

def leonardo ( n ) : if ( n == 0 ) : return 1 return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1

def leonardo ( n ) : if n == 0 or n == 1 : return 1 return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )

73.83
75.49
78.24
70.83
static int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }

def maxTasks ( high , low , n ) : if ( n <= 0 ) : return 0 return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) )

def maxTasks ( high , low , n ) : if ( n <= 0 ) : return 0 return max ( high [ n - 1 ] , low [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) )

def maxTasks ( high , low , n ) : if n <= 0 : return 0 return max ( high [ n - 1 ] + maxTasks ( high , low , n - 2 ) , low [ n - 1 ] + maxTasks ( high , low , n - 1 ) )

74.08
67.72
74.08
67.72
public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }

def countDyckPaths ( n ) : res = 1 for i in range ( 0 , n ) : res *= ( 2 * n - i ) res /= ( i + 1 ) return res / ( n + 1 )

def countDyckPaths ( n ) : res = 1 for i in range ( n ) : res *= ( 2 * n - i ) res /= ( n + 1 ) return res

def countDyckPaths ( n ) : res = 1 for i in range ( n ) : res *= ( 2 * n - i ) res /= ( n + 1 ) return res

74.26
54.54
77.41
58.42
static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }

def countSol ( coeff , n , rhs ) : dp = [ 0 for i in range ( rhs + 1 ) ] dp [ 0 ] = 1 for i in range ( n ) : for j in range ( coeff [ i ] , rhs + 1 ) : dp [ j ] += dp [ j - coeff [ i ] ] return dp [ rhs ]

def countSol ( coeff , n , rhs ) : dp = [ 0 for k in range ( n ) ] for i in range ( 0 , n ) : for j in range ( coeff [ i ] , rhs ) : dp [ j ] += dp [ j - coeff [ i ] ] return dp [ rhs ]

def countSol ( coeff , n , rhs ) : dp = [ rhs + 1 for i in range ( n ) ] dp [ 0 ] = 1 for i in range ( n ) : for j in coeff [ i ] : dp [ j ] += dp [ j - coeff [ i ] ] return dp [ rhs ]

74.42
60.67
70.16
68.02
static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } System . out . println ( "Principal Diagonal:" + principal ) ; System . out . println ( "Secondary Diagonal:" + secondary ) ; }

def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : principal += mat [ i ] [ i ] secondary += mat [ i ] [ n - i - 1 ] print ( "PrincipalDiagonal:" , principal ) print ( "SecondaryDiagonal:" , secondary )

def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( n ) : principal += mat [ i ] [ i ] secondary += mat [ i ] [ n - i - 1 ] printDiagonalSums ( mat , n - i - 1 )

def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( n ) : principal += mat [ i ] [ i ] secondary += mat [ i ] [ n - i - 1 ]

74.47
62.63
82.81
78.79
public static String noAdjacentDup ( String s1 ) { int n = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = 'a' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }

def noAdjacentDup ( s ) : n = len ( s ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = "a" while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 return s

def noAdjacentDup ( s1 ) : n = len ( s1 ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = 'a' i += 1 elif ( s [ i ] == s [ i - 1 ] ) : s [ i ] = 'b' while ( s [ i ] == s [ i + 1 ] ) : s [ i ] += ( '

def noAdjacentDup ( s1 ) : n = s1 . length ( ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = 'a' while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 return ( new String ( s ) )

74.54
61.59
82.2
71.58
static int maxProfit ( int price [ ] , int n , int k ) { int profit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }

def maxProfit ( price , n , k ) : profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] for i in range ( 1 , k + 1 ) : prevDiff = float ( '-inf' ) for j in range ( 1 , n ) : prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) return profit [ k ] [ n - 1 ]

def maxProfit ( price , n , k ) : profit = [ 0 for i in range ( k + 1 , n + 1 ) ] for j in range ( 1 , n ) : prevDiff = float ( 'inf' ) for i in range ( 1 , k ) : profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j ] + prevDiff return profit [ k ] [ n - 1 ]

def maxProfit ( price , n , k ) : profit [ ] = [ 0 for i in range ( k ) ] for j in range ( 0 , n , 1 ) : prevDiff = float ( 'inf' ) for i in range ( 1 , k ) : prevDiff = float ( 'inf' ) for j in range ( n ) : prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) return profit [ k ] [ n - 1 ]

74.6
68.39
87.38
78.01
static int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }

def MinOperation ( a , n , k ) : result = 0 for i in range ( n ) : if ( a [ i ] != 1 and a [ i ] > k ) : result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) else : result = result + k - a [ i ] return result

def MinOperation ( a , n , k ) : result = 0 for i in range ( 0 , n ) : if ( a [ i ] != 1 ) : result = result + a [ i ] % k , k - a [ i ] % k ) else : result = result + k - a [ i ] % k return result

def MinOperation ( a , n , k ) : result = 0 for i in range ( n ) : if a [ i ] != 1 and a [ i ] > k : result = result + min ( a [ i ] % k , k - a [ i ] % k ) else : result = result + k - a [ i ] return result

74.61
71.87
74.62
76.1
static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }

def minValue ( A , B , n ) : sorted ( A ) sorted ( B ) result = 0 for i in range ( n ) : result += ( A [ i ] * B [ n - i - 1 ] ) return result

def minValue ( A , B , n ) : A . sort ( ) B . sort ( ) result = 0 for i in range ( 0 , n ) : result += ( A [ i ] * B [ n - i - 1 ] ) return result

def minValue ( A , B , n ) : A . sort ( A ) B . sort ( ) result = 0 for i in range ( 0 , n ) : result += ( A [ i ] * B [ n - i - 1 ] ) return result

74.63
78.32
93.22
86.49
static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; }

def countPairs ( a , n ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( a [ i ] & a [ j ] ) == 0 : count += 2 return count

def countPairs ( a , n ) : count = 0 for i in range ( 0 , n ) : if ( a [ i ] & a [ j ] ) == 0 : count += 2 return count

def countPairs ( a , n ) : count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( a [ i ] & a [ j ] ) == 0 : count += 2 return count

74.64
67.43
74.36
63.66
public static int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }

def maxSum ( grid , n ) : incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) excl = 0 for i in range ( 1 , n ) : excl_new = max ( excl , incl ) incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) excl = excl_new return max ( excl , incl )

def maxSum ( grid , n ) : incl = 0 excl = 0 excl_new = 0 for i in range ( 1 , n ) : excl_new = max ( excl , incl ) incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) excl = excl_new return max ( excl , incl )

def maxSum ( grid , n ) : incl = 0 excl = 0 excl_new = 0 for i in range ( 1 , n ) : excl_new = max ( excl , incl ) incl = excl + max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) excl = excl_new return max ( excl , incl )

74.74
45.45
62.89
39.22
static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }

def numberOfPaths ( m , n ) : for i in range ( n , ( m + n - 1 ) ) : path *= i path //= ( i - n + 1 ) return path

def numberOfPaths ( m , n ) : path = 1 for i in range ( n , m + n - 1 ) : path *= i path /= ( i - n + 1 ) return path

def numberOfPaths ( m , n ) : path = 1 for i in range ( n ) : path *= i path /= ( i - n + 1 ) return path

75.05
73.79
95.37
93.78
public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }

def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i == j ) : d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) : d2 += arr [ i ] [ j ] return abs ( d1 - d2 )

def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i == j ) d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] if ( i == n - j - 1 ) : d2 += arr [ i ] [ j ] return Math . abs ( d1 - d2 )

def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( n ) : for j in range ( 0 , n ) : if ( i == j ) : d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) : d2 += arr [ i ] [ j ] return abs ( d1 - d2 )

75.12
69.4
92.32
95.81
static int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }

def binarySearch ( arr , low , high ) : if high >= low : mid = ( low + high ) // 2 if mid is arr [ mid ] : return mid if mid > arr [ mid ] : return binarySearch ( arr , ( mid + 1 ) , high ) else : return binarySearch ( arr , low , ( mid - 1 ) ) return - 1

def binarySearch ( arr , low , high ) : if low <= high : return - 1 else : mid = ( low + high ) // 2 if mid == arr [ mid ] : return mid if mid > arr [ mid ] : return binarySearch ( arr , low , mid - 1 ) else : return binarySearch ( arr , mid + 1 , high )

def binarySearch ( arr , low , high ) : if high >= low : mid = ( low + high ) // 2 if mid == arr [ mid ] : return mid if mid > arr [ mid ] : return binarySearch ( arr , ( mid + 1 ) , high ) else : return binarySearch ( arr , low , ( mid - 1 ) )

75.41
58.4
55.22
64.1
static int FindMaxProduct ( int arr [ ] [ ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } } } return max ; }

def FindMaxProduct ( arr , n ) : max = 0 for i in range ( n ) : for j in range ( n ) : if ( ( j - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) if ( max < result ) : max = result if ( ( i - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) if ( max < result ) : max = result if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) if ( max < result ) : max = result return max

def FindMaxProduct ( arr , n ) : max = 0 for i in range ( n ) : for j in range ( 0 , n ) : if ( j - 3 ) >= 0 : result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] if ( max < result ) max = result if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 : result = arr [ i ] [ j ] * arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j - 3 ] if ( max < result ) : max = result if ( i - 3 ) >= 0 : result = arr [ i ] [ j ] * arr [ i - 2 ] [ j - 3 ] if ( max < result ) max = result if ( i - 3 ) >= 0 : result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 3 ] [ j ] if ( max < result ) : max = result if ( max < result ) : max = result if ( i

def FindMaxProduct ( arr , n ) : max = 0 for i in range ( n ) : for j in range ( n ) : if ( j - 3 ) >= 0 : result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] [ j ] if max < result : max = result if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 : result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j ] if max < result : max = result return max

75.42
72.93
75.42
72.93
static void mergeTwoHalf ( int [ ] A , int n ) { Arrays . sort ( A ) ; }

def mergeTwoHalf ( A , n ) : A . sort ( )

def mergeTwoHalf ( A , n ) : A . sort ( reverse = True )

def mergeTwoHalf ( A , n ) : A . sort ( reverse = True )

75.44
63.75
73.83
61.27
static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }

def cutRod ( price , n ) : val = [ 0 for x in range ( n + 1 ) ] val [ 0 ] = 0 for i in range ( 1 , n + 1 ) : max_val = INT_MIN for j in range ( i ) : max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) val [ i ] = max_val return val [ n ]

def cutRod ( price , n ) : val = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : max_val = float ( 'inf' ) for j in range ( i + 1 , n ) : max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) val [ i ] = max_val return val [ n ]

def cutRod ( price , n ) : val = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : max_val = float ( 'inf' ) for j in range ( 1 , n ) : max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) val [ i ] = max_val return val [ n ]

75.48
51.55
72.16
47.52
static boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }

def checkForSorting ( arr , n ) : for i in range ( 0 , n - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : if ( arr [ i ] - arr [ i + 1 ] == 1 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] else : return False return True

def checkForSorting ( arr , n ) : for i in range ( n ) : if ( arr [ i ] > arr [ i + 1 ] ) : arr [ i ] = arr [ i + 1 ] i += 1 if ( arr [ i ] - arr [ i + 1 ] == 1 ) : arr [ i ] = arr [ i ] i + 1 ] = temp return true

def checkForSorting ( arr , n ) : for i in range ( n ) : if arr [ i ] > arr [ i + 1 ] : if ( arr [ i ] - arr [ i + 1 ] == 1 ) : arr [ i ] = arr [ i ] arr [ i ] = arr [ i + 1 ] arr [ i + 1 ] = temp return True

75.53
73.61
75.53
73.61
public static int kthSmallest ( Integer [ ] arr , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }

def kthSmallest ( arr , n , k ) : arr . sort ( ) return arr [ k - 1 ]

def kthSmallest ( arr , k ) : arr . sort ( reverse = True ) return arr [ k - 1 ]

def kthSmallest ( arr , k ) : arr . sort ( reverse = True ) return arr [ k - 1 ]

75.7
58.31
91.84
65.39
static int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }

def findMin ( arr , low , high ) : if high < low : return arr [ 0 ] if high == low : return arr [ low ] mid = int ( ( low + high ) / 2 ) if mid < high and arr [ mid + 1 ] < arr [ mid ] : return arr [ mid + 1 ] if mid > low and arr [ mid ] < arr [ mid - 1 ] : return arr [ mid ] if arr [ high ] > arr [ mid ] : return findMin ( arr , low , mid - 1 ) return findMin ( arr , mid + 1 , high )

def findMin ( arr , low , high ) : if low == high : return arr [ 0 ] if high == low : return arr [ low ] if high == low : return arr [ low ] mid = low + ( high - low ) // 2 if mid < low and arr [ mid + 1 ] < arr [ mid ] : return arr [ mid + 1 ] if mid > high and arr [ mid ] > arr [ mid ] : return findMin ( arr , low , mid - 1 ) if arr [ mid ] > arr [ mid ] : return findMin ( arr , mid + 1 , high )

def findMin ( arr , low , high ) : if high < low : return arr [ 0 ] if high == low : return arr [ low ] mid = low + ( high - low ) // 2 if mid < high and arr [ mid + 1 ] < arr [ mid ] : return arr [ mid + 1 ] if mid > low and arr [ mid ] < arr [ mid - 1 ] : return arr [ mid ] if arr [ high ] > arr [ mid ] : return findMin ( arr , low , mid - 1 ) return findMin ( arr , mid + 1 , high )

75.98
64.64
81.6
66.11
static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }

def checkIsAP ( arr , n ) : if ( n == 1 ) : return True arr . sort ( ) d = arr [ 1 ] - arr [ 0 ] for i in range ( 2 , n ) : if ( arr [ i ] - arr [ i - 1 ] != d ) : return False return True

def checkIsAP ( arr , n ) : if ( n == 1 ) : return checkIsAP ( arr , n - 2 ) else : d = arr [ 0 ] - arr [ 0 ] for i in range ( 2 , n ) : if ( arr [ i ] - arr [ i - 1 ] != d ) : return false return true

def checkIsAP ( arr , n ) : if n == 1 : return True types = [ bool , float ] d = arr [ 1 ] - arr [ 0 ] for i in range ( 2 , n ) : if ( arr [ i ] - arr [ i - 1 ] != d ) : return False return True

76.1
49.42
78.96
80.65
public static int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }

def eulerian ( n , m ) : if ( m >= n or n == 0 ) : return 0 if ( m == 0 ) : return 1 return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) )

def eulerian ( n , m ) : if ( m >= n || n == 0 ) : return 1 return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m )

def eulerian ( n , m ) : if m >= n or n == 0 : return 0 if m == 0 : return 1 return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m )

76.13
59.31
59.22
47.79
static int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }

def maxvolume ( s ) : maxvalue = 0 i = 1 for i in range ( s - 1 ) : j = 1 for j in range ( s ) : k = s - i - j maxvalue = max ( maxvalue , i * j * k ) return maxvalue

def maxvolume ( s ) : maxvalue = 0 for i in range ( 1 , s - 2 ) : for j in range ( 1 , s - 1 ) : k = s - i - j maxvalue = max ( maxvalue , i * j * k ) return maxvalue

def maxvolume ( s ) : maxvalue = 0 for i in range ( 1 , s ) : for j in range ( 1 , s - 2 ) : for k in range ( 1 , s - 1 ) : maxvalue = max ( maxvalue , i * j * k ) return maxvalue

76.13
60.65
100.0
100.0
static int find_Area ( int r ) { return ( 2 * r * r ) ; }

def find_Area ( r ) : return ( 2 * r * r )

def find_Area ( r ) : return ( 2 * r

def find_Area ( r ) : return ( 2 * r * r )

76.18
52.99
66.64
45.06
static long mulmod ( long a , long b , long mod ) { long res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) { res = ( res + a ) % mod ; } a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }

def mulmod ( a , b , mod ) : res = 0 a = a % mod while ( b > 0 ) : if ( b % 2 == 1 ) : res = ( res + a ) % mod a = ( a * 2 ) % mod b //= 2 return res % mod

def mulmod ( a , b , mod ) : res = 0 a = a % mod b = b % mod while ( b > 0 ) : res = ( res + a ) % mod a = ( a * 2 ) % mod b /= 2 res = res + a

def mulmod ( a , b , mod ) : res = 0 a = a % mod b = b // 2 while b > 0 : if b % 2 == 1 : res = ( res + a ) % mod a = ( a * 2 ) % mod b = ( b * 2 ) % mod b /= 2 return res % mod

76.42
61.99
65.66
49.53
static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }

def isDivisible ( str , k ) : n = len ( str ) c = 0 for i in range ( 0 , k ) : if ( str [ n - i - 1 ] == '0' ) : c += 1 return ( c == k )

def isDivisible ( str , k ) : c = 0 for i in range ( k ) : if ( str [ n - i - 1 ] == '0' ) : c += 1 return ( c == k )

def isDivisible ( str , k ) : c = 0 for i in range ( k ) : if str [ n - i - 1 ] == '0' : c += 1 return ( c == k )

76.43
75.18
100.0
100.0
static int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }

def countOccurrences ( arr , n , x ) : res = 0 for i in range ( n ) : if x == arr [ i ] : res += 1 return res

def countOccurrences ( arr , n , x ) : res = 0 for i in range ( 0 , n ) : if ( x == arr [ i ] ) : res += 1 return res

def countOccurrences ( arr , n , x ) : res = 0 for i in range ( n ) : if x == arr [ i ] : res += 1 return res

76.53
55.61
84.13
85.36
static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }

def power ( x , y , p ) : res = 1 x = x % p while ( y > 0 ) : if ( ( y & 1 ) == 1 ) : res = ( res * x ) % p y = y >> 1 x = ( x * x ) % p return res

def power ( x , y , p ) : res = 1 x = x % p y = y >> 1 while ( y > 0 ) : res = ( res * x ) % p y = y >> 1 x = ( x * x ) % p res = ( res * x ) % p return res

def power ( x , y , p ) : res = 1 x = x % p while y > 0 : if ( y & 1 ) == 1 : res = ( res * x ) % p y = y >> 1 x = ( x * x ) % p return res

76.62
62.7
77.79
69.84
static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( "Minimal Value = " + smallest ) ; System . out . println ( "Total Pairs = " + count ) ; }

def pairs ( arr , n , k ) : smallest = 999999999999 count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if abs ( arr [ i ] + arr [ j ] - k ) < smallest : smallest = abs ( arr [ i ] + arr [ j ] - k ) count = 1 elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : count += 1 print ( "MinimalValue=" , smallest ) print ( "TotalPairs=" , count )

def pairs ( arr , n , k ) : smallest = float ( 'inf' ) count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] + arr [ j ] - k ) < smallest : smallest = abs ( arr [ i ] + arr [ j ] - k ) count = 1 if ( arr [ i ] + arr [ j ] - k ) == smallest : smallest =

def pairs ( arr , n , k ) : smallest = INT_MAX_VALUE count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) : smallest = abs ( arr [ i ] + arr [ j ] - k ) count = 1 elif ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) : count += 1 print ( "Minimal Value = " + smallest ) print ( "Total Pairs = " + count )

76.73
73.71
76.73
73.71
static int findRoot ( pair arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . first - arr [ i ] . second ) ; } return root ; }

def findRoot ( arr , n ) : root = 0 for i in range ( n ) : root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) return root

def findRoot ( arr , n ) : root = 0 for i in range ( n ) : root += ( arr [ i ] . first - arr [ i ] . second ) return root

def findRoot ( arr , n ) : root = 0 for i in range ( n ) : root += ( arr [ i ] . first - arr [ i ] . second ) return root

76.84
65.54
78.08
65.13
static int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }

def countSol ( coeff , start , end , rhs ) : if ( rhs == 0 ) : return 1 result = 0 for i in range ( start , end + 1 ) : if ( coeff [ i ] <= rhs ) : result += countSol ( coeff , i , end , rhs - coeff [ i ] ) return result

def countSol ( coeff , start , end , rhs ) : result = 0 for i in range ( start , end ) : if ( coeff [ i ] <= rhs ) : result += countSol ( coeff , i , end , rhs - coeff [ i ] ) return result

def countSol ( coeff , start , end , rhs ) : if rhs == 0 : return 1 result = 0 for i in range ( start , end ) : if coeff [ i ] <= rhs : result += countSol ( coeff , i , end , rhs - coeff [ i ] ) return result

76.92
63.78
77.72
59.12
static int findInteger ( int arr [ ] , int n ) { int neg = 0 , pos = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) neg ++ ; else pos ++ ; } return ( sum / Math . abs ( neg - pos ) ) ; }

def findInteger ( arr , n ) : neg = 0 pos = 0 sum = 0 for i in range ( 0 , n ) : sum += arr [ i ] if ( arr [ i ] < 0 ) : neg += 1 else : pos += 1 return ( sum / abs ( neg - pos ) )

def findInteger ( arr , n ) : neg = 0 pos = 0 sum = 0 for i in range ( n ) : sum += arr [ i ] if ( arr [ i ] < 0 ) : neg += 1 else : pos += 1 return sum

def findInteger ( arr , n ) : neg = 0 pos = 0 sum = 0 for i in range ( n ) : sum += arr [ i ] if arr [ i ] < 0 : neg ++ else : pos += 1 return ( sum / math . abs ( neg - pos ) )

77.34
73.64
77.34
73.64
static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }

def sumEqualProduct ( a , n ) : zero = 0 two = 0 for i in range ( n ) : if a [ i ] == 0 : zero += 1 if a [ i ] == 2 : two += 1 cnt = ( zero * ( zero - 1 ) ) // 2 + \ ( two * ( two - 1 ) ) // 2 return cnt

def sumEqualProduct ( a , n ) : zero = 0 two = 0 for i in range ( n ) : if ( a [ i ] == 0 ) : zero += 1 if ( a [ i ] == 2 ) : two += 1 cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 return cnt

def sumEqualProduct ( a , n ) : zero = 0 two = 0 for i in range ( n ) : if ( a [ i ] == 0 ) : zero += 1 if ( a [ i ] == 2 ) : two += 1 cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 return cnt

77.52
61.18
76.78
60.97
static float findArea ( float a ) { float area ; area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4 ; return area ; }

def findArea ( a ) : area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4 return area

def findArea ( a ) : area = ( float ) ( ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4 return area

def findArea ( a ) : area = ( float ( math . sqrt ( 5 * ( 5 + 2 * ( math . sqrt ( 5 ) ) ) * a * a ) / 4 return area

77.6
66.46
88.23
63.82
int catalan ( int n ) { int res = 0 ; if ( n <= 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }

def catalan ( n ) : if n <= 1 : return 1 res = 0 for i in range ( n ) : res += catalan ( i ) * catalan ( n - i - 1 ) return res

def catalan ( n ) : res = 0 for i in range ( n ) : res += catalan ( i ) * catalan ( n - i - 1 ) return res

def catalan ( n ) : res = 0 if n <= 1 : return 1 for i in range ( n ) : res += catalan ( i ) * catalan ( n - i - 1 ) return res

77.73
60.54
78.26
61.15
private static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) { int dp [ ] = new int [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; }

def unboundedKnapsack ( W , n , val , wt ) : dp = [ 0 for i in range ( W + 1 ) ] ans = 0 for i in range ( W + 1 ) : for j in range ( n ) : if ( wt [ j ] <= i ) : dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) return dp [ W ]

def unboundedKnapsack ( W , n , val , wt ) : dp = [ 0 for i in range ( W , n ) ] for j in range ( 0 , n ) : if ( wt [ j ] <= i ) : dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) return dp [ W ]

def unboundedKnapsack ( W , n , val , wt ) : dp = [ INT_MAX for i in range ( W , n ) ] for i in range ( W , n ) : for j in range ( n ) : if wt [ j ] <= i : dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) return dp [ W ]

77.74
72.64
89.63
86.95
static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }

def arraySortedOrNot ( arr , n ) : if ( n == 0 or n == 1 ) : return True for i in range ( 1 , n ) : if ( arr [ i - 1 ] > arr [ i ] ) : return False return True

def arraySortedOrNot ( arr , n ) : if ( n == 0 ) : return false for i in range ( 1 , n ) : if ( arr [ i - 1 ] > arr [ i ] ) : return false return true

def arraySortedOrNot ( arr , n ) : if n == 0 or n == 1 : return True for i in range ( 1 , n ) : if ( arr [ i - 1 ] > arr [ i ] ) : return False return True

77.75
78.62
100.0
100.0
static int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }

def nswp ( n ) : if n == 0 or n == 1 : return 1 return 2 * nswp ( n - 1 ) + nswp ( n - 2 )

def nswp ( n ) : if ( n == 0 ) : return 1 return 2 * nswp ( n - 1 ) + nswp ( n - 2 )

def nswp ( n ) : if n == 0 or n == 1 : return 1 return 2 * nswp ( n - 1 ) + nswp ( n - 2 )

77.85
75.95
89.84
88.68
static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }

def pow ( a , b ) : if ( b == 0 ) : return 1 answer = a increment = a for i in range ( 1 , b ) : for j in range ( 1 , a ) : answer += increment increment = answer return answer

def pow ( a , b ) : if ( b == 0 ) : return 1 answer = a increment = a for i in range ( 1 , b ) : answer += increment increment = answer return answer

def pow ( a , b ) : if b == 0 : return 1 answer = a increment = a for i in range ( 1 , b ) : for j in range ( 1 , a ) : answer += increment increment = answer return answer

77.92
69.65
68.07
81.67
static int getMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }

def getMissingNo ( a , n ) : x1 = a [ 0 ] x2 = 1 for i in range ( 1 , n ) : x1 = x1 ^ a [ i ] for i in range ( 2 , n + 2 ) : x2 = x2 ^ i return x1 ^ x2

def getMissingNo ( a , n ) : x1 = a [ 0 ] x2 = a [ 1 ] for i in range ( n ) : x1 = x1 ^ a [ i ] for i in range ( 2 , n + 1 ) : x2 = x2 ^ i return ( x1 ^ x2 )

def getMissingNo ( a , n ) : x1 = a [ 0 ] x2 = 1 for i in range ( 1 , n ) : x1 = x1 ^ a [ i ] for i in range ( 1 , n ) : x1 = x1 ^ a [ i ] for i in range ( 2 , n + 1 ) : x2 = x2 ^ i return ( x1 ^ x2 )

77.94
71.72
85.87
65.14
static void replaceOriginal ( String s , int n ) { char r [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( "" ) ; }

def replaceOriginal ( s , n ) : r = [ '' ] * n for i in range ( n ) : r [ i ] = s [ n - 1 - i ] if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) : print ( r [ i ] , end = "" ) print ( )

def replaceOriginal ( s , n ) : r = [ 0 for i in range ( n ) ] for i in range ( n ) : r [ i ] = s [ n - 1 - i ] if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' : print ( r [ i ] ) i -= 1 if ( s [ i ] != 'u

def replaceOriginal ( s , n ) : r = [ 0 for i in range ( n ) ] for i in range ( n ) : r [ i ] = s [ n - 1 - i ] if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) : print ( r [ i ] )

77.98
60.11
82.71
66.23
static int countSubstr ( String s ) { int n = s . length ( ) ; int [ ] auxArr = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ] ; return count ; }

def countSubstr ( s ) : n = len ( s ) auxArr = [ 0 for i in range ( n ) ] if ( s [ 0 ] == '1' ) : auxArr [ 0 ] = 1 for i in range ( 0 , n ) : if ( s [ i ] == '1' ) : auxArr [ i ] = auxArr [ i - 1 ] + 1 else : auxArr [ i ] = auxArr [ i - 1 ] count = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( s [ i ] == '1' ) : count += auxArr [ i ] return count

def countSubstr ( s ) : n = len ( s ) auxArr = [ 1 for k in range ( n ) ] for i in range ( n ) : if ( s [ i ] == '1' ) auxArr [ i ] = 1 else : auxArr [ i ] = auxArr [ i - 1 ] + 1 count = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( s [ i ] == '1' ) : count += auxArr [ i ] if ( s [ i ] == '1' ) : count += auxArr [ i ] return count

def countSubstr ( s ) : auxArr = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : if ( s [ i ] == '1' ) : auxArr [ i ] = 1 for i in range ( 1 , n ) : if ( s [ i ] == '1' ) : auxArr [ i ] = auxArr [ i - 1 ] + 1 else : auxArr [ i ] = auxArr [ i - 1 ] count = 0 for i in range ( n - 1 ) : if ( s [ i ] == '1' ) : count += auxArr [ i ] return count

78.16
55.69
42.71
46.03
int countwalks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; return count ; }

def countwalks ( graph , u , v , k ) : if ( k == 0 and u == v ) : return 1 if ( k == 1 and graph [ u ] [ v ] ) : return 1 if ( k <= 0 ) : return 0 count = 0 for i in range ( 0 , V ) : if ( graph [ u ] [ i ] == 1 ) : count += countwalks ( graph , i , v , k - 1 ) return count

def countwalks ( graph , u , v , k ) : if ( u == v ) : return 1 if ( k == 1 and graph [ u ] [ v ] == 1 ) : return countwalks ( graph , u , v , k - 1 ) else : count = 0 for i in range ( 0 , V ) : if ( graph [ u ] [ i ] == 1 ) : count += countwalks ( graph , i , v , k - 1 ) : return count

def countwalks ( graph , u , v , k ) : count = 0 for i in range ( V ) : if ( graph [ u ] [ i ] == 1 ) : count += countwalks ( graph , i , v , k - 1 ) return count

78.25
63.43
63.51
50.43
static int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }

def count ( n ) : dp = [ 0 for _ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if i <= 3 : dp [ i ] = 1 elif i == 4 : dp [ i ] = 2 else : dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] return dp [ n ]

def count ( n ) : dp = [ 0 for i in range ( n ) ] for i in range ( 1 , n + 1 ) : if ( i >= 1 and i <= 3 ) : dp [ i ] = 1 else : dp [ i ] = 2 dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] return dp [ n ]

def count ( n ) : dp = [ 0 for i in range ( n ) ] for i in range ( 1 , n ) : if ( i >= 1 and i <= 3 ) : dp [ i ] = 1 else : dp [ i ] = ( dp [ i - 1 ] + dp [ i - 4 ] ) return dp [ n ]

78.39
70.17
78.39
70.17
static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; }

def mod ( num , a ) : res = 0 for i in range ( 0 , len ( num ) ) : res = ( res * 10 + int ( num [ i ] ) ) % a return res

def mod ( num , a ) : res = 0 for i in range ( len ( num ) ) : res = ( res * 10 + ( int ) num [ i ] - '0' ) % a return res

def mod ( num , a ) : res = 0 for i in range ( len ( num ) ) : res = ( res * 10 + ( int ) num [ i ] - '0' ) % a return res

78.39
80.74
82.14
88.89
static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '(' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }

def maxLength ( s , n ) : invalidOpenBraces = 0 invalidCloseBraces = 0 for i in range ( n ) : if ( s [ i ] == '(' ) : invalidOpenBraces += 1 else : if ( invalidOpenBraces == 0 ) : invalidCloseBraces += 1 else : invalidOpenBraces -= 1 return ( n - ( invalidOpenBraces + invalidCloseBraces ) )

def maxLength ( s , n ) : invalidOpenBraces = 0 invalidCloseBraces = 0 for i in range ( n ) : if ( s [ i ] == '(' ) : invalidCloseBraces += 1 elif ( s [ i ] == ')' ) : invalidOpenBraces -= 1 else : invalidCloseBraces -= 1 return ( n - ( invalidOpenBraces + invalidCloseBraces ) )

def maxLength ( s , n ) : invalidOpenBraces = 0 invalidCloseBraces = 0 for i in range ( n ) : if ( s [ i ] == '(' ) : invalidOpenBraces += 1 else : if ( invalidOpenBraces == 0 ) : invalidCloseBraces -- elif ( invalidOpenBraces == 0 ) : invalidOpenBraces -= 1 else : invalidCloseBraces -= 1 return ( n - ( invalidOpenBraces + invalidCloseBraces ) )

78.49
74.34
78.7
67.7
static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) if ( arr2 [ i ] == arr1 [ j ] ) break ; if ( j == m ) return false ; } return true ; }

def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( n ) : for j in range ( m ) : if ( arr2 [ i ] == arr1 [ j ] ) : break if ( j == m ) : return 0 return 1

def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( 0 , n ) : if ( arr2 [ i ] == arr1 [ j ] ) : break if ( j == m ) : return false return true

def isSubset ( arr1 , arr2 , m , n ) : for i in range ( n ) : for j in range ( 0 , m , n ) : if ( arr2 [ i ] == arr1 [ j ] ) : break if ( j == m ) : return False return True

78.53
67.67
61.54
55.32
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }

def getInvCount ( arr , n ) : invcount = 0 for i in range ( 1 , n - 1 ) : small = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : small += 1 great = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( arr [ i ] < arr [ j ] ) : great += 1 invcount += great * small return invcount

def getInvCount ( arr , n ) : invcount = 0 for i in range ( n ) : small = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) small += 1 great = 0 for j in range ( i - 1 , n ) : if ( arr [ i ] < arr [ j ] ) great += 1 invcount += small * small return invcount

def getInvCount ( arr , n ) : invcount = 0 for i in range ( n ) : small = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : small += 1 if ( arr [ i ] < arr [ j ] ) : great += small * j return invcount

78.62
70.14
69.58
65.81
static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + " " ) ; }

def countWaysToJump ( arr , n ) : count_jump = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] >= n - i - 1 ) : count_jump [ i ] += 1 j = i + 1 while ( j < n - 1 and j <= arr [ i ] + i ) : if ( count_jump [ j ] != - 1 ) : count_jump [ i ] += count_jump [ j ] j += 1 if ( count_jump [ i ] == 0 ) : count_jump [ i ] = - 1 for i in range ( n ) : print ( count_jump [ i ] , end = "" )

def countWaysToJump ( arr , n ) : count_jump = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] >= n - i - 1 ) : count_jump [ i ] += 1 if ( count_jump [ i ] == 0 ) : count_jump [ i ] = - 1 else : for j in range ( i + 1 , n - 1 ) : if ( j <= arr [ i ] + i ) : if ( count_jump [ j ] != - 1 ) : count_jump [ i ] += count_jump [ j ] if ( count_jump [ i ] == 0 ) : count_jump [ i ] = 0 print ( count_jump [ i ]

def countWaysToJump ( arr , n ) : count_jump = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] >= n - i - 1 ) : count_jump [ i ] += count_jump [ i ] for j in range ( i + 1 , n - 1 ) : if ( count_jump [ j ] != - 1 ) : count_jump [ i ] += count_jump [ j ] if ( count_jump [ i ] == 0 ) : count_jump [ i ] = - 1 return count_jump

78.62
56.92
44.0
52.5
static int findMinRooms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }

def findMinRooms ( slots , n , m ) : counts = [ 0 ] * m for i in range ( n ) : for j in range ( m ) : if ( slots [ i ] [ j ] == '1' ) : counts [ j ] += 1 return max ( counts )

def findMinRooms ( slots , n , m ) : counts = [ 0 for i in range ( n , m ) ] for j in range ( 0 , n , m ) : if ( slots [ i ] [ j ] == '1' ) : counts [ j ] += 1 return max

def findMinRooms ( slots , n , m ) : counts = [ 0 for k in range ( m ) ] for i in range ( 0 , m ) : counts [ i ] = 0 for i in range ( 0 , n ) : if ( slots [ i ] [ j ] == '1' ) : counts [ j ] += 1 max = - 1 for i in range ( 0 , m ) : if ( max < counts [ i ] ) : max = counts [ i ] return max

78.88
66.73
92.99
91.9
static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }

def maxSubarrayXOR ( arr , n ) : ans = - 2147483648 for i in range ( n ) : curr_xor = 0 for j in range ( i , n ) : curr_xor = curr_xor ^ arr [ j ] ans = max ( ans , curr_xor ) return ans

def maxSubarrayXOR ( arr , n ) : ans = Integer . MIN_VALUE for i in range ( 0 , n ) : curr_xor = 0 for j in range ( i + 1 , n ) : curr_xor = curr_xor ^ arr [ j ] ans = max ( ans , curr_xor ) return ans

def maxSubarrayXOR ( arr , n ) : ans = INT_MIN_VALUE for i in range ( n ) : curr_xor = 0 for j in range ( i , n ) : curr_xor = curr_xor ^ arr [ j ] ans = max ( ans , curr_xor ) return ans

79.05
59.13
79.24
54.92
static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }

def findSmallestDifference ( A , B , m , n ) : A . sort ( ) B . sort ( ) a = 0 b = 0 result = sys . maxsize while ( a < m and b < n ) : if ( abs ( A [ a ] - B [ b ] ) < result ) : result = abs ( A [ a ] - B [ b ] ) if ( A [ a ] < B [ b ] ) : a += 1 else : b += 1 return result

def findSmallestDifference ( A , B , m , n ) : A . sort ( ) B . sort ( ) a = 0 b = 0 result = float ( 'inf' ) while ( a < m && b < n ) : if ( A [ a ] < B [ b ] ) : result = abs ( A [ a ] - B [ b ] ) a += 1 else : b += 1 if ( A [ a ] < B [ b ] ) : result =

def findSmallestDifference ( A , B , m , n ) : a = 0 b = 0 result = float ( 'inf' ) while a < m and b < n : if ( abs ( A [ a ] - B [ b ] ) < result ) : result = abs ( A [ a ] - B [ b ] ) if ( A [ a ] < B [ b ] ) : a += 1 else : b += 1 return result

79.15
48.23
60.66
37.87
public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

def search ( arr , n , x ) : for i in range ( 0 , n ) : if ( arr [ i ] == x ) : return i return - 1

def search ( arr , x ) : n = arr . length for i in range ( 0 , n ) : if ( arr [ i ] == x ) : return i

def search ( arr , x ) : n = arr . length for i in range ( n ) : if arr [ i ] == x : return i return - 1

79.32
73.25
100.0
100.0
static int maxSum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }

def maxSum ( arr , N , k ) : MS = [ 0 for i in range ( N ) ] MS [ N - 1 ] = arr [ N - 1 ] for i in range ( N - 2 , - 1 , - 1 ) : if ( i + k + 1 >= N ) : MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) else : MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) return MS [ 0 ]

def maxSum ( arr , N , k ) : MS = [ 0 for i in range ( N ) ] for i in range ( N - 2 , - 1 , - 1 ) : if ( i + k + 1 >= N ) : MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) else : MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) if ( k + 1 >= N ) : MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] ) return MS [ 0 ]

def maxSum ( arr , N , k ) : MS = [ 0 for i in range ( N ) ] MS [ N - 1 ] = arr [ N - 1 ] for i in range ( N - 2 , - 1 , - 1 ) : if ( i + k + 1 >= N ) : MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) else : MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) return MS [ 0 ]

79.37
80.01
86.24
85.86
static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }

def Right_most_setbit ( num ) : pos = 1 for i in range ( INT_SIZE ) : if not ( num & ( 1 << i ) ) : pos += 1 else : break return pos

def Right_most_setbit ( num ) : pos = 1 for i in range ( INT_SIZE ) : if ( num & ( 1 << i ) ) == 0 : pos ++ else : break return pos

def Right_most_setbit ( num ) : pos = 1 for i in range ( INT_SIZE ) : if ( num & ( 1 << i ) ) == 0 : pos += 1 else : break return pos

79.53
73.66
77.29
65.27
static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }

def numOfways ( n , k ) : p = 1 if ( k % 2 ) : p = - 1 return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n

def numOfways ( n , k ) : p = 1 if ( k % 2 == 0 ) : p = - 1 return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n

def numOfways ( n , k ) : p = 1 if k % 2 != 0 : p = - 1 return ( int ( math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n

79.57
82.09
86.88
83.43
static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }

def maxProduct ( arr , n ) : if n < 3 : return - 1 arr . sort ( ) return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )

def maxProduct ( arr , n ) : if ( n < 2 ) : return - 1 else : arr . sort ( reverse = True ) return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )

def maxProduct ( arr , n ) : if n < 3 : return - 1 sort ( arr ) return max ( arr [ 0 ] * arr [ 1 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )

79.71
73.54
88.03
78.3
static int maxXOR ( int mat [ ] [ ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }

def maxXOR ( mat , N ) : max_xor = 0 for i in range ( N ) : r_xor = 0 c_xor = 0 for j in range ( N ) : r_xor = r_xor ^ mat [ i ] [ j ] c_xor = c_xor ^ mat [ j ] [ i ] if ( max_xor < max ( r_xor , c_xor ) ) : max_xor = max ( r_xor , c_xor ) return max_xor

def maxXOR ( mat , N ) : r_xor , c_xor = 0 , 0 for i in range ( N ) : r_xor = 0 c_xor = 0 for j in range ( N ) : r_xor = r_xor ^ mat [ i ] [ j ] c_xor = c_xor ^ mat [ j ] [ i ] max_xor = max ( r_xor , c_xor ) return max_xor

def maxXOR ( mat , N ) : r_xor , c_xor = 0 , 0 for i in range ( N ) : r_xor = 0 c_xor = 0 for j in range ( N ) : r_xor = r_xor ^ mat [ i ] [ j ] c_xor = c_xor ^ mat [ j ] [ i ] if max_xor < max ( r_xor , c_xor ) : max_xor = max ( r_xor , c_xor ) return max_xor

79.74
84.25
94.5
87.66
static int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; return res ; }

def countDivisibles ( arr , n ) : res = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : res += 1 return res

def countDivisibles ( arr , n ) : res = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] % arr [ j ] == 0 ) : res += 1 return res

def countDivisibles ( arr , n ) : res = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : res += 1 return res

79.75
56.74
82.47
60.87
static char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }

def maxRepeating ( str ) : n = len ( str ) count = 0 res = str [ 0 ] cur_count = 1 for i in range ( n ) : if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : cur_count += 1 else : if cur_count > count : count = cur_count res = str [ i ] cur_count = 1 return res

def maxRepeating ( str ) : n = len ( str ) res = str [ 0 ] cur_count = 1 for i in range ( n ) : if ( str [ i ] == str [ i + 1 ] ) : cur_count += 1 else : if ( cur_count > count ) : count = cur_count res = str [ i ] cur_count = 1 return res

def maxRepeating ( str ) : count = 0 res = str [ 0 ] cur_count = 1 for i in range ( 0 , n , - 1 ) : if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : cur_count += 1 else : if ( cur_count > count ) : count = cur_count res = str [ i ] cur_count = 1 return res

79.75
48.65
75.16
45.07
static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " " + arr2 [ j ] ) ; }

def findPairs ( arr1 , arr2 , n , m , x ) : for i in range ( 0 , n ) : for j in range ( 0 , m ) : if ( arr1 [ i ] + arr2 [ j ] == x ) : print ( arr1 [ i ] , arr2 [ j ] )

def findPairs ( arr1 , arr2 , n , m , x ) : for i in range ( 0 , n , m ) : if ( arr1 [ i ] + arr2 [ j ] == x ) : print ( arr1 [ i ] + " " + arr2 [ j ] )

def findPairs ( arr1 , arr2 , n , m , x ) : for i in range ( n ) : for j in range ( m ) : if arr1 [ i ] + arr2 [ j ] == x : print ( arr1 [ i ] + " " + arr2 [ j ] )

79.84
65.79
83.44
68.8
static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; System . out . println ( "(" + x + ", " + y + ")" ) ; }

def section ( x1 , x2 , y1 , y2 , m , n ) : x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) print ( x , y )

def section ( x1 , x2 , y1 , y2 , m , n ) : x = ( n * x1 ) + ( m * x2 ) ) / ( m + n ) y = ( n * y1 ) + ( m * y2 ) ) / ( m + n ) print ( "(" + x + ", " + y + ")" ) exit ( )

def section ( x1 , x2 , y1 , y2 , m , n ) : x = ( n * x1 + ( m * x2 ) ) / ( m + n ) y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) print ( x , y )

80.06
51.42
86.66
58.95
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }

def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

def knapSack ( W , wt , val , n ) : if ( n == 0 || W == 0 ) : return 0 if wt [ n - 1 ] > W : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if wt [ n - 1 ] > W : return knapSack ( W , wt , val , n ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n ) , knapSack ( W , wt , val , n - 1 ) )

80.06
51.42
86.66
58.95
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }

def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

def knapSack ( W , wt , val , n ) : if ( n == 0 || W == 0 ) : return 0 if wt [ n - 1 ] > W : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if wt [ n - 1 ] > W : return knapSack ( W , wt , val , n ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n ) , knapSack ( W , wt , val , n - 1 ) )

80.06
51.42
86.66
58.95
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }

def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

def knapSack ( W , wt , val , n ) : if ( n == 0 || W == 0 ) : return 0 if wt [ n - 1 ] > W : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if wt [ n - 1 ] > W : return knapSack ( W , wt , val , n ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n ) , knapSack ( W , wt , val , n - 1 ) )

80.08
79.25
74.16
70.4
static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; }

def allCharactersSame ( s ) : n = len ( s ) for i in range ( 1 , n ) : if s [ i ] != s [ 0 ] : return False return True

def allCharactersSame ( s ) : n = len ( s ) for i in range ( 1 , n ) : if ( s [ i ] != s [ 0 ] ) : return false return true

def allCharactersSame ( s ) : n = s . length ( ) for i in range ( 1 , n ) : if ( s [ i ] != s [ 0 ] ) : return False return True

80.08
64.08
86.77
70.42
static int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }

def countRotations ( arr , n ) : min = arr [ 0 ] for i in range ( 0 , n ) : if ( min > arr [ i ] ) : min = arr [ i ] min_index = i return min_index

def countRotations ( arr , n ) : min = arr [ 0 ] min_index = - 1 for i in range ( n ) : if ( min > arr [ i ] ) : min = arr [ i ] min_index = i } return min_index

def countRotations ( arr , n ) : min = arr [ 0 ] , min_index = - 1 for i in range ( 0 , n ) : if ( min > arr [ i ] ) : min = arr [ i ] min_index = i return min_index

80.29
69.28
81.54
80.43
static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }

def findGreatest ( arr , n ) : result = - 1 for i in range ( n ) : for j in range ( n - 1 ) : for k in range ( j + 1 , n ) : if ( arr [ j ] * arr [ k ] == arr [ i ] ) : result = max ( result , arr [ i ] ) return result

def findGreatest ( arr , n ) : result = - 1 for i in range ( 0 , n ) : for j in range ( 0 , n - 1 , - 1 ) : if ( arr [ j ] * arr [ k ] == arr [ i ] ) : result = max ( result , arr [ i ] ) return result

def findGreatest ( arr , n ) : result = - 1 for i in range ( n ) : for j in range ( 0 , n - 1 , - 1 ) : if ( arr [ j ] * arr [ k ] == arr [ i ] ) : result = max ( result , arr [ i ] ) return result

80.31
59.28
73.37
76.67
static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = Integer . MAX_VALUE ; int x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }

def eggDrop ( n , k ) : if ( k == 1 or k == 0 ) : return k if ( n == 1 ) : return k min = sys . maxsize for x in range ( 1 , k + 1 ) : res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) if ( res < min ) : min = res return min + 1

def eggDrop ( n , k ) : if ( k == 0 ) : return k if ( n == 1 || k == 0 ) : return k min = float ( 'inf' ) for x in range ( 1 , k ) : res = eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) if ( res < min ) : min = res return min + 1

def eggDrop ( n , k ) : if k == 1 or k == 0 : return k min = float ( 'inf' ) for x in range ( 1 , k ) : res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) if ( res < min ) : min = res return min + 1

80.38
64.18
85.87
70.82
static int minTime ( int [ ] arr , int n , int m ) { int t = 0 ; while ( true ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }

def minTime ( arr , n , m ) : t = 0 while ( 1 ) : items = 0 for i in range ( n ) : items += ( t // arr [ i ] ) if ( items >= m ) : return t t += 1

def minTime ( arr , n , m ) : t = 0 for i in range ( n ) : items = 0 for i in range ( n ) : items += ( t / arr [ i ] ) if ( items >= m ) : return t

def minTime ( arr , n , m ) : t = 0 while True : items = 0 for i in range ( n ) : items += ( t / arr [ i ] ) if ( items >= m ) : return t t += 1

80.5
67.89
69.82
64.12
static int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }

def minRadius ( k , x , y , n ) : dis = [ 0 ] * n for i in range ( 0 , n ) : dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] dis . sort ( ) return dis [ k - 1 ]

def minRadius ( k , x , y , n ) : dis = [ 0 for i in range ( n ) ] for i in range ( 0 , k ) : dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] return dis [ k - 1 ]

def minRadius ( k , x , y , n ) : dis = [ 0 for k in range ( k ) ] for i in range ( n ) : dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] dis [ i ] = float ( 'inf' ) sort ( dis ) return dis [ k - 1 ]

80.8
83.15
80.8
83.15
static int find_extra_element_index ( int [ ] arrA , int [ ] arrB ) { int extra_element = sum ( arrA ) - sum ( arrB ) ; return indexOf ( arrA , extra_element ) ; }

def find_extra_element_index ( arrA , arrB ) : extra_element = sum ( arrA ) - sum ( arrB ) return arrA . index ( extra_element )

def find_extra_element_index ( arrA , arrB ) : extra_element = sum ( arrA ) - sum ( arrB ) return indexOf ( arrA , extra_element )

def find_extra_element_index ( arrA , arrB ) : extra_element = sum ( arrA ) - sum ( arrB ) return indexOf ( arrA , extra_element )

80.94
84.27
84.71
81.44
static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }

def seiresSum ( n , a ) : res = 0 for i in range ( 0 , 2 * n ) : if ( i % 2 == 0 ) : res += a [ i ] * a [ i ] else : res -= a [ i ] * a [ i ] return res

def seiresSum ( n , a ) : res = 0 for i in range ( 2 * n ) : res += a [ i ] * a [ i ] for i in range ( 2 * n ) : if ( i % 2 == 0 ) : res -= a [ i ] * a [ i ] return res

def seiresSum ( n , a ) : res = 0 for i in range ( 2 * n ) : if i % 2 == 0 : res += a [ i ] * a [ i ] else : res -= a [ i ] * a [ i ] return res

81.12
78.73
87.07
86.66
static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }

def isPossible ( a , b , n , k ) : a . sort ( reverse = True ) b . sort ( ) for i in range ( n ) : if ( a [ i ] + b [ i ] < k ) : return False return True

def isPossible ( a , b , n , k ) : a . sort ( reverse = True ) b . sort ( reverse = True ) for i in range ( 0 , n ) : if ( a [ i ] + b [ i ] < k ) : return false return true

def isPossible ( a , b , n , k ) : a . sort ( reverse = True ) b . sort ( ) for i in range ( 0 , n , - 1 ) : if ( a [ i ] + b [ i ] < k ) : return False return True

81.15
71.95
89.67
79.58
static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }

def countPairsWithDiffK ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : count += 1 return count

def countPairsWithDiffK ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] - arr [ j ] == k ) : count += 1 if ( arr [ j ] - arr [ i ] == k ) : count += 1 return count

def countPairsWithDiffK ( arr , n , k ) : count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k ) : count += 1 return count

81.41
49.29
84.61
53.56
int lcs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }

def lcs ( X , Y , m , n ) : if m == 0 or n == 0 : return 0 ; elif X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else : return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;

def lcs ( X , Y , m , n ) : if ( m == 0 || n == 0 ) : return 0 if X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m , n - 1 ) else : return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) )

def lcs ( X , Y , m , n ) : if m == 0 or n == 0 : return 0 if X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m - 1 , n ) else : return max ( lcs ( X , Y , m , n ) , lcs ( X , Y , m - 1 , n ) )

81.41
49.29
84.61
53.56
int lcs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }

def lcs ( X , Y , m , n ) : if m == 0 or n == 0 : return 0 ; elif X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else : return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;

def lcs ( X , Y , m , n ) : if ( m == 0 || n == 0 ) : return 0 if X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m , n - 1 ) else : return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) )

def lcs ( X , Y , m , n ) : if m == 0 or n == 0 : return 0 if X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m - 1 , n ) else : return max ( lcs ( X , Y , m , n ) , lcs ( X , Y , m - 1 , n ) )

81.41
81.56
94.61
82.8
static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }

def getSingle ( arr , n ) : ones = 0 twos = 0 for i in range ( n ) : twos = twos | ( ones & arr [ i ] ) ones = ones ^ arr [ i ] common_bit_mask = ~ ( ones & twos ) ones &= common_bit_mask twos &= common_bit_mask return ones

def getSingle ( arr , n ) : ones = 0 twos = 0 for i in range ( n ) : ones = ones | ( arr [ i ] ) twos = twos & arr [ i ] common_bit_mask = ~ ( ones & twos ) ones &= common_bit_mask twos &= common_bit_mask return twos

def getSingle ( arr , n ) : ones = 0 twos = 0 common_bit_mask = 0 for i in range ( n ) : twos = twos | ( ones & arr [ i ] ) ones = ones ^ arr [ i ] common_bit_mask = ~ ( ones & twos ) ones &= common_bit_mask twos &= common_bit_mask return ones

81.77
75.01
85.85
70.13
static int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }

def minTime ( arr , n ) : if ( n <= 0 ) : return 0 incl = arr [ 0 ] excl = 0 for i in range ( 1 , n ) : incl_new = arr [ i ] + min ( excl , incl ) excl_new = incl incl = incl_new excl = excl_new return min ( incl , excl )

def minTime ( arr , n ) : if ( n <= 0 ) : return 0 incl = arr [ 0 ] excl = arr [ 0 ] for i in range ( 1 , n ) : incl_new = arr [ i ] + min ( excl , incl ) excl = incl_new return min ( incl , excl )

def minTime ( arr , n ) : if n <= 0 : return 0 incl = arr [ 0 ] excl = 0 for i in range ( 1 , n ) : incl_new = arr [ i ] + Math . min ( excl , incl ) int excl_new = incl incl = incl_new excl = excl_new return min ( incl , excl )

82.89
60.21
91.67
70.88
static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }

def maxSubArraySumRepeated ( a , n , k ) : max_so_far = - 2147483648 max_ending_here = 0 for i in range ( n * k ) : max_ending_here = max_ending_here + a [ i % n ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if ( max_ending_here < 0 ) : max_ending_here = 0 return max_so_far

def maxSubArraySumRepeated ( a , n , k ) : max_so_far = 0 for i in range ( 0 , n * k ) : max_ending_here = a [ i % n ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if ( max_ending_here < 0 ) : max_ending_here = 0 return max_so_far

def maxSubArraySumRepeated ( a , n , k ) : max_so_far = 0 for i in range ( n * k ) : max_ending_here = max_ending_here + a [ i % n ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if ( max_ending_here < 0 ) : max_ending_here = 0 return max_so_far

82.9
71.95
83.06
78.4
static int countPairs ( String s ) { int cnt [ ] = new int [ MAX ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s . charAt ( i ) ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; }

def countPairs ( s ) : cnt = [ 0 for i in range ( 0 , MAX ) ] for i in range ( len ( s ) ) : cnt [ ord ( s [ i ] ) - 97 ] += 1 ans = 0 for i in range ( 0 , MAX ) : ans += cnt [ i ] * cnt [ i ] return ans

def countPairs ( s ) : cnt = [ 0 for i in range ( len ( s ) ) ] for i in range ( len ( s ) ) : cnt [ s [ i ] ] += 1 ans = 0 for i in range ( 0 , MAX ) : ans += cnt [ i ] * cnt [ i ] return ans

def countPairs ( s ) : cnt = [ 0 for i in range ( MAX ) ] for i in range ( len ( s ) ) : cnt [ s [ i ] ] += 1 ans = 0 for i in range ( 0 , MAX ) : ans += cnt [ i ] * cnt [ i ] return ans

82.94
81.53
89.18
91.89
static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i ; i += Math . abs ( arr [ i ] - x ) ; } return - 1 ; }

def search ( arr , n , x ) : i = 0 while ( i <= n - 1 ) : if ( arr [ i ] == x ) : return i i += abs ( arr [ i ] - x ) return - 1

def search ( arr , n , x ) : i = 0 while ( i <= n - 1 ) : if ( arr [ i ] == x ) : return i i += 1 if ( arr [ i ] == x ) : return - 1

def search ( arr , n , x ) : i = 0 while i <= n - 1 : if ( arr [ i ] == x ) : return i i += abs ( arr [ i ] - x ) return - 1

82.98
56.42
86.19
61.43
static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }

def cosXSertiesSum ( x , n ) : x = x * ( PI / 180.0 ) res = 1 sign = 1 fact = 1 pow = 1 for i in range ( 1 , 5 ) : sign = sign * - 1 fact = fact * ( 2 * i - 1 ) * ( 2 * i ) pow = pow * x * x res = res + sign * pow / fact return res

def cosXSertiesSum ( x , n ) : x = x * x sign = 1 fact = 1 pow = 1 for i in range ( 1 , n ) : sign = sign * - 1 fact = fact * ( 2 * i - 1 ) * ( 2 * i - 1 ) pow = pow * x * x res = res + sign * pow / fact return res

def cosXSertiesSum ( x , n ) : res = 1 sign = 1 fact = 1 pow = 1 for i in range ( 1 , 5 ) : sign = sign * - 1 fact = fact * ( 2 * i - 1 ) * ( 2 * i ) pow = pow * x * x res = res + sign * pow / fact return res

83.22
65.92
81.51
63.54
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }

def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : arr . sort ( ) dp = [ 0 ] * N dp [ 0 ] = 0 for i in range ( 1 , N ) : dp [ i ] = dp [ i - 1 ] if ( arr [ i ] - arr [ i - 1 ] < K ) : if ( i >= 2 ) : dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) else : dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) return dp [ N - 1 ]

def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : dp = [ 0 for i in range ( N ) ] for i in range ( 1 , N ) : dp [ i ] = dp [ i - 1 ] if ( arr [ i ] - arr [ i - 1 ] < K ) : dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) else : dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) return dp [ N - 1 ]

def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : dp = [ 0 for i in range ( 1 , N ) ] for i in range ( 1 , N ) : dp [ i ] = dp [ i - 1 ] if arr [ i ] - arr [ i - 1 ] < K : if i >= 2 : dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) else : dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) return dp [ N - 1 ]

83.34
62.54
94.41
75.32
static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }

def countInRange ( arr , n , x , y ) : count = 0 ; for i in range ( n ) : if ( arr [ i ] >= x and arr [ i ] <= y ) : count += 1 return count

def countInRange ( arr , n , x , y ) : count = 0 for i in range ( 0 , n ) : if ( arr [ i ] >= x && arr [ i ] <= y ) : count += 1 return count

def countInRange ( arr , n , x , y ) : count = 0 for i in range ( n ) : if ( arr [ i ] >= x and arr [ i ] <= y ) : count += 1 return count

83.46
76.64
100.0
100.0
static boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }

def oppositeSigns ( x , y ) : return ( ( x ^ y ) < 0 )

def oppositeSigns ( x , y ) : return ( x ^ y ) < 0

def oppositeSigns ( x , y ) : return ( ( x ^ y ) < 0 )

83.88
80.53
83.88
80.53
static int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }

def maxTripletSum ( arr , n ) : arr . sort ( ) return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )

def maxTripletSum ( arr , n ) : arr . sort ( reverse = True ) return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ]

def maxTripletSum ( arr , n ) : arr . sort ( reverse = True ) return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ]

83.96
69.7
83.96
69.7
static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }

def countCommon ( mat , n ) : res = 0 for i in range ( n ) : if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : res = res + 1 return res

def countCommon ( mat , n ) : res = 0 for i in range ( n ) : if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) : res += 1 return res

def countCommon ( mat , n ) : res = 0 for i in range ( n ) : if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) : res += 1 return res

84.79
70.29
89.78
94.9
static int findFlips ( String str , int n ) { char last = ' ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; }

def findFlips ( str , n ) : last = '' res = 0 for i in range ( n ) : if ( last != str [ i ] ) : res += 1 last = str [ i ] return res // 2

def findFlips ( str , n ) : res = 0 for i in range ( n ) : if ( last != str [ i ] ) : res += 1 last = str [ i ] return res

def findFlips ( str , n ) : last = ' ' res = 0 for i in range ( n ) : if ( last != str [ i ] ) : res += 1 last = str [ i ] return res

85.43
70.48
83.73
67.11
static void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; }

def timeToMeet ( s , v ) : V = 3 * v / 2 time = s / V print ( time )

def timeToMeet ( s , v ) : V = 3 * v / 2 time = s / V print ( time ) print ( V )

def timeToMeet ( s , v ) : V = 3 * v / 2 time = s / V print ( ( float ) time )

85.93
52.8
100.0
75.0
static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }

def findElement ( arr , n , key ) : for i in range ( n ) : if ( arr [ i ] == key ) : return i return - 1

def findElement ( arr , n , key ) : for i in range ( 0 , n ) : if ( arr [ i ] == key ) : return i

def findElement ( arr , n , key ) : for i in range ( n ) : if ( arr [ i ] == key ) : return i return - 1

86.25
74.26
89.5
83.52
static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }

def distancesum ( x , y , n ) : sum = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) return sum

def distancesum ( x , y , n ) : sum = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : sum += ( x [ i ] - x [ j ] ) + ( y [ i ] - y [ j ] ) return sum

def distancesum ( x , y , n ) : sum = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) return sum

87.55
80.75
69.68
45.92
public static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; }

def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x start = 1 end = x while ( start <= end ) : mid = ( start + end ) // 2 if ( mid * mid == x ) : return mid if ( mid * mid < x ) : start = mid + 1 ans = mid else : end = mid - 1 return ans

def floorSqrt ( x ) : if ( x == 0 ) : return x else : start = 1 end = x while ( start <= end ) : mid = ( start + end ) // 2 if ( mid * mid == x ) : return mid if ( mid * mid > x ) : start = mid + 1 ans = mid else : end = mid - 1 return ans

def floorSqrt ( x ) : if x == 0 or x == 1 : return x start = 1 end = x ans = 0 while start <= end : mid = ( start + end ) // 2 if mid * mid == x : return mid if mid * mid < x : start = mid + 1 ans = mid - 1 else : end = mid - 1 return ans

87.64
60.85
100.0
100.0
static double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }

def compute ( a , b ) : AM = ( a + b ) / 2 GM = math . sqrt ( a * b ) HM = ( GM * GM ) / AM return HM

def compute ( a , b ) : AM = ( a + b ) / 2 GM = ( a * b ) HM = ( GM * GM ) / AM return HM

def compute ( a , b ) : AM = ( a + b ) / 2 GM = math . sqrt ( a * b ) HM = ( GM * GM ) / AM return HM

87.71
66.87
100.0
100.0
static int minJumps ( int a , int b , int d ) { int temp = a ; a = Math . min ( a , b ) ; b = Math . max ( temp , b ) ; if ( d >= b ) return ( d + b - 1 ) / b ; if ( d == 0 ) return 0 ; if ( d == a ) return 1 ; return 2 ; }

def minJumps ( a , b , d ) : temp = a a = min ( a , b ) b = max ( temp , b ) if ( d >= b ) : return ( d + b - 1 ) / b if ( d == 0 ) : return 0 if ( d == a ) : return 1 return 2

def minJumps ( a , b , d ) : temp = a a = b b = min ( a , b ) d = max ( a , b ) if ( d >= b ) : return ( d + b - 1 ) / b if ( d == 0 ) : return 0 if ( d == a ) : return 1 return 2

def minJumps ( a , b , d ) : temp = a a = min ( a , b ) b = max ( temp , b ) if ( d >= b ) : return ( d + b - 1 ) / b if ( d == 0 ) : return 0 if ( d == a ) : return 1 return 2

88.1
77.13
74.91
66.05
public static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) res ++ ; } return res ; }

def count ( s , c ) : res = 0 for i in range ( len ( s ) ) : if ( s [ i ] == c ) : res = res + 1 return res

def count ( s , c ) : res = 0 for i in range ( len ( s ) ) : if ( s [ i ] == c ) : res += 1 return res

def count ( s , c ) : res = 0 for i in range ( len ( s ) ) : if s [ i ] == c : res += 1 return res

88.5
70.81
100.0
100.0
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }

def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

def nextPowerOf2 ( n ) : n -= 1 n |= n >> 0 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

88.5
70.81
100.0
100.0
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }

def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

def nextPowerOf2 ( n ) : n -= 1 n |= n >> 0 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

88.66
83.89
88.57
85.84
static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }

def findSum ( N , K ) : ans = 0 for i in range ( 1 , N + 1 ) : ans += ( i % K ) return ans

def findSum ( N , K ) : ans = 0 for i in range ( 1 , N , K ) : ans += ( i % K ) return ans

def findSum ( N , K ) : ans = 0 for i in range ( 1 , N ) : ans += ( i % K ) return ans

89.0
75.43
79.25
71.88
static int findHeight ( int [ ] parent , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i , current = 1 ; while ( parent [ p ] != - 1 ) { current ++ ; p = parent [ p ] ; } res = Math . max ( res , current ) ; } return res ; }

def findHeight ( parent , n ) : res = 0 for i in range ( n ) : p = i current = 1 while ( parent [ p ] != - 1 ) : current += 1 p = parent [ p ] res = max ( res , current ) return res

def findHeight ( parent , n ) : res = 0 for i in range ( 0 , n ) : p = i current = 1 while ( parent [ p ] != - 1 ) : current ++ p = parent [ p ] res = max ( res , current ) return res

def findHeight ( parent , n ) : res = 0 for i in range ( n ) : p = i while parent [ p ] != - 1 : current += 1 parent [ p ] = parent [ p ] res = max ( res , current ) return res

89.25
76.9
78.06
59.68
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }

def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) for i in range ( n ) : for j in range ( i , n ) : if ( s [ i ] == s [ j ] ) : result = result + 1 return result

def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) for i in range ( n ) : for j in range ( i + 1 , n ) : if ( s [ i ] == s [ j ] ) : result += 1 return result

def countSubstringWithEqualEnds ( s ) : result = 0 n = s . length for i in range ( 0 , n ) : for j in range ( i , n ) : if ( s [ i ] == s [ j ] ) : result += 1 return result

90.07
76.47
100.0
100.0
static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s . charAt ( i ) == 'b' ) bCount = ( aCount + 2 * bCount ) ; else if ( s . charAt ( i ) == 'c' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }

def countSubsequences ( s ) : aCount = 0 bCount = 0 cCount = 0 for i in range ( len ( s ) ) : if ( s [ i ] == 'a' ) : aCount = ( 1 + 2 * aCount ) elif ( s [ i ] == 'b' ) : bCount = ( aCount + 2 * bCount ) elif ( s [ i ] == 'c' ) : cCount = ( bCount + 2 * cCount ) return cCount

def countSubsequences ( s ) : aCount = 0 bCount = 0 cCount = 0 for i in range ( len ( s ) ) : if ( s [ i ] == 'a' ) : aCount = ( 1 + 2 * aCount ) elif ( s [ i ] == 'b' ) : bCount = ( 1 + 2 * bCount ) else : s [ i ] == 'c' ) cCount = ( bCount + 2 * cCount ) return cCount

def countSubsequences ( s ) : aCount = 0 bCount = 0 cCount = 0 for i in range ( len ( s ) ) : if ( s [ i ] == 'a' ) : aCount = ( 1 + 2 * aCount ) elif ( s [ i ] == 'b' ) : bCount = ( aCount + 2 * bCount ) elif ( s [ i ] == 'c' ) : cCount = ( bCount + 2 * cCount ) return cCount

90.35
91.04
100.0
100.0
static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }

def maxSubArraySum ( a , size ) : max_so_far = a [ 0 ] curr_max = a [ 0 ] for i in range ( 1 , size ) : curr_max = max ( a [ i ] , curr_max + a [ i ] ) max_so_far = max ( max_so_far , curr_max ) return max_so_far

def maxSubArraySum ( a , size ) : max_so_far = 0 curr_max = a [ 0 ] for i in range ( 1 , size ) : curr_max = max ( a [ i ] , curr_max + a [ i ] ) max_so_far = max ( max_so_far , curr_max ) return max_so_far

def maxSubArraySum ( a , size ) : max_so_far = a [ 0 ] curr_max = a [ 0 ] for i in range ( 1 , size ) : curr_max = max ( a [ i ] , curr_max + a [ i ] ) max_so_far = max ( max_so_far , curr_max ) return max_so_far

90.7
87.22
90.7
87.22
public static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; }

def isPossibleToMakeDivisible ( arr , n ) : remainder = 0 for i in range ( 0 , n ) : remainder = ( remainder + arr [ i ] ) % 3 return ( remainder == 0 )

def isPossibleToMakeDivisible ( arr , n ) : remainder = 0 for i in range ( n ) : remainder = ( remainder + arr [ i ] ) % 3 return ( remainder == 0 )

def isPossibleToMakeDivisible ( arr , n ) : remainder = 0 for i in range ( n ) : remainder = ( remainder + arr [ i ] ) % 3 return ( remainder == 0 )

90.94
89.46
90.94
89.46
static int summingSeries ( long n ) { int S = 0 ; for ( i = 1 ; i <= n ; i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ) ; return S ; }

def summingSeries ( n ) : S = 0 for i in range ( 1 , n + 1 ) : S += i * i - ( i - 1 ) * ( i - 1 ) return S

def summingSeries ( n ) : S = 0 for i in range ( 1 , n ) : S += i * i - ( i - 1 ) * ( i - 1 ) return S

def summingSeries ( n ) : S = 0 for i in range ( 1 , n ) : S += i * i - ( i - 1 ) * ( i - 1 ) return S

91.39
82.39
91.39
82.39
static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ; return result ; }

def countToMake0lternate ( s ) : result = 0 for i in range ( len ( s ) - 1 ) : if ( s [ i ] == s [ i + 1 ] ) : result += 1 return result

def countToMake0lternate ( s ) : result = 0 for i in range ( len ( s ) ) : if ( s [ i ] == s [ i + 1 ] ) : result += 1 return result

def countToMake0lternate ( s ) : result = 0 for i in range ( len ( s ) ) : if ( s [ i ] == s [ i + 1 ] ) : result += 1 return result

91.39
89.06
91.39
89.06
static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }

def sumOfSeries ( n ) : sum = 0 for i in range ( 1 , n + 1 ) : sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) return sum

def sumOfSeries ( n ) : sum = 0 for i in range ( 1 , n ) : sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) return sum

def sumOfSeries ( n ) : sum = 0 for i in range ( 1 , n ) : sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) return sum

91.79
82.65
82.29
73.08
public static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i < right ; ++ i ) if ( arr [ i ] == element ) ++ count ; return count ; }

def findFrequency ( arr , n , left , right , element ) : count = 0 for i in range ( left - 1 , right ) : if ( arr [ i ] == element ) : count += 1 return count

def findFrequency ( arr , n , left , right , element ) : count = 0 for i in range ( left , right ) : if ( arr [ i ] == element ) : count += 1 return count

def findFrequency ( arr , n , left , right , element ) : count = 0 for i in range ( left , right ) : if ( arr [ i ] == element ) : ++ count return count

92.97
79.99
81.34
62.73
static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }

def solve ( arr , n ) : arr . sort ( ) a = 0 b = 0 for i in range ( n ) : if ( i % 2 != 0 ) : a = a * 10 + arr [ i ] else : b = b * 10 + arr [ i ] return a + b

def solve ( arr , n ) : arr . sort ( reverse = True ) a = 0 b = 0 for i in range ( n ) : if ( i % 2 != 0 ) : a = a * 10 + arr [ i ] else : b = b * 10 + arr [ i ] return a + b

def solve ( arr , n ) : a = 0 b = 0 for i in range ( n ) : if i % 2 != 0 : a = a * 10 + arr [ i ] else : b = b * 10 + arr [ i ] return a + b

92.99
92.25
88.13
85.04
static long findMinSum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }

def findMinSum ( a , b , n ) : a . sort ( ) b . sort ( ) sum = 0 for i in range ( n ) : sum = sum + abs ( a [ i ] - b [ i ] ) return sum

def findMinSum ( a , b , n ) : a . sort ( ) b . sort ( ) sum = 0 for i in range ( 0 , n ) : sum = sum + abs ( a [ i ] - b [ i ] ) return sum

def findMinSum ( a , b , n ) : a . sort ( a ) b . sort ( ) sum = 0 for i in range ( 0 , n ) : sum = sum + abs ( a [ i ] - b [ i ] ) return sum

92.99
89.8
92.65
93.95
static int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }

def getInvCount ( arr , n ) : inv_count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : inv_count += 1 return inv_count

def getInvCount ( arr , n ) : inv_count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : inv_count += 1 return inv_count

def getInvCount ( n ) : inv_count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : inv_count += 1 return inv_count

94.45
68.51
75.38
72.94
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }

def findExtra ( arr1 , arr2 , n ) : for i in range ( 0 , n ) : if ( arr1 [ i ] != arr2 [ i ] ) : return i return n

def findExtra ( arr1 , arr2 , n ) : for i in range ( 0 , n ) : if ( arr1 [ i ] != arr2 [ i ] ) : return i

def findExtra ( arr1 , arr2 , n ) : for i in range ( n ) : if arr1 [ i ] != arr2 [ i ] : return i return n

94.73
97.32
68.43
69.93
public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }

def minmaxProduct ( arr1 , arr2 , n1 , n2 ) : arr1 . sort ( ) arr2 . sort ( ) return arr1 [ n1 - 1 ] * arr2 [ 0 ]

def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : arr1 . sort ( ) arr2 . sort ( ) return arr1 [ n1 - 1 ] * arr2 [ 0 ]

def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : sort ( arr1 ) sort ( arr2 ) return arr1 [ n1 - 1 ] * arr2 [ 0 ]

94.87
90.0
100.0
100.0
static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }

def modInverse ( a , m ) : a = a % m for x in range ( 1 , m ) : if ( ( a * x ) % m == 1 ) : return x return 1

def modInverse ( a , m ) : a = a % m for x in range ( 1 , m ) : if ( ( a * x ) % m == 1 ) : return x

def modInverse ( a , m ) : a = a % m for x in range ( 1 , m ) : if ( ( a * x ) % m == 1 ) : return x return 1

100.0
100.0
87.97
72.37
static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }

def firstFactorialDivisibleNumber ( x ) : i = 1 fact = 1 for i in range ( 1 , x ) : fact = fact * i if ( fact % x == 0 ) : break return i

def firstFactorialDivisibleNumber ( x ) : i = 1 fact = 1 for i in range ( 1 , x ) : fact = fact * i if ( fact % x == 0 ) : break return i

def firstFactorialDivisibleNumber ( x ) : fact = 1 for i in range ( 1 , x ) : fact = fact * i if ( fact % x == 0 ) : break return i

100.0
75.0
84.93
58.03
public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }

def find ( n , k ) : if ( n + 1 >= k ) : return ( k - 1 ) else : return ( 2 * n + 1 - k )

def find ( n , k ) : if ( n + 1 >= k ) : return ( k - 1 ) else : return ( 2 * n + 1 - k )

def find ( n , k ) : if n + 1 >= k : return ( k - 1 ) else : return ( 2 * n + 1 - k )

100.0
100.0
92.95
86.23
static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }

def countPairs ( arr , n ) : ans = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : ans += 1 return ans

def countPairs ( arr , n ) : ans = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : ans += 1 return ans

def countPairs ( arr , n ) : ans = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : ans += 1 return ans

100.0
100.0
100.0
100.0
static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }

def unitDigitXRaisedY ( x , y ) : res = 1 for i in range ( y ) : res = ( res * x ) % 10 return res

def unitDigitXRaisedY ( x , y ) : res = 1 for i in range ( y ) : res = ( res * x ) % 10 return res

def unitDigitXRaisedY ( x , y ) : res = 1 for i in range ( y ) : res = ( res * x ) % 10 return res

100.0
100.0
100.0
100.0
static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }

def horner ( poly , n , x ) : result = poly [ 0 ] for i in range ( 1 , n ) : result = result * x + poly [ i ] return result

def horner ( poly , n , x ) : result = poly [ 0 ] for i in range ( 1 , n ) : result = result * x + poly [ i ] return result

def horner ( poly , n , x ) : result = poly [ 0 ] for i in range ( 1 , n ) : result = result * x + poly [ i ] return result

100.0
100.0
100.0
100.0
static boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }

def checkOrigin ( x1 , y1 , x2 , y2 ) : return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) )

def checkOrigin ( x1 , y1 , x2 , y2 ) : return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) )

def checkOrigin ( x1 , y1 , x2 , y2 ) : return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) )

100.0
100.0
100.0
100.0
static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }

def calculateSum ( n ) : sum = 0 for row in range ( n ) : sum = sum + ( 1 << row ) return sum

def calculateSum ( n ) : sum = 0 for row in range ( n ) : sum = sum + ( 1 << row ) return sum

def calculateSum ( n ) : sum = 0 for row in range ( n ) : sum = sum + ( 1 << row ) return sum

100.0
100.0
100.0
100.0
static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }

def findSum ( n ) : sum = 0 for i in range ( n ) : sum += i * ( n - i ) return 2 * sum

def findSum ( n ) : sum = 0 for i in range ( n ) : sum += i * ( n - i ) return 2 * sum

def findSum ( n ) : sum = 0 for i in range ( n ) : sum += i * ( n - i ) return 2 * sum

100.0
100.0
86.91
60.41
static float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }

def squareRoot ( n ) : x = n y = 1 e = 0.000001 while ( x - y > e ) : x = ( x + y ) / 2 y = n / x return x

def squareRoot ( n ) : x = n y = 1 e = 0.000001 while ( x - y > e ) : x = ( x + y ) / 2 y = n / x return x

def squareRoot ( n ) : x = n y = 1 e = 0.000001 while x - y > e : x = ( x + y ) / 2 y = n / x return x

