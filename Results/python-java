CodeT5_bleu,
CodeT5_codebleu,
FSCT_bleu,
FSCT_codebleu 
src,
gold, 
CodeT5_translation 
FSCT_translation
total num: 1402
0.0
2.12
6.09
13.04
def reverse ( string ) : string = string [ : : - 1 ] return string

static void reverse ( char str [ ] ) { int n = str . length , i ; for ( i = 0 ; i < n / 2 ; i ++ ) { swap ( str , i , n - i - 1 ) ; } }

def reverse ( string )

. toLowerCase ( ) { reverse ( string ) ; String str = string . toLowerCase ( ) ; return str . toLowerCase ( ) ; }

0.09
0.38
100.0
100.0
def Circumference ( l , w ) : return ( 2 * ( l + w ) )

static int Circumference ( int l , int w ) { return ( 2 * ( l + w ) ) ; }

def Circumference (

static int Circumference ( int l , int w ) { return ( 2 * ( l + w ) ) ; }

0.13
5.12
1.28
10.29
def printRoman ( number ) : num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] sym = [ "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" , "C" , "CD" , "D" , "CM" , "M" ] i = 12 while number : div = number // num [ i ] number %= num [ i ] while div : print ( sym [ i ] , end = "" ) div -= 1 i -= 1

static void printRoman ( int number ) { char c [ ] = new char [ 10001 ] ; int i = 0 ; if ( number <= 0 ) { System . out . printf ( "Invalid number" ) ; return ; } while ( number != 0 ) { if ( number >= 1000 ) { i = digit ( 'M' , number / 1000 , i , c ) ; number = number % 1000 ; } else if ( number >= 500 ) { if ( number < 900 ) { i = digit ( 'D' , number / 500 , i , c ) ; number = number % 500 ; } else { i = sub_digit ( 'C' , 'M' , i , c ) ; number = number % 100 ; } } else if ( number >= 100 ) { if ( number < 400 ) { i = digit ( 'C' , number / 100 , i , c ) ; number = number % 100 ; } else { i = sub_digit ( 'C' , 'D' , i , c ) ; number = number % 100 ; } } else if ( number >= 50 ) { if ( number < 90 ) { i = digit ( 'L' , number / 50 , i , c ) ; number = number % 50 ; } else { i = sub_digit ( 'X' , 'C' , i , c ) ; number = number % 10 ; } } else if ( number >= 10 ) { if ( number < 40 ) { i = digit ( 'X' , number / 10 , i , c ) ; number = number % 10 ; } else { i = sub_digit ( 'X' , 'L' , i , c ) ; number = number % 10 ; } } else if ( number >= 5 ) { if ( number < 9 ) { i = digit ( 'V' , number / 5 , i , c ) ; number = number % 5 ; } else { i = sub_digit ( 'I' , 'X' , i , c ) ; number = 0 ; } } else if ( number >= 1 ) { if ( number < 4 ) { i = digit ( 'I' , number , i , c ) ; number = 0 ; } else { i = sub_digit ( 'I' , 'V' , i , c ) ; number = 0 ; } } } System . out . printf ( "Roman numeral is: " ) ; for ( int j = 0 ; j < i ; j ++ ) { System . out . printf ( "%c" , c [ j ] ) ; } }

static void printRoman ( int number ) { int num [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; for ( int i = 0 ; i < num [ i ] ; i ++ ) { int div = number / num [ i ] ; number %= num [ i ] ; } return ; }

static void printRoman ( int number ) { int num = 1 ; int sym = [ "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" , "C" , "CD" , "D" , "CM" , "M" ] ; int i = 12 ; while ( number > 0 ) { int div = number // num [ i ] number %= num [ i ] ; while ( div ) { div = number // num [ i ] number %= num [ i ] ; while ( div ) { div = number // num [ i ] number %= num [ i ] ; div -- ; } } print ( sym [ i ] , end = "" ) ; i -- ; } }

0.25
10.04
21.66
33.01
def findMaxPoints ( A ) : P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] for i in range ( 1 , N + 1 ) : for j in range ( 1 , M + 1 ) : P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( N , 0 , - 1 ) : for j in range ( M , 0 , - 1 ) : P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( N , 0 , - 1 ) : for j in range ( 1 , M + 1 ) : P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( 1 , N + 1 ) : for j in range ( M , 0 , - 1 ) : P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ans = 0 for i in range ( 2 , N ) : for j in range ( 2 , M ) : op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + \ P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + \ P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ans = max ( ans , max ( op1 , op2 ) ) return ans

static int findMaxPoints ( int A [ ] [ ] ) { int [ ] [ ] P1S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P1E = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2E = new int [ M + 2 ] [ N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }

static void findMaxPoints ( int [ ] A ) { int [ ] P1S = [ [ 0 for i in range ( N + 2 ) ] ; int [ ] P1E = [ [ 0 for i in range ( N + 2 ) ] ; int [ ] P2S = [ [ 0 for i in range ( N + 2 ) ] ; int [ ] P2E = [ [ 0 for i in range ( M + 2 ) ] ; for (

int N ) { int P1S [ ] = new int [ N ] ; int P1E [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int j = 0 ; j < M ; j ++ ) { P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { P2S [ i ] [ j ] = max ( P2S [ i ] [ j ] , P2S [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } for ( int j = 0 ; j < M ; j ++ ) { P2

0.33
9.59
6.1
20.85
def midPointCircleDraw ( x_centre , y_centre , r ) : x = r y = 0 print ( "(" , x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) if ( r > 0 ) : print ( "(" , x + x_centre , "," , - y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , x + y_centre , ")" , sep = "" ) P = 1 - r while ( x > y ) : y += 1 if ( P <= 0 ) : P = P + 2 * y + 1 else : x -= 1 P = P + 2 * y - 2 * x + 1 if ( x < y ) : break print ( "(" , x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , x + x_centre , "," , - y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - x + x_centre , "," , - y + y_centre , ")" , sep = "" ) if ( x != y ) : print ( "(" , y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , y + x_centre , "," , - x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , - x + y_centre , ")" , sep = "" )

static void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r , y = 0 ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; if ( r > 0 ) { System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . println ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; } int P = 1 - r ; while ( x > y ) { y ++ ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { x -- ; P = P + 2 * y - 2 * x + 1 ; } if ( x < y ) break ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; System . out . print ( "(" + ( - x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; System . out . println ( "(" + ( - x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; if ( x != y ) { System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . print ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . print ( "(" + ( y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ; System . out . println ( "(" + ( - y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ; } } }

static void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = x_centre ; int y = y_centre ; if ( r < 0 ) { print ( "(" , - x + x_centre , "," , - y + y_centre , ")" , sep = "" ) print ( "(" , - x + x_centre , "," , - y + y_centre , ")" ,

static void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r ; int y = r ; int P = 1 - r ; while ( x > y ) { y += 1 if ( P <= 0 ) P = P + 2 * y - 2 * x + 1 ; else : x -= 1 P = P + 2 * y - 2 * x + 1 ; } print ( "(" , x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) ; print ( "(" , - x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) ; }

0.37
2.01
25.1
24.18
def squareRoot ( n ) : return pow ( 2 , 0.5 * math . log2 ( n ) )

static double squareRoot ( double n ) { return Math . pow ( 2 , 0.5 * ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }

def squareRoot ( n ) :

static int squareRoot ( int n ) { return pow ( 2 , Math . log2 ( n ) ) ; }

0.4
11.01
11.69
22.94
def zodiac_sign ( day , month ) : if month == 'december' : astro_sign = 'Sagittarius' if ( day < 22 ) else 'capricorn' elif month == 'january' : astro_sign = 'Capricorn' if ( day < 20 ) else 'aquarius' elif month == 'february' : astro_sign = 'Aquarius' if ( day < 19 ) else 'pisces' elif month == 'march' : astro_sign = 'Pisces' if ( day < 21 ) else 'aries' elif month == 'april' : astro_sign = 'Aries' if ( day < 20 ) else 'taurus' elif month == 'may' : astro_sign = 'Taurus' if ( day < 21 ) else 'gemini' elif month == 'june' : astro_sign = 'Gemini' if ( day < 21 ) else 'cancer' elif month == 'july' : astro_sign = 'Cancer' if ( day < 23 ) else 'leo' elif month == 'august' : astro_sign = 'Leo' if ( day < 23 ) else 'virgo' elif month == 'september' : astro_sign = 'Virgo' if ( day < 23 ) else 'libra' elif month == 'october' : astro_sign = 'Libra' if ( day < 23 ) else 'scorpio' elif month == 'november' : astro_sign = 'scorpio' if ( day < 22 ) else 'sagittarius' print ( astro_sign )

static void zodiac_sign ( int day , String month ) { String astro_sign = "" ; if ( month == "december" ) { if ( day < 22 ) astro_sign = "Sagittarius" ; else astro_sign = "capricorn" ; } else if ( month == "january" ) { if ( day < 20 ) astro_sign = "Capricorn" ; else astro_sign = "aquarius" ; } else if ( month == "february" ) { if ( day < 19 ) astro_sign = "Aquarius" ; else astro_sign = "pisces" ; } else if ( month == "march" ) { if ( day < 21 ) astro_sign = "Pisces" ; else astro_sign = "aries" ; } else if ( month == "april" ) { if ( day < 20 ) astro_sign = "Aries" ; else astro_sign = "taurus" ; } else if ( month == "may" ) { if ( day < 21 ) astro_sign = "Taurus" ; else astro_sign = "gemini" ; } else if ( month == "june" ) { if ( day < 21 ) astro_sign = "Gemini" ; else astro_sign = "cancer" ; } else if ( month == "july" ) { if ( day < 23 ) astro_sign = "Cancer" ; else astro_sign = "leo" ; } else if ( month == "august" ) { if ( day < 23 ) astro_sign = "Leo" ; else astro_sign = "virgo" ; } else if ( month == "september" ) { if ( day < 23 ) astro_sign = "Virgo" ; else astro_sign = "libra" ; } else if ( month == "october" ) { if ( day < 23 ) astro_sign = "Libra" ; else astro_sign = "scorpio" ; } else if ( month == "november" ) { if ( day < 22 ) astro_sign = "scorpio" ; else astro_sign = "sagittarius" ; } System . out . println ( astro_sign ) ; }

static int zodiac_sign ( int day , int month ) { int astro_sign = 'Sagittarius' ; if ( day < 22 ) astro_sign = 'Capricorn' ; if ( month == 'january' ) astro_sign = 'January' ; if ( day < 19 ) else 'aquarius' ; if ( month == 'february' ) astro_sign = '

static int zodiac_sign ( int day , String astro_sign ) { int astro_sign = "Sagittarius" ; if ( day < 22 ) { astro_sign = "Sagittarius" ; } else if ( month == 'december' ) { astro_sign = "Sagittarius" ; } else if ( month == 'december' ) { astro_sign = "Sagittarius" ; } else if ( month == 'december' ) { astro_sign = "Sagittarius" ; } else if ( month == 'december' ) { astro_sign = "Sagittarius" ; } else if ( month == 'december' ) { astro_sign = "Sagittarius" ; } else if ( month == 'december' ) { astro_sign = "Sagittarius" ; } else if ( month == 'december' ) { astro_sign = "Sagittarius" ; } else if ( month == 'december'

0.51
5.44
9.84
21.87
def yMod ( y , x ) : return ( y % pow ( 2 , x ) )

static long yMod ( long y , long x ) { if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y ; if ( x > 63 ) return y ; return ( y % ( 1 << ( int ) x ) ) ; }

def yModPow2 ( y , x ) { return ( y

static int yMod ( int y , int x ) { return ( y % pow ( 2 , x ) ) ; }

1.06
2.43
78.12
74.49
def sumOfSeries ( n ) : return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) )

static double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }

def sumOfSeries ( n ) {

static int sumOfSeries ( int n ) { return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }

1.19
10.8
12.22
18.39
def decode ( Str ) : integerstack = [ ] stringstack = [ ] temp = "" result = "" for i in range ( len ( Str ) ) : count = 0 if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) i += 1 i -= 1 integerstack . append ( count ) elif ( Str [ i ] == ']' ) : temp = "" count = 0 if ( len ( integerstack ) != 0 ) : count = integerstack [ - 1 ] integerstack . pop ( ) while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) : temp = stringstack [ - 1 ] + temp stringstack . pop ( ) if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) : stringstack . pop ( ) for j in range ( count ) : result = result + temp for j in range ( len ( result ) ) : stringstack . append ( result [ j ] ) result = "" elif ( Str [ i ] == '[' ) : if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : stringstack . append ( Str [ i ] ) else : stringstack . append ( Str [ i ] ) integerstack . append ( 1 ) else : stringstack . append ( Str [ i ] ) while len ( stringstack ) != 0 : result = stringstack [ - 1 ] + result stringstack . pop ( ) return result

static String decode ( String str ) { Stack < Integer > integerstack = new Stack < > ( ) ; Stack < Character > stringstack = new Stack < > ( ) ; String temp = "" , result = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( Character . isDigit ( str . charAt ( i ) ) ) { while ( Character . isDigit ( str . charAt ( i ) ) ) { count = count * 10 + str . charAt ( i ) - '0' ; i ++ ; } i -- ; integerstack . push ( count ) ; } else if ( str . charAt ( i ) == ']' ) { temp = "" ; count = 0 ; if ( ! integerstack . isEmpty ( ) ) { count = integerstack . peek ( ) ; integerstack . pop ( ) ; } while ( ! stringstack . isEmpty ( ) && stringstack . peek ( ) != '[' ) { temp = stringstack . peek ( ) + temp ; stringstack . pop ( ) ; } if ( ! stringstack . empty ( ) && stringstack . peek ( ) == '[' ) stringstack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) stringstack . push ( result . charAt ( j ) ) ; result = "" ; } else if ( str . charAt ( i ) == '[' ) { if ( Character . isDigit ( str . charAt ( i - 1 ) ) ) stringstack . push ( str . charAt ( i ) ) ; else { stringstack . push ( str . charAt ( i ) ) ; integerstack . push ( 1 ) ; } } else stringstack . push ( str . charAt ( i ) ) ; } while ( ! stringstack . isEmpty ( ) ) { result = stringstack . peek ( ) + result ; stringstack . pop ( ) ; } return result ; }

static int decode ( String Str ) { int count = 0 ; int stringstack = [ ] ; for ( int i = 0 ; i < len ( Str ) ; i ++ ) { if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) { while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) { count = count * 10 + int ( Str [ i ] ) - int ( '0

static void decode ( String Str ) { int integerstack = [ ] stringstack = [ ] result = "" ; for ( int i = 0 ; i < len ( Str ) ; i ++ ) { int count = 0 ; if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) { while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) { count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) ; integerstack . append ( count ) ; } count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) ; integerstack . append ( count ) ; while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) { count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) ; i += 1 i -= 1 integerstack . append ( count ) ; } count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) ; result = result + temp for j in range ( count )

1.29
2.2
67.05
76.08
def summingSeries ( n ) : return math . pow ( n , 2 )

static int summingSeries ( long n ) { return ( int ) Math . pow ( n , 2 ) ; }

def summingSeries ( ) :

static int summingSeries ( int n ) { return Math . pow ( n , 2 ) ; }

1.3
1.89
24.63
22.15
def circumference ( r ) : return ( 2 * PI * r )

static double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; }

def circumference ( r ) :

static int circumference ( int r ) { return ( 2 * PI * r ) ; }

1.32
2.49
93.56
92.22
def procal ( n ) : return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )

static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }

def procal ( n ) {

static int procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }

1.49
8.87
54.29
55.51
def height ( N ) : return math . ceil ( math . log2 ( N + 1 ) ) - 1

static int height ( int N ) { return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math . log ( 2 ) ) - 1 ; }

def height ( N ) {return N ; }

static int height ( int N ) { return Math . ceil ( Math . log2 ( N + 1 ) ) - 1 ; }

1.5
8.12
5.13
15.86
def singleNumber ( nums ) : return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2

static int singleNumber ( int a [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i : a ) { s . add ( i ) ; } int arr_sum = 0 ; for ( int i : a ) { arr_sum += i ; } int set_sum = 0 ; for ( int i : s ) { set_sum += i ; } return ( 3 * set_sum - arr_sum ) / 2 ; }

static double singleNumber ( int ... nums ) {  def singleNumber ( int ... nums ) { return ( nums - 1 ) / 2.0 ; }

static int singleNumber ( int nums ) { return ( 3 * sum ( set ( nums ) ) - sum ( set ( nums ) ) / 2 ) ; }

1.64
1.95
49.17
59.77
def largest ( arr , n ) : return max ( arr )

static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; }

def largest ( arr , n )

static int largest ( int [ ] arr , int n ) { return largest ( arr , n ) ; }

1.68
1.77
41.03
39.05
def minHeight ( area , base ) : return math . ceil ( ( 2 * area ) / base )

static double minHeight ( double base , double area ) { double d = ( 2 * area ) / base ; return Math . ceil ( d ) ; }

def minHeight ( area , base ) {

public static int minHeight ( int area , int base ) { return Math . ceil ( ( 2 * area ) / base ) ; }

1.84
2.71
32.57
45.19
def countIntegralSolutions ( n ) : return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 )

static int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }

def countIntegralSolutions ( n ) {

static int countIntegralSolutions ( int n ) { return countIntegralSolutions ( n ) ; }

1.9
12.13
83.47
66.07
def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }

static int nextPowerOf2 ( int n ) { return n

static int nextPowerOf2 ( int n ) { n -= 1 ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n += 1 ; }

1.9
12.13
83.47
66.07
def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n

static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }

static int nextPowerOf2 ( int n ) { return n

static int nextPowerOf2 ( int n ) { n -= 1 ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n += 1 ; }

1.99
21.52
34.93
43.53
def countParenth ( symb , oper , n ) : F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n ) : if symb [ i ] == 'F' : F [ i ] [ i ] = 1 else : F [ i ] [ i ] = 0 if symb [ i ] == 'T' : T [ i ] [ i ] = 1 else : T [ i ] [ i ] = 0 for gap in range ( 1 , n ) : i = 0 for j in range ( gap , n ) : T [ i ] [ j ] = F [ i ] [ j ] = 0 for g in range ( gap ) : k = i + g tik = T [ i ] [ k ] + F [ i ] [ k ] tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] if oper [ k ] == '&' : T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) if oper [ k ] == '|' : F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) if oper [ k ] == '^' : T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) i += 1 return T [ 0 ] [ n - 1 ]

static int countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ ] [ ] = new int [ n ] [ n ] ; int T [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '|' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '^' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }

static int countParenth ( int symb [ ] , int oper [ ] , int n ) { int F [ ] [ ] = new int [ n + 1 ] [ n ] ; int T [ ] [ ] = new int [ n + 1 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( symb [ i ] == 'F' ) F [ i ] [ i ] = 1 ; else T [ i ] [ i ] = 0 ; } }

int countParenth ( String symb , String oper , int n ) { int F [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int tik = T [ i ] [ i ] + F [ i ] [ i ] ; int tkj = T [ i ] [ i ] + F [ i ] [ i ] ; if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } else if ( oper [ k ] == '|' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } else if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] *

2.03
14.56
29.02
31.05
def printShortestSuperSeq ( x , y ) : m = len ( x ) n = len ( y ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if i == 0 : dp [ i ] [ j ] = j elif j == 0 : dp [ i ] [ j ] = i elif x [ i - 1 ] == y [ j - 1 ] : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] string = "" i = m j = n while i > 0 and j > 0 : if x [ i - 1 ] == y [ j - 1 ] : string += x [ i - 1 ] i -= 1 j -= 1 index -= 1 elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] : string += y [ j - 1 ] j -= 1 index -= 1 else : string += x [ i - 1 ] i -= 1 index -= 1 while i > 0 : string += x [ i - 1 ] i -= 1 index -= 1 while j > 0 : string += y [ j - 1 ] j -= 1 index -= 1 string = list ( string ) string . reverse ( ) return '' . join ( string )

static String printShortestSuperSeq ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = j ; } else if ( j == 0 ) { dp [ i ] [ j ] = i ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int index = dp [ m ] [ n ] ; String str = "" ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; j -- ; index -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; index -- ; } else { str += ( X . charAt ( i - 1 ) ) ; i -- ; index -- ; } } while ( i > 0 ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; index -- ; } while ( j > 0 ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; index -- ; } str = reverse ( str ) ; return str ; }

static void printShortestSuperSeq ( int [ ] x , int [ ] y ) { int [ ] dp = new int [ m + 1 ] [ n + 1 ] [ ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( x [ i ] == y [ j - 1 ] ) string += x [ i - 1 ] ; j -= 1 ; else string

static void printShortestSuperSeq ( int x , int y ) { int m = len ( x ) ; int n = len ( y ) ; int dp [ ] [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i ] [ j ] = i ; } else if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i ] [ j ] = i ; } else if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i ] [ j ] = i ; } else if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i ] [ j ] = i ; } else if ( x [ i - 1 ] == y [ j -

2.06
2.92
96.07
98.98
def numberOfSticks ( x ) : return ( 3 * x * ( x + 1 ) ) / 2

public static int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }

def numberOfSticks ( ) { return

; public static int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }

2.11
9.15
32.78
40.3
def printSpiral ( mat , r , c ) : a = 0 b = 2 low_row = 0 if ( 0 > a ) else a low_column = 0 if ( 0 > b ) else b - 1 high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 while ( ( low_row > 0 - r and low_column > 0 - c ) ) : i = low_column + 1 while ( i <= high_column and i < c and low_row >= 0 ) : print ( mat [ low_row ] [ i ] , end = "" ) i += 1 low_row -= 1 i = low_row + 2 while ( i <= high_row and i < r and high_column < c ) : print ( mat [ i ] [ high_column ] , end = "" ) i += 1 high_column += 1 i = high_column - 2 while ( i >= low_column and i >= 0 and high_row < r ) : print ( mat [ high_row ] [ i ] , end = "" ) i -= 1 high_row += 1 i = high_row - 2 while ( i > low_row and i >= 0 and low_column >= 0 ) : print ( mat [ i ] [ low_column ] , end = "" ) i -= 1 low_column -= 1 print ( )

static void printSpiral ( int [ ] [ ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) System . out . print ( mat [ low_row ] [ i ] + " " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) System . out . print ( mat [ i ] [ high_column ] + " " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) System . out . print ( mat [ high_row ] [ i ] + " " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) System . out . print ( mat [ i ] [ low_column ] + " " ) ; low_column -= 1 ; } System . out . println ( ) ; }

static void printSpiral ( int mat [ ] , int r , int c ) { int i = 0 ; int low_row = 0 ; int low_column = 0 ; int high_row = 0 ; int high_column = 0 ; int high_row = 0 ; int low_column = 0 ; int high_row = 0 ; int high_column = 0 ; for ( int i = 0 ; i <= high_row ; i ++ ) { if

static void printSpiral ( int mat [ ] , int r , int c ) { int a = 0 ; int b = 2 ; int low_row = r - 1 ; int low_column = 0 ; int high_row = r - 1 ; int high_column = c - 1 ; int i = high_column + 1 ; while ( i <= high_column && i < c && low_row >= 0 ) { print ( mat [ low_row ] [ i ] , end = "" ) ; i += 1 ; low_row -= 1 ; i = high_column + 1 ; while ( i <= low_column && i < r && high_row >= 0 ) { print ( mat [ low_row ] [ i ] , end = "" ) ; i += 1 ; high_column += 1 i = high_column - 2 ; while ( i >= low_column && i >= 0 && high_row < r ) { print ( mat [ high_row ] [ i ] , end = "" ) i -= 1 ; high_row += 1 i = high_column - 2 ; while ( i >= low_column && i >= 0 && high_row < r ) { print ( mat [

2.2
11.19
16.45
21.1
def find_max ( A , N , K ) : Count = dict ( ) for i in range ( K - 1 ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 Myset = dict ( ) for x in Count : if ( Count [ x ] == 1 ) : Myset [ x ] = 1 for i in range ( K - 1 , N ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 if ( Count [ A [ i ] ] == 1 ) : Myset [ A [ i ] ] = 1 else : del Myset [ A [ i ] ] if ( len ( Myset ) == 0 ) : print ( "Nothing" ) else : maxm = - 10 ** 9 for i in Myset : maxm = max ( i , maxm ) print ( maxm ) x = A [ i - K + 1 ] if x in Count . keys ( ) : Count [ x ] -= 1 if ( Count [ x ] == 1 ) : Myset [ x ] = 1 if ( Count [ x ] == 0 ) : del Myset [ x ]

static void find_max ( int [ ] A , int N , int K ) { HashMap < Integer , Integer > Count = new HashMap < > ( ) ; for ( int i = 0 ; i < K - 1 ; i ++ ) if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ; else Count . put ( A [ i ] , 1 ) ; TreeSet < Integer > Myset = new TreeSet < Integer > ( ) ; for ( Map . Entry x : Count . entrySet ( ) ) { if ( Integer . parseInt ( String . valueOf ( x . getValue ( ) ) ) == 1 ) Myset . add ( Integer . parseInt ( String . valueOf ( x . getKey ( ) ) ) ) ; } for ( int i = K - 1 ; i < N ; i ++ ) { if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ; else Count . put ( A [ i ] , 1 ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( A [ i ] ) ) ) == 1 ) Myset . add ( A [ i ] ) ; else Myset . remove ( A [ i ] ) ; if ( Myset . size ( ) == 0 ) System . out . println ( "Nothing" ) ; else System . out . println ( Myset . last ( ) ) ; int x = A [ i - K + 1 ] ; Count . put ( x , Count . get ( x ) - 1 ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 1 ) Myset . add ( x ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 0 ) Myset . remove ( x ) ; } }

static int find_max ( int [ ] A , int N , int K ) { int Count = new int [ A . length ] ; int Myset = new int [ A . length ] ; for ( int i = 0 ; i < A . length ; i ++ ) { int Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 ; if ( Count [ A [ i ] ] == 1 ) { Myset [ A

static void find_max ( int A , int N , int K ) { int Count = dict ( ) ; for ( int i = 0 ; i < K ; i ++ ) { Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 ; Myset [ A [ i ] ] = 1 ; if ( Count [ A [ i ] ] == 1 ) Myset [ A [ i ] ] = 1 ; else : del Myset [ A [ i ] ] ; if ( len ( Myset ) == 0 ) { print ( "Nothing" ) ; } else { maxm = - 10 ** 9 for i in Myset : maxm = max ( i , maxm ) print ( maxm ) ; x = A [ i - K + 1 ] if ( x in Count . keys ( ) ) { Count [ x ] -= 1 if ( Count [ x ] == 1 ) : Myset [ x ] = 1 if ( Count [ x ] == 0 ) { del Myset [ x ] ; } } } } }

2.35
2.36
82.9
83.94
def areaSquare ( side ) : area = side * side return area

static int areaSquare ( int side ) { int area = side * side ; return area ; }

def areaSquare ( ) :

( int side ) { int area = side * side ; return area ; }

2.74
15.25
24.05
27.07
def count ( s , Len ) : global MAX cur = 0 dig = 0 Sum = [ 0 ] * MAX dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , Len + 1 ) : dig = int ( s [ i - 1 ] ) - 48 cur += dig cur %= 3 Sum [ i ] = cur dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] dp [ i ] [ Sum [ i ] ] += 1 ans = 0 dprev = 0 value = 0 dprev2 = 0 for i in range ( 1 , Len + 1 ) : dig = int ( s [ i - 1 ] ) - 48 if dig == 8 : ans += 1 if i - 2 >= 0 : dprev = int ( s [ i - 2 ] ) - 48 value = dprev * 10 + dig if ( value % 8 == 0 ) and ( value % 3 != 0 ) : ans += 1 if i - 3 >= 0 : dprev2 = int ( s [ i - 3 ] ) - 48 dprev = int ( s [ i - 2 ] ) - 48 value = ( dprev2 * 100 + dprev * 10 + dig ) if value % 8 != 0 : continue ans += ( i - 2 ) ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) return ans

static int count ( String s , int len ) { int MAX = 1000 ; int cur = 0 , dig = 0 ; int [ ] sum = new int [ MAX ] ; int [ ] [ ] dp = new int [ MAX ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; if ( dig == 8 ) ans ++ ; if ( i - 2 >= 0 ) { dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ; } if ( i - 3 >= 0 ) { dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ; dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) continue ; ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; }

static int count ( int s [ ] ) { int cur = 0 ; int Sum [ ] = new int [ Len + 1 ] [ ] ; int dp [ ] [ ] [ ] = new int [ Len + 1 ] [ ] ; for ( int i = 1 ; i <= Len ; i ++ ) { int dig = int ( s [ i - 1 ] ) - 48 ; if ( dig == 8 ) { if ( i - 2 >= 0 ) dprev = int

int count ( String s , int Len ) { int cur = 0 ; int dig = int ( s [ 0 ] ) - 48 ; if ( dig == 8 ) { ans += 1 ; if ( i - 2 >= 0 ) dprev2 = int ( s [ i - 2 ] ) - 48 dprev = int ( s [ i - 3 ] ) - 48 ; value = dprev * 100 + dprev * 10 + dig ; if ( value % 3 != 0 ) ans += 1 ; if ( i - 3 >= 0 ) dprev2 = int ( s [ i - 3 ] ) - 48 dprev = int ( s [ i - 2 ] ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 3 != 0 ) ans += 1 ; if ( i - 2 >= 0 ) dprev2 = int ( s [ i - 2 ] ) - 48 dprev = int ( s [ i - 3 ] ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 3 != 0 ) ans += 1 ; if ( i - 3 >= 0 ) dprev2 = int ( s [ i - 3 ] )

2.95
20.47
33.59
37.02
def numberofways ( A , B , N , M ) : pos = [ [ ] for _ in range ( MAX ) ] for i in range ( M ) : pos [ ord ( B [ i ] ) ] . append ( i + 1 ) dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( 1 , N + 1 ) : for j in range ( 1 , M + 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 else : dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) LCS = dpl [ N ] [ M ] dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( N , 0 , - 1 ) : for j in range ( M , 0 , - 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 else : dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ans = 0 for i in range ( N + 1 ) : for j in range ( MAX ) : for x in pos [ j ] : if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : ans += 1 break return ans

static int numberofways ( String A , String B , int N , int M ) { Vector < Integer > [ ] pos = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) pos [ i ] = new Vector < > ( ) ; for ( int i = 0 ; i < M ; i ++ ) pos [ B . charAt ( i ) ] . add ( i + 1 ) ; int [ ] [ ] dpl = new int [ N + 2 ] [ M + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int [ ] [ ] dpr = new int [ N + 2 ] [ M + 2 ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( int x : pos [ j ] ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }

static int numberofways ( int [ ] A , int [ ] B , int N , int M ) { int [ ] pos = new int [ MAX ] ; for ( int i = 0 ; i < N ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) { dpl [ i ] [ j ] = dpl [ i ] [ j ] ; } } }

int numberofways ( int A , int B , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i + 1 ] [ j + 1 ] ) ; } ans ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i + 1 ] [ j + 1 ] ) ; } } } for ( int i = 0 ; i < M ; i ++ )

2.98
14.23
23.5
26.29
def printMaxOfMin ( arr , n ) : s = [ ] left = [ - 1 ] * ( n + 1 ) right = [ n ] * ( n + 1 ) for i in range ( n ) : while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : s . pop ( ) if ( len ( s ) != 0 ) : left [ i ] = s [ - 1 ] s . append ( i ) while ( len ( s ) != 0 ) : s . pop ( ) for i in range ( n - 1 , - 1 , - 1 ) : while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : s . pop ( ) if ( len ( s ) != 0 ) : right [ i ] = s [ - 1 ] s . append ( i ) ans = [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) : ans [ i ] = 0 for i in range ( n ) : Len = right [ i ] - left [ i ] - 1 ans [ Len ] = max ( ans [ Len ] , arr [ i ] ) for i in range ( n - 1 , 0 , - 1 ) : ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) for i in range ( 1 , n + 1 ) : print ( ans [ i ] , end = "" )

static void printMaxOfMin ( int n ) { Stack < Integer > s = new Stack < > ( ) ; int left [ ] = new int [ n + 1 ] ; int right [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ; s . push ( i ) ; } int ans [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }

static void printMaxOfMin ( int arr [ ] , int n ) { int s [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( len ( s ) != 0 ) { left [ i ] = s [ - 1 ] ; s . append ( i ) ; while ( len ( s ) != 0 ) { right [ i ] = s [ - 1 ] - left [ i ] - 1 ; } } }

static void printMaxOfMin ( int arr [ ] , int n ) { int [ ] left = [ - 1 ] * ( n + 1 ) ; int [ ] right = [ n ] * ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { int Len = right [ i ] - left [ i ] - 1 ; ans [ Len ] = max ( ans [ Len ] , arr [ i ] ) for i in range ( n - 1 , 0 , - 1 ) ; ans [ i ] = max ( ans [ i ] , arr [ i ] ) for i in range ( 1 , n + 1 ) : ans [ i ] = max ( ans [ i ] , arr [ i ] ) for i in range ( 1 , n + 1 ) : ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) for i in range ( 1 , n + 1 ) : ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) for i in range ( 1 , n + 1 ) : ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) for i in range ( 1

3.04
15.24
11.58
23.09
def PrintMinNumberForPattern ( arr ) : curr_max = 0 last_entry = 0 i = 0 while i < len ( arr ) : noOfNextD = 0 if arr [ i ] == "I" : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 if i == 0 : curr_max = noOfNextD + 2 last_entry += 1 print ( "" , last_entry , end = "" ) print ( "" , curr_max , end = "" ) last_entry = curr_max else : curr_max += noOfNextD + 1 last_entry = curr_max print ( "" , last_entry , end = "" ) for k in range ( noOfNextD ) : last_entry -= 1 print ( "" , last_entry , end = "" ) i += 1 elif arr [ i ] == "D" : if i == 0 : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 curr_max = noOfNextD + 2 print ( "" , curr_max , curr_max - 1 , end = "" ) last_entry = curr_max - 1 else : print ( "" , last_entry - 1 , end = "" ) last_entry -= 1 i += 1 print ( )

static void PrintMinNumberForPattern ( String arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case 'I' : j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == 'D' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; System . out . print ( " " + ++ last_entry ) ; System . out . print ( " " + curr_max ) ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; System . out . print ( " " + last_entry ) ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( " " + -- last_entry ) ; i ++ ; } break ; case 'D' : if ( i == 0 ) { j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == 'D' ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; System . out . print ( " " + curr_max + " " + ( curr_max - 1 ) ) ; last_entry = curr_max - 1 ; } else { System . out . print ( " " + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } System . out . println ( ) ; }

static void PrintMinNumberForPattern ( String arr [ ] ) { int noOfNextD = 0 ; int curr_max = 0 ; int last_entry = 0 ; int i = 0 ; while ( i < len ( arr ) ) { int j = i + 1 ; while ( j < len ( arr ) && arr [ j ] == "I" ) noOfNextD += 1 ; if ( i == 0 ) curr_max = noOfNextD +

static void PrintMinNumberForPattern ( String arr [ ] ) { int curr_max = 0 ; int last_entry = 0 ; int i = 0 ; while ( i < len ( arr ) ) { int noOfNextD = 0 ; if ( arr [ i ] == "I" ) { j = i + 1 while j < len ( arr ) && arr [ j ] == "D" : noOfNextD += 1 j += 1 curr_max = noOfNextD + 2 last_entry += 1 print ( "" , last_entry , end = "" ) ; last_entry = curr_max ; } else { curr_max += noOfNextD + 1 last_entry = curr_max ; } print ( "" , last_entry , end = "" ) ; } i ++ ; }

3.24
17.63
24.22
28.37
def findSubString ( string , pat ) : len1 = len ( string ) len2 = len ( pat ) if len1 < len2 : print ( "Nosuchwindowexists" ) return "" hash_pat = [ 0 ] * no_of_chars hash_str = [ 0 ] * no_of_chars for i in range ( 0 , len2 ) : hash_pat [ ord ( pat [ i ] ) ] += 1 start , start_index , min_len = 0 , - 1 , float ( 'inf' ) count = 0 for j in range ( 0 , len1 ) : hash_str [ ord ( string [ j ] ) ] += 1 if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : count += 1 if count == len2 : while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : hash_str [ ord ( string [ start ] ) ] -= 1 start += 1 len_window = j - start + 1 if min_len > len_window : min_len = len_window start_index = start if start_index == - 1 : print ( "Nosuchwindowexists" ) return "" return string [ start_index : start_index + min_len ]

static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( "No such window exists" ) ; return "" ; } int hash_pat [ ] = new int [ no_of_chars ] ; int hash_str [ ] = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) ] ++ ; if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . charAt ( start ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { System . out . println ( "No such window exists" ) ; return "" ; } return str . substring ( start_index , start_index + min_len ) ; }

static String findSubString ( String string , String pat ) { int no_of_chars = 32 ; int len1 = string . length ( ) ; int len2 = pat . length ( ) ; int hash_str [ ] = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) { hash_str [ ord ( string [ i ] ) ] ++ ; if ( hash_str [ ord ( string

static String findSubString ( String string , String pat ) { int start = 0 ; int len1 = len ( string ) ; int len2 = len ( pat ) ; int min_len = 0 , - 1 , float ( 'inf' ) ; for ( int i = 0 ; i < len1 ; i ++ ) { hash_str [ ord ( string [ i ] ) ] += 1 ; if ( hash_str [ ord ( string [ i ] ) ] != 0 && hash_str [ ord ( string [ i ] ) ] <= hash_pat [ ord ( string [ i ] ) ] ) { count ++ ; if ( count == len2 ) while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) { hash_str [ ord ( string [ start ] ) ] -= 1 start += 1 len_window = j - start + 1 if min_len > len_window : min_len = len_window ;

3.52
13.38
6.76
15.82
def countRotationsDivBy8 ( n ) : l = len ( n ) count = 0 if ( l == 1 ) : oneDigit = int ( n [ 0 ] ) if ( oneDigit % 8 == 0 ) : return 1 return 0 if ( l == 2 ) : first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) if ( first % 8 == 0 ) : count += 1 if ( second % 8 == 0 ) : count += 1 return count threeDigit = 0 for i in range ( 0 , ( l - 2 ) ) : threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 return count

static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }

static int countRotationsDivBy8 ( int n [ ] ) { int count = 0 ; int oneDigit = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ; if ( oneDigit % 8 == 0 ) count += 1 ; if ( l == 3 ) { int first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ; if ( second % 8 == 0 ) count += 1 ; if ( first

int countRotationsDivBy8 ( int n [ ] ) { int l = len ( n ) ; int first = int ( n [ 0 ] ) * 100 + int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) ; int second = int ( n [ 1 ] ) * 10 + int ( n [ 1 ] ) ; if ( first % 8 == 0 ) { count += 1 ; } if ( second % 8 == 0 ) { count += 1 ; } if ( threeDigit % 8 == 0 ) { count += 1 ; } } return count ; }

3.54
11.48
100.0
100.0
def fact ( n ) : if ( n == 0 ) : return 1 return n * fact ( n - 1 )

static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }

def fact ( n ) { return n}

static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }

3.55
2.9
38.74
45.13
def calculateSum ( n ) : sum = 0 sum = 1 << n return ( sum - 1 )

static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }

def calculateSum ( n ) { return sum

private static int calculateSum ( int n ) { int sum = 0 ; int sum = 1 ; if ( sum == 0 ) return ( sum - 1 ) ; else return ( sum - 1 ) ; }

3.64
17.37
48.29
58.93
def direction ( R , C ) : if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if R == C and R % 2 != 0 and C % 2 != 0 : print ( "Right" ) return if R == C and R % 2 == 0 and C % 2 == 0 : print ( "Left" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return

static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { System . out . println ( "Right" ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { System . out . println ( "Right" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { System . out . println ( "Right" ) ; return ; } }

static void direction ( int R , int C ) { if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) { print ( "Down" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) { print ( "Left" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) { print ( "Up"

static void direction ( int R , int C ) { if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print ( "Up" ) ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print ( "Right" ) ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print ( "Up" ) ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print ( "Right" ) ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print ( "Up" ) ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print ( "Up" ) ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { print

3.66
13.2
100.0
100.0
def power ( n ) : if n == 1 : return 2 return 2 * power ( n - 1 )

static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }

def power ( n ) { return n

static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }

3.69
14.74
67.92
58.9
def findgroups ( arr , n ) : c = [ 0 , 0 , 0 ] res = 0 for i in range ( 0 , n ) : c [ arr [ i ] % 3 ] += 1 res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) res += c [ 1 ] * c [ 2 ] res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) res += c [ 0 ] * c [ 1 ] * c [ 2 ] return res

int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 }; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }

static int findgroups ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { c [ arr [ i ] % 3 ] += 1 ; } return res ; }

static int findgroups ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int c [ arr [ i ] % 3 ] += 1 ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 2 ) ) / 6 ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 2 ) ) / 6 ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 2 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 2 ) ) / 6 ; } return res ; }

4.14
20.49
41.45
41.98
def printMaxSubSquare ( M ) : R = len ( M ) C = len ( M [ 0 ] ) S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ] for i in range ( 1 , R ) : for j in range ( 1 , C ) : if ( M [ i ] [ j ] == 1 ) : S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1 else : S [ i ] [ j ] = 0 max_of_s = S [ 0 ] [ 0 ] max_i = 0 max_j = 0 for i in range ( R ) : for j in range ( C ) : if ( max_of_s < S [ i ] [ j ] ) : max_of_s = S [ i ] [ j ] max_i = i max_j = j print ( "Maximumsizesub-matrixis:" ) for i in range ( max_i , max_i - max_of_s , - 1 ) : for j in range ( max_j , max_j - max_of_s , - 1 ) : print ( M [ i ] [ j ] , end = "" ) print ( "" )

static void printMaxSubSquare ( int M [ ] [ ] ) { int i , j ; int R = M . length ; int C = M [ 0 ] . length ; int S [ ] [ ] = new int [ R ] [ C ] ; int max_of_s , max_i , max_j ; for ( i = 0 ; i < R ; i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ] ; for ( j = 0 ; j < C ; j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ] ; for ( i = 1 ; i < R ; i ++ ) { for ( j = 1 ; j < C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 ; else S [ i ] [ j ] = 0 ; } } max_of_s = S [ 0 ] [ 0 ] ; max_i = 0 ; max_j = 0 ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( max_of_s < S [ i ] [ j ] ) { max_of_s = S [ i ] [ j ] ; max_i = i ; max_j = j ; } } } System . out . println ( "Maximum size sub-matrix is: " ) ; for ( i = max_i ; i > max_i - max_of_s ; i -- ) { for ( j = max_j ; j > max_j - max_of_s ; j -- ) { System . out . print ( M [ i ] [ j ] + " " ) ; } System . out . println ( ) ; } }

static void printMaxSubSquare ( int [ ] M ) { int R = M . length ; int C = M . length ; int [ ] S = new int [ R ] [ C ] ; for ( int i = 1 ; i <= R ; i ++ ) { for ( int j = 1 ; j <= C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = S [ i ] [ j -

static void printMaxSubSquare ( int [ ] M ) { int R = len ( M ) ; int C = len ( M [ 0 ] ) ; for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j - 1 ] , S [ i - 1 ] [ j - 1 ] ) + 1 ; else S [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j - 1 ] , S [ i - 1 ] [ j - 1 ] ) + 1 ; else S [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < R ; i ++ ) { for ( int

4.15
16.73
31.77
32.4
def getMinStepToReachEnd ( arr , N ) : visit = [ False for i in range ( N ) ] distance = [ 0 for i in range ( N ) ] digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ] for i in range ( 1 , N ) : digit [ arr [ i ] ] . append ( i ) distance [ 0 ] = 0 visit [ 0 ] = True q = [ ] q . append ( 0 ) while ( len ( q ) > 0 ) : idx = q [ 0 ] q . remove ( q [ 0 ] ) if ( idx == N - 1 ) : break d = arr [ idx ] for i in range ( len ( digit [ d ] ) ) : nextidx = digit [ d ] [ i ] if ( visit [ nextidx ] == False ) : visit [ nextidx ] = True q . append ( nextidx ) distance [ nextidx ] = distance [ idx ] + 1 if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : visit [ idx - 1 ] = True q . append ( idx - 1 ) distance [ idx - 1 ] = distance [ idx ] + 1 if ( idx + 1 < N and visit [ idx + 1 ] == False ) : visit [ idx + 1 ] = True q . append ( idx + 1 ) distance [ idx + 1 ] = distance [ idx ] + 1 return distance [ N - 1 ]

static int getMinStepToReachEnd ( int arr [ ] , int N ) { boolean [ ] visit = new boolean [ N ] ; int [ ] distance = new int [ N ] ; Vector < Integer > [ ] digit = new Vector [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) digit [ i ] = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) visit [ i ] = false ; for ( int i = 1 ; i < N ; i ++ ) digit [ arr [ i ] ] . add ( i ) ; distance [ 0 ] = 0 ; visit [ 0 ] = true ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int idx = q . peek ( ) ; q . remove ( ) ; if ( idx == N - 1 ) break ; int d = arr [ idx ] ; for ( int i = 0 ; i < digit [ d ] . size ( ) ; i ++ ) { int nextidx = digit [ d ] . get ( i ) ; if ( ! visit [ nextidx ] ) { visit [ nextidx ] = true ; q . add ( nextidx ) ; distance [ nextidx ] = distance [ idx ] + 1 ; } } digit [ d ] . clear ( ) ; if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true ; q . add ( idx - 1 ) ; distance [ idx - 1 ] = distance [ idx ] + 1 ; } if ( idx + 1 < N && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true ; q . add ( idx + 1 ) ; distance [ idx + 1 ] = distance [ idx ] + 1 ; } } return distance [ N - 1 ] ; }

static int getMinStepToReachEnd ( int [ ] arr , int N ) { int [ ] digit = new int [ arr . length ] ; int [ ] distance = new int [ arr . length ] ; for ( int i = 0 ; i < N ; i ++ ) { int nextidx = digit [ arr [ i ] ] . append ( i ) ; if ( visit [ nextidx ] == False ) { visit [ nextidx ] = true q . append ( nextidx ) ; } } return distance [ 0 ] ; }

static int getMinStepToReachEnd ( int arr [ ] , int N ) { int [ ] visit = [ False for i in range ( N ) ] for ( int i = 0 ; i < N ; i ++ ) { int d = arr [ i ] for i in range ( len ( digit [ d ] ) ) { int nextidx = digit [ d ] [ i ] if ( visit [ nextidx ] == False ) { visit [ nextidx ] = true q . append ( nextidx ) distance [ nextidx ] = distance [ idx ] + 1 if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : visit [ idx - 1 ] = true q . append ( idx - 1 ) distance [ idx - 1 ] = distance [ idx - 1 ] + 1 if ( idx + 1 < N and visit [ idx + 1 ] == False ) : visit [ idx + 1 ] = true q . append ( idx + 1 ) distance [ idx + 1 ] = distance [ idx ] + 1 if ( idx + 1 < N and visit [ idx + 1 ] == False ) : visit [ idx + 1 ] = true q . append ( idx + 1 ) distance [ idx + 1 ] = distance

4.24
19.94
51.11
47.13
def findMaxValue ( arr , n ) : if n < 4 : print ( "Thearrayshouldhaveatlest4elements" ) return MIN table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) for i in range ( n - 1 , - 1 , - 1 ) : table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) for i in range ( n - 2 , - 1 , - 1 ) : table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) for i in range ( n - 3 , - 1 , - 1 ) : table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) for i in range ( n - 4 , - 1 , - 1 ) : table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) return table4 [ 0 ]

static int findMaxValue ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( "The array should have" + " atleast 4 elements" ) ; } int table1 [ ] = new int [ n + 1 ] ; int table2 [ ] = new int [ n ] ; int table3 [ ] = new int [ n - 1 ] ; int table4 [ ] = new int [ n - 2 ] ; Arrays . fill ( table1 , Integer . MIN_VALUE ) ; Arrays . fill ( table2 , Integer . MIN_VALUE ) ; Arrays . fill ( table3 , Integer . MIN_VALUE ) ; Arrays . fill ( table4 , Integer . MIN_VALUE ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; for ( int i = n - 4 ; i >= 0 ; i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; return table4 [ 0 ] ; }

static int findMaxValue ( int arr [ ] , int n ) { int table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * ( n - 2 ) ; int table3 , table4 = [ MIN ] * ( n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) ; for (

static int findMaxValue ( int arr [ ] , int n ) { int table1 [ ] = new int [ n ] ; int table2 [ ] = new int [ n ] ; int table3 [ ] = new int [ n ] ; int table4 [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { table1 [ i ] = max ( table1 [ i + 1 ] , table1 [ i + 1 ] + arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { table2 [ i ] = max ( table2 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { table3 [ i ] = max ( table3 [ i + 1 ] , table3 [ i + 1 ] + arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { table4 [ i ] = max ( table4 [ i ] , table4 [ i + 1 ] + arr [ i ] ) ; } } return table4 [ 0 ] ; }

4.44
20.47
4.7
33.29
def sortString ( str ) : charCount = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( 0 , len ( str ) , 1 ) : charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( 0 , MAX_CHAR , 1 ) : for j in range ( 0 , charCount [ i ] , 1 ) : print ( chr ( ord ( 'a' ) + i ) , end = "" )

public static String sortString ( String inputString ) { char tempArray [ ] = inputString . toCharArray ( ) ; Arrays . sort ( tempArray ) ; return new String ( tempArray ) ; }

static void sortString ( String str , int MAX_CHAR ) { int charCount [ ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { print ( chr ( 'a' ) + j ) , end = "" ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { for ( int j = 0 ; j <

static void sortString ( String str ) { charCount = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 ; for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { print ( chr ( ord ( 'a' ) + i ) , end = "" ) ; } } } }

4.65
20.69
24.38
37.28
def SumOfKsubArray ( arr , n , k ) : Sum = 0 S = deque ( ) G = deque ( ) for i in range ( k ) : while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : S . pop ( ) while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : G . pop ( ) G . append ( i ) S . append ( i ) for i in range ( k , n ) : Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] while ( len ( S ) > 0 and S [ 0 ] <= i - k ) : S . popleft ( ) while ( len ( G ) > 0 and G [ 0 ] <= i - k ) : G . popleft ( ) while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : S . pop ( ) while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : G . pop ( ) G . append ( i ) S . append ( i ) Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] return Sum

public static int SumOfKsubArray ( int arr [ ] , int k ) { int sum = 0 ; Deque < Integer > S = new LinkedList < > ( ) , G = new LinkedList < > ( ) ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } for ( ; i < arr . length ; i ++ ) { sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ; while ( ! S . isEmpty ( ) && S . peekFirst ( ) <= i - k ) S . removeFirst ( ) ; while ( ! G . isEmpty ( ) && G . peekFirst ( ) <= i - k ) G . removeFirst ( ) ; while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ; return sum ; }

static int SumOfKsubArray ( int arr [ ] , int n , int k ) { int Sum = 0 ; int S = new int [ n ] ; int G = new int [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { while ( len ( S ) > 0 && arr [ S [ - 1 ] ] >= arr [ i ] ) { S . pushleft ( ) while ( len ( G ) > 0 && arr

static int SumOfKsubArray ( int arr [ ] , int n , int k ) { int Sum = 0 ; int S = deque ( ) ; for ( int i = 0 ; i < k ; i ++ ) { while ( S . size ( ) > 0 && arr [ S [ 0 ] ] >= arr [ i ] ) { S . pop ( ) ; } while ( S . size ( ) > 0 && arr [ S [ - 1 ] ] <= arr [ i ] ) { S . pop ( ) ; } while ( G . size ( ) > 0 && arr [ G [ - 1 ] ] >= arr [ i ] ) { G . pop ( ) ; } while ( S . size ( ) > 0 && arr [ S [ - 1 ] ] <= arr [ i ] ) { S . pop ( ) ; } while ( G . size ( ) > 0 && arr [ G [ - 1 ] ] <= arr [ i ] ) { G . pop ( ) ; } } return Sum ; }

4.72
16.97
30.4
30.17
def findpath ( graph ) : n = len ( graph ) numofadj = list ( ) for i in range ( n ) : numofadj . append ( sum ( graph [ i ] ) ) startpoint = 0 numofodd = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( numofadj [ i ] % 2 == 1 ) : numofodd += 1 startpoint = i if ( numofodd > 2 ) : print ( "NoSolution" ) return stack = list ( ) path = list ( ) cur = startpoint while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) : if ( sum ( graph [ cur ] ) == 0 ) : path . append ( cur + 1 ) cur = stack . pop ( - 1 ) else : for i in range ( n ) : if graph [ cur ] [ i ] == 1 : stack . append ( cur ) graph [ cur ] [ i ] = 0 graph [ i ] [ cur ] = 0 cur = i break for ele in path : print ( ele , "->" , end = '' ) print ( cur + 1 )

static void findpath ( int [ ] [ ] graph , int n ) { Vector < Integer > numofadj = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) numofadj . add ( accumulate ( graph [ i ] , 0 ) ) ; int startPoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj . elementAt ( i ) % 2 == 1 ) { numofodd ++ ; startPoint = i ; } } if ( numofodd > 2 ) { System . out . println ( "No Solution" ) ; return ; } Stack < Integer > stack = new Stack < > ( ) ; Vector < Integer > path = new Vector < > ( ) ; int cur = startPoint ; while ( ! stack . isEmpty ( ) || accumulate ( graph [ cur ] , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , 0 ) == 0 ) { path . add ( cur ) ; cur = stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . add ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( int ele : path ) System . out . print ( ele + " -> " ) ; System . out . println ( cur ) ; }

static void findpath ( int [ ] graph ) { int n = graph . length ; int numofadj = new int [ n ] ; int startpoint = 0 ; int numofodd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( numofadj [ i ] % 2 == 1 ) { numofodd += 1 ; startpoint = i ; } } if ( numofodd > 0 ) { for ( int i =

static void findpath ( int graph [ ] ) { int n = graph . length ; int numofadj = list ( ) . size ( ) ; int startpoint = 0 ; int numofodd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numofadj . append ( graph [ i ] ) ; if ( numofadj [ i ] % 2 == 1 ) numofodd ++ ; startpoint = i ; } for ( int i = startpoint ; i < n ; i ++ ) { if ( graph [ i ] [ cur ] == 1 ) { stack . append ( cur ) graph [ i ] [ cur ] = 0 graph [ i ] [ cur ] = 0 graph [ i ] [ cur ] = 0 cur = i break ; } } for ( int i = startpoint ; i < n ; i ++ ) { graph [ i ] [ cur ] = 0 graph [ i ] [ cur ] = 0 graph [ i ] [ cur ] = 0 cur = i ; } for ( int i = startpoint ; i < n ; i ++ ) { graph [ i ] [ cur ] = 0 graph [ i ] [ cur ] = 0 graph [ i ] [ cur ] =

4.74
3.58
71.43
74.19
def areaOfInscribedCircle ( a ) : return ( PI / 4 ) * a * a

static double areaOfInscribedCircle ( float a ) { return ( PI / 4 ) * a * a ; }

def areaOfInscribedCircle ( a ) {

; public static int areaOfInscribedCircle ( int a ) { return ( PI / 4 ) * a * a ; }

4.79
20.67
28.56
34.53
def rotateMatrix ( mat ) : if not len ( mat ) : return top = 0 bottom = len ( mat ) - 1 left = 0 right = len ( mat [ 0 ] ) - 1 while left < right and top < bottom : prev = mat [ top + 1 ] [ left ] for i in range ( left , right + 1 ) : curr = mat [ top ] [ i ] mat [ top ] [ i ] = prev prev = curr top += 1 for i in range ( top , bottom + 1 ) : curr = mat [ i ] [ right ] mat [ i ] [ right ] = prev prev = curr right -= 1 for i in range ( right , left - 1 , - 1 ) : curr = mat [ bottom ] [ i ] mat [ bottom ] [ i ] = prev prev = curr bottom -= 1 for i in range ( bottom , top - 1 , - 1 ) : curr = mat [ i ] [ left ] mat [ i ] [ left ] = prev prev = curr left += 1 return mat

static void rotatematrix ( int m , int n , int mat [ ] [ ] ) { int row = 0 , col = 0 ; int prev , curr ; while ( row < m && col < n ) { if ( row + 1 == m || col + 1 == n ) break ; prev = mat [ row + 1 ] [ col ] ; for ( int i = col ; i < n ; i ++ ) { curr = mat [ row ] [ i ] ; mat [ row ] [ i ] = prev ; prev = curr ; } row ++ ; for ( int i = row ; i < m ; i ++ ) { curr = mat [ i ] [ n - 1 ] ; mat [ i ] [ n - 1 ] = prev ; prev = curr ; } n -- ; if ( row < m ) { for ( int i = n - 1 ; i >= col ; i -- ) { curr = mat [ m - 1 ] [ i ] ; mat [ m - 1 ] [ i ] = prev ; prev = curr ; } } m -- ; if ( col < n ) { for ( int i = m - 1 ; i >= row ; i -- ) { curr = mat [ i ] [ col ] ; mat [ i ] [ col ] = prev ; prev = curr ; } } col ++ ; } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( mat [ i ] [ j ] + " " ) ; System . out . print ( "\n" ) ; } }

static void rotateMatrix ( int [ ] mat ) { int top = 0 ; int bottom = mat . length - 1 ; int left = 0 ; int right = mat . length - 1 ; int prev = mat [ 0 ] [ left ] ; for ( int i = 0 ; i < right ; i ++ ) { int curr = mat [ i ] [ right ] ; mat [ i ] [ right ] = prev ; prev = curr ; left ++ ; for ( int i =

int rotateMatrix ( int mat [ ] [ ] ) { int top = 0 ; int bottom = len ( mat [ 0 ] ) - 1 ; int left = 0 ; int right = 0 ; int bottom = len ( mat [ 0 ] ) - 1 ; for ( int i = 0 ; i < right ; i ++ ) { int prev = mat [ i ] [ left ] ; mat [ i ] [ left ] = prev ; prev = mat [ i ] [ right ] ; mat [ i ] [ right ] = prev ; prev = curr ; right -= 1 for ( int i = 0 ; i < right ; i ++ ) { curr = mat [ i ] [ right ] ; mat [ i ] [ right ] = prev ; prev = curr ; right -= 1 for ( int i = 0 ; i < right ; i ++ ) { curr = mat [ i ] [ left ] ; mat [ i ] [ left ] = prev ; } } } return mat ; }

4.8
17.39
46.55
50.05
def luDecomposition ( mat , n ) : lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : for k in range ( i , n ) : sum = 0 for j in range ( i ) : sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) upper [ i ] [ k ] = mat [ i ] [ k ] - sum for k in range ( i , n ) : if ( i == k ) : lower [ i ] [ i ] = 1 else : sum = 0 for j in range ( i ) : sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) print ( "LowerTriangular\t\tUpperTriangular" ) for i in range ( n ) : for j in range ( n ) : print ( lower [ i ] [ j ] , end = "\t" ) print ( "" , end = "\t" ) for j in range ( n ) : print ( upper [ i ] [ j ] , end = "\t" ) print ( "" )

static void luDecomposition ( int [ ] [ ] mat , int n ) { int [ ] [ ] lower = new int [ n ] [ n ] ; int [ ] [ ] upper = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) lower [ i ] [ i ] = 1 ; else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } } System . out . println ( setw ( 2 ) + " Lower Triangular" + setw ( 10 ) + "Upper Triangular" ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [ j ] + "\t" ) ; System . out . print ( "\t" ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [ j ] + "\t" ) ; System . out . print ( "\n" ) ; } }

static void luDecomposition ( int mat [ ] , int n ) { int lower [ ] [ ] = new int [ n ] [ ] ; int upper [ ] [ ] = new int [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < n ; k ++ ) { int sum = 0 ; for ( int i = i ; j < n ; j ++ ) { if ( i

static void luDecomposition ( int mat [ ] , int n ) { int lower [ ] [ ] = new int [ n ] ; int upper [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < i ; k ++ ) { if ( i == k ) { lower [ i ] [ j ] = 1 ; } else if ( i == k ) { lower [ i ] [ j ] = 1 ; } else { sum = 0 for ( j in range ( i ) ) { sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) ; upper [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {

4.86
16.69
39.31
37.49
def maximumPalinUsingKChanges ( strr , k ) : palin = strr l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( strr [ l ] != strr [ r ] ) : palin [ l ] = palin [ r ] = max ( strr [ l ] , strr [ r ] ) k -= 1 l += 1 r -= 1 if ( k < 0 ) : return "Notpossible" l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( l == r ) : if ( k > 0 ) : palin [ l ] = '9' if ( palin [ l ] < '9' ) : if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : k -= 1 palin [ l ] = palin [ r ] = '9' elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : k -= 1 palin [ l ] = palin [ r ] = '9' l += 1 r -= 1 return palin

static String maximumPalinUsingKChanges ( String str , int k ) { char palin [ ] = str . toCharArray ( ) ; String ans = "" ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) { return "Not possible" ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < palin . length ; i ++ ) ans += palin [ i ] ; return ans ; }

static String maximumPalinUsingKChanges ( String strr , int k ) { int l = 0 ; int r = len ( strr ) - 1 ; while ( l <= r ) { if ( palin [ l ] < '9' ) palin [ l ] = '9' ; else palin [ l ] = '9' ; else palin [ r ] = '9' ; } l = 0 ; r = len ( strr ) - 1 ; while ( l <=

static String maximumPalinUsingKChanges ( String strr , int k ) { String palin = strr ; int l = 0 ; int r = len ( strr ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) palin [ l ] = '9' if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == strr [ l ] && palin [ r ] == strr [ r ] ) k -= 1 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != strr [ l ] || palin [ r ] != strr [ r ] ) ) k -= 1 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 2 && palin [ l ] == strr [ l ] && palin [ r ] == strr [ r ] ) k -= 1 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != strr [ l ] || palin [ r ]

5.06
18.88
11.55
12.73
def SieveOfAtkin ( limit ) : if ( limit > 2 ) : print ( 2 , end = "" ) if ( limit > 3 ) : print ( 3 , end = "" ) sieve = [ False ] * limit for i in range ( 0 , limit ) : sieve [ i ] = False x = 1 while ( x * x < limit ) : y = 1 while ( y * y < limit ) : n = ( 4 * x * x ) + ( y * y ) if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : sieve [ n ] ^= True n = ( 3 * x * x ) + ( y * y ) if ( n <= limit and n % 12 == 7 ) : sieve [ n ] ^= True n = ( 3 * x * x ) - ( y * y ) if ( x > y and n <= limit and n % 12 == 11 ) : sieve [ n ] ^= True y += 1 x += 1 r = 5 while ( r * r < limit ) : if ( sieve [ r ] ) : for i in range ( r * r , limit , r * r ) : sieve [ i ] = False for a in range ( 5 , limit ) : if ( sieve [ a ] ) : print ( a , end = "" )

static int SieveOfAtkin ( int limit ) { if ( limit > 2 ) System . out . print ( 2 + " " ) ; if ( limit > 3 ) System . out . print ( 3 + " " ) ; boolean sieve [ ] = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) System . out . print ( a + " " ) ; return 0 ; }

static void SieveOfAtkin ( int limit ) { if ( limit > 2 ) print ( 2 , end = "" ) if ( limit > 3 ) print ( 3 , end = "" ) if ( limit > 4 ) print ( 4 , end = "" ) if ( limit > 5 ) sieve [ 5 ] = true ; else sieve [ 5 ] = false ; for ( int i = 0 ; i < limit ; i ++ ) { if ( sieve [ r ] ) {

static void SieveOfAtkin ( int limit ) { if ( limit > 1 ) { System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print ( " " ) ; System . out . print

5.26
16.1
34.34
41.53
def findMaxValue ( mat ) : maxValue = - sys . maxsize - 1 maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] maxv = mat [ N - 1 ] [ N - 1 ] for j in range ( N - 2 , - 1 , - 1 ) : if ( mat [ N - 1 ] [ j ] > maxv ) : maxv = mat [ N - 1 ] [ j ] maxArr [ N - 1 ] [ j ] = maxv maxv = mat [ N - 1 ] [ N - 1 ] for i in range ( N - 2 , - 1 , - 1 ) : if ( mat [ i ] [ N - 1 ] > maxv ) : maxv = mat [ i ] [ N - 1 ] maxArr [ i ] [ N - 1 ] = maxv for i in range ( N - 2 , - 1 , - 1 ) : for j in range ( N - 2 , - 1 , - 1 ) : if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) return maxValue

static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; int maxArr [ ] [ ] = new int [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }

static int findMaxValue ( int [ ] mat , int N ) { int [ ] maxArr [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] > maxValue ) { maxValue = mat [ i ] [ j ] ; maxArr [ i ] [ j ] = max ( max

int [ ] findMaxValue ( int [ ] mat ) { int maxValue = - sys . maxsize - 1 ; int [ ] maxArr = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) { maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) ; maxArr [ i ] [ j ] = max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j + 1 ] , max ( maxArr [ i ] [ j

5.28
25.33
38.86
42.2
def find ( arr ) : n = len ( arr ) i = 0 j = n - 1 res = - 1 while i < n and j >= 0 : if arr [ i ] [ j ] == 0 : while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : j -= 1 if j == - 1 : res = i break else : i += 1 else : while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : i += 1 if i == n : res = j break else : j -= 1 if res == - 1 : return res for i in range ( 0 , n ) : if res != i and arr [ i ] [ res ] != 1 : return - 1 for j in range ( 0 , j ) : if res != j and arr [ res ] [ j ] != 0 : return - 1 ; return res ;

static int find ( boolean arr [ ] [ ] ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == false ) { while ( j >= 0 && ( arr [ i ] [ j ] == false || i == j ) ) { j -- ; } if ( j == - 1 ) { res = i ; break ; } else { i ++ ; } } else { while ( i < n && ( arr [ i ] [ j ] == true || i == j ) ) { i ++ ; } if ( i == n ) { res = j ; break ; } else { j -- ; } } } if ( res == - 1 ) { return res ; } for ( int k = 0 ; k < n ; k ++ ) { if ( res != k && arr [ k ] [ res ] != true ) { return - 1 ; } } for ( int l = 0 ; l < n ; l ++ ) { if ( res != l && arr [ res ] [ l ] != false ) { return - 1 ; } } return res ; }

static int find ( int [ ] arr ) { int i = 0 ; int j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == 0 ) res = i ; else res = j ; } } return res ; }

static int find ( int arr [ ] [ ] ) { int i = 0 ; int j = 0 ; int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] [ j ] == 0 ) { while ( j >= 0 && arr [ i ] [ j ] == 0 ) { while ( j >= 0 && arr [ i ] [ j ] == 0 ) { j -- ; if ( j == - 1 ) res = i ; break ; } } } if ( res == - 1 ) res = i ; else if ( arr [ i ] [ j ] == 1 ) res = i ; else if ( arr [ i ] [ j ] == 0 ) res = i ; else if ( arr [ i ] [ j ] == 1 ) res = j ; else if ( arr [ i ] [ j ] == 0 ) res = i ; else if ( arr [ i ] [ j ] == 1 ) res = j ; else if ( arr [ i ] [ j ] == 0 ) res = i ; else if ( arr [ i ] [ j ] == 1 ) res = j ; else if ( arr [ i ] [ j ] == 0 ) res =

5.57
17.81
27.95
32.83
def getLevenstein ( inpt ) : revInput = inpt [ : : - 1 ] n = len ( inpt ) dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ 0 ] [ i ] = i dp [ i ] [ 0 ] = i for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if inpt [ i - 1 ] == revInput [ j - 1 ] : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) res = INT_MAX i , j = n , 0 while i >= 0 : res = min ( res , dp [ i ] [ j ] ) if i < n : res = min ( res , dp [ i + 1 ] [ j ] ) if i > 0 : res = min ( res , dp [ i - 1 ] [ j ] ) i -= 1 j += 1 return res

static int getLevenstein ( StringBuilder input ) { StringBuilder revInput = new StringBuilder ( input ) ; revInput = revInput . reverse ( ) ; int n = input . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = Integer . MAX_VALUE ; for ( int i = n , j = 0 ; i >= 0 ; i -- , j ++ ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }

static int getLevenstein ( int [ ] inpt ) { int n = revInput . length ; int [ ] dp = [ [ - 1 for _ in range ( n + 1 ) ] ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( inpt [ i - 1 ] == revInput [ j - 1 ] ) res =

static int getLevenstein ( int inpt [ ] ) { int [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; while ( i >= 0 ) { res = min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ; if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ; i -= 1 j += 1 ; } } return res ; }

5.64
19.86
36.36
36.2
def printSuperSeq ( a , b ) : m = len ( a ) n = len ( b ) dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( 0 , m + 1 ) : for j in range ( 0 , n + 1 ) : if not i : dp [ i ] [ j ] = j elif not j : dp [ i ] [ j ] = i elif ( a [ i - 1 ] == b [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] res = [ "" ] * ( index ) i = m j = n while ( i > 0 and j > 0 ) : if ( a [ i - 1 ] == b [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 j -= 1 index -= 1 elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 else : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 while ( i > 0 ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 while ( j > 0 ) : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 print ( "" . join ( res ) )

static void printSuperSeq ( String a , String b ) { int m = a . length ( ) , n = b . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } String res = "" ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) { res = a . charAt ( i - 1 ) + res ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res = a . charAt ( i - 1 ) + res ; i -- ; } else { res = b . charAt ( j - 1 ) + res ; j -- ; } } while ( i > 0 ) { res = a . charAt ( i - 1 ) + res ; i -- ; } while ( j > 0 ) { res = b . charAt ( j - 1 ) + res ; j -- ; } System . out . println ( res ) ; }

static String printSuperSeq ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) res [ i ] = a [ i - 1 ] ; else res [ i ] = b [ j - 1 ] ; } } return res ; }

static void printSuperSeq ( String a , String b ) { int m = len ( a ) ; int n = len ( b ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res [ index - 1 ] = b [ j - 1

5.72
23.2
51.28
48.7
def drawPattern ( N ) : n = N row = 1 nst = 1 nsp1 = n - 1 nsp2 = - 1 val1 = row val2 = 1 while ( row <= n ) : csp1 = 1 while ( csp1 <= nsp1 ) : print ( "" , end = "" ) csp1 = csp1 + 1 cst1 = 1 while ( cst1 <= nst ) : print ( val1 , end = "" ) val1 = val1 - 1 cst1 = cst1 + 1 csp2 = 1 while ( csp2 <= nsp2 ) : print ( "" , end = "" ) csp2 = csp2 + 1 if ( row != 1 and row != n ) : cst2 = 1 while ( cst2 <= nst ) : print ( val2 , end = "" ) val2 = val2 + 1 cst2 = cst2 + 1 print ( ) if ( row <= n // 2 ) : nst = nst + 1 nsp1 = nsp1 - 2 nsp2 = nsp2 + 2 val1 = row + 1 val2 = 1 else : nst = nst - 1 nsp1 = nsp1 + 2 nsp2 = nsp2 - 2 val1 = n - row val2 = 1 row = row + 1

static void drawPattern ( int N ) { int n = N ; int row = 1 ; int nst = 1 ; int nsp1 = n - 1 ; int nsp2 = - 1 ; int val1 = row ; int val2 = 1 ; while ( row <= n ) { int csp1 = 1 ; while ( csp1 <= nsp1 ) { System . out . print ( " " ) ; csp1 = csp1 + 1 ; } int cst1 = 1 ; while ( cst1 <= nst ) { System . out . print ( val1 + " " ) ; val1 = val1 - 1 ; cst1 = cst1 + 1 ; } int csp2 = 1 ; while ( csp2 <= nsp2 ) { System . out . print ( " " ) ; csp2 = csp2 + 1 ; } if ( row != 1 && row != n ) { int cst2 = 1 ; while ( cst2 <= nst ) { System . out . print ( val2 + " " ) ; val2 = val2 + 1 ; cst2 = cst2 + 1 ; } } System . out . println ( ) ; if ( row <= n / 2 ) { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 + 2 ; val1 = row + 1 ; val2 = 1 ; } else { nst = nst - 1 ; nsp1 = nsp1 + 2 ; nsp2 = nsp2 - 2 ; val1 = n - row ; val2 = 1 ; } row = row + 1 ; } }

static void drawPattern ( int N ) { int nst = 1 ; int nsp1 = - 1 ; int nsp2 = - 1 ; int val1 = row ; int val2 = row ; while ( row <= n ) { int cst1 = 1 ; while ( cst1 <= nst ) { print ( val1 , end = "" ) val1 = val1 - 1 cst1 = cst1 + 1 ; if ( cst2 <= n

static void drawPattern ( int N ) { int row = 1 ; int n = N ; int nsp1 = 1 ; int nsp2 = 1 ; int val1 = row ; int val2 = row ; while ( row <= n ) { int csp1 = 1 ; while ( csp1 <= nsp1 ) { print ( val1 , end = "" ) ; val1 = val1 - 1 ; cst1 = 1 ; while ( cst1 <= nst ) { print ( val2 , end = "" ) ; val2 = val2 - 1 ; cst2 = cst2 + 1 if ( row != 1 && row != n ) { cst2 = 1 ; while ( cst2 <= nst ) { print ( val2 , end = "" ) ; val2 = val2 + 1 ; cst2 = cst2 + 1 if ( row != 1 ) { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 - 2 ; val1 = row + 1 ; val2 = 1 ; } else { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 - 2 ; val1 = row

6.05
21.32
33.7
33.31
def smallestNumber ( num ) : num = list ( num ) n = len ( num ) rightMin = [ 0 ] * n right = 0 rightMin [ n - 1 ] = - 1 ; right = n - 1 ; for i in range ( n - 2 , 0 , - 1 ) : if num [ i ] > num [ right ] : rightMin [ i ] = right else : rightMin [ i ] = - 1 right = i small = - 1 for i in range ( 1 , n ) : if num [ i ] != '0' : if small == - 1 : if num [ i ] < num [ 0 ] : small = i elif num [ i ] < num [ small ] : small = i if small != - 1 : num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ] else : for i in range ( 1 , n ) : if rightMin [ i ] != - 1 : num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] break return '' . join ( num )

public static String smallestNumber ( String str ) { char [ ] num = str . toCharArray ( ) ; int n = str . length ( ) ; int [ ] rightMin = new int [ n ] ; rightMin [ n - 1 ] = - 1 ; int right = n - 1 ; for ( int i = n - 2 ; i >= 1 ; i -- ) { if ( num [ i ] > num [ right ] ) rightMin [ i ] = right ; else { rightMin [ i ] = - 1 ; right = i ; } } int small = - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( num [ i ] != '0' ) { if ( small == - 1 ) { if ( num [ i ] < num [ 0 ] ) small = i ; } else if ( num [ i ] < num [ small ] ) small = i ; } if ( small != - 1 ) { char temp ; temp = num [ 0 ] ; num [ 0 ] = num [ small ] ; num [ small ] = temp ; } else { for ( int i = 1 ; i < n ; i ++ ) { if ( rightMin [ i ] != - 1 ) { char temp ; temp = num [ i ] ; num [ i ] = num [ rightMin [ i ] ] ; num [ rightMin [ i ] ] = temp ; break ; } } } return ( new String ( num ) ) ; }

static String smallestNumber ( String num ) { int n = num . length ( ) ; int rightMin [ ] = - 1 ; int small = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( num [ i ] < num [ right ] ) { rightMin [ i ] = right ; } else { rightMin [ i ] = i ; } } return num ; } }

public static String smallestNumber ( String num ) { int n = num . length ( ) ; int rightMin [ ] = new int [ n ] ; int right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( num [ i ] != '0' ) if ( rightMin [ i ] != - 1 ) num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] ; else if ( rightMin [ i ] != - 1 ) num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] ; else if ( rightMin [ i ] != - 1 ) num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] ; else if ( rightMin [ i ] != - 1 ) num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] ; else if ( rightMin [ i ] != - 1 ) num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ]

6.13
20.88
24.32
27.63
def minOperations ( str , n ) : lastUpper = - 1 firstLower = - 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( str [ i ] . isupper ( ) ) : lastUpper = i break for i in range ( n ) : if ( str [ i ] . islower ( ) ) : firstLower = i break if ( lastUpper == - 1 or firstLower == - 1 ) : return 0 countUpper = 0 for i in range ( firstLower , n ) : if ( str [ i ] . isupper ( ) ) : countUpper += 1 countLower = 0 for i in range ( lastUpper ) : if ( str [ i ] . islower ( ) ) : countLower += 1 return min ( countLower , countUpper )

static int minOperations ( String str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 || firstLower == - 1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { countLower ++ ; } } return Math . min ( countLower , countUpper ) ; }

static int minOperations ( String str , int n ) { int countUpper = - 1 ; int countLower = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] . islower ( ) ) { countLower += 1 ; } } return 0 ; }

static int minOperations ( String str , int n ) { int lastUpper = - 1 ; int firstLower = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] . isupper ( ) ) lastUpper = i ; else if ( str [ i ] . islower ( ) ) firstLower = i ; else if ( str [ i ] . isupper ( ) ) lastUpper = i ; else if ( str [ i ] . islower ( ) ) lastUpper = i ; else if ( str [ i ] . isupper ( ) ) lastUpper = i ; else if ( str [ i ] . islower ( ) ) lastUpper = i ; else if ( str [ i ] . isupper ( ) ) lastUpper = i ; else if ( str [ i ] . islower ( ) ) lastUpper = i ; else if ( str [ i ] . isupper ( ) ) lastUpper = i ; else if ( str [ i ] . isupper ( ) ) lastUpper = i ; else if ( str [ i ] . islower ( ) ) lastUpper = i ; } return minOperations ( str , n ) ; }

6.17
13.91
24.5
21.94
def simplify ( Str ) : Len = len ( Str ) res = [ None ] * Len index = 0 i = 0 s = [ ] s . append ( 0 ) while ( i < Len ) : if ( Str [ i ] == '+' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '-' index += 1 if ( s [ - 1 ] == 0 ) : res [ index ] = '+' index += 1 elif ( Str [ i ] == '-' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '+' index += 1 elif ( s [ - 1 ] == 0 ) : res [ index ] = '-' index += 1 elif ( Str [ i ] == '(' and i > 0 ) : if ( Str [ i - 1 ] == '-' ) : x = 0 if ( s [ - 1 ] == 1 ) else 1 s . append ( x ) elif ( Str [ i - 1 ] == '+' ) : s . append ( s [ - 1 ] ) elif ( Str [ i ] == ')' ) : s . pop ( ) else : res [ index ] = Str [ i ] index += 1 i += 1 return res

static String simplify ( String str ) { int len = str . length ( ) ; char res [ ] = new char [ len ] ; int index = 0 , i = 0 ; Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; while ( i < len ) { if ( str . charAt ( i ) == '+' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = '-' ; if ( s . peek ( ) == 0 ) res [ index ++ ] = '+' ; } else if ( str . charAt ( i ) == '-' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = '+' ; else if ( s . peek ( ) == 0 ) res [ index ++ ] = '-' ; } else if ( str . charAt ( i ) == '(' && i > 0 ) { if ( str . charAt ( i - 1 ) == '-' ) { int x = ( s . peek ( ) == 1 ) ? 0 : 1 ; s . push ( x ) ; } else if ( str . charAt ( i - 1 ) == '+' ) s . push ( s . peek ( ) ) ; } else if ( str . charAt ( i ) == ')' ) s . pop ( ) ; else res [ index ++ ] = str . charAt ( i ) ; i ++ ; } return new String ( res ) ; }

static int simplify ( String Str ) { int Len = Str . length ( ) ; int index = 0 ; int s = new int [ Len ] ; while ( i < Len ) { if ( s [ - 1 ] == 0 ) res [ index ] = '+' index += 1 ; else res [ index ] = '-' index += 1 ; } else { int x = 0 ; if ( s [ - 1 ] == 0 ) res [ index ] = '+' index += 1 ; else

static int simplify ( String Str ) { int Len = len ( Str ) ; int index = 0 ; for ( int i = 0 ; i < Len ; i ++ ) { if ( Str [ i ] == '+' ) { res [ index ] = '+' ; index ++ ; if ( s [ - 1 ] == 1 ) res [ index ] = '-' ; index ++ ; } else if ( Str [ i ] == '-' ) { if ( s [ - 1 ] == 1 ) res [ index ] = '+' ; index ++ ; } else if ( Str [ i ] == '(' and i > 0 ) { if ( Str [ i - 1 ] == '-' ) { x = 0 if ( s [ - 1 ] == 1 ) else 1 s . append ( x ) ; } else { res . append ( s [ - 1 ] ) ; } } else { res [ index ] = Str [ i ] ; index ++ ; } } else { res [ index ] = Str [ i ] ; index ++ ; } } return res ; }

6.19
17.93
20.66
30.56
def checkEulerFourSquareIdentity ( a , b ) : ab = a * b flag = False i = 0 while i * i <= ab : j = i while i * i + j * j <= ab : k = j while i * i + j * j + k * k <= ab : l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) if l == int ( l ) and l >= k : flag = True print ( "i=" , i ) print ( "j=" , j ) print ( "k=" , k ) print ( "l=" , l ) print ( "Productof" , a , "and" , b , "canbewrittenassumofsquaresofi,j,k,l" ) print ( ab , "=" , i , "*" , i , "+" , j , "*" , j , "+" , k , "*" , k , "+" , l , "*" , l ) k += 1 j += 1 i += 1 if flag == False : print ( "Solutiondoesn'texist!" ) return

public static void checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; boolean flag = false ; int i = 0 ; while ( i * i <= ab ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { double l = Math . sqrt ( ab - ( i * i + j * j + k * k ) ) ; if ( Math . floor ( l ) == Math . ceil ( l ) && l >= k ) { flag = true ; System . out . print ( "i = " + i + "\n" ) ; System . out . print ( "j = " + j + "\n" ) ; System . out . print ( "k = " + k + "\n" ) ; System . out . print ( "l = " + ( int ) l + "\n" ) ; System . out . print ( "Product of " + a + " and " + b + " can be written as sum of squares" + " of i, j, k, l \n" ) ; System . out . print ( ab + " = " + i + "*" + i + " + " + j + "*" + j + " + " + k + "*" + k + " + " + ( int ) l + "*" + ( int ) l + "\n" ) ; } k += 1 ; } j += 1 ; } i += 1 ; } if ( flag == false ) { System . out . println ( "Solution doesn't exist!" ) ; return ; } }

static boolean checkEulerFourSquareIdentity ( int a , int b ) { int i = 0 ; while ( i * i + j * j + k * k <= ab ) { int j = i ; int k = j ; while ( i * i + j * j + k * k <= ab ) { int l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) ; if ( l == int

static void checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; int i = 0 ; int j = 0 ; int k = 0 ; int l = 0 ; while ( i * i + j * j + k * k <= ab ) { l = ( ab - ( i * i + j * j + k * k ) ) ** 0.5 ; if ( l == int ( l ) && l >= k ) flag = true ; print ( "Productof" , a , "and" , b , "canbewrittenassumofsquaresofi,j,k,l" ) print ( ab , "=" , i , "*" , i , "+" , j , "*" , j , "+" , k , "*" , k , "+" , l , "*" , l ) ; i ++ ; j ++ ; k ++ ; } if ( flag == false ) print ( "Solutiondoesn'texist!" ) ; return ; }

6.44
14.38
40.82
42.98
def minMaxLengthWords ( inp ) : length = len ( inp ) si = ei = 0 min_length = length min_start_index = max_length = max_start_index = 0 while ei <= length : if ( ei < length ) and ( inp [ ei ] != "" ) : ei += 1 else : curr_length = ei - si if curr_length < min_length : min_length = curr_length min_start_index = si if curr_length > max_length : max_length = curr_length max_start_index = si ei += 1 si = ei minWord = inp [ min_start_index : min_start_index + min_length ] maxWord = inp [ max_start_index : max_length ] print ( "Minimumlengthword:" , minWord ) print ( "Maximumlengthword:" , maxWord )

static void minMaxLengthWords ( String input ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int min_length = len , min_start_index = 0 , max_length = 0 , max_start_index = 0 ; while ( ei <= len ) { if ( ei < len && input . charAt ( ei ) != ' ' ) { ei ++ ; } else { int curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } if ( curr_length > max_length ) { max_length = curr_length ; max_start_index = si ; } ei ++ ; si = ei ; } } minWord = input . substring ( min_start_index , min_start_index + min_length ) ; maxWord = input . substring ( max_start_index , max_length ) ; }

static int minMaxLengthWords ( String inp ) { int si = 0 ; int ei = 0 ; int max_length = length ; int min_start_index = 0 ; int max_start_index = 0 ; int minWord = inp [ min_start_index : min_start_index + min_length ] maxWord = inp [ max_start_index : max_start_index + max_length ] ; int maxWord = inp [ max_start

static void minMaxLengthWords ( String [ ] inp , int length ) { int si = 0 ; int ei = 0 ; int min_length = length ; int min_start_index = 0 ; int max_length = 0 ; int max_start_index = 0 ; int max_start_index = 0 ; while ( ei <= length ) { if ( ei < length ) { if ( inp [ ei ] != "" ) { ei ++ ; } else { curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } else { curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } } else { curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } } } } maxWord = inp [ max_start_index : max_length ] ; } }

6.85
23.09
31.32
37.3
def MaximumDecimalValue ( mat , n ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] if ( mat [ 0 ] [ 0 ] == 1 ) : dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , n ) : if ( mat [ 0 ] [ i ] == 1 ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i else : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] for i in range ( 1 , n ) : if ( mat [ i ] [ 0 ] == 1 ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i else : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( mat [ i ] [ j ] == 1 ) : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ n - 1 ] [ n - 1 ]

static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }

static int MaximumDecimalValue ( int [ ] mat , int n ) { int [ ] dp = new int [ n ] [ ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i ; else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** ( i ) ; } return dp [ n ] ; }

static int MaximumDecimalValue ( double [ ] mat , int n ) { double dp [ ] [ ] = new double [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 2 ** i ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 2 ** i ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ n - 1 ] [ n - 1 ] ; }

6.9
3.27
70.89
75.1
def binomialCoeffSum ( n ) : return ( 1 << n )

static int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }

def binomialCoeffSum ( n ) :

static int binomialCoeffSum ( int n ) { return binomialCoeffSum ( n ) ; }

7.0
21.9
47.38
42.48
def minMaxValues ( arr , n , m ) : sum = 0 INF = 1000000000 MAX = 50 for i in range ( 0 , ( n + m ) ) : sum += arr [ i ] arr [ i ] += 50 dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 0 , ( n + m ) ) : for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : for j in range ( 0 , MAX * MAX + 1 ) : if ( dp [ k - 1 ] [ j ] ) : dp [ k ] [ j + arr [ i ] ] = 1 max_value = - 1 * INF min_value = INF for i in range ( 0 , MAX * MAX + 1 ) : if ( dp [ n ] [ i ] ) : temp = i - 50 * n max_value = max ( max_value , temp * ( sum - temp ) ) min_value = min ( min_value , temp * ( sum - temp ) ) print ( "MaximumValue:{}\nMinimumValue:{}" . format ( max_value , min_value ) )

static void minMaxValues ( int [ ] arr , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = true ; } } } double max_value = - 1 * INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . print ( "Maximum Value: " + ( int ) max_value + "\n" + "Minimum Value: " + ( int ) min_value + "\n" ) ; }

static void minMaxValues ( int arr [ ] , int n , int m ) { int sum = 0 ; int max_value = - 1 * INF ; int min_value = - 1 * INF ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { if ( dp [ n ] [ i ] ) { max_value = max ( max_value , temp * ( sum - temp ) ) ; min_value = min (

static void minMaxValues ( int arr [ ] , int n , int m ) { int sum = 0 ; int INF = 1000000000 ; int MAX = 50 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k ] [ j ] ) { dp [ k ] [ j + arr [ i ] ] = 1 ; } } } for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } } for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } for

7.01
15.75
36.76
35.68
def minInitialPoints ( points ) : dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] m , n = R , C if points [ m - 1 ] [ n - 1 ] > 0 : dp [ m - 1 ] [ n - 1 ] = 1 else : dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 for i in range ( m - 2 , - 1 , - 1 ) : dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) for i in range ( 2 , - 1 , - 1 ) : dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) for i in range ( m - 2 , - 1 , - 1 ) : for j in range ( n - 2 , - 1 , - 1 ) : min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) return dp [ 0 ] [ 0 ]

static int minInitialPoints ( int points [ ] [ ] , int R , int C ) { int dp [ ] [ ] = new int [ R ] [ C ] ; int m = R , n = C ; dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ; for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = Math . max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }

static int minInitialPoints ( int [ ] points , int R , int C ) { int [ ] dp = new int [ points . length ] [ ] ; for ( int i = 0 ; i < m ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( points [ i ] [ j ] > 0 ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] -

static int minInitialPoints ( int [ ] points ) { int [ ] dp = new int [ points . length ] ; for ( int i = 0 ; i < points . length ; i ++ ) { for ( int j = 0 ; j < points . length ; j ++ ) { dp [ i ] [ j ] = minInitialPoints ( points [ i ] ) ; if ( points [ i ] [ j ] > 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = abs ( points [ i ] [ j ] ) + 1 ; } for ( int i = 0 ; i < points . length ; i ++ ) { dp [ i ] [ n - 1 ] = abs ( points [ i ] [ n - 1 ] ) + 1 ; for ( int j = 0 ; j < points . length ; j ++ ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] - points [ i ] [ j ] , 1 ) ; } } } return dp [ 0 ] [ 0 ] ; }

7.06
14.67
16.02
18.69
def countDistinct ( arr , k , n ) : mp = defaultdict ( lambda : 0 ) dist_count = 0 for i in range ( k ) : if mp [ arr [ i ] ] == 0 : dist_count += 1 mp [ arr [ i ] ] += 1 print ( dist_count ) for i in range ( k , n ) : if mp [ arr [ i - k ] ] == 1 : dist_count -= 1 mp [ arr [ i - k ] ] -= 1 if mp [ arr [ i ] ] == 0 : dist_count += 1 mp [ arr [ i ] ] += 1 print ( dist_count )

static void countDistinct ( int arr [ ] , int k ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } } System . out . println ( dist_count ) ; for ( int i = k ; i < arr . length ; i ++ ) { if ( hM . get ( arr [ i - k ] ) == 1 ) { hM . remove ( arr [ i - k ] ) ; dist_count -- ; } else { int count = hM . get ( arr [ i - k ] ) ; hM . put ( arr [ i - k ] , count - 1 ) ; } if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } System . out . println ( dist_count ) ; } }

static int countDistinct ( int arr [ ] , int k , int n ) { int dist_count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( mp [ arr [ i ] ] == 0 ) dist_count -= 1 mp [ arr [ i ] ] -= 1 ; if ( mp [ arr [ i ] ] == 1 ) dist_count -= 1 mp [ arr [ i ] ] -= 1 ; if ( mp [ arr

static void countDistinct ( int arr [ ] , int k , int n ) { int dist_count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( mp [ arr [ i ] ] == 0 ) dist_count -= 1 mp [ arr [ i ] ] -= 1 ; if ( mp [ arr [ i ] ] == 0 ) dist_count += 1 mp [ arr [ i ] ] += 1 ; if ( mp [ arr [ i ] ] == 0 ) dist_count += 1 mp [ arr [ i ] ] -= 1 ; if ( mp [ arr [ i ] ] == 0 ) dist_count += 1 mp [ arr [ i ] ] += 1 ; } }

7.41
21.79
40.41
43.41
def solve ( a , b , n ) : s = 0 for i in range ( 0 , n ) : s += a [ i ] + b [ i ] if n == 1 : return a [ 0 ] + b [ 0 ] if s % n != 0 : return - 1 x = s // n for i in range ( 0 , n ) : if a [ i ] > x : return - 1 if i > 0 : a [ i ] += b [ i - 1 ] b [ i - 1 ] = 0 if a [ i ] == x : continue y = a [ i ] + b [ i ] if i + 1 < n : y += b [ i + 1 ] if y == x : a [ i ] = y b [ i ] = 0 if i + 1 < n : b [ i + 1 ] = 0 continue if a [ i ] + b [ i ] == x : a [ i ] += b [ i ] b [ i ] = 0 continue if i + 1 < n and a [ i ] + b [ i + 1 ] == x : a [ i ] += b [ i + 1 ] b [ i + 1 ] = 0 continue return - 1 for i in range ( 0 , n ) : if b [ i ] != 0 : return - 1 return x

static int solve ( int a [ ] , int b [ ] , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }

static int solve ( int [ ] a , int [ ] b , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] + b [ i ] == 0 ) a [ i ] = 0 ; if ( a [ i ] + b [ i ] == 0 ) a [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( b

static int solve ( int a [ ] , int b [ ] , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i ] + b [ i ] > x ) return - 1 ; if ( a [ i

7.43
17.33
43.8
46.56
def ReversespiralPrint ( m , n , a ) : b = [ 0 for i in range ( 100 ) ] i , k , l = 0 , 0 , 0 z = 0 size = m * n while ( k < m and l < n ) : val = 0 for i in range ( l , n ) : val = a [ k ] [ i ] b [ z ] = val z += 1 k += 1 for i in range ( k , m ) : val = a [ i ] [ n - 1 ] b [ z ] = val z += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : val = a [ m - 1 ] [ i ] b [ z ] = val z += 1 m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : val = a [ i ] [ l ] b [ z ] = val z += 1 l += 1 for i in range ( size - 1 , - 1 , - 1 ) : print ( b [ i ] , end = "" )

public static void ReversespiralPrint ( int m , int n , int a [ ] [ ] ) { long b [ ] = new long [ 100 ] ; int i , k = 0 , l = 0 ; int z = 0 ; int size = m * n ; while ( k < m && l < n ) { int val ; for ( i = l ; i < n ; ++ i ) { val = a [ k ] [ i ] ; b [ z ] = val ; ++ z ; } k ++ ; for ( i = k ; i < m ; ++ i ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; ++ z ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { val = a [ m - 1 ] [ i ] ; b [ z ] = val ; ++ z ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { val = a [ i ] [ l ] ; b [ z ] = val ; ++ z ; } l ++ ; } } for ( int x = size - 1 ; x >= 0 ; -- x ) { System . out . print ( b [ x ] + " " ) ; } }

static void ReversespiralPrint ( int m , int n ) { int i = 0 , k = 0 , l = 0 , z = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k < m ) { for ( int i = 0 ; i < l ; i ++ ) { if ( l < n ) {

static void ReversespiralPrint ( int m , int n , int a [ ] ) { int b [ ] = new int [ size ] ; for ( int i = 0 ; i < m ; i ++ ) { int val = 0 for ( int i = 0 ; i < n ; i ++ ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; z += 1 ; } } for ( int i = 0 ; i < m ; i ++ ) { val = 0 for ( int i = 0 ; i < m ; i ++ ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; z += 1 ; } } for ( int i = 0 ; i < m ; i ++ ) { val = a [ i ] [ l ] ; b [ z ] = val ; z += 1 ; } for ( int i = 0 ; i < n ; i ++ ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; z += 1 ; } for ( int i = 0 ; i < m ; i ++ ) { b [ z ] = a [ i ] [ l ] ;

7.51
22.8
47.31
48.01
def longLenStrictBitonicSub ( arr , n ) : inc , dcr = dict ( ) , dict ( ) len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n longLen = 0 for i in range ( n ) : len = 0 if inc . get ( arr [ i ] - 1 ) in inc . values ( ) : len = inc . get ( arr [ i ] - 1 ) inc [ arr [ i ] ] = len_inc [ i ] = len + 1 for i in range ( n - 1 , - 1 , - 1 ) : len = 0 if dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) : len = dcr . get ( arr [ i ] - 1 ) dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 for i in range ( n ) : if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) : longLen = len_inc [ i ] + len_dcr [ i ] - 1 return longLen

static int longLenStrictBitonicSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > inc = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > dcr = new HashMap < Integer , Integer > ( ) ; int len_inc [ ] = new int [ n ] ; int len_dcr [ ] = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ; len_inc [ i ] = len + 1 ; inc . put ( arr [ i ] , len_inc [ i ] ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . containsKey ( arr [ i ] - 1 ) ) len = dcr . get ( arr [ i ] - 1 ) ; len_dcr [ i ] = len + 1 ; dcr . put ( arr [ i ] , len_dcr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }

static long longLenStrictBitonicSub ( int arr [ ] , int n ) { int len_inc , len_dcr ; inc [ arr [ i ] ] = 0 ; dcr [ arr [ i ] ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) : len = dcr . get (

static int longLenStrictBitonicSub ( int arr [ ] , int n ) { int inc [ ] = new int [ n ] ; int dcr [ ] = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( inc . get ( arr [ i ] - 1 ) in inc . values ( ) ) inc [ arr [ i ] ] = inc . get ( arr [ i ] - 1 ) ; if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; else if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; else if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; } } return longLen ; }

7.58
23.3
38.06
40.82
def findMaxVal ( arr , n , num , maxLimit ) : ind = - 1 val = - 1 dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] for ind in range ( n ) : for val in range ( maxLimit + 1 ) : if ( ind == 0 ) : if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : dp [ ind ] [ val ] = 1 else : dp [ ind ] [ val ] = 0 else : if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : dp [ ind ] [ val ] = 1 elif ( val - arr [ ind ] >= 0 ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] elif ( val + arr [ ind ] <= maxLimit ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] else : dp [ ind ] [ val ] = 0 for val in range ( maxLimit , - 1 , - 1 ) : if ( dp [ n - 1 ] [ val ] == 1 ) : return val return - 1

static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind ; int val ; int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] == 1 ) { return val ; } } return - 1 ; }

static int findMaxVal ( int [ ] arr , int n , int maxLimit ) { int [ ] dp = new int [ n ] [ maxLimit + 1 ] [ ] ; for ( int ind = 0 ; ind < n ; ind ++ ) { for ( int val = 0 ; val < arr . length ; val ++ ) { if ( dp [ ind ] [ val ] == 1 ) { dp [ ind ] [ val ] = 1 ; } else { if (

static int findMaxVal ( int arr [ ] , int n , int maxLimit ) { int ind = - 1 ; int val = - 1 ; int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( num - arr [ i ] == val || num + arr [ i ] == val ) { dp [ ind ] [ val ] = 1 ; } else if ( num - arr [ i ] == val || num + arr [ i ] == val ) { dp [ ind ] [ val ] = 1 ; } else if ( num - arr [ i ] == val || num + arr [ i ] == val ) { dp [ ind ] [ val ] = 1 ; } else if ( num - arr [ i ] == val || num + arr [ i ] == val ) { dp [ ind ] [ val ] = 1 ; } else if ( num - arr [ i ] == val || num + arr [ i ] == val ) { dp [ ind ] [ val ] = 1 ; } else if ( num - arr [ i ] == val || num + arr [ i ] == val ) { dp [ ind ] [ val ] = 1 ; }

7.64
16.63
36.64
37.0
def isRectangle ( matrix ) : rows = len ( matrix ) if ( rows == 0 ) : return False columns = len ( matrix [ 0 ] ) table = { } for i in range ( rows ) : for j in range ( columns - 1 ) : for k in range ( j + 1 , columns ) : if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : if ( j in table and k in table [ j ] ) : return True if ( k in table and j in table [ k ] ) : return True if j not in table : table [ j ] = set ( ) if k not in table : table [ k ] = set ( ) table [ j ] . add ( k ) table [ k ] . add ( j ) return False

static boolean isRectangle ( int matrix [ ] [ ] ) { int rows = matrix . length ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . length ; HashMap < Integer , HashSet < Integer >> table = new HashMap < > ( ) ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns - 1 ; j ++ ) { for ( int k = j + 1 ; k < columns ; k ++ ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( table . containsKey ( j ) && table . get ( j ) . contains ( k ) ) { return true ; } if ( table . containsKey ( k ) && table . get ( k ) . contains ( j ) ) { return true ; } if ( ! table . containsKey ( j ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( k ) ; table . put ( j , x ) ; } else { table . get ( j ) . add ( k ) ; } if ( ! table . containsKey ( k ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( j ) ; table . put ( k , x ) ; } else { table . get ( k ) . add ( j ) ; } } } } } return false ; }

static boolean isRectangle ( int [ ] matrix ) { int rows = matrix . length ; int columns = matrix . length ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) { if ( k == 0 ) return true ; if ( j in table ) return true ; if ( k in table ) return true ; if ( j in table ) return true ; if ( k in table ) return

static boolean isRectangle ( int rows , int columns , int table [ ] ) { for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) { for ( int k = 0 ; k < rows ; k ++ ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( j in table && table [ j ] . contains ( k ) ) return true ; if ( table [ k ] . contains ( j ) ) return true ; if ( table [ j ] . contains ( k ) ) return true ; if ( table [ k ] . contains ( j ) ) return true ; if ( table [ j ] . contains ( k ) ) return true ; if ( table [ k ] . contains ( j ) ) return true ; if ( table [ j ] . contains ( k ) ) return true ; if ( table [ k ] . contains ( j ) ) return true ; if ( table [ j ] . contains ( k ) ) return true ; } } } return false ; }

7.75
39.56
5.91
39.01
def sparseSearch ( arr , key , low , high ) : left = 0 right = 0 while low <= high : mid = ( low + high ) // 2 if arr [ mid ] == '' : left = mid - 1 right = mid + 1 if left < low and right > high : return - 1 elif right <= high and arr [ right ] != '' : mid = right elif left >= low and arr [ left ] != '' : mid = left if arr [ mid ] == key : print ( 'Foundstring{}atindex{}' . format ( arr [ mid ] , mid ) ) return elif arr [ mid ] > key : high = mid - 1 elif arr [ mid ] < key : low = mid + 1 left -= 1 right += 1 return - 1

static int sparseSearch ( String arr [ ] , String x , int n ) { return binarySearch ( arr , 0 , n - 1 , x ) ; }

static int sparseSearch ( int arr [ ] , int key ) { int left = 0 ; int right = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == key ) left ++ ; else right ++ ; if ( arr [ mid ] > key ) high = mid + 1 ; else left ++ ; if ( arr [ mid ] < key ) low = mid - 1 ; else right ++ ; if (

static int sparseSearch ( String arr , int key , int low , int high ) { int left = 0 ; int right = 0 ; while ( low <= high ) { int mid = ( low + high ) // 2 ; if ( arr [ mid ] == '' ) left = mid - 1 ; else if ( arr [ mid ] == key ) left = mid + 1 ; else if ( arr [ mid ] > key ) high = mid - 1 ; else if ( arr [ mid ] < key ) low = mid + 1 ; else if ( arr [ mid ] > key ) low = mid - 1 ; else if ( arr [ mid ] < key ) high = mid + 1 ; else return - 1 ; } return - 1 ; }

7.76
17.33
21.45
30.17
def minSwaps ( arr ) : n = len ( arr ) arrpos = [ * enumerate ( arr ) ] arrpos . sort ( key = lambda it : it [ 1 ] ) vis = { k : False for k in range ( n ) } ans = 0 for i in range ( n ) : if vis [ i ] or arrpos [ i ] [ 0 ] == i : continue cycle_size = 0 j = i while not vis [ j ] : vis [ j ] = True j = arrpos [ j ] [ 0 ] cycle_size += 1 if cycle_size > 0 : ans += ( cycle_size - 1 ) return ans

public static int minSwaps ( int [ ] arr ) { int n = arr . length ; ArrayList < Pair < Integer , Integer >> arrpos = new ArrayList < Pair < Integer , Integer >> ( ) ; for ( int i = 0 ; i < n ; i ++ ) arrpos . add ( new Pair < Integer , Integer > ( arr [ i ] , i ) ) ; arrpos . sort ( new Comparator < Pair < Integer , Integer >> ( ) { @ Override public int compare ( Pair < Integer , Integer > o1 , Pair < Integer , Integer > o2 ) { if ( o1 . getKey ( ) > o2 . getKey ( ) ) return - 1 ; else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) ) ) return 0 ; else return 1 ; } } ) ; Boolean [ ] vis = new Boolean [ n ] ; Arrays . fill ( vis , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos . get ( i ) . getValue ( ) == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos . get ( j ) . getValue ( ) ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; }

static int minSwaps ( int arr [ ] ) { int n = arr . length ; int arrpos [ ] = new int [ n ] [ 0 ] ; vis [ 0 ] = false ; for ( int i = 0 ; i < n ; i ++ ) { vis [ i ] = true ; for ( int j = i ; j < arrpos [ j ] [ 0 ] ; j ++ ) { vis [ j ] = true ; } } return ans ; }

static int minSwaps ( int arr [ ] ) { int n = arr . length ; int arrpos [ ] = new int [ n ] ; arrpos . sort ( key = lambda it : it [ 1 ] ) ; vis [ i ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos [ i ] [ 0 ] == i ) continue ; int cycle_size = 0 ; j = i ; while ( ! vis [ j ] ) { j = arrpos [ j ] [ 0 ] ; cycle_size += 1 ; if ( cycle_size > 0 ) ans += ( cycle_size - 1 ) ; } } return ans ; }

7.77
17.7
31.09
28.55
def multiply ( num1 , num2 ) : len1 = len ( num1 ) len2 = len ( num2 ) if len1 == 0 or len2 == 0 : return "0" result = [ 0 ] * ( len1 + len2 ) i_n1 = 0 i_n2 = 0 for i in range ( len1 - 1 , - 1 , - 1 ) : carry = 0 n1 = ord ( num1 [ i ] ) - 48 i_n2 = 0 for j in range ( len2 - 1 , - 1 , - 1 ) : n2 = ord ( num2 [ j ] ) - 48 summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry carry = summ // 10 result [ i_n1 + i_n2 ] = summ % 10 i_n2 += 1 if ( carry > 0 ) : result [ i_n1 + i_n2 ] += carry i_n1 += 1 i = len ( result ) - 1 while ( i >= 0 and result [ i ] == 0 ) : i -= 1 if ( i == - 1 ) : return "0" s = "" while ( i >= 0 ) : s += chr ( result [ i ] + 48 ) i -= 1 return s

static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; int result [ ] = new int [ len1 + len2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 . charAt ( i ) - '0' ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 . charAt ( j ) - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = "" ; while ( i >= 0 ) s += ( result [ i -- ] ) ; return s ; }

static String multiply ( String num , String num2 ) { int i = 0 ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) { int carry = 0 ; for ( int j = 0 ; j < len2 ; j ++ ) { int summ = result [ i_n1 + i_n2 ] + carry ; result [ i_n1 + i_

static String multiply ( int num1 , int num2 ) { int len1 = len ( num1 ) ; int len2 = len ( num2 ) ; int i_n1 = 0 i_n2 = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) { int carry = 0 ; int n1 = ord ( num1 [ i ] ) - 48 ; int n2 = ord ( num2 [ i ] ) - 48 ; int summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry carry = summ // 10 result [ i_n1 + i_n2 ] = carry ; carry = summ % 10 i_n2 += carry ; if ( carry > 0 ) result [ i_n1 + i_n2 ] = carry ; i_n1 += 1 if ( carry > 0 ) result [ i_n1 + i_n2 ] = carry ; i_n2 += 1 if ( carry > 0 ) result [ i_n1 + i_n2 ] = carry ; i_n1 += 1 if ( carry > 0 ) result [ i_n1 + i_n2

7.78
20.62
41.59
39.96
def maxProduct ( arr , n ) : if ( n < 2 ) : print ( "Nopairsexists" ) return if ( n == 2 ) : print ( arr [ 0 ] , "" , arr [ 1 ] ) return posa = 0 posb = 0 nega = 0 negb = 0 for i in range ( n ) : if ( arr [ i ] > posa ) : posb = posa posa = arr [ i ] elif ( arr [ i ] > posb ) : posb = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : negb = nega nega = arr [ i ] elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : negb = arr [ i ] if ( nega * negb > posa * posb ) : print ( "Maxproductpairis{" , nega , "," , negb , "}" ) else : print ( "Maxproductpairis{" , posa , "," , posb , "}" )

static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( "No pairs exists" ) ; return ; } if ( n == 2 ) { System . out . println ( arr [ 0 ] + " " + arr [ 1 ] ) ; return ; } int posa = Integer . MIN_VALUE , posb = Integer . MIN_VALUE ; int nega = Integer . MIN_VALUE , negb = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) { posb = posa ; posa = arr [ i ] ; } else if ( arr [ i ] > posb ) posb = arr [ i ] ; if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( nega ) ) { negb = nega ; nega = arr [ i ] ; } else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( negb ) ) negb = arr [ i ] ; } if ( nega * negb > posa * posb ) System . out . println ( "Max product pair is { " + nega + ", " + negb + "}" ) ; else System . out . println ( "Max product pair is { " + posa + ", " + posb + "}" ) ; }

static void maxProduct ( int arr [ ] , int n ) { if ( arr [ 0 ] > arr [ 1 ] ) { print ( "Maxproductpairis{" , arr [ 0 ] , "," , arr [ 1 ] , "}" ) ; return ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > nega ) { nega = nega nega = arr [ i ] ; if ( arr

static void maxProduct ( int arr [ ] , int n ) { int posa = 0 ; int posb = 0 ; int nega = 0 ; int negb = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) posa = arr [ i ] ; if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) ) nega = arr [ i ] ; else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) ) nega = arr [ i ] ; else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb ) ) negb = arr [ i ] ; else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) ) nega = arr [ i ] ; else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb ) ) negb = arr [ i ] ; else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb ) )

7.82
17.47
34.7
36.32
def evaluate ( n ) : if ( n == 1 or n == 2 ) : print ( "NoPythagoras" + "Tripletexists" ) elif ( n % 2 == 0 ) : var = n * n / 4 print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var - 1 ) , "" , int ( var + 1 ) ) elif ( n % 2 != 0 ) : var = n * n + 1 print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , int ( var / 2 ) )

static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( "No Pythagoras " + "Triplet exists" ) ; else if ( n % 2 == 0 ) { int var = 1 * n * n / 4 ; System . out . print ( "Pythagoras Triplets " + "exist i.e. " ) ; System . out . print ( n + " " ) ; System . out . print ( var - 1 + " " ) ; System . out . println ( var + 1 + " " ) ; } else if ( n % 2 != 0 ) { int var = 1 * n * n + 1 ; System . out . print ( "Pythagoras Triplets " + "exist i.e. " ) ; System . out . print ( n + " " ) ; System . out . print ( var / 2 - 1 + " " ) ; System . out . println ( var / 2 + " " ) ; } }

static void evaluate ( int n ) { if ( n == 0 ) { print ( "PythagorasTriplets" + "existi.e." ) print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , int ( var / 2 + 1 ) ) ; } else { print ( "NoPythagorasTriplets" + "existi.e." ) print ( int ( n ) , "" , int (

static void evaluate ( int n ) { int var ; if ( n == 1 || n == 2 ) { var = n * n / 4 ; print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var - 1 ) , "" , int ( var + 1 ) ) ; } else if ( n % 2 != 0 ) { var = n * n + 1 ; print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , int ( var / 2 ) ) ; } else if ( n % 2 != 0 ) { var = n * n + 1 ; print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , int ( var / 2 ) ) ; } }

7.93
19.34
5.95
14.55
def findSum ( A , B , n ) : Hash = defaultdict ( lambda : 0 ) for i in range ( 0 , n ) : Hash [ A [ i ] ] += 1 Hash [ B [ i ] ] += 1 Sum = 0 for x in Hash : if Hash [ x ] == 1 : Sum += x return Sum

static int findSum ( int [ ] A , int [ ] B , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . containsKey ( A [ i ] ) ) hash . put ( A [ i ] , 1 + hash . get ( A [ i ] ) ) ; else hash . put ( A [ i ] , 1 ) ; if ( hash . containsKey ( B [ i ] ) ) hash . put ( B [ i ] , 1 + hash . get ( B [ i ] ) ) ; else hash . put ( B [ i ] , 1 ) ; } int sum = 0 ; for ( Map . Entry entry : hash . entrySet ( ) ) { if ( Integer . parseInt ( ( entry . getValue ( ) ) . toString ( ) ) == 1 ) sum += Integer . parseInt ( ( entry . getKey ( ) ) . toString ( ) ) ; } return sum ; }

static int findSum ( int [ ] A , int [ ] B , int n ) { int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Hash [ A [ i ] ] == 1 ) { Sum += i ; } } return - 1 ; } return 0 ; }

static int findSum ( int A , int B , int n ) { int Hash [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { Hash [ A [ i ] ] += 1 ; Hash [ B [ i ] ] += 1 ; } return Sum ; }

8.11
22.18
45.99
44.01
def printTreeEdges ( prufer , m ) : vertices = m + 2 vertex_set = [ 0 ] * vertices for i in range ( vertices - 2 ) : vertex_set [ prufer [ i ] - 1 ] += 1 print ( "TheedgesetE(G)is:" ) j = 0 for i in range ( vertices - 2 ) : for j in range ( vertices ) : if ( vertex_set [ j ] == 0 ) : vertex_set [ j ] = - 1 print ( "(" , ( j + 1 ) , "," , prufer [ i ] , ")" , sep = "" , end = "" ) vertex_set [ prufer [ i ] - 1 ] -= 1 break j = 0 for i in range ( vertices ) : if ( vertex_set [ i ] == 0 and j == 0 ) : print ( "(" , ( i + 1 ) , "," , sep = "" , end = "" ) j += 1 elif ( vertex_set [ i ] == 0 and j == 1 ) : print ( ( i + 1 ) , ")" )

static void printTreeEdges ( int prufer [ ] , int m ) { int vertices = m + 2 ; int vertex_set [ ] = new int [ vertices ] ; for ( int i = 0 ; i < vertices ; i ++ ) vertex_set [ i ] = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ; System . out . print ( "\nThe edge set E(G) is :\n" ) ; int j = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) { vertex_set [ j ] = - 1 ; System . out . print ( "(" + ( j + 1 ) + ", " + prufer [ i ] + ") " ) ; vertex_set [ prufer [ i ] - 1 ] -- ; break ; } } } j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) { System . out . print ( "(" + ( i + 1 ) + ", " ) ; j ++ ; } else if ( vertex_set [ i ] == 0 && j == 1 ) System . out . print ( ( i + 1 ) + ")\n" ) ; } }

static void printTreeEdges ( int [ ] prufer , int m ) { int [ ] vertex_set = new int [ vertices ] ; for ( int i = 0 ; i < vertices ; i ++ ) { for ( int j = 0 ; j < vertices ; j ++ ) if ( vertex_set [ j ] == 0 ) { print ( "(" , ( i + 1 ) , "," , prufer [ i ] , ")" , sep = "" , end =

static void printTreeEdges ( int prufer , int m ) { int vertices = prufer . length ; for ( int i = 0 ; i < vertices ; i ++ ) { for ( int j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) vertex_set [ j ] = - 1 ; print ( "(" , ( j + 1 ) , "," , prufer [ i ] , ")" , sep = "" , end = "" ) ; } } j = 0 for ( int i = 0 ; i < vertices ; i ++ ) { for ( int j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) vertex_set [ j ] = - 1 ; print ( "(" , ( j + 1 ) , "," , prufer [ i ] , ")" , sep = "" , end = "" ) ; } } j = 0 for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 ) vertex_set [ j ] = - 1 ; print ( "(" , ( j + 1 ) , "," , prufer [ i ] , ")" , sep

8.33
13.07
18.36
24.89
def strToBinary ( s ) : bin_conv = [ ] for c in s : ascii_val = ord ( c ) binary_val = bin ( ascii_val ) bin_conv . append ( binary_val [ 2 : ] ) return ( '' . join ( bin_conv ) )

static void strToBinary ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = Integer . valueOf ( s . charAt ( i ) ) ; String bin = "" ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; System . out . print ( bin + " " ) ; } }

static String strToBinary ( String s ) { int bin_conv = [ ] ; for ( char c in s ) { int binary_val = bin ( ascii_val ) ; binary_conv . append ( binary_val [ 2 : ] ) ; } return ( s ) ; }

public static String strToBinary ( String s ) { int bin_conv [ ] = new int [ 2 ] ; for ( int c = 0 ; c < s . length ; c ++ ) { int ascii_val = ord ( s [ c ] ) ; int binary_val = bin ( ascii_val ) ; bin_conv . append ( binary_val [ 2 : ] ) ; return ( '' . join ( bin_conv ) ) ; } }

8.4
33.17
59.8
60.74
def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : print ( "Pointinsidetheviewingpane:" ) for i in range ( n ) : if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) : if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) : print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" ) print ( "\n\nPointoutsidetheviewingpane:" ) for i in range ( n ) : if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) : print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" ) if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) ) : print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" )

static void pointClip ( int XY [ ] [ ] , int n , int Xmin , int Ymin , int Xmax , int Ymax ) { System . out . printf ( "Point inside the viewing pane:\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) { if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } } System . out . printf ( "\nPoint outside the viewing pane:\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } }

static void pointClip ( int [ ] XY , int n , int Xmin , int Ymin , int Ymax ) { System . out . print ( "Pointinsidetheviewingpane : " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) System . out . print ( "[" , XY [

static void pointClip ( int XY [ ] [ ] , int Xmin , int Ymin , int Xmax , int Ymax ) { System . out . print ( "Pointinsidetheviewingpane:" ) for i in range ( n ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) { if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) { print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" ) ; } } else if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) { print ( "[" , XY [ i ] [ 0 ] , "," , XY [ i ] [ 1 ] , "]" , sep = "" , end = "" ) ; } } } }

8.5
69.2
95.92
97.46
def nthTerm ( n ) : return ( n * n ) + ( n * n * n )

public static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }

static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) + ( n * n * n ) + ( n * n * n ) + ( n * n * n * n ) + ( n * n * n ) + ( n * n * n ) + ( n * n * n ) + ( n * n * n ) + ( n * n * n ) + ( n * n * n ) + ( n * n * n * n ) + ( n * n * n ) + n * n * n * n ) + n * n * n ) + n * n * n * n * n ) + n * n * n * n * n ) * n * n * n * n ) * n * n * n * n ) * n * n * n ) * n * n * n * n * n * n * n * n ) * n * n * n ) * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n

static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }

8.72
23.39
39.39
32.48
def numoffbt ( arr , n ) : maxvalue = - 2147483647 minvalue = 2147483647 for i in range ( n ) : maxvalue = max ( maxvalue , arr [ i ] ) minvalue = min ( minvalue , arr [ i ] ) mark = [ 0 for i in range ( maxvalue + 2 ) ] value = [ 0 for i in range ( maxvalue + 2 ) ] for i in range ( n ) : mark [ arr [ i ] ] = 1 value [ arr [ i ] ] = 1 ans = 0 for i in range ( minvalue , maxvalue + 1 ) : if ( mark [ i ] != 0 ) : j = i + i while ( j <= maxvalue and j // i <= i ) : if ( mark [ j ] == 0 ) : continue value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) if ( i != j // i ) : value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) j += i ans += value [ i ] return ans

static int numoffbt ( int arr [ ] , int n ) { int maxvalue = - 2147483647 ; int minvalue = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { maxvalue = Math . max ( maxvalue , arr [ i ] ) ; minvalue = Math . min ( minvalue , arr [ i ] ) ; } int mark [ ] = new int [ maxvalue + 2 ] ; int value [ ] = new int [ maxvalue + 2 ] ; Arrays . fill ( mark , 0 ) ; Arrays . fill ( value , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ arr [ i ] ] = 1 ; value [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = minvalue ; i <= maxvalue ; i ++ ) { if ( mark [ i ] != 0 ) { for ( int j = i + i ; j <= maxvalue && j / i <= i ; j += i ) { if ( mark [ j ] == 0 ) continue ; value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; } } ans += value [ i ] ; } return ans ; }

static int numoffbt ( int arr [ ] , int n ) { int maxvalue = - 2147483647 ; int minvalue = 2147483647 ; int minvalue = 2147483647 ; for ( int i = 0 ; i <= n ; i ++ ) { int mark [ ] = 0 ; value [ arr [ i ] ] = 0 ; for ( int i = 0 ; i <= maxvalue ; i ++ ) { if ( mark [ i ] == 0 ) {

static int numoffbt ( int arr [ ] , int n ) { int maxvalue = - 2147483647 ; int minvalue = 2147483647 ; int maxvalue = 2147483647 ; int minvalue = 2147483647 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + i while ( j <= maxvalue && j // i <= i ) { if ( mark [ j ] == 0 ) continue value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) ; if ( i != j // i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) ; if ( i != j // i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) ; } } return ans ; }

9.02
19.79
30.01
30.2
def nthPalindrome ( n , k ) : if ( k & 1 ) : temp = k // 2 else : temp = k // 2 - 1 palindrome = 10 ** temp palindrome = palindrome + n - 1 print ( palindrome , end = "" ) if ( k & 1 ) : palindrome = palindrome // 10 while ( palindrome ) : print ( palindrome % 10 , end = "" ) palindrome = palindrome // 10

static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( "" ) ; }

static int nthPalindrome ( int n , int k ) { int palindrome ; if ( k & 2 ) { palindrome = palindrome + n - 1 ; } else { palindrome = palindrome + n - 1 ; } return palindrome ; }

static void nthPalindrome ( int n , int k ) { int temp = k ; int palindrome = 10 ** temp ; palindrome = palindrome + n - 1 ; print ( palindrome , end = "" ) ; if ( k & 1 ) palindrome = palindrome // 10 while ( palindrome ) { palindrome = palindrome % 10 ; print ( palindrome % 10 , end = "" ) ; palindrome = palindrome // 10 ; } }

9.06
19.65
22.02
27.66
def findSum ( str1 , str2 ) : if len ( str1 ) > len ( str2 ) : temp = str1 str1 = str2 str2 = temp str3 = "" n1 = len ( str1 ) n2 = len ( str2 ) diff = n2 - n1 carry = 0 for i in range ( n1 - 1 , - 1 , - 1 ) : sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 if ( carry ) : str3 + str ( carry + '0' ) str3 = str3 [ : : - 1 ] return str3

static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = "" ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; }

static String findSum ( String str1 , String str2 ) { String temp = str1 ; String str2 = str2 ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( int ( str1 [ i ] ) - ord ( '0' ) ) + int ( str2 [ i +

static String findSum ( String str1 , String str2 ) { String str3 = "" ; int n1 = len ( str1 ) ; int n2 = len ( str2 ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) ; str3 = str3 + str ( sum % 10 ) ; carry = sum // 10 if ( ( carry ) ) str3 = str3 + str ( carry + '0' ) ; str3 = str3 [ : : - 1 ] ; } return str3 ; }

9.09
19.53
25.62
25.54
def findSubString ( str ) : n = len ( str ) dist_count = len ( set ( [ x for x in str ] ) ) count , start , start_index , min_len = 0 , 0 , - 1 , 9999999999 curr_count = defaultdict ( lambda : 0 ) for j in range ( n ) : curr_count [ str [ j ] ] += 1 if curr_count [ str [ j ] ] == 1 : count += 1 if count == dist_count : while curr_count [ str [ start ] ] > 1 : if curr_count [ str [ start ] ] > 1 : curr_count [ str [ start ] ] -= 1 start += 1 len_window = j - start + 1 if min_len > len_window : min_len = len_window start_index = start return str [ start_index : start_index + min_len ]

static String findSubString ( String str ) { int n = str . length ( ) ; int dist_count = 0 ; boolean [ ] visited = new boolean [ MAX_CHARS ] ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str . charAt ( i ) ] == false ) { visited [ str . charAt ( i ) ] = true ; dist_count ++ ; } } int start = 0 , start_index = - 1 ; int min_len = Integer . MAX_VALUE ; int count = 0 ; int [ ] curr_count = new int [ MAX_CHARS ] ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str . charAt ( j ) ] ++ ; if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str . charAt ( start ) ] > 1 ) { if ( curr_count [ str . charAt ( start ) ] > 1 ) curr_count [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } return str . substring ( start_index , start_index + min_len ) ; }

static String findSubString ( String str , int min_len ) { int count = 0 ; int start = 0 ; int start_index = 0 ; int len_window = str . length ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr_count [ str [ j ] ] > 1 ) start ++ ; if ( curr_count [ str [ j ] ] > 1 ) start ++ ; if ( curr_count [

static int findSubString ( String str , int n ) { int count = 0 , start = 0 , start_index = 0 , min_len = 0 , - 1 , 9999999999 ; curr_count = defaultdict ( lambda : 0 ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr_count [ str [ j ] ] > 1 ) { if ( curr_count [ str [ j ] ] > 1 ) { if ( curr_count [ str [ j ] ] > 1 ) { if ( curr_count [ str [ j ] ] > 1 ) { if ( curr_count [ str [ j ] ] > 1 ) { if ( curr_count [ str [ j ] ] > 1 ) { if ( curr_count [ str [ j ] ] > 1 ) { if ( curr_count [ str [ j ] ] > 1 ) { curr_count [ str [ j ] ] -- ; } } } } } } } } return str [ start_index : start_index + min_len ] ; }

9.23
25.5
46.89
43.18
def longestRepeatedSubSeq ( str ) : n = len ( str ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) res = '' i = n j = n while ( i > 0 and j > 0 ) : if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : res += str [ i - 1 ] i -= 1 j -= 1 elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : i -= 1 else : j -= 1 res = '' . join ( reversed ( res ) ) return res

static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = "" ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } String reverse = "" ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) { reverse = reverse + res . charAt ( k ) ; } return reverse ; }

static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int [ ] dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] + 1 ) res += str [ i - 1 ] ; } } return res ; }

static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n ] ; int i = 0 ; int j = 0 ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res += str [ i - 1 ] ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res += str [ i - 1 ] ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res += str [ i - 1 ] ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] + 1 ) { res += str [ i - 1 ] ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] + 1 ) { res += str [ i - 1 ] ; i --

9.29
24.1
63.26
58.09
def CountPS ( str , n ) : dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] P = [ [ False for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : P [ i ] [ i ] = True for i in range ( n - 1 ) : if ( str [ i ] == str [ i + 1 ] ) : P [ i ] [ i + 1 ] = True dp [ i ] [ i + 1 ] = 1 for gap in range ( 2 , n ) : for i in range ( n - gap ) : j = gap + i ; if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : P [ i ] [ j ] = True if ( P [ i ] [ j ] == True ) : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) else : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) return dp [ 0 ] [ n - 1 ]

static int CountPS ( char str [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; boolean P [ ] [ ] = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }

static int CountPS ( String str , int n ) { int [ ] dp = new int [ n ] [ n ] ; int [ ] P [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ j ] ) P [ i ] [ j ] = true ; else dp [ i ] [ j ] = ( dp [ i ] [ j -

static int CountPS ( String str , int n ) { int dp [ ] [ ] = new int [ n ] ; int [ ] P [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) { P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) { P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) ; } else { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) ; } } } } } return dp [ 0 ] [ n - 1 ] ; }

9.43
21.78
34.71
34.33
def binaryMedian ( m , r , d ) : mi = m [ 0 ] [ 0 ] mx = 0 for i in range ( r ) : if m [ i ] [ 0 ] < mi : mi = m [ i ] [ 0 ] if m [ i ] [ d - 1 ] > mx : mx = m [ i ] [ d - 1 ] desired = ( r * d + 1 ) // 2 while ( mi < mx ) : mid = mi + ( mx - mi ) // 2 place = [ 0 ] for i in range ( r ) : j = upper_bound ( m [ i ] , mid ) place [ 0 ] = place [ 0 ] + j if place [ 0 ] < desired : mi = mid + 1 else : mx = mid print ( "Medianis" , mi ) return

static int binaryMedian ( int m [ ] [ ] , int r , int c ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ; } int desired = ( r * c + 1 ) / 2 ; while ( min < max ) { int mid = min + ( max - min ) / 2 ; int place = 0 ; int get = 0 ; for ( int i = 0 ; i < r ; ++ i ) { get = Arrays . binarySearch ( m [ i ] , mid ) ; if ( get < 0 ) get = Math . abs ( get ) - 1 ; else { while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ; } place = place + get ; } if ( place < desired ) min = mid + 1 ; else max = mid ; } return min ; }

static int binaryMedian ( int [ ] m , int r , int d ) { int mi = 0 ; int mx = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j = lower_bound ( m [ i ] , mi ) ; place [ 0 ] = j ; if ( place [ 0 ] > desired ) mi = mid + 1 ; else mx = mid ; } return mi ; } }

int binaryMedian ( int [ ] m , int r , int d ) { int mi = m [ 0 ] [ 0 ] ; int mx = 0 ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ d - 1 ] < mi ) mi = m [ i ] [ d - 1 ] ; if ( m [ i ] [ d - 1 ] > mx ) mx = m [ i ] [ d - 1 ] ; if ( m [ i ] [ d - 1 ] [ d - 1 ] > mx ) mx = m [ i ] [ d - 1 ] ; desired = ( r * d + 1 ) // 2 while ( mi < mx ) { mid = mi + ( mx - mi ) // 2 place [ 0 ] = place [ 0 ] + j if ( place [ 0 ] < desired ) mi = mid + 1 else : mx = mid ; } } return mi ; }

9.6
15.85
4.89
18.05
def printNumbers ( numbers ) : numbers = map ( str , numbers ) result = [ ] for num in numbers : if ( '1' in num and '2' in num and '3' in num ) : result . append ( num ) if not result : result = [ '-1' ] return sorted ( result ) ;

private static String printNumbers ( int [ ] numbers ) { ArrayList < Integer > array = new ArrayList < > ( ) ; for ( int number : numbers ) { if ( findContainsOneTwoThree ( number ) ) array . add ( number ) ; } Collections . sort ( array ) ; StringBuffer strbuf = new StringBuffer ( ) ; Iterator it = array . iterator ( ) ; while ( it . hasNext ( ) ) { int value = ( int ) it . next ( ) ; if ( strbuf . length ( ) > 0 ) strbuf . append ( ", " ) ; strbuf . append ( Integer . toString ( value ) ) ; } return ( strbuf . length ( ) > 0 ) ? strbuf . toString ( ) : "-1" ; }

static String printNumbers ( List < String > numbers ) { String result = [ ] ; for ( String num in numbers ) { if ( '1' in num and '2' in num ) result . append ( num ) ; if ( '3' in num ) result . append ( num ) ; if ( '4' in num ) result . append ( num ) ; if ( '5' in num ) result . append ( num ) ; if ( '6' in

static int printNumbers ( List < String > numbers ) { List < String > result = new ArrayList < String > ( ) ; for ( String num : numbers ) { result . add ( num ) ; } return sorted ( result ) ; }

9.61
18.71
26.85
29.57
def countDistictSubarray ( arr , n ) : vis = dict ( ) for i in range ( n ) : vis [ arr [ i ] ] = 1 k = len ( vis ) vid = dict ( ) ans = 0 right = 0 window = 0 for left in range ( n ) : while ( right < n and window < k ) : if arr [ right ] in vid . keys ( ) : vid [ arr [ right ] ] += 1 else : vid [ arr [ right ] ] = 1 if ( vid [ arr [ right ] ] == 1 ) : window += 1 right += 1 if ( window == k ) : ans += ( n - right + 1 ) vid [ arr [ left ] ] -= 1 if ( vid [ arr [ left ] ] == 0 ) : window -= 1 return ans

static int countDistictSubarray ( int arr [ ] , int n ) { HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) { @ Override public Integer get ( Object key ) { if ( ! containsKey ( key ) ) return 0 ; return super . get ( key ) ; } }; for ( int i = 0 ; i < n ; ++ i ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) ; if ( vis . get ( arr [ right ] ) == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) ; if ( vis . get ( arr [ left ] ) == 0 ) -- window ; } return ans ; }

static int countDistictSubarray ( int [ ] arr , int n ) { int k = len ( vis ) ; int ans = 0 ; int right = 0 ; int window = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in vid . keys ( ) ) { vid [ arr [ i ] ] += 1 ; else { vid [ arr [ i ] ] = 1 ; } } } return ans ; }

static int countDistictSubarray ( int arr [ ] , int n ) { int vis [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in vis . keys ( ) ) { if ( arr [ i ] in vid . keys ( ) ) { if ( arr [ i ] in vid . keys ( ) ) { vid [ arr [ i ] ] += 1 ; } else { vid [ arr [ i ] ] = 1 ; } } } if ( arr [ i ] in vid . keys ( ) ) { vid [ arr [ i ] ] += 1 ; } else { vid [ arr [ i ] ] = 1 ; } } if ( window == k ) { ans += ( n - right + 1 ) ; vid [ arr [ left ] ] -= 1 ; if ( vid [ arr [ left ] ] == 0 ) { window -- ; } } } return ans ; }

9.64
25.52
35.26
39.47
def interLeaveQueue ( q ) : if ( q . qsize ( ) % 2 != 0 ) : print ( "Inputevennumberofintegers." ) s = [ ] halfSize = int ( q . qsize ( ) / 2 ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) for i in range ( halfSize ) : q . put ( q . queue [ 0 ] ) q . get ( ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) q . put ( q . queue [ 0 ] ) q . get ( )

static void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( "Input even number of integers." ) ; Stack < Integer > s = new Stack < > ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } }

static void interLeaveQueue ( Queue q ) { int halfSize = 0 ; while ( q . qsize ( ) % 2 != 0 ) s . append ( q . queue [ 0 ] ) q . get ( ) ; for ( int i = 0 ; i < halfSize ; i ++ ) { if ( len ( s ) != 0 ) q . put ( s [ - 1 ] ) q . get ( ) ; while ( len ( s ) != 0 ) q .

static void interLeaveQueue ( Queue < ? > q ) { for ( int i = 0 ; i < q . qsize ( ) ; i ++ ) { q . put ( q . queue [ 0 ] ) ; q . get ( ) ; } for ( int i = 0 ; i < q . qsize ( ) ; i ++ ) { q . put ( q . queue [ 0 ] ) ; q . get ( ) ; } for ( int i = 0 ; i < q . qsize ( ) ; i ++ ) { q . put ( q . queue [ 0 ] ) ; } for ( int i = 0 ; i < q . qsize ( ) ; i ++ ) { q . put ( q . queue [ i ] ) ; } for ( int i = 0 ; i < q . qsize ( ) ; i ++ ) { q . put ( q . queue [ i ] ) ; } for ( int i = 0 ; i < q . qsize ( ) ; i ++ ) { q . put ( q . queue [ i ] ) ; } }

9.69
15.3
14.88
21.31
def printDuplicates ( arr ) : dict = { } for ele in arr : try : dict [ ele ] += 1 except : dict [ ele ] = 1 for item in dict : if ( dict [ item ] > 1 ) : print ( item , end = "" ) print ( "\n" )

private static void printDuplicates ( int [ ] arr , int n ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int count = 0 ; boolean dup = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , count + 1 ) ; } else { map . put ( arr [ i ] , 1 ) ; } } for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { System . out . print ( entry . getKey ( ) + " " ) ; dup = true ; } } if ( ! dup ) { System . out . println ( "-1" ) ; } }

static void printDuplicates ( int arr [ ] ) { int dict [ int ] = 0 ; for ( int item in arr ) { if ( dict [ item ] > 1 ) { print ( item , end = "" ) print ( "\n" ) ; } else { if ( dict [ item ] == 1 ) { print ( item , end = "" ) print ( "\n" ) } else { print ( item , end = "" ) print ( "\n" ) } } }

static void printDuplicates ( int arr [ ] ) { int [ ] dict = new int [ arr . size ( ) ] ; for ( int ele = 0 ; ele < arr . size ( ) ; ele ++ ) { try { dict [ ele ] ++ ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } for ( int item = 0 ; item < arr . size ( ) ; item ++ ) { if ( dict [ item ] > 1 ) { print ( item , end = "" ) ; } } }

9.74
22.5
41.75
40.69
def minPalPartion ( str1 ) : n = len ( str1 ) C = [ 0 ] * ( n + 1 ) P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n ) : P [ i ] [ i ] = True for L in range ( 2 , n + 1 ) : for i in range ( n - L + 1 ) : j = i + L - 1 if ( L == 2 ) : P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) else : P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) for i in range ( n ) : if ( P [ 0 ] [ i ] == True ) : C [ i ] = 0 else : C [ i ] = sys . maxsize for j in range ( i ) : if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) : C [ i ] = 1 + C [ j ] return C [ n - 1 ]

static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; } } for ( i = 0 ; i < n ; i ++ ) { if ( P [ 0 ] [ i ] == true ) C [ i ] = 0 ; else { C [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ] ; } } } return C [ n - 1 ] ; }

static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( P [ i ] [ i ] == true ) C [ i ] = 1 ; else C [ i ] = sys . maxsize ; for ( int j = i + 1 ; j <= n ; j ++ ) { if (

static int minPalPartion ( String str1 ) { int n = str1 . length ( ) ; int C [ ] = [ 0 ] * ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( P [ i ] [ j ] == true ) { C [ i ] = 0 ; } else { C [ i ] = 1 ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( P [ i ] [ i ] == true ) { C [ i ] = 0 ; } else { C [ i ] = sys . maxsize ; } for ( int j = i + 1 ; j < n ; j ++ ) { if ( P [ i ] [ j ] == true ) { C [ i ] = 0 ; } else { C [ i ] = 1 + C [ j ] ; } } } } return C [ n - 1 ] ; }

9.74
20.27
18.76
25.57
def mergeIntervals ( arr ) : arr . sort ( key = lambda x : x [ 0 ] ) m = [ ] s = - 10000 max = - 100000 for i in range ( len ( arr ) ) : a = arr [ i ] if a [ 0 ] > max : if i != 0 : m . append ( [ s , max ] ) max = a [ 1 ] s = a [ 0 ] else : if a [ 1 ] >= max : max = a [ 1 ] if max != - 100000 and [ s , max ] not in m : m . append ( [ s , max ] ) print ( "TheMergedIntervalsare:" , end = "" ) for i in range ( len ( m ) ) : print ( m [ i ] , end = "" )

public static void mergeIntervals ( Interval arr [ ] ) { Arrays . sort ( arr , new Comparator < Interval > ( ) { public int compare ( Interval i1 , Interval i2 ) { return i2 . start - i1 . start ; } } ) ; int index = 0 ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ index ] . end >= arr [ i ] . start ) { arr [ index ] . end = Math . max ( arr [ index ] . end , arr [ i ] . end ) ; arr [ index ] . start = Math . min ( arr [ index ] . start , arr [ i ] . start ) ; } else { arr [ index ] = arr [ i ] ; index ++ ; } } System . out . print ( "The Merged Intervals are: " ) ; for ( int i = 0 ; i <= index ; i ++ ) { System . out . print ( "[" + arr [ i ] . start + "," + arr [ i ] . end + "]" ) ; } }

static void mergeIntervals ( int [ ] arr ) { int m . length = 0 ; int s = - 10000 ; int max = - 100000 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( s != - 10000 ) m . append ( [ s , max ] ) ; s = a [ 1 ] ; } } if ( max != - 100000 ) m . append ( [ s , max ] ) ; else m . append ( [

static void mergeIntervals ( int arr [ ] ) { int [ ] m = new int [ arr . length ] ; int s = - 10000 ; int max = - 100000 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int a = arr [ i ] ; if ( a [ 0 ] > max ) { if ( i != 0 ) m . append ( [ s , max ] ) ; max = a [ 1 ] s = a [ 0 ] ; } else if ( a [ 1 ] >= max ) max = a [ 1 ] ; else if ( a [ 1 ] >= max ) max = a [ 1 ] ; if ( max != - 100000 && [ s , max ] not in m ) m . append ( [ s , max ] ) ; } }

9.75
15.62
32.93
25.63
def smallestSubsegment ( a , n ) : left = dict ( ) count = dict ( ) mx = 0 mn , strindex = 0 , 0 for i in range ( n ) : x = a [ i ] if ( x not in count . keys ( ) ) : left [ x ] = i count [ x ] = 1 else : count [ x ] += 1 if ( count [ x ] > mx ) : mx = count [ x ] mn = i - left [ x ] + 1 strindex = left [ x ] elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) : mn = i - left [ x ] + 1 strindex = left [ x ] for i in range ( strindex , strindex + mn ) : print ( a [ i ] , end = "" )

static void smallestSubsegment ( int a [ ] , int n ) { HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; int mx = 0 ; int mn = - 1 , strindex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count . get ( x ) == null ) { left . put ( x , i ) ; count . put ( x , 1 ) ; } else count . put ( x , count . get ( x ) + 1 ) ; if ( count . get ( x ) > mx ) { mx = count . get ( x ) ; mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) { mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

static void smallestSubsegment ( int [ ] a , int n ) { int mx = 0 , mn = 0 , strindex = 0 ; int count [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count [ x ] < mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } }

static void smallestSubsegment ( int [ ] a , int n ) { int mx = 0 , mn = 0 , strindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x not in count . keys ( ) ) { left [ x ] = i ; count [ x ] = 1 ; } else { count [ x ] = 0 ; } if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x not in count . keys ( ) ) { left [ x ] = i ; count [ x ] = 1 ; } else { count [ x ] = 1 ; } if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } } return ; }

9.75
18.42
39.92
42.26
def getNthUglyNo ( n ) : ugly = [ 0 ] * n ugly [ 0 ] = 1 i2 = i3 = i5 = 0 next_multiple_of_2 = 2 next_multiple_of_3 = 3 next_multiple_of_5 = 5 for l in range ( 1 , n ) : ugly [ l ] = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) if ugly [ l ] == next_multiple_of_2 : i2 += 1 next_multiple_of_2 = ugly [ i2 ] * 2 if ugly [ l ] == next_multiple_of_3 : i3 += 1 next_multiple_of_3 = ugly [ i3 ] * 3 if ugly [ l ] == next_multiple_of_5 : i5 += 1 next_multiple_of_5 = ugly [ i5 ] * 5 return ugly [ - 1 ]

int getNthUglyNo ( int n ) { int ugly [ ] = new int [ n ] ; int i2 = 0 , i3 = 0 , i5 = 0 ; int next_multiple_of_2 = 2 ; int next_multiple_of_3 = 3 ; int next_multiple_of_5 = 5 ; int next_ugly_no = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { next_ugly_no = Math . min ( next_multiple_of_2 , Math . min ( next_multiple_of_3 , next_multiple_of_5 ) ) ; ugly [ i ] = next_ugly_no ; if ( next_ugly_no == next_multiple_of_2 ) { i2 = i2 + 1 ; next_multiple_of_2 = ugly [ i2 ] * 2 ; } if ( next_ugly_no == next_multiple_of_3 ) { i3 = i3 + 1 ; next_multiple_of_3 = ugly [ i3 ] * 3 ; } if ( next_ugly_no == next_multiple_of_5 ) { i5 = i5 + 1 ; next_multiple_of_5 = ugly [ i5 ] * 5 ; } } return next_ugly_no ; }

static int getNthUglyNo ( int n ) { int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; int l = 0 ; for ( int l = 1 ; l <= n ; l ++ ) { ugly [ l ] = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) ; if ( ugly [ l ] == next_

static int getNthUglyNo ( int n ) { int i2 = 1 ; int i3 = 0 ; int i5 = 0 ; int next_multiple_of_2 = 2 ; int next_multiple_of_3 = 3 ; int next_multiple_of_5 = 5 ; for ( int l = 1 ; l < n ; l ++ ) { ugly [ l ] = min ( ugly [ l ] , next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) ; if ( ugly [ l ] == next_multiple_of_2 ) i2 += 1 ; next_multiple_of_2 = ugly [ i2 ] * 2 ; if ( ugly [ l ] == next_multiple_of_3 ) i3 += 1 ; next_multiple_of_3 = ugly [ i3 ] * 3 ; if ( ugly [ l ] == next_multiple_of_5 ) i5 += 1 ; } return ugly [ - 1 ] ; }

9.76
24.52
38.89
44.65
def counterClockspiralPrint ( m , n , arr ) : k = 0 l = 0 cnt = 0 total = m * n while ( k < m and l < n ) : if ( cnt == total ) : break for i in range ( k , m ) : print ( arr [ i ] [ l ] , end = "" ) cnt += 1 l += 1 if ( cnt == total ) : break for i in range ( l , n ) : print ( arr [ m - 1 ] [ i ] , end = "" ) cnt += 1 m -= 1 if ( cnt == total ) : break if ( k < m ) : for i in range ( m - 1 , k - 1 , - 1 ) : print ( arr [ i ] [ n - 1 ] , end = "" ) cnt += 1 n -= 1 if ( cnt == total ) : break if ( l < n ) : for i in range ( n - 1 , l - 1 , - 1 ) : print ( arr [ k ] [ i ] , end = "" ) cnt += 1 k += 1

static void counterClockspiralPrint ( int m , int n , int arr [ ] [ ] ) { int i , k = 0 , l = 0 ; int cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) break ; for ( i = k ; i < m ; ++ i ) { System . out . print ( arr [ i ] [ l ] + " " ) ; cnt ++ ; } l ++ ; if ( cnt == total ) break ; for ( i = l ; i < n ; ++ i ) { System . out . print ( arr [ m - 1 ] [ i ] + " " ) ; cnt ++ ; } m -- ; if ( cnt == total ) break ; if ( k < m ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( arr [ i ] [ n - 1 ] + " " ) ; cnt ++ ; } n -- ; } if ( cnt == total ) break ; if ( l < n ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( arr [ k ] [ i ] + " " ) ; cnt ++ ; } k ++ ; } } }

static void counterClockspiralPrint ( int m , int n ) { int cnt = 0 ; int total = m * n ; for ( int k = 0 ; k < m ; k ++ ) { for ( int l = 0 ; l < n ; l ++ ) { if ( cnt == total ) break ; for ( int i = 0 ; i < m ; i ++ ) { if ( cnt == total ) break ; for ( int i = 0 ; i <

static void counterClockspiralPrint ( int m , int n , int arr [ ] ) { int k = 0 ; int l = 0 ; int cnt = 0 ; total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) break for ( i in range ( k , m ) ) { for ( i in range ( l , n ) ) { print ( arr [ i ] [ m - 1 ] , end = "" ) ; cnt += 1 ; } } } if ( k < m ) { for ( i in range ( m - 1 , k - 1 , - 1 ) ) { print ( arr [ i ] [ l ] , end = "" ) ; cnt += 1 ; } } if ( l < n ) { for ( i in range ( n - 1 , l - 1 , - 1 ) ) { print ( arr [ k ] [ l ] , end = "" ) ; cnt += 1 ; } } }

9.79
18.34
36.48
40.49
def reverse ( string ) : if len ( string ) == 0 : return temp = string [ 0 ] reverse ( string [ 1 : ] ) print ( temp , end = '' )

void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }

static void reverse ( String string ) { String temp = string [ 0 ] ; reverse ( string [ 1 : ] ) ; print ( temp , end = '' ) ; }  def reverse ( String string ) { String temp = string [ 0 ] ; reverse ( string [ 1 : ] ) ; return ; }

static void reverse ( String string ) { String temp = string . substring ( 0 , string . length ( ) - 1 ) ; String reverseString = string . substring ( string . length ( ) - 1 ) ; String reverseString = string . substring ( string . length ( ) - 1 ) ; System . out . print ( reverseString ) ; }

9.83
25.08
53.08
45.72
def prefixSum2D ( a ) : global C , R psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] for i in range ( 1 , C ) : psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) for i in range ( 0 , R ) : psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) for i in range ( 1 , R ) : for j in range ( 1 , C ) : psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) for i in range ( 0 , R ) : for j in range ( 0 , C ) : print ( psa [ i ] [ j ] , end = "" ) print ( )

public static void prefixSum2D ( int a [ ] [ ] ) { int R = a . length ; int C = a [ 0 ] . length ; int psa [ ] [ ] = new int [ R ] [ C ] ; psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ; for ( int i = 1 ; i < C ; i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ; for ( int i = 1 ; i < R ; i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( psa [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

static void prefixSum2D ( int [ ] a ) { int [ ] psa = new int [ C ] [ R ] [ ] ; for ( int i = 1 ; i <= R ; i ++ ) { for ( int j = 0 ; j <= C ; j ++ ) { if ( i == 0 ) psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - ps

static void prefixSum2D ( int [ ] a ) { global C , R psa = new int [ C ] [ ] ; for ( int i = 0 ; i < C ; i ++ ) { for ( int j = 0 ; j < R ; j ++ ) { psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) ; for ( int i = 0 ; i < R ; i ++ ) { psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) ; } for ( int i = 0 ; i < R ; i ++ ) { psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) ; } } }

9.83
30.08
76.36
77.73
def surface_area_octahedron ( side ) : return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) )

static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }

static int surface_area_octahedron ( int side ) { int surface_area_octahedron = surface_area_octahedron(int side) ; return surface_area_octahedron ; }

static int surface_area_octahedron ( int side ) { return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) ; }

9.87
18.45
24.61
26.63
def findRandomIndexOfMax ( arr , n ) : mp = dict ( ) for i in range ( n ) : if ( arr [ i ] in mp ) : mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 else : mp [ arr [ i ] ] = 1 max_element = - 323567 max_so_far = - 323567 for p in mp : if ( mp [ p ] > max_so_far ) : max_so_far = mp [ p ] max_element = p r = int ( ( ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) ) i = 0 count = 0 while ( i < n ) : if ( arr [ i ] == max_element ) : count = count + 1 if ( count == r ) : print ( "Elementwithmaximumfrequencypresentatindex" , i ) break i = i + 1

static void findRandomIndexOfMax ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } int max_element = Integer . MIN_VALUE ; int max_so_far = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > p : mp . entrySet ( ) ) { if ( p . getValue ( ) > max_so_far ) { max_so_far = p . getValue ( ) ; max_element = p . getKey ( ) ; } } int r = ( int ) ( ( new Random ( ) . nextInt ( max_so_far ) % max_so_far ) + 1 ) ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) count ++ ; if ( count == r ) { System . out . print ( "Element with maximum frequency present " + "at index " + i + "\n" ) ; break ; } } }

static void findRandomIndexOfMax ( int [ ] arr , int n ) { int [ ] mp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp [ arr [ i ] ] > max_element ) { max_so_far = mp [ arr [ i ] ] + 1 ; } else { mp [ arr [ i ] ] = 1 ; } } for ( int i = 0 ; i < n

int findRandomIndexOfMax ( int arr [ ] , int n ) { int i = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) { count = count + 1 ; if ( count == r ) { print ( "Elementwithmaximumfrequencypresentatindex" , i ) ; break ; } i = i + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) { count = count + 1 ; if ( count == r ) { print ( "Elementwithmaximumfrequencypresentatindex" , i ) break ; } i = i + 1 ; } } return i ; }

9.9
23.1
52.89
50.55
def solve ( A , B , C ) : i = len ( A ) - 1 j = len ( B ) - 1 k = len ( C ) - 1 min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) while i != - 1 and j != - 1 and k != - 1 : current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) if current_diff < min_diff : min_diff = current_diff max_term = max ( A [ i ] , B [ j ] , C [ k ] ) if A [ i ] == max_term : i -= 1 elif B [ j ] == max_term : j -= 1 else : k -= 1 return min_diff

static int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }

static int solve ( int A [ ] , int B [ ] , int C [ ] ) { int i = 0 ; int j = 0 ; int k = 0 ; while ( i != - 1 ) { int current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) ; if ( current_diff < min_diff ) min

static int solve ( int A , int B , int C ) { int i = 0 ; int j = 0 ; int k = 0 ; int min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - max ( A [ i ] , B [ j ] , C [ k ] ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - max ( A [ i ] , B [ j ] , C [ k ] ) ) ; if current_diff < min_diff ) min_diff = current_diff ; max_term = max ( A [ i ] , B [ j ] , C [ k ] ) ; if ( A [ i ] == max_term ) i -= 1 elif B [ j ] == max_term ) j -= 1 else else k -= 1 ; } return min_diff ; }

9.92
18.55
11.93
20.93
def subArraySum ( arr , n , Sum ) : Map = { } curr_sum = 0 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if curr_sum == Sum : print ( "Sumfoundbetweenindexes0to" , i ) return if ( curr_sum - Sum ) in Map : print ( "Sumfoundbetweenindexes" , \ Map [ curr_sum - Sum ] + 1 , "to" , i ) return Map [ curr_sum ] = i print ( "Nosubarraywithgivensumexists" )

public static void subArraySum ( int [ ] arr , int n , int sum ) { int cur_sum = 0 ; int start = 0 ; int end = - 1 ; HashMap < Integer , Integer > hashMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cur_sum = cur_sum + arr [ i ] ; if ( cur_sum - sum == 0 ) { start = 0 ; end = i ; break ; } if ( hashMap . containsKey ( cur_sum - sum ) ) { start = hashMap . get ( cur_sum - sum ) + 1 ; end = i ; break ; } hashMap . put ( cur_sum , i ) ; } if ( end == - 1 ) { System . out . println ( "No subarray with given sum exists" ) ; } else { System . out . println ( "Sum found between indexes " + start + " to " + end ) ; } }

static void subArraySum ( int arr [ ] , int n , int Sum ) { Map [ Sum ] = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( curr_sum - Sum ) in Map : print ( "Sumfoundbetweenindexes" , Sum + 1 , "to" , i ) return ; Map [ curr_sum - Sum ] = i ; } return ; }  static void subArraySum ( int

static void subArraySum ( int arr [ ] , int Sum ) { int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; if ( curr_sum == Sum ) return if ( curr_sum - Sum in Map ) return Map [ curr_sum - Sum ] + 1 ; else Map [ curr_sum - Sum ] = i ; } }

9.94
22.39
39.64
37.0
def findSum ( str1 , str2 ) : if ( len ( str1 ) > len ( str2 ) ) : t = str1 str1 = str2 str2 = t str = "" n1 = len ( str1 ) n2 = len ( str2 ) str1 = str1 [ : : - 1 ] str2 = str2 [ : : - 1 ] carry = 0 for i in range ( n1 ) : sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ) str += chr ( sum % 10 + 48 ) carry = int ( sum / 10 ) for i in range ( n1 , n2 ) : sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry ) str += chr ( sum % 10 + 48 ) carry = ( int ) ( sum / 10 ) if ( carry ) : str += chr ( carry + 48 ) str = str [ : : - 1 ] return str

static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = "" ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ; str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ; return str ; }

static String findSum ( String str1 , String str2 ) { String t = str1 ; String str2 = str2 ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( ord ( str1 [ i ] ) - 48 ) + carry ) ) str += chr ( sum % 10 +

static String findSum ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ) ; str += chr ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; for ( int i = 0 ; i < n2 ; i ++ ) { sum = ( ( ord ( str2 [ i ] ) - 48 ) + ( ( ord ( str1 [ i ] ) - 48 ) + carry ) ) ; str += chr ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; } if ( ( carry ) ) str += chr ( carry + 48 ) ; str = str [ : : - 1 ] ; } return str ; }

10.05
25.43
49.31
37.74
def PerformQueries ( a , vec ) : ans = [ ] n = len ( a ) - 1 q = len ( vec ) for i in range ( q ) : t = vec [ i ] [ 0 ] m = vec [ i ] [ 1 ] if ( m > n ) : ans . append ( - 1 ) continue turn = t // n rem = t % n if ( rem == 0 and turn % 2 == 1 ) : ans . append ( - 1 ) continue if ( rem == 0 and turn % 2 == 0 ) : ans . append ( a [ m ] ) continue if ( turn % 2 == 0 ) : cursize = n - rem if ( cursize < m ) : ans . append ( - 1 ) continue ans . append ( a [ m + rem ] ) else : cursize = rem if ( cursize < m ) : ans . append ( - 1 ) continue ans . append ( a [ m ] ) for i in ans : print ( i )

static void PerformQueries ( int [ ] a , int [ ] [ ] vec ) { Vector < Integer > ans = new Vector < > ( ) ; int n = ( int ) a . length - 1 ; int q = ( int ) vec . length ; for ( int i = 0 ; i < q ; ++ i ) { long t = vec [ i ] [ 0 ] ; int m = vec [ i ] [ 1 ] ; if ( m > n ) { ans . add ( - 1 ) ; continue ; } int turn = ( int ) ( t / n ) ; int rem = ( int ) ( t % n ) ; if ( rem == 0 && turn % 2 == 1 ) { ans . add ( - 1 ) ; continue ; } if ( rem == 0 && turn % 2 == 0 ) { ans . add ( a [ m ] ) ; continue ; } if ( turn % 2 == 0 ) { int cursize = n - rem ; if ( cursize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m + rem ] ) ; } else { int cursize = rem ; if ( cursize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m ] ) ; } } for ( int i : ans ) System . out . print ( i + "\n" ) ; }

static void PerformQueries ( int [ ] [ ] a , int [ ] [ ] vec ) { int i = 0 ; int q = vec . length ; for ( int i = 0 ; i < q ; i ++ ) { int t = a [ i ] [ 0 ] ; int m = a [ i ] [ 1 ] ; int rem = t % n ; if ( rem == 0 ) ans . append ( a [ m ] ) ; else ans . append ( a

static void PerformQueries ( int [ ] a , int [ ] vec ) { int t = vec [ 0 ] [ 0 ] ; int m = vec [ 0 ] [ 1 ] ; if ( m > n ) { ans . append ( - 1 ) ; continue ; } int turn = t // n rem = t % n ; if ( turn % 2 == 1 ) { ans . append ( a [ m ] ) ; } if ( turn % 2 == 0 ) { cursize = n - rem if ( cursize < m ) ans . append ( - 1 ) ; continue ans . append ( a [ m + rem ] ) ; } else if ( turn % 2 == 0 ) { cursize = n - rem if ( cursize < m ) ans . append ( - 1 ) ; continue ans . append ( a [ m + rem ] ) ; } else { cursize = rem if ( cursize < m ) ans . append ( - 1 ) ; continue ans . append ( a [ m + rem ] ) ; } } for ( int i = 0 ; i < ans . length ; i ++ ) PerformQueries ( a [ i ] , vec ) ; }

10.07
26.84
23.19
34.59
def lbs ( arr ) : n = len ( arr ) lis = [ 1 for i in range ( n + 1 ) ] for i in range ( 1 , n ) : for j in range ( 0 , i ) : if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : lis [ i ] = lis [ j ] + 1 lds = [ 1 for i in range ( n + 1 ) ] for i in reversed ( range ( n - 1 ) ) : for j in reversed ( range ( i - 1 , n ) ) : if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : lds [ i ] = lds [ j ] + 1 maximum = lis [ 0 ] + lds [ 0 ] - 1 for i in range ( 1 , n ) : maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) return maximum

static int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }

static int lbs ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) lds [ i ] = l

static int lbs ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n ] ; int lds [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) { lis [ i ] = lis [ j ] + 1 ; lds [ i ] = lds [ j ] + 1 ; } } } return maximum ; }

10.09
18.4
14.59
23.7
def SumNodes ( l ) : leafNodeCount = pow ( 2 , l - 1 ) vec = [ [ ] for i in range ( l ) ] for i in range ( 1 , leafNodeCount + 1 ) : vec [ l - 1 ] . append ( i ) for i in range ( l - 2 , - 1 , - 1 ) : k = 0 while ( k < len ( vec [ i + 1 ] ) - 1 ) : vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) k += 2 Sum = 0 for i in range ( l ) : for j in range ( len ( vec [ i ] ) ) : Sum += vec [ i ] [ j ] return Sum

static int sumNodes ( int l ) { int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ; Vector < Vector < Integer >> vec = new Vector < Vector < Integer >> ( ) ; for ( int i = 1 ; i <= l ; i ++ ) vec . add ( new Vector < Integer > ( ) ) ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec . get ( l - 1 ) . add ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) { vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) + vec . get ( i + 1 ) . get ( k + 1 ) ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec . get ( i ) . size ( ) ; j ++ ) sum += vec . get ( i ) . get ( j ) ; } return sum ; }

static int SumNodes ( int l ) { int vec [ ] = new int [ l ] [ ] ; for ( int i = 1 ; i <= l ; i ++ ) { int k = 0 ; while ( k < len ( vec [ i + 1 ] ) - 1 ) { vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) ; k ++ ; } return 0 ; } }

static int SumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; int vec [ ] = new int [ leafNodeCount + 1 ] ; for ( int i = 1 ; i < l ; i ++ ) { vec [ i ] . append ( i ) ; for ( int j = 0 ; j < leafNodeCount ; j ++ ) { vec [ i ] . append ( vec [ i ] [ j ] + vec [ i ] [ j + 1 ] [ j + 1 ] ) ; } } return SumNodes ( l ) ; }

10.11
22.85
27.41
27.55
def greatest ( s ) : n = len ( s ) a = [ 0 for i in range ( n ) ] Sum = 0 for i in range ( n ) : a [ i ] = ord ( s [ i ] ) - ord ( '0' ) Sum += a [ i ] if ( a [ n - 1 ] % 2 ) : if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) % 3 != 0 ) : print ( "-1" ) else : print ( n ) else : re = Sum % 3 dell = - 1 flag = 0 for i in range ( n - 1 ) : if ( ( a [ i ] ) % 3 == re ) : if ( a [ i + 1 ] > a [ i ] ) : dell = i flag = 1 break else : dell = i if ( flag == 0 ) : if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : dell = n - 1 if ( dell == - 1 ) : print ( "-1" ) else : print ( dell + 1 )

static void greatest ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . charAt ( i ) - '0' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 != 0 ) { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) { System . out . println ( "-1" ) ; } else { System . out . println ( n ) ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) System . out . println ( - 1 ) ; else { System . out . println ( del + 1 ) ; } } }

static int greatest ( String s ) { int n = s . length ( ) ; int Sum = 0 ; int dell = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] ) % 3 == 0 ) { if ( a [ i + 1 ] > a [ i ] ) { dell = i ; flag = 1 ; } else { dell = i ; if (

static void greatest ( String s ) { int n = s . length ( ) ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ord ( s [ i ] ) - ord ( '0' ) ; Sum += a [ i ] ; if ( a [ i ] % 2 != 0 || ( Sum - a [ i ] ) % 3 != 0 ) ) { if ( a [ i ] % 2 != 0 || ( Sum - a [ i ] ) % 3 != 0 ) { if ( a [ i ] % 2 != 0 || ( Sum - a [ i ] ) % 3 != 0 ) { print ( "-1" ) ; } else { print ( dell + 1 ) ; } } } } }

10.12
24.36
36.23
42.86
def worstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : wstIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if wstIdx == - 1 : wstIdx = j elif blockSize [ wstIdx ] < blockSize [ j ] : wstIdx = j if wstIdx != - 1 : allocation [ i ] = wstIdx blockSize [ wstIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )

static void worstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( wstIdx == - 1 ) wstIdx = j ; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j ; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( "Not Allocated" ) ; System . out . println ( ) ; } }

static void worstFit ( int [ ] blockSize , int [ ] processSize , int n ) { int wstIdx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; } }

static void worstFit ( int blockSize , int m , int processSize , int n ) { int [ ] allocation = new int [ n ] * n ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( wstIdx == - 1 ) wstIdx = j ; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j ; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j ; } if ( wstIdx != - 1 ) allocation [ i ] = wstIdx ; } } }

10.15
22.46
62.83
56.06
def findSmallestRange ( arr , n , k ) : i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 for i in range ( k + 1 ) : ptr [ i ] = 0 minrange = 10 ** 9 while ( 1 ) : minind = - 1 minval = 10 ** 9 maxval = - 10 ** 9 flag = 0 for i in range ( k ) : if ( ptr [ i ] == n ) : flag = 1 break if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : minind = i minval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] if ( flag ) : break ptr [ minind ] += 1 if ( ( maxval - minval ) < minrange ) : minel = minval maxel = maxval minrange = maxel - minel print ( "Thesmallestrangeis[" , minel , maxel , "]" )

static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) { minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( "The smallest range is [%d , %d]\n" , minel , maxel ) ; }

static int findSmallestRange ( int [ ] ptr , int n ) { int i = 0 ; int minel = 0 ; int maxel = 0 ; int minrange = 10 ** 9 ; int flag = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; if ( ( maxval - minval ) < min

static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { i = 0 ; minval = 0 ; maxval = 0 ; minrange = 10 ** 9 ; minel = 0 ; maxel = 0 ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) minval = arr [ i ] [ ptr [ i ] ] ; if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) minval = arr [ i ] [ ptr [ i ] ] ; if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) maxval = arr [ i ] [ ptr [ i ] ] ; if ( flag ) { break ; } } if ( ( maxval - minval ) < minrange ) { minel = minval maxel = maxval minrange = maxel - minel ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if

10.17
18.56
37.75
34.63
def cassini ( n ) : return - 1 if ( n & 1 ) else 1

static int cassini ( int n ) { return ( n & 1 ) != 0 ? - 1 : 1 ; }

int cassini ( int n ) {

static int cassini ( int n ) { return - 1 ; }

10.26
24.57
29.4
27.68
def findTriplets ( x ) : fact = [ ] factors = set ( ) for i in range ( 2 , int ( sqrt ( x ) ) ) : if ( x % i == 0 ) : fact . append ( i ) if ( x / i != i ) : fact . append ( x // i ) factors . add ( i ) factors . add ( x // i ) found = False k = len ( fact ) for i in range ( k ) : a = fact [ i ] for j in range ( k ) : b = fact [ j ] if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : print ( a , b , x // ( a * b ) ) found = True break if ( found ) : break if ( not found ) : print ( "-1" )

static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " " + b + " " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . print ( "-1" ) ; }

static void findTriplets ( int x ) { Set < int > factors = new HashSet < int > ( ) ; for ( int i = 2 ; i <= k ; i ++ ) { if ( x % i == 0 ) fact . append ( i ) if ( x / i != i ) fact . append ( i ) if ( x / i != i ) { fact . append ( x / i ) ; if ( x / ( a * b ) != 1 ) {

static void findTriplets ( int x ) { int [ ] fact = new int [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { if ( x % i == 0 ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; if ( x / i != i ) fact . add ( i ) ; } }

10.3
18.41
3.91
14.86
def countPaths ( n , m ) : if ( n == 0 or m == 0 ) : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )

static int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }

static int countPaths ( int n , int m ) { int countPaths ( int n , int m ) { int countPaths ( int n , int m ) ; return ( countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths

static int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }

10.31
27.59
43.03
38.63
def minSum ( arr , n ) : dp = [ 0 ] * n if ( n == 1 ) : return arr [ 0 ] if ( n == 2 ) : return min ( arr [ 0 ] , arr [ 1 ] ) if ( n == 3 ) : return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) if ( n == 4 ) : return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) dp [ 0 ] = arr [ 0 ] dp [ 1 ] = arr [ 1 ] dp [ 2 ] = arr [ 2 ] dp [ 3 ] = arr [ 3 ] for i in range ( 4 , n ) : dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) )

static int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }

static int minSum ( int arr [ ] , int n ) { int dp [ ] = new int [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) return min ( arr [ 0 ] , arr [ 1 ] ) ; dp [ i ] = arr [ i ] + min ( dp [ i - 1 ] , dp [ i - 2 ] ) ; dp [ i ] = arr [ i ] + min

static int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dp [ i ] = arr [ i ] ; dp [ i - 1 ] = arr [ i - 1 ] ; dp [ i - 2 ] = arr [ i - 2 ] ; dp [ i - 3 ] = arr [ i - 3 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dp [ i ] = arr [ i ] ; dp [ i - 1 ] = arr [ i - 1 ] ; dp [ i - 2 ] = arr [ i - 2 ] ; dp [ i - 3 ] = arr [ i - 3 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; } } return min ( dp [ n - 1 ] , dp [ n - 2 ] ) ; }

10.38
23.89
30.85
32.9
def fill0X ( m , n ) : i , k , l = 0 , 0 , 0 r = m c = n a = [ [ None ] * n for i in range ( m ) ] x = 'X' while k < m and l < n : for i in range ( l , n ) : a [ k ] [ i ] = x k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = x n -= 1 if k < m : for i in range ( n - 1 , l - 1 , - 1 ) : a [ m - 1 ] [ i ] = x m -= 1 if l < n : for i in range ( m - 1 , k - 1 , - 1 ) : a [ i ] [ l ] = x l += 1 x = 'X' if x == '0' else '0' for i in range ( r ) : for j in range ( c ) : print ( a [ i ] [ j ] , end = "" ) print ( )

static void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ ] [ ] = new char [ m ] [ n ] ; char x = 'X' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? 'X' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) System . out . print ( a [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

static void fill0X ( int m , int n ) { int i , k , l ; int x ; for ( i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == '0' ) x = 'X' ; else x = 'X' ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j =

static void fill0X ( int m , int k , int l , int n , int r , int c ) { int i , k , l , int r , int c , int a [ ] [ ] ) { for ( int i = 0 ; i < m && l < n ; i ++ ) { a [ i ] [ l ] = x k ; a [ i ] [ n - 1 ] = x n - 1 ; a [ i ] [ m - 1 ] = x m - 1 ; a [ i ] [ l ] = x l ++ ; x = 'X' if x == '0' else '0' for i in range ( m - 1 , k - 1 , - 1 ) { a [ i ] [ l ] = x l ++ ; x = 'X' if x == '0' else '0' for i in range ( m - 1 , k - 1 , - 1 ) { a [ i ] [ l ] = x m - 1 ; a [ i ] [ m - 1 ] = x l ++ ; x = 'X' if x == '0' else '0' for i in range ( m - 1 , k - 1 , - 1 ) { a

10.61
24.08
17.44
28.31
def isValidString ( str ) : freq = [ 0 ] * CHARS for i in range ( len ( str ) ) : freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 freq1 = 0 count_freq1 = 0 for i in range ( CHARS ) : if ( freq [ i ] != 0 ) : freq1 = freq [ i ] count_freq1 = 1 break freq2 = 0 count_freq2 = 0 for j in range ( i + 1 , CHARS ) : if ( freq [ j ] != 0 ) : if ( freq [ j ] == freq1 ) : count_freq1 += 1 else : count_freq2 = 1 freq2 = freq [ j ] break for k in range ( j + 1 , CHARS ) : if ( freq [ k ] != 0 ) : if ( freq [ k ] == freq1 ) : count_freq1 += 1 if ( freq [ k ] == freq2 ) : count_freq2 += 1 else : return False if ( count_freq1 > 1 and count_freq2 > 1 ) : return False return True

static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ; } else { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } } return true ; }

static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; int count = 0 ; int freq1 = 0 ; int count_freq1 = 0 ; int count_freq2 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { if ( freq [ i ] == freq1 ) count_freq1 += 1 ; if ( freq [ i ] == freq2

static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; int count_freq1 = 0 ; int count_freq2 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { if ( freq [ i ] == freq1 ) count_freq1 += 1 ; if ( freq [ i ] == freq2 ) count_freq2 += 1 ; else if ( freq [ i ] == freq2 ) count_freq2 += 1 ; else return false ; } } return true ; }

10.86
28.96
22.11
35.92
def maxDifference ( arr , N , k ) : S = 0 S1 = 0 max_difference = 0 for i in range ( N ) : S += arr [ i ] arr . sort ( reverse = True ) M = max ( k , N - k ) for i in range ( M ) : S1 += arr [ i ] max_difference = S1 - ( S - S1 ) return max_difference

static int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }

static int maxDifference ( int arr [ ] , int N , int k ) { int S = 0 ; int S1 = 0 ; int max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S1 += arr [ i ] ; } return max_difference ; }

static int maxDifference ( int arr [ ] , int N , int k ) { int S = 0 ; int S1 = 0 ; int max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; } return max_difference ; }

10.86
21.06
53.36
46.01
def sortSquares ( arr , n ) : K = 0 for K in range ( n ) : if ( arr [ K ] >= 0 ) : break i = K - 1 j = K ind = 0 temp = [ 0 ] * n while ( i >= 0 and j < n ) : if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 else : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 while ( i >= 0 ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 ind += 1 while ( j < n ) : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 for i in range ( n ) : arr [ i ] = temp [ i ]

public static void sortSquares ( int arr [ ] ) { int n = arr . length ; int k ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] >= 0 ) break ; } int i = k - 1 ; int j = k ; int ind = 0 ; int [ ] temp = new int [ n ] ; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; } ind ++ ; } while ( i >= 0 ) { temp [ ind ++ ] = arr [ i ] * arr [ i ] ; i -- ; } while ( j < n ) { temp [ ind ++ ] = arr [ j ] * arr [ j ] ; j ++ ; } for ( int x = 0 ; x < n ; x ++ ) arr [ x ] = temp [ x ] ; }

static int sortSquares ( int arr [ ] , int n ) { int K = 0 ; int i = 0 ; int j = 0 ; int ind = 0 ; for ( int K = 0 ; K < n ; K ++ ) { if ( arr [ K ] >= 0 ) { break ; } } for ( int K = K - 1 ; K <= K ; K ++ ) { if ( arr [ K ] >= 0 ) { break ; } } return K ; }

static void sortSquares ( int arr [ ] , int n ) { int K = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int j = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -= 1 ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j += 1 ; } } } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -= 1 ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j += 1 ; } } } return ; }

10.87
19.47
14.43
20.94
def printRect ( X , Y , n ) : Xmax = max ( X ) Xmin = min ( X ) Ymax = max ( Y ) Ymin = min ( Y ) print ( "{" , Xmin , "," , Ymin , "}" , sep = "" ) print ( "{" , Xmin , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymin , "}" , sep = "" )

static void printRect ( Integer X [ ] , Integer Y [ ] , int n ) { int Xmax = Collections . max ( Arrays . asList ( X ) ) ; int Xmin = Collections . min ( Arrays . asList ( X ) ) ; int Ymax = Collections . max ( Arrays . asList ( Y ) ) ; int Ymin = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( "{" + Xmin + ", " + Ymin + "}" ) ; System . out . println ( "{" + Xmin + ", " + Ymax + "}" ) ; System . out . println ( "{" + Xmax + ", " + Ymax + "}" ) ; System . out . println ( "{" + Xmax + ", " + Ymin + "}" ) ; }

static void printRect ( int X , int Y , int n ) { int Xmax = max ( X ) Xmin = min ( X ) Xmin = min ( X ) Ymax = max ( Y ) Ymin = min ( Y ) print ( "{" , Xmax , "," , Ymin , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymin

static void printRect ( int X , int Y , int n ) { int Xmax = max ( X ) ; int Ymax = min ( Y ) ; int Ymin = min ( Y ) ; print ( "{" , Xmax , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymin , "}" , sep = "" ) ; print ( "{" , Xmax , "," , Ymax , "}" , sep = "" ) ; }

11.13
32.74
16.47
29.56
def printUnsorted ( arr , n ) : e = n - 1 for s in range ( 0 , n - 1 ) : if arr [ s ] > arr [ s + 1 ] : break if s == n - 1 : print ( "Thecompletearrayissorted" ) exit ( ) e = n - 1 while e > 0 : if arr [ e ] < arr [ e - 1 ] : break e -= 1 max = arr [ s ] min = arr [ s ] for i in range ( s + 1 , e + 1 ) : if arr [ i ] > max : max = arr [ i ] if arr [ i ] < min : min = arr [ i ] for i in range ( s ) : if arr [ i ] > min : s = i break i = n - 1 while i >= e + 1 : if arr [ i ] < max : e = i break i -= 1 print ( "Theunsortedsubarraywhichmakesthegivenarray" ) print ( "sortedliesbetweentheindexes%dand%d" % ( s , e ) )

static void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( "The complete array is sorted" ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " The unsorted subarray which" + " makes the given array sorted lies" + " between the indices " + s + " and " + e ) ; return ; }

static void printUnsorted ( int arr [ ] , int n ) { int s = 0 ; for ( int s = 0 ; s < n ; s ++ ) { if ( arr [ s ] < arr [ s + 1 ] ) break ; e = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < min ) min = arr [ i ] ; if ( arr [ i ] > max ) max =

static void printUnsorted ( int arr [ ] , int n ) { int s = 0 ; int e = n - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > arr [ s ] ) break ; if ( arr [ i ] < arr [ e ] ) break ; if ( arr [ i ] > arr [ e ] ) break ; if ( arr [ i ] < arr [ s ] ) s = i ; if ( arr [ i ] > arr [ e ] ) e = i ; } }

11.24
37.16
81.77
79.42
def vol_of_dodecahedron ( side ) : return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) )

static double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }

static int vol_of_dodecahedron ( int side ) { int vol_of_dodecahedron = vol_of_dodecahedron ( int side ) ; return vol_of_dodecahedron ; }

public static int vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) ; }

11.34
23.86
61.54
59.25
def NextFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n j = 0 for i in range ( n ) : while j < m : if blockSize [ j ] >= processSize [ i ] : allocation [ i ] = j blockSize [ j ] -= processSize [ i ] break j = ( j + 1 ) % m print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )

static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] , j = 0 ; Arrays . fill ( allocation , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } System . out . print ( "\nProcess No.\tProcess Size\tBlock no.\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) { System . out . print ( allocation [ i ] + 1 ) ; } else { System . out . print ( "Not Allocated" ) ; } System . out . println ( "" ) ; } }

static void NextFit ( int [ ] blockSize , int [ ] processSize , int n ) { int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; } else { allocation [ i ] = - 1 ; } } }

static void NextFit ( int blockSize , int m , int processSize , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; } j = ( j + 1 ) % m ; } } for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; } j = ( j + 1 ) % m ; } } if ( allocation [ i ] != - 1 ) { print ( allocation [ i ] + 1 ) ; } else { print ( "NotAllocated" ) ; } } return ; }

11.38
4.21
59.98
73.05
def Circumference ( a ) : return ( 4 * a )

int Circumference ( int a ) { return 4 * a ; }

def Circumference ( a ) :

static int Circumference ( int a ) { return ( 4 * a ) ; }

11.48
22.25
26.51
35.33
def evaluateBoolExpr ( s ) : n = len ( s ) for i in range ( 0 , n - 2 , 2 ) : if ( s [ i + 1 ] == "A" ) : if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) : s [ i + 2 ] = "0" else : s [ i + 2 ] = "1" elif ( s [ i + 1 ] == "B" ) : if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) : s [ i + 2 ] = "1" else : s [ i + 2 ] = "0" else : if ( s [ i + 2 ] == s [ i ] ) : s [ i + 2 ] = "0" else : s [ i + 2 ] = "1" return ord ( s [ n - 1 ] ) - ord ( "0" )

static int evaluateBoolExpr ( StringBuffer s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s . charAt ( i + 1 ) == 'A' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == 'B' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . setCharAt ( i + 2 , '1' ) ; else s . setCharAt ( i + 2 , '0' ) ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } } } return s . charAt ( n - 1 ) - '0' ; }

static int evaluateBoolExpr ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i + 1 ] == "A" ) { if ( s [ i + 2 ] == "1" ) s [ i + 2 ] = "1" ; else s [ i + 2 ] = "0" ; } else { if ( s [ i + 1 ] == "B" ) { if ( s

static int evaluateBoolExpr ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i + 1 ] == "A" ) { if ( s [ i + 2 ] == "0" || s [ i ] == "0" ) { s [ i + 2 ] = "0" ; } else if ( s [ i + 2 ] == "1" ) { s [ i + 2 ] = "1" ; } else if ( s [ i + 2 ] == "1" ) { s [ i + 2 ] = "1" ; } else if ( s [ i + 2 ] == s [ i ] ) { s [ i + 2 ] = "0" ; } else if ( s [ i + 2 ] == s [ i ] ) { s [ i + 2 ] = "1" ; } else if ( s [ i + 2 ] == s [ i ] ) { s [ i + 2 ] = "0" ; } else if ( s [ i + 2 ] == s [ i ] ) { s [ i + 2 ] = "0" ; } else if ( s [

11.54
20.29
24.0
28.32
def checkSentence ( string ) : length = len ( string ) if string [ 0 ] < 'A' or string [ 0 ] > 'Z' : return False if string [ length - 1 ] != '.' : return False prev_state = 0 curr_state = 0 index = 1 while ( string [ index ] ) : if string [ index ] >= 'A' and string [ index ] <= 'Z' : curr_state = 0 elif string [ index ] == '' : curr_state = 1 elif string [ index ] >= 'a' and string [ index ] <= 'z' : curr_state = 2 elif string [ index ] == '.' : curr_state = 3 if prev_state == curr_state and curr_state != 2 : return False if prev_state == 2 and curr_state == 0 : return False if curr_state == 3 and prev_state != 1 : return True index += 1 prev_state = curr_state return False

static boolean checkSentence ( char [ ] str ) { int len = str . length ; if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false ; if ( str [ len - 1 ] != '.' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . length ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ; else if ( str [ index ] == ' ' ) curr_state = 1 ; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ; else if ( str [ index ] == '.' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ; index ++ ; prev_state = curr_state ; } return false ; }

static boolean checkSentence ( String string ) { int length = string . length ( ) ; int prev_state = 0 ; int curr_state = 0 ; while ( index < length ) { if ( string [ index ] == 'a' and string [ index ] <= 'z' ) curr_state = 1 ; else if ( string [ index ] == 'a' and string [ index ] <= 'z' ) curr_state = 2 ; else curr_state = 3

static boolean checkSentence ( String string ) { int length = string . length ( ) ; int index = 0 ; while ( string [ index ] != ' ' ) { if ( string [ index ] < 'A' || string [ index ] > 'Z' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; if ( string [ index ] == ' ' ) return false ; return true ; }

11.57
39.41
64.32
60.39
def areaOctagon ( side ) : return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side )

static double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }

static int areaOctagon ( int side) {  int areaOctagon ( int side ) { return ( 2 * side * side ) * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side ) * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side * side ) ; }

static int areaOctagon ( int side ) { return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) * side * side ) ) ; }

11.57
29.0
64.7
65.48
def countSubSeq ( A , N , M ) : ans = 0 h = [ 0 ] * M for i in range ( 0 , N ) : A [ i ] = A [ i ] % M h [ A [ i ] ] = h [ A [ i ] ] + 1 for i in range ( 0 , M ) : for j in range ( i , M ) : rem = ( M - ( i + j ) % M ) % M if ( rem < j ) : continue if ( i == j and rem == j ) : ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 elif ( i == j ) : ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) elif ( i == rem ) : ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 elif ( rem == j ) : ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 else : ans = ans + h [ i ] * h [ j ] * h [ rem ] return ans

static int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ ] = new int [ M ] ; Arrays . fill ( h , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }

static int countSubSeq ( int [ ] A , int N , int M ) { int h [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i == j ) { ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ j ] - 2 ) / 6 ; } else {

static int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h = [ 0 ] * M ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) { continue if ( i == j ) { ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; } else if ( i == j ) { ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ) ; } else if ( i == rem ) { ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ) ; } else if ( i == rem ) { ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ) ; } else if ( rem == j ) { ans = ans + h [ j ] * ( h [ j

11.72
23.55
45.21
38.4
def sortUsingHash ( a , n ) : Max = max ( a ) Min = abs ( min ( a ) ) hashpos = [ 0 ] * ( Max + 1 ) hashneg = [ 0 ] * ( Min + 1 ) for i in range ( 0 , n ) : if a [ i ] >= 0 : hashpos [ a [ i ] ] += 1 else : hashneg [ abs ( a [ i ] ) ] += 1 for i in range ( Min , 0 , - 1 ) : if hashneg [ i ] != 0 : for j in range ( 0 , hashneg [ i ] ) : print ( ( - 1 ) * i , end = "" ) for i in range ( 0 , Max + 1 ) : if hashpos [ i ] != 0 : for j in range ( 0 , hashpos [ i ] ) : print ( i , end = "" )

static void sortUsingHash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int min = Math . abs ( Arrays . stream ( a ) . min ( ) . getAsInt ( ) ) ; int hashpos [ ] = new int [ max + 1 ] ; int hashneg [ ] = new int [ min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ; else hashneg [ Math . abs ( a [ i ] ) ] += 1 ; } for ( int i = min ; i > 0 ; i -- ) { if ( hashneg [ i ] > 0 ) { for ( int j = 0 ; j < hashneg [ i ] ; j ++ ) { System . out . print ( ( - 1 ) * i + " " ) ; } } } for ( int i = 0 ; i <= max ; i ++ ) { if ( hashpos [ i ] > 0 ) { for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) { System . out . print ( i + " " ) ; } } } }

static void sortUsingHash ( int [ ] a , int n ) { int [ ] hashpos = [ ] * ( Max + 1 ) ; int [ ] hashneg = [ ] * ( Min + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashpos [ i ] != 0 ) { for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) { if ( hashneg [ i ] ==

static void sortUsingHash ( int a [ ] , int n ) { int Max = max ( a ) ; int Min = min ( a ) ; int hashpos = [ 0 ] ; int hashneg = [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] ++ ; else hashneg [ abs ( a [ i ] ) ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] ++ ; else hashneg [ abs ( a [ i ] ) ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] ++ ; else hashneg [ abs ( a [ i ] ) ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( hashpos [ i ] != 0 ) for ( j in range ( 0 , hashpos [ i ] ) ) { print ( i , end = "" ) ; } } } }

11.76
18.19
41.98
43.55
def lenOfLongSubarr ( arr , n ) : um = { i : 0 for i in range ( 10 ) } sum = 0 maxLen = 0 for i in range ( n ) : if arr [ i ] == 0 : sum += - 1 else : sum += 1 if ( sum == 1 ) : maxLen = i + 1 elif ( sum not in um ) : um [ sum ] = i if ( ( sum - 1 ) in um ) : if ( maxLen < ( i - um [ sum - 1 ] ) ) : maxLen = i - um [ sum - 1 ] return maxLen

static int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }

static int lenOfLongSubarr ( int arr [ ] , int n ) { int sum = 0 ; int um [ ] = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { um [ i ] ++ ; } } return maxLen ; }

static int lenOfLongSubarr ( int arr [ ] , int n ) { int sum = 0 ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) sum += - 1 ; else if ( sum == 1 ) sum += - 1 ; else if ( sum == 0 ) sum += - 1 ; else if ( sum == 1 ) sum += - 1 ; if ( sum == 1 ) sum = i + 1 ; if ( sum == 1 ) sum = i + 1 ; if ( ( sum - 1 ) in um ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) { maxLen = i - um [ sum - 1 ] ; } } } if ( ( sum - 1 ) in um ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) { maxLen = i - um [ sum - 1 ] ; } } } return maxLen ; }

11.77
29.14
44.4
44.71
def minStepToDeleteString ( str ) : N = len ( str ) dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] for l in range ( 1 , N + 1 ) : i = 0 j = l - 1 while j < N : if ( l == 1 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] if ( str [ i ] == str [ i + 1 ] ) : dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) for K in range ( i + 2 , j + 1 ) : if ( str [ i ] == str [ K ] ) : dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) i += 1 j += 1 return dp [ 0 ] [ N - 1 ]

static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }

static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int i = 0 ; int j = 0 ; for ( int l = 1 ; l <= N ; l ++ ) { if ( str [ i ] == str [ i + 1 ] ) { dp [ i ] [ j ] = min ( dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; } } return dp [ 0 ] [ N - 1 ] ; }

static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int dp [ ] [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int j = 0 ; while ( j < N ) { if ( l == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = 1 + dp [ i + 2 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; } } return dp [ 0 ] [ N - 1 ] ; }

11.84
23.61
36.89
22.85
def replaceSpaces ( string ) : string = string . strip ( ) i = len ( string ) space_count = string . count ( '' ) new_length = i + space_count * 2 if new_length > MAX : return - 1 index = new_length - 1 string = list ( string ) for f in range ( i - 2 , new_length - 2 ) : string . append ( '0' ) for j in range ( i - 1 , 0 , - 1 ) : if string [ j ] == '' : string [ index ] = '0' string [ index - 1 ] = '2' string [ index - 2 ] = '%' index = index - 3 else : string [ index ] = string [ j ] index -= 1 return '' . join ( string )

static char [ ] replaceSpaces ( char [ ] str ) { int space_count = 0 , i = 0 ; for ( i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == ' ' ) space_count ++ ; while ( str [ i - 1 ] == ' ' ) { space_count -- ; i -- ; } int new_length = i + space_count * 2 ; if ( new_length > MAX ) return str ; int index = new_length - 1 ; char [ ] new_str = str ; str = new char [ new_length ] ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( new_str [ j ] == ' ' ) { str [ index ] = '0' ; str [ index - 1 ] = '2' ; str [ index - 2 ] = '%' ; index = index - 3 ; } else { str [ index ] = new_str [ j ] ; index -- ; } } return str ; }

static int replaceSpaces ( String string ) { int i = string . length ( ) ; int new_length = string . count ( ' ' ) ; if ( new_length == 0 ) return - 1 ; string . append ( '0' ) ; for ( int j = 0 ; j < i ; j ++ ) { string [ index ] = '0' ; string [ index - 1 ] = '2' ; string [ index - 2 ] = '2' ;

static int replaceSpaces ( String string ) { int i = string . length ( ) ; int space_count = string . count ( '' ) ; int new_length = i + space_count * 2 ; if ( new_length > MAX ) return - 1 ; int index = new_length - 1 ; string = new String ( string ) ; for ( int f = 0 ; f < i ; f ++ ) { string . append ( '0' ) ; for j in range ( i - 1 , 0 , - 1 ) { if ( string [ j ] == '' ) string [ index ] = '0' string [ index - 1 ] = '2' string [ index - 2 ] = '%' index = index - 3 ; else string [ index ] = string [ j ] ; index -- ; } } return - 1 ; }

11.88
22.41
51.56
48.78
def maxSum ( mat , n ) : if n == 1 : return mat [ 0 ] [ 0 ] dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] maxSum = INT_MIN for j in range ( n ) : dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] for i in range ( n - 2 , - 1 , - 1 ) : for j in range ( n ) : maxi = INT_MIN if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : maxi = dp [ i + 1 ] [ j - 1 ] if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : maxi = dp [ i + 1 ] [ j + 1 ] dp [ i ] [ j ] = mat [ i ] [ j ] + maxi for j in range ( n ) : if ( maxSum < dp [ 0 ] [ j ] ) : maxSum = dp [ 0 ] [ j ] return maxSum

static int maxSum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }

static int maxSum ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( maxSum < dp [ i ] [ j ] ) maxSum = dp [ i ] [ j ] + maxi ; if ( ( maxSum <

int maxSum ( int [ ] mat , int n ) { int [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = mat [ i ] [ j ] ; if ( ( ( j - 1 ) >= 0 ) && ( maxSum < dp [ i + 1 ] [ j - 1 ] ) ) ) maxSum = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( ( j + 1 ) < n ) && ( maxSum < dp [ i + 1 ] [ j + 1 ] ) ) ) maxSum = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + maxSum ; } } return maxSum ; }

11.89
20.88
51.19
50.93
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , m + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 if ( cnt [ i ] [ j ] >= k ) : for a in range ( k , cnt [ i ] [ j ] + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) return lcs [ n ] [ m ]

static int longestSubsequenceCommonSegment ( int k , String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }

static int longestSubsequenceCommonSegment ( int k , int s1 [ ] , int s2 [ ] ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int [ ] lcs [ ] [ ] = new int [ n ] [ m ] ; int [ ] cnt [ ] [ ] = new int [ n ] [ m ] ; for ( int i = 1 ; i <= n ; i ++ ) { for (

static int longestSubsequenceCommonSegment ( int k , int s1 , int s2 ) { int n = len ( s1 ) ; int m = len ( s2 ) ; int lcs = [ ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) lcs [ i ] [ j ] = lcs [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) for ( a in range ( k , cnt [ i ] [ j ] + 1 ) ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } return lcs [ n ] [ m ] ; }

11.9
22.69
73.78
73.32
def lcsOf3 ( X , Y , Z , m , n , o ) : L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : for k in range ( o + 1 ) : if ( i == 0 or j == 0 or k == 0 ) : L [ i ] [ j ] [ k ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 else : L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) return L [ m ] [ n ] [ o ]

static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }

static int lcsOf3 ( int X [ ] , int Y [ ] , int Z [ ] , int m , int n , int o ) { int L [ ] [ ] [ ] [ ] = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] [ ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k =

static int lcsOf3 ( int X , int Y , int Z , int m , int n , int o ) { int [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { for ( int k = 0 ; k < m + 1 ; k ++ ) { if ( i == 0 || j == 0 or k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }

12.09
19.39
25.88
26.93
def findCommon ( mat ) : global M global N cnt = dict ( ) cnt = defaultdict ( lambda : 0 , cnt ) i = 0 j = 0 while ( i < M ) : cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 j = 1 while ( j < N ) : if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : cnt [ mat [ i ] [ j ] ] = cnt [ mat [ i ] [ j ] ] + 1 j = j + 1 i = i + 1 for ele in cnt : if ( cnt [ ele ] == M ) : return ele return - 1

static int findCommon ( int mat [ ] [ ] ) { HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) { cnt . put ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ 0 ] , 1 ) ; } for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) if ( cnt . containsKey ( mat [ i ] [ j ] ) ) { cnt . put ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ j ] , 1 ) ; } } } for ( Map . Entry < Integer , Integer > ele : cnt . entrySet ( ) ) { if ( ele . getValue ( ) == M ) return ele . getKey ( ) ; } return - 1 ; }

static int findCommon ( int [ ] mat ) { int i = 0 ; int j = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ 0 ] ) { cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 ; j = j + 1 ; while ( j < N ) { if ( cnt [ mat [

static int findCommon ( int mat [ ] [ ] ) { int i = 0 ; int j = 0 ; while ( i < M ) { cnt [ mat [ i ] [ 0 ] ] = 0 ; cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 ; cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 ; cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 cnt [

12.23
20.82
42.14
59.43
def isEven ( n ) : return ( not ( n & 1 ) )

public static boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }

static boolean isEven ( int n ) { return

static boolean isEven ( int n ) { return ( ! ( n & 1 ) ) ; }

12.29
29.12
32.14
35.35
def printSumTricky ( mat , k ) : global n if k > n : return stripSum = [ [ None ] * n for i in range ( n ) ] for j in range ( n ) : Sum = 0 for i in range ( k ) : Sum += mat [ i ] [ j ] stripSum [ 0 ] [ j ] = Sum for i in range ( 1 , n - k + 1 ) : Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) stripSum [ i ] [ j ] = Sum for i in range ( n - k + 1 ) : Sum = 0 for j in range ( k ) : Sum += stripSum [ i ] [ j ] print ( Sum , end = "" ) for j in range ( 1 , n - k + 1 ) : Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) print ( Sum , end = "" ) print ( )

static void printSumTricky ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int stripSum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + " " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " " ) ; } System . out . println ( ) ; } }

static void printSumTricky ( int mat [ ] [ ] , int k ) { int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += mat [ i ] [ j ] ; stripSum [ i ] [ j ] = Sum ; for ( int j = 0 ; j < k ; j ++ ) { Sum += ( mat [ i ] [ j ] - mat [ i - 1 ] [ j ] ) ; } }

static void printSumTricky ( int [ ] mat , int k ) { global n ; for ( int i = 0 ; i < n ; i ++ ) { int Sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) { Sum += mat [ i ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k - 1 ] [ j ] ; Sum += mat [ i + k -

12.32
26.14
79.85
81.67
def CountSquares ( a , b ) : return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 )

double countSquares ( int a , int b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }

static int CountSquares ( int a , int b ) { int CountSquares ( int a , int b ) { int CountSquares ( int a , int b ) ; int CountSquares ( int b , int a ) { int CountSquares ( int a , int b ) ; int CountSquares ( int b , int a ) ; int CountSquares ( int b , int a ) ; int CountSquares ( int b , int b ) ; int

static int CountSquares ( int a , int b ) { return ( Math . floor ( math . sqrt ( b ) ) - Math . ceil ( math . sqrt ( a ) ) + 1 ) ; }

12.48
26.19
39.64
38.17
def sortArray ( arr , n , A , B , C ) : for i in range ( n ) : arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ) index = - ( sys . maxsize - 1 ) maximum = - ( sys . maxsize - 1 ) for i in range ( n ) : if maximum < arr [ i ] : index = i maximum = arr [ i ] i = 0 j = n - 1 new_arr = [ 0 ] * n k = 0 while i < index and j > index : if arr [ i ] < arr [ j ] : new_arr [ k ] = arr [ i ] k += 1 i += 1 else : new_arr [ k ] = arr [ j ] k += 1 j -= 1 while i < index : new_arr [ k ] = arr [ i ] k += 1 i += 1 while j > index : new_arr [ k ] = arr [ j ] k += 1 j -= 1 new_arr [ n - 1 ] = maximum for i in range ( n ) : arr [ i ] = new_arr [ i ]

static void sortArray ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int index = - 1 ; int maximum = - 999999 ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int [ ] new_arr = new int [ n ] ; int k = 0 ; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ] ; else new_arr [ k ++ ] = arr [ j -- ] ; } while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ; while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ; new_arr [ n - 1 ] = maximum ; for ( int p = 0 ; p < n ; p ++ ) arr [ p ] = new_arr [ p ] ; }

static int sortArray ( int arr [ ] , int n , int A , int B , int C ) { int index = - ( sys . maxsize - 1 ) ; int maximum = - ( sys . maxsize - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ j ] ) { new_arr [ k ] = arr [ j ] ; k += 1 i += 1 ; } } return index ; }

static void sortArray ( int arr [ ] , int n , int A , int B , int C ) { int index = - ( sys . maxsize - 1 ) ; int maximum = - ( sys . maxsize - 1 ) ; for ( int i = 0 ; i < index ; i ++ ) { if ( arr [ i ] < arr [ j ] ) { if ( arr [ i ] < arr [ j ] ) { if ( arr [ i ] < arr [ j ] ) { new_arr [ k ] = arr [ i ] ; k += 1 i += 1 else : new_arr [ k ] = arr [ j ] ; k += 1 j -= 1 while i < index : new_arr [ k ] = arr [ i ] k += 1 i += 1 else : new_arr [ k ] = arr [ j ] k += 1 j -= 1 while i < index : new_arr [ k ] = arr [ i ] k += 1 i += 1 while j > index : new_arr [ k ] = arr [ j ] k += 1 j -= 1 while i < index : new_arr [ k ] = arr [ i ] k += 1 i += 1 while j > index : new_arr

12.58
24.39
36.72
38.87
def maxNumOfChocolates ( arr , n , k ) : um , curr_rem , maxSum = { } , 0 , 0 sm = [ 0 ] * n sm [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : sm [ i ] = sm [ i - 1 ] + arr [ i ] for i in range ( n ) : curr_rem = sm [ i ] % k if ( not curr_rem and maxSum < sm [ i ] ) : maxSum = sm [ i ] elif ( not curr_rem in um ) : um [ curr_rem ] = i elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) : maxSum = sm [ i ] - sm [ um [ curr_rem ] ] return maxSum // k

static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int [ ] sum = new int [ n ] ; int curr_rem ; int maxSum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sum [ i ] % k ; if ( curr_rem == 0 ) { if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ; } else if ( ! um . containsKey ( curr_rem ) ) um . put ( curr_rem , i ) ; else if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_rem ) ] ) ) maxSum = sum [ i ] - sum [ um . get ( curr_rem ) ] ; } return ( maxSum / k ) ; }

static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { int maxSum = 0 ; int um [ ] = { } ; for ( int i = 1 ; i <= n ; i ++ ) { int curr_rem = sm [ i ] % k ; if ( ! curr_rem ) um [ curr_rem ] = i ; else maxSum = sm [ i ] - sm [ curr_rem ] ; } return max

; static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { int um [ ] , curr_rem , maxSum = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sm [ i ] % k ; if ( ! curr_rem && maxSum < sm [ i ] ) maxSum = sm [ i ] ; if ( ! curr_rem ) um [ curr_rem ] = i ; if ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) maxSum = sm [ i ] - sm [ um [ curr_rem ] ] ; if ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) maxSum = sm [ i ] - sm [ um [ curr_rem ] ] ; } return maxSum ; }

12.65
25.47
48.89
44.69
def maxAlternateSum ( arr , n ) : if ( n == 1 ) : return arr [ 0 ] dec = [ 0 for i in range ( n + 1 ) ] inc = [ 0 for i in range ( n + 1 ) ] dec [ 0 ] = inc [ 0 ] = arr [ 0 ] flag = 0 for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ j ] > arr [ i ] ) : dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) flag = 1 elif ( arr [ j ] < arr [ i ] and flag == 1 ) : inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) result = - 2147483648 for i in range ( n ) : if ( result < inc [ i ] ) : result = inc [ i ] if ( result < dec [ i ] ) : result = dec [ i ] return result

static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }

static int maxAlternateSum ( int arr [ ] , int n ) { int result = - 2147483648 ; int inc [ ] = new int [ n + 1 ] ; int dec [ ] = new int [ n + 1 ] ; int inc [ ] = new int [ n + 1 ] ; int inc [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] > arr

static int maxAlternateSum ( int arr [ ] , int n ) { int result = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i ] ) { dec [ i ] = max ( dec [ i ] , inc [ i ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ i ] < arr [ i ] && flag == 1 ) { inc [ i ] = max ( inc [ i ] , dec [ i ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ i ] < arr [ i ] && flag == 1 ) { inc [ i ] = max ( inc [ i ] , dec [ i ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ i ] < arr [ i ] && flag == 1 ) { inc [ i ] = max ( inc [ i ] , dec [ i ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ i ] < arr [ i ] && flag == 1 ) { inc [ i ] = max ( inc [ i ] , dec [ i ] + arr [

12.68
27.95
70.26
67.89
def maxSumWO3Consec ( arr , n ) : sum = [ 0 for k in range ( n ) ] if n >= 1 : sum [ 0 ] = arr [ 0 ] if n >= 2 : sum [ 1 ] = arr [ 0 ] + arr [ 1 ] if n > 2 : sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) for i in range ( 3 , n ) : sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) return sum [ n - 1 ]

static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }

static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = arr [ i ] + arr [ i ] ; } return sum [ n - 1 ] ; }

public static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { sum [ i ] = arr [ i ] ; if ( n >= 1 ) sum [ 1 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 2 ] = arr [ 1 ] + arr [ 2 ] ; if ( n > 2 ) sum [ 3 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 1 ; i < n ; i ++ ) { sum [ i ] = arr [ i ] + arr [ i ] ; } } return sum [ n - 1 ] ; }

12.82
26.69
33.85
40.59
def KMP ( m , n , str2 , str1 ) : pos = 0 Len = 0 p = [ 0 for i in range ( m + 1 ) ] k = 0 for i in range ( 2 , n + 1 ) : while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) : k = p [ k ] if ( str1 [ k ] == str1 [ i - 1 ] ) : k += 1 p [ i ] = k j = 0 for i in range ( m ) : while ( j > 0 and j < n and str1 [ j ] != str2 [ i ] ) : j = p [ j ] if ( j < n and str1 [ j ] == str2 [ i ] ) : j += 1 if ( j > Len ) : Len = j pos = i - j + 1 print ( "Shift=" , pos ) print ( "Prefix=" , str1 [ : Len ] )

static void KMP ( int m , int n , String str2 , String str1 ) { int pos = 0 , len = 0 ; int [ ] p = new int [ m + 1 ] ; int k = 0 ; char [ ] ch1 = str1 . toCharArray ( ) ; char [ ] ch2 = str2 . toCharArray ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] ; if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p [ j ] ; if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } System . out . println ( "Shift = " + pos ) ; System . out . println ( "Prefix = " + str1 . substring ( 0 , len ) ) ; }

static int KMP ( int m , int n , int str1 [ ] , int str2 [ ] ) { int p [ ] = new int [ m + 1 ] ; int j = 0 ; for ( int i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && str1 [ j ] == str2 [ i ] ) { j = p [ j ] ; if ( j > Len ) { Len = j ;

static void KMP ( int m , int n , String str2 , String str1 ) { int pos = 0 ; int Len = 0 ; for ( int i = 0 ; i < m ; i ++ ) { while ( p [ i ] != str1 [ i - 1 ] ) { k = p [ i ] ; if ( k > 0 && str1 [ k ] != str2 [ i ] ) { k = p [ k ] ; if ( k < n ) { j = p [ j ] ; if ( j < n ) { j ++ ; } } } if ( j > Len ) { Len = j ; pos = i - j + 1 ; print ( "Shift=" , pos ) ; str1 [ : Len ] = str2 [ : Len ] ; } } } }

12.88
21.22
40.34
52.28
def Round_off ( N , n ) : b = N c = floor ( N ) i = 0 while ( b >= 1 ) : b = b / 10 i = i + 1 d = n - i b = N b = b * pow ( 10 , d ) e = b + 0.5 if ( float ( e ) == float ( ceil ( b ) ) ) : f = ( ceil ( b ) ) h = f - 2 if ( h % 2 != 0 ) : e = e - 1 j = floor ( e ) m = pow ( 10 , d ) j = j / m print ( "Thenumberafterrounding-offis" , j )

static void Round_off ( double N , double n ) { int h ; double l , a , b , c , d , e , i , j , m , f , g ; b = N ; c = floor ( N ) ; for ( i = 0 ; b >= 1 ; ++ i ) b = b / 10 ; d = n - i ; b = N ; b = b * pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ( ceil ( b ) ) ; h = ( int ) ( f - 2 ) ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; System . out . println ( "The number after rounding-off is " + j ) ; }

static int Round_off ( int N , int n ) { int b = c ; int c = floor ( N ) ; int i = 0 ; while ( b >= 1 ) { b = b / 10 ; i = i + 1 ; } } int d = n - i ; int i = 0 ; while ( b >= 1 ) { b = b / 10 ; i = i + 1 ; while ( b >= 1 ) { b = b / 10 ; i =

static void Round_off ( int N , int i ) { int b = N ; int c = floor ( N ) ; int d = n - i ; int e = b + 0.5 ; if ( float ( e ) == float ( ceil ( b ) ) ) { f = ( ceil ( b ) ) ; h = f - 2 ; if ( h % 2 != 0 ) e = e - 1 ; j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; } if ( j % 2 != 0 ) j = j - 1 ; else j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; } while ( b >= 1 ) { b = b / 10 i = i + 1 d = n - i ; b = b * 10 i = i + 1 ; e = b + 0.5 ; if ( float ( e ) == float ( ceil ( b ) ) ) { f = ( ceil ( b ) ) ; h = f - 2 ; if ( h % 2 != 0 ) j = j - 1 ; m = pow ( 10 , d ) ; j = j / m ; } } }

12.94
27.33
54.09
55.12
def shortestPath ( graph , u , v , k ) : global V , INF sp = [ [ None ] * V for i in range ( V ) ] for i in range ( V ) : for j in range ( V ) : sp [ i ] [ j ] = [ None ] * ( k + 1 ) for e in range ( k + 1 ) : for i in range ( V ) : for j in range ( V ) : sp [ i ] [ j ] [ e ] = INF if ( e == 0 and i == j ) : sp [ i ] [ j ] [ e ] = 0 if ( e == 1 and graph [ i ] [ j ] != INF ) : sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] if ( e > 1 ) : for a in range ( V ) : if ( graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF ) : sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) return sp [ u ] [ v ] [ k ]

int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { int sp [ ] [ ] [ ] = new int [ V ] [ V ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ; if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; if ( e > 1 ) { for ( int a = 0 ; a < V ; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } return sp [ u ] [ v ] [ k ] ; }

static int shortestPath ( int [ ] graph , int u , int v , int k ) { int [ ] [ ] sp [ ] [ ] [ ] = new int [ V ] [ ] [ ] ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( graph [ i ] [ j ] != INF ) { sp [ i ] [ j ] [ e ] = min

static int shortestPath ( int graph , int u , int v , int k ) { global V , INF sp = [ [ ] * V ] ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int e = 0 ; e < k ; e ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( graph [ i ] [ j ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) { sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } return sp [ u ] [ v ] [ k ] ; }

12.95
56.71
89.27
82.76
def sumOfSeries ( n ) : return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n )

static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }

static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * n - 0.55 * n - 0.55 * n ) ; }  def sumOfSeries ( int n ) { return 0.6172 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n ) - 0.55 * n ) + 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n - 0.55 * n

static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }

13.06
23.18
19.8
24.41
def countFreq ( a , n ) : hm = { } for i in range ( 0 , n ) : hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 st = set ( ) for x in hm : st . add ( ( x , hm [ x ] ) ) cumul = 0 for x in sorted ( st ) : cumul += x [ 1 ] print ( x [ 0 ] , cumul )

static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ; SortedMap < Integer , Integer > st = new TreeMap < > ( ) ; for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) { st . put ( x . getKey ( ) , x . getValue ( ) ) ; } int cumul = 0 ; for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) { cumul += x . getValue ( ) ; System . out . println ( x . getKey ( ) + " " + cumul ) ; } }

static int countFreq ( int [ ] a , int n ) { int hm = { } ; for ( int i = 0 ; i < n ; i ++ ) { hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 ; } return hm . get ( a [ n ] , 0 ) ; }

static void countFreq ( int [ ] a , int n ) { int hm [ ] = new int [ n ] ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 ; st . add ( ( x , hm [ x ] ) ) ; cumul += x [ 1 ] ; } }

13.15
24.3
29.07
32.97
def minRemove ( a , b , n , m ) : countA = dict ( ) countB = dict ( ) for i in range ( n ) : countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 for i in range ( n ) : countB [ b [ i ] ] = countB . get ( b [ i ] , 0 ) + 1 res = 0 for x in countA : if x in countB . keys ( ) : res += min ( countA [ x ] , countB [ x ] ) return res

public static int minRemove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; else countA . put ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; else countB . put ( b [ i ] , 1 ) ; } int res = 0 ; Set < Integer > s = countA . keySet ( ) ; for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ; return res ; }

static int minRemove ( int [ ] a , int [ ] b , int n , int m ) { int countA = dict ( ) ; int countB = dict ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x in countB ) {

static int minRemove ( int [ ] a , int [ ] b , int n , int m ) { int countA = dict ( ) ; int countB = dict ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 ; for ( int i = 0 ; i < n ; i ++ ) { countB [ b [ i ] ] = countB . get ( b [ i ] , 0 ) + 1 ; } res = 0 ; for ( int x in countA . keys ( ) ) { res += min ( countA [ x ] , countB [ x ] ) ; } return res ; } }

13.16
28.08
25.28
36.81
def maximumZeros ( arr , n , k ) : global MAX5 subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1 ) ] subset [ 0 ] [ 0 ] = 0 for p in arr : pw2 , pw5 = 0 , 0 while not p % 2 : pw2 += 1 p //= 2 while not p % 5 : pw5 += 1 p //= 5 for i in range ( k - 1 , - 1 , - 1 ) : for j in range ( MAX5 ) : if subset [ i ] [ j ] != - 1 : subset [ i + 1 ] [ j + pw5 ] = ( max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ) ans = 0 for i in range ( MAX5 ) : ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) return ans

static int maximumZeros ( int arr [ ] , int n , int k ) { int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ; for ( int [ ] row : subset ) { Arrays . fill ( row , - 1 ) ; } subset [ 0 ] [ 0 ] = 0 ; for ( int p = 0 ; p < n ; p ++ ) { int pw2 = 0 , pw5 = 0 ; while ( arr [ p ] % 2 == 0 ) { pw2 ++ ; arr [ p ] /= 2 ; } while ( arr [ p ] % 5 == 0 ) { pw5 ++ ; arr [ p ] /= 5 ; } for ( int i = k - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) { subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) ; } } } } int ans = 0 ; for ( int i = 0 ; i < MAX5 ; i ++ ) { ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ; } return ans ; }

static int maximumZeros ( int arr [ ] , int n , int k ) { int subset [ ] [ ] = new int [ MAX5 + 5 ] ; for ( int i = 0 ; i < k ; i ++ ) { int pw2 = 0 ; pw5 = 0 ; for ( int j = 0 ; j < MAX5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) subset [ i ] [ j + pw2 ] = (

static int maximumZeros ( int arr [ ] , int n , int k ) { int [ ] subset = new int [ k + 1 ] [ MAX5 + 1 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < MAX5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ] [ j + pw5 ] = ( max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ; } } return ans ; }

13.17
19.84
34.28
32.5
def substringConversions ( str1 , k , b ) : for i in range ( 0 , len ( str1 ) - k + 1 ) : sub = str1 [ i : k + i ] Sum = 0 counter = 0 for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) counter += 1 print ( Sum , end = "" )

static void substringConversions ( String str , int k , int b ) { int i = 0 , sum = 0 , counter = k - 1 ; for ( i = 0 ; i < k ; i ++ ) { sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter -- ; } System . out . print ( sum + " " ) ; int prev = sum ; sum = 0 ; counter = 0 ; for ( ; i < str . length ( ) ; i ++ ) { sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) * Math . pow ( b , k - 1 ) ) ) ; sum = sum * b ; sum = sum + ( str . charAt ( i ) - '0' ) ; System . out . print ( sum + " " ) ; prev = sum ; counter ++ ; } }

static int substringConversions ( String str , int k , int b ) { int Sum = 0 ; int counter = 0 ; for ( int i = 0 ; i < len ( str ) ; i ++ ) { Sum = ( Sum + ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) ; counter ++ ; } return Sum ; }

static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { String sub = str [ i ] ; Sum = 0 ; counter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) ; counter ++ ; } Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) ; counter ++ ; } }

13.2
28.56
17.02
27.82
def cycleSort ( array ) : writes = 0 for cycleStart in range ( 0 , len ( array ) - 1 ) : item = array [ cycleStart ] pos = cycleStart for i in range ( cycleStart + 1 , len ( array ) ) : if array [ i ] < item : pos += 1 if pos == cycleStart : continue while item == array [ pos ] : pos += 1 array [ pos ] , item = item , array [ pos ] writes += 1 while pos != cycleStart : pos = cycleStart for i in range ( cycleStart + 1 , len ( array ) ) : if array [ i ] < item : pos += 1 while item == array [ pos ] : pos += 1 array [ pos ] , item = item , array [ pos ] writes += 1 return writes

public static void cycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle_start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle_start ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } }

static int cycleSort ( int [ ] array , int cycleStart ) { int item = array [ cycleStart ] ; int pos = cycleStart ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] > item ) pos += 1 ; else if ( item == array [ pos ] ) pos += 1 ; else if ( pos == cycleStart ) continue ; if ( item == array [ pos ] ) pos += 1 ; else

int cycleSort ( int array [ ] ) { int writes = 0 ; for ( int cycleStart = 0 ; cycleStart < array . length ; cycleStart ++ ) { int item = array [ cycleStart ] ; int pos = cycleStart for i in range ( cycleStart + 1 , len ( array ) ) { if ( array [ i ] < item ) pos += 1 ; while ( item == array [ pos ] ) pos += 1 ; array [ pos ] , item = item , array [ pos ] writes ++ ; } } return writes ; }

13.27
26.59
29.11
38.18
def constructPalin ( string , l ) : string = list ( string ) i = - 1 j = l while i < j : i += 1 j -= 1 if ( string [ i ] == string [ j ] and string [ i ] != '*' ) : continue elif ( string [ i ] == string [ j ] and string [ i ] == '*' ) : string [ i ] = 'a' string [ j ] = 'a' continue elif string [ i ] == '*' : string [ i ] = string [ j ] continue elif string [ j ] == '*' : string [ j ] = string [ i ] continue print ( "NotPossible" ) return "" return '' . join ( string )

static String constructPalin ( char [ ] str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) { str [ i ] = 'a' ; str [ j ] = 'a' ; continue ; } else if ( str [ i ] == '*' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == '*' ) { str [ j ] = str [ i ] ; continue ; } System . out . println ( "Not Possible" ) ; return "" ; } return String . valueOf ( str ) ; }

static String constructPalin ( String string , int l ) { int i = - 1 ; int j = l ; while ( i < j ) { if ( string [ i ] == 'a' ) string [ i ] = 'a' continue else if ( string [ i ] == 'a' ) string [ j ] = 'a' continue else : string [ i ] = 'a' continue else : string [ j ] = 'a' continue else : string [

static String constructPalin ( String string , int l ) { String string [ ] = new String [ l ] ; int i = - 1 ; int j = l ; while ( i < j ) { i += 1 ; j -= 1 if ( string [ i ] == string [ j ] && string [ i ] != '*' ) { string [ i ] = 'a' ; string [ j ] = 'a' ; } else if ( string [ i ] == string [ j ] && string [ i ] == '*' ) { string [ i ] = 'a' ; string [ j ] = 'a' ; } else if ( string [ i ] == string [ j ] && string [ i ] == '*' ) { string [ i ] = 'a' ; string [ j ] = 'a' ; } else if ( string [ i ] == string [ j ] && string [ i ] == '*' ) { string [ i ] = 'a' ; string [ j ] = 'a' ; } else if ( string [ j ] == '*' ) { string [ i ] = 'a' ; string [ j ] = 'a' ; } else { string [ j ] = string [ i ] ; } } }

13.28
25.33
39.01
45.57
def getFirstSetBitPos ( n ) : return math . log2 ( n & - n ) + 1

public static int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; }

static int getFirstSetBitPos ( int n ) { return math . log2 ( n

static int getFirstSetBitPos ( int n ) { return Math . log2 ( n & - n ) + 1 ; }

13.28
24.44
45.62
39.54
def findGreatest ( arr , n ) : m = dict ( ) for i in arr : m [ i ] = m . get ( i , 0 ) + 1 arr = sorted ( arr ) for i in range ( n - 1 , 0 , - 1 ) : j = 0 while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : if ( arr [ i ] % arr [ j ] == 0 ) : result = arr [ i ] // arr [ j ] if ( result != arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 0 ) : return arr [ i ] elif ( result == arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 1 ) : return arr [ i ] j += 1 return - 1

static int findGreatest ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ; } } Arrays . sort ( arr ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m . get ( result ) == null || m . get ( result ) > 0 ) { return arr [ i ] ; } else if ( result == arr [ j ] && m . get ( result ) > 1 ) { return arr [ i ] ; } } } } return - 1 ; }

static int findGreatest ( int [ ] arr , int n ) { int m [ ] = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 ) { result = arr [ i ] % arr [ j ] ; if ( result == 0 ) return arr [ i ] ; if ( m . get

static int findGreatest ( int arr [ ] , int n ) { int m [ ] = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { int j = 0 ; while ( j < i && arr [ j ] <= sqrt ( arr [ i ] ) ) { if ( arr [ i ] % arr [ j ] == 0 ) { if ( arr [ i ] % arr [ j ] == 0 ) { if ( arr [ i ] % arr [ j ] == 0 ) { result = arr [ i ] // arr [ j ] if ( result != arr [ j ] && ( result in m . keys ( ) ) && m [ result ] > 0 ) return arr [ i ] ; if ( result == arr [ j ] && ( result in m . keys ( ) ) && m [ result ] > 1 ) return arr [ i ] ; } j ++ ; } } } return - 1 ; }

13.39
27.12
41.22
39.58
def antiSpiralTraversal ( m , n , a ) : k = 0 l = 0 stk = [ ] while ( k <= m and l <= n ) : for i in range ( l , n + 1 ) : stk . append ( a [ k ] [ i ] ) k += 1 for i in range ( k , m + 1 ) : stk . append ( a [ i ] [ n ] ) n -= 1 if ( k <= m ) : for i in range ( n , l - 1 , - 1 ) : stk . append ( a [ m ] [ i ] ) m -= 1 if ( l <= n ) : for i in range ( m , k - 1 , - 1 ) : stk . append ( a [ i ] [ l ] ) l += 1 while len ( stk ) != 0 : print ( str ( stk [ - 1 ] ) , end = "" ) stk . pop ( )

public static void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Stack < Integer > stk = new Stack < Integer > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { System . out . print ( stk . peek ( ) + " " ) ; stk . pop ( ) ; } }

static void antiSpiralTraversal ( int m , int n , int [ ] a ) { int k = 0 ; int l = 0 ; int stk = [ ] ; while ( k <= m && l <= n ) { for ( int i = 0 ; i <= n ; i ++ ) stk . append ( a [ k ] [ i ] ) k += 1 ; for ( int i = 0 ; i <= m ; i ++ ) stk . append (

static void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int k = 0 ; int l = 0 ; int stk = [ ] ; while ( k <= m && l <= n ) { for ( int i = 0 ; i <= k ; i ++ ) { stk . append ( a [ k ] [ i ] ) k ++ ; stk . append ( a [ m ] [ i ] ) m -- ; stk . append ( a [ i ] [ l ] ) l ++ ; } while ( k <= m && l <= n ) { for ( int i = 0 ; i <= k ; i ++ ) { stk . append ( a [ k ] [ i ] ) k ++ ; stk . append ( a [ m ] [ i ] ) m -- ; stk . append ( a [ i ] [ l ] ) l ++ ; } } } while ( k <= m && l <= n ) { for ( int i = 0 ; i <= k ; i ++ ) { stk . append ( a [ k ] [ i ] ) k ++ ; stk . append ( a [ m ] [ i ] ) m -- ; stk . append (

13.43
23.77
54.3
55.54
def printEqualModNumbers ( arr , n ) : arr . sort ( ) d = arr [ n - 1 ] - arr [ 0 ] v = [ ] i = 1 while ( i * i <= d ) : if ( d % i == 0 ) : v . append ( i ) if ( i != d / i ) : v . append ( d / i ) i += 1 for i in range ( len ( v ) ) : temp = arr [ 0 ] % v [ i ] j = 1 while ( j < n ) : if ( arr [ j ] % v [ i ] != temp ) : break j += 1 if ( j == n ) : print ( v [ i ] , end = "" )

static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + " " ) ; } }

static void printEqualModNumbers ( int [ ] arr , int n ) { int i = 1 ; int j = 1 ; while ( j < n ) { if ( arr [ j ] % v [ i ] != 0 ) { v . append ( j ) if ( j != n ) { v . append ( j ) if ( j != n ) { v . append ( j ) if ( j != n ) { v . append ( j ) if ( j != n

static void printEqualModNumbers ( int arr [ ] , int n ) { int d = arr [ n - 1 ] - arr [ 0 ] ; int v [ ] = new int [ n ] ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) v . append ( i ) ; if ( i != d / i ) v . append ( d / i ) ; i ++ ; } } for ( int i = 1 ; i < n ; i ++ ) { temp = arr [ 0 ] % v [ i ] ; j = 1 ; while ( j < n ) { if ( arr [ j ] % v [ i ] != temp ) { break j ++ ; } } j ++ ; if ( j == n ) { print ( v [ i ] , end = "" ) ; } } }

13.55
24.46
24.42
22.82
def generateSquare ( n ) : magicSquare = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] i = n / 2 j = n - 1 num = 1 while num <= ( n * n ) : if i == - 1 and j == n : j = n - 2 i = 0 else : if j == n : j = 0 if i < 0 : i = n - 1 if magicSquare [ int ( i ) ] [ int ( j ) ] : j = j - 2 i = i + 1 continue else : magicSquare [ int ( i ) ] [ int ( j ) ] = num num = num + 1 j = j + 1 i = i - 1 print ( "MagicSqureforn=" , n ) print ( "Sumofeachroworcolumn" , n * ( n * n + 1 ) / 2 , "\n" ) for i in range ( 0 , n ) : for j in range ( 0 , n ) : print ( '%2d' % ( magicSquare [ i ] [ j ] ) , end = '' ) if j == n - 1 : print ( )

static void generateSquare ( int n ) { int [ ] [ ] magicSquare = new int [ n ] [ n ] ; int i = n / 2 ; int j = n - 1 ; for ( int num = 1 ; num <= n * n ; ) { if ( i == - 1 && j == n ) { j = n - 2 ; i = 0 ; } else { if ( j == n ) j = 0 ; if ( i < 0 ) i = n - 1 ; } if ( magicSquare [ i ] [ j ] != 0 ) { j -= 2 ; i ++ ; continue ; } else magicSquare [ i ] [ j ] = num ++ ; j ++ ; i -- ; } System . out . println ( "The Magic Square for " + n + ":" ) ; System . out . println ( "Sum of each row or column " + n * ( n * n + 1 ) / 2 + ":" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) System . out . print ( magicSquare [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

static void generateSquare ( int n ) { int i = 0 ; int j = 0 ; int num = 1 ; while ( num <= ( n * n + 1 ) ) { if ( i == - 1 ) i = 0 ; else j = n - 1 ; else if ( j == n ) j = n - 2 ; else if ( i == n - 1 ) j = n - 1 ; else if ( j == n ) i = 0 ; else if ( i

static void generateSquare ( int n ) { int i = n / 2 ; int j = n - 1 ; int num = 1 ; while ( num <= ( n * n ) ) { if ( i < 0 ) i = n - 1 ; if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) i = i + 1 ; else if ( magicSquare [ int ( i ) ] [

13.62
37.5
16.29
46.92
def smallest ( x , y , z ) : if ( not ( y / x ) ) : return y if ( not ( y / z ) ) else z return x if ( not ( x / z ) ) else z

static int smallest ( int x , int y , int z ) { if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ; return ( ( x / z ) != 1 ) ? x : z ; }

static double smallest ( double x , double y , double z ) { return x if ( not ( x / y ) ) else y if ( not ( y / z ) ) else z return x if ( not ( x / y ) ) else y if ( not ( y / z ) ) else z return x if ( not ( x / y ) ) else y if ( not ( x / z ) ) else z return y if ( not ( y / z ) )

public static int smallest ( int x , int y , int z ) { return x ; } public static int smallest ( int x , int y , int z ) { return y ; } public static int smallest ( int x , int y , int z ) { return x ; } public static int smallest ( int x , int y , int z ) { return y ; } public static int smallest ( int x , int y , int z ) { return x ; } public static int smallest ( int x , int y , int z ) { return z ; } }

13.63
30.69
58.07
50.85
def areacircumscribed ( a ) : return ( a * a * ( PI / 2 ) )

static float areacircumscribed ( float a ) { float PI = 3.14159265f ; return ( a * a * ( PI / 2 ) ) ; }

static double areacircumscribed ( double a ) { return ( a * a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*

static int areacircumscribed ( int a ) { return ( a * a * ( PI / 2 ) ) ; }

13.66
26.2
36.15
38.86
def maxLen ( arr , n ) : hash_map = { } curr_sum = 0 max_len = 0 ending_index = - 1 for i in range ( 0 , n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 else : arr [ i ] = 1 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if ( curr_sum == 0 ) : max_len = i + 1 ending_index = i if ( curr_sum + n ) in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum + n ] ) else : hash_map [ curr_sum ] = i for i in range ( 0 , n ) : if ( arr [ i ] == - 1 ) : arr [ i ] = 0 else : arr [ i ] = 1 print ( ending_index - max_len + 1 , end = "" ) print ( "to" , end = "" ) print ( ending_index ) return max_len

int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; int start_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_index = i ; } if ( hM . containsKey ( sum + n ) ) { if ( max_len < i - hM . get ( sum + n ) ) { max_len = i - hM . get ( sum + n ) ; ending_index = i ; } } else hM . put ( sum + n , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; } int end = ending_index - max_len + 1 ; System . out . println ( end + " to " + ending_index ) ; return max_len ; }

static int maxLen ( int arr [ ] , int n ) { int curr_sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = 0 ; else arr [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curr_sum == 0 ) {

static int maxLen ( int arr [ ] , int n ) { int curr_sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; if ( curr_sum == 0 ) max_len = i + 1 ; ending_index = i ; if ( curr_sum + n ) in hash_map ) max_len = max ( max_len , i - hash_map [ curr_sum + n ] ) ; else hash_map [ curr_sum + n ] = i ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; if ( curr_sum == 0 ) max_len = i + 1 ; ending_index = i ; if ( curr_sum + n ) in hash_map ) max_len = max ( max_len , i - hash_map [ curr_sum + n ] ) ; else hash_map [ curr_sum + n ] = i ; } } return max_len ; }

13.7
20.86
50.41
56.12
def stirlingFactorial ( n ) : if ( n == 1 ) : return 1 e = 2.71 z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) return math . floor ( z )

public static int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; double e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }

static int stirlingFactorial ( int n ) { float z = 0 ; if ( z == 0 ) return 1 ; return 0 ; } return stirlingFactorial ( n ) ; }

static int stirlingFactorial ( int n ) { int e = 2.71 ; int z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) ; return Math . floor ( z ) ; }

13.73
19.58
20.66
24.06
def isMajority ( a ) : mp = { } for i in a : if i in mp : mp [ i ] += 1 else : mp [ i ] = 1 for x in mp : if mp [ x ] >= len ( a ) // 2 : return True return False

static boolean isMajority ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; else mp . put ( a [ i ] , 1 ) ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ; return false ; }

static boolean isMajority ( int [ ] a ) { int [ ] mp = { } ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( mp [ i ] >= len ( a ) / 2 ) return true ; } return false ; }

public static boolean isMajority ( int a [ ] ) { int mp [ ] = new int [ len ( a ) ] ; for ( int i = 0 ; i < mp . length ; i ++ ) { if ( mp [ i ] >= mp . length ) return true ; if ( mp [ i ] >= mp . length ) return true ; } return false ; }

13.74
27.0
15.73
30.11
def countWords ( str , l ) : count = 1 ; if ( l == 1 ) : return count if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : count *= 2 for j in range ( 1 , l - 1 ) : if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : count *= 1 elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : count *= 2 else : count *= 3 if ( str [ l - 1 ] == str [ l - 2 ] ) : count *= 1 else : count *= 2 return count

static int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }

static int countWords ( String str , int l ) { int count = 1 ; if ( str [ 0 ] == str [ 1 ] ) { count *= 1 ; } else { count *= 2 ; if ( str [ 0 ] == str [ l - 1 ] ) { count *= 1 ; } else { count *= 3 ; if ( str [ l - 1 ] == str [ l - 2 ] ) { count *= 1 ; } else { count *= 2 ; if ( str

static int countWords ( String str , int l ) { int count = 1 ; if ( l == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ] == str [ 1 ] && str [ 1 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ] == str [ 1 ] && str [ 1 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ] == str [ 1 ] && str [ 1 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ] == str [ 1 ] && str [ 1 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ] == str [ 1 ] && str [ 1 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ] == str [ 1 ] && str [ 1 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ] == str [ 1 ] && str [ 1 ] == str [ 1 ] ) { count = 1 ; } else if ( str [ 0 ]

13.97
20.78
31.63
30.06
def NFG ( a , n ) : if ( n <= 0 ) : print ( "Listempty" ) return [ ] stack = [ 0 ] * n freq = { } for i in a : freq [ a [ i ] ] = 0 for i in a : freq [ a [ i ] ] += 1 res = [ 0 ] * n top = - 1 top += 1 stack [ top ] = 0 for i in range ( 1 , n ) : if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) : top += 1 stack [ top ] = i else : while ( top > - 1 and freq [ a [ stack [ top ] ] ] < freq [ a [ i ] ] ) : res [ stack [ top ] ] = a [ i ] top -= 1 top += 1 stack [ top ] = i while ( top > - 1 ) : res [ stack [ top ] ] = - 1 top -= 1 return res

static void NFG ( int a [ ] , int n , int freq [ ] ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; int res [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ] && s . size ( ) > 0 ) { res [ s . peek ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( s . size ( ) > 0 ) { res [ s . peek ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " " ) ; } }

static int NFG ( int [ ] a , int n ) { int [ ] res = new int [ n ] ; int top = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) { top += 1 ; stack [ top ] = i ; } else { while ( top > - 1 ) res [ stack [ top ] ] = 0 ; } } }

static int NFG ( int [ ] a , int n ) { int [ ] res = new int [ n ] ; int [ ] stack = new int [ n ] ; int top = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ a [ i ] ] > freq [ a [ i ] ] ) { top += 1 ; stack [ top ] = i ; } else { while ( top > - 1 && freq [ a [ stack [ top ] ] > freq [ a [ i ] ] ) { res [ stack [ top ] ] = a [ i ] ; top -= 1 top += 1 stack [ top ] = i ; } } while ( top > - 1 ) { res [ stack [ top ] ] = a [ i ] ; top -= 1 top += 1 stack [ top ] = i ; } } return res ; }

14.02
28.72
56.37
54.49
def findIndex ( str ) : l = len ( str ) open = [ None ] * ( l + 1 ) close = [ None ] * ( l + 1 ) index = - 1 open [ 0 ] = 0 close [ l ] = 0 if ( str [ 0 ] == '(' ) : open [ 1 ] = 1 if ( str [ l - 1 ] == ')' ) : close [ l - 1 ] = 1 for i in range ( 1 , l ) : if ( str [ i ] == '(' ) : open [ i + 1 ] = open [ i ] + 1 else : open [ i + 1 ] = open [ i ] for i in range ( l - 2 , - 1 , - 1 ) : if ( str [ i ] == ')' ) : close [ i ] = close [ i + 1 ] + 1 else : close [ i ] = close [ i + 1 ] if ( open [ l ] == 0 ) : return len if ( close [ 0 ] == 0 ) : return 0 for i in range ( l + 1 ) : if ( open [ i ] == close [ i ] ) : index = i return index

static int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == '(' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ')' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ')' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }

static int findIndex ( String str ) { int l = str . length ( ) ; int open [ ] = new int [ l + 1 ] ; int close [ ] = new int [ l + 1 ] ; for ( int i = 0 ; i < l ; i ++ ) { if ( str [ i ] == '(' ) open [ i ] = open [ i ] + 1 ; else close [ i ] = close [ i ] + 1 ; for ( int i =

static int findIndex ( String str ) { int l = str . length ( ) ; int open [ ] = new int [ l + 1 ] ; int close [ ] = new int [ l + 1 ] ; for ( int i = 0 ; i < l ; i ++ ) { if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] + 1 ; if ( str . charAt ( i ) == ')' ) open [ i + 1 ] = open [ i + 1 ] + 1 ; else open [ i + 1 ] = open [ i ] ; if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i + 1 ] + 1 ; else open [ i + 1 ] = open [ i ] ; if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i + 1 ] + 1 ; else open [ i + 1 ] = open [ i ] ; if ( str . charAt ( i ) == ')' ) close [ i + 1 ] = close [ i ] ; if ( open [ i ] == ')' ) close [ i

14.06
27.29
28.75
35.39
def countEndless ( input_mat , n ) : row = np . zeros ( ( n , n ) ) col = np . zeros ( ( n , n ) ) for j in range ( n ) : isEndless = 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 col [ i ] [ j ] = isEndless for i in range ( n ) : isEndless = 1 for j in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 row [ i ] [ j ] = isEndless ans = 0 for i in range ( n ) : for j in range ( 1 , n ) : if ( row [ i ] [ j ] and col [ i ] [ j ] ) : ans += 1 return ans

static int countEndless ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] ; boolean col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }

static int countEndless ( int [ ] input_mat , int n ) { int [ ] row = new int [ n ] [ n ] ; int [ ] col = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( input_mat [ i ] [ j ] == 0 ) { isEndless = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if (

static int countEndless ( int [ ] input_mat , int n ) { int [ ] row = np . zeros ( ( n , n ) ) ; int [ ] col = np . zeros ( ( n , n ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input_mat [ i ] [ j ] == 0 ) isEndless = 1 for j in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 for j in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 for j in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) is

14.08
25.9
45.87
57.46
def search ( mat , fromRow , toRow , fromCol , toCol , key ) : i = fromRow + ( toRow - fromRow ) // 2 j = fromCol + ( toCol - fromCol ) // 2 if ( mat [ i ] [ j ] == key ) : print ( "Found" , key , "at" , i , "" , j ) else : if ( i != toRow or j != fromCol ) : search ( mat , fromRow , i , j , toCol , key ) if ( fromRow == toRow and fromCol + 1 == toCol ) : if ( mat [ fromRow ] [ toCol ] == key ) : print ( "Found" , key , "at" , fromRow , "" , toCol ) if ( mat [ i ] [ j ] < key ) : if ( i + 1 <= toRow ) : search ( mat , i + 1 , toRow , fromCol , toCol , key ) else : if ( j - 1 >= fromCol ) : search ( mat , fromRow , toRow , fromCol , j - 1 , key )

public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) { int i = fromRow + ( toRow - fromRow ) / 2 ; int j = fromCol + ( toCol - fromCol ) / 2 ; if ( mat [ i ] [ j ] == key ) System . out . println ( "Found " + key + " at " + i + " " + j ) ; else { if ( i != toRow || j != fromCol ) search ( mat , fromRow , i , j , toCol , key ) ; if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) System . out . println ( "Found " + key + " at " + fromRow + " " + toCol ) ; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= toRow ) search ( mat , i + 1 , toRow , fromCol , toCol , key ) ; } else { if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ; } } }

static void search ( int [ ] mat , int fromRow , int toRow , int fromCol , int toCol ) { int i = fromRow ; int j = fromCol ; if ( mat [ i ] [ j ] < key ) { if ( mat [ i ] [ j ] > key ) { if ( mat [ i ] [ j ] < key ) { if ( mat [ i ] [ j ] > key ) { if ( mat [ i ] [ j

static void search ( int mat , int fromRow , int toRow , int fromCol , int toCol , int key ) { int i = fromRow + ( toRow - fromRow ) / 2 ; int j = fromCol + ( toCol - fromCol ) / 2 ; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= toRow ) search ( mat , i + 1 , toRow , fromCol , toCol , key ) ; else if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ; else if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ; } }

14.17
29.42
18.24
32.75
def getCount ( keypad , n ) : if ( not keypad or n <= 0 ) : return 0 if ( n == 1 ) : return 10 odd = [ 0 ] * 10 even = [ 0 ] * 10 i = 0 j = 0 useOdd = 0 totalCount = 0 for i in range ( 10 ) : odd [ i ] = 1 for j in range ( 2 , n + 1 ) : useOdd = 1 - useOdd if ( useOdd == 1 ) : even [ 0 ] = odd [ 0 ] + odd [ 8 ] even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] else : odd [ 0 ] = even [ 0 ] + even [ 8 ] odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] totalCount = 0 if ( useOdd == 1 ) : for i in range ( 10 ) : totalCount += even [ i ] else : for i in range ( 10 ) : totalCount += odd [ i ] return totalCount

static int getCount ( char keypad [ ] [ ] , int n ) { if ( keypad == null || n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }

static int getCount ( int keypad , int n ) { int totalCount = 0 ; int i = 0 ; int j = 0 ; int useOdd = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int odd [ ] = 0 ; int even [ ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 1 ] + odd [ 2 ] + odd [ 3 ] + odd [ 2 ] + odd [ 4 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( useOdd == 1 ) { even [ ] = 0 ; for ( int j = 0 ; j ++ ) { if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 1 ] + odd [ 2 ] + odd [ 3 ] + odd [ 2 ] + odd [ 3 ] + odd [ 4 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] + odd [ 4 ] + odd [ 5 ] +

static int getCount ( int keypad , int n ) { int totalCount = 0 ; int odd [ 0 ] = odd [ 0 ] + odd [ 8 ] ; int even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 3 ] + odd [ 4 ] ; int even [ 2 ] = odd [ 2 ] + odd [ 3 ] + odd [ 5 ] ; int even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] ; int even [ 5 ] = odd [ 5 ] + odd [ 1 ] + odd [ 4 ] + odd [ 8 ] ; int even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 8 ] ; int even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; int even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; int even [ 9 ] = odd [ 9 ] + odd [ 0 ] + odd [ 5 ] + odd [ 8 ] ; int even [ 9 ] = odd [ 9 ] + odd [ 0 ] + odd [

14.17
27.82
61.45
48.45
def longestRepeatedSubstring ( str ) : n = len ( str ) LCSRe = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] res = "" res_length = 0 index = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) : LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 if ( LCSRe [ i ] [ j ] > res_length ) : res_length = LCSRe [ i ] [ j ] index = max ( i , index ) else : LCSRe [ i ] [ j ] = 0 if ( res_length > 0 ) : for i in range ( index - res_length + 1 , index + 1 ) : res = res + str [ i - 1 ] return res

static String longestRepeatedSubstring ( String str ) { int n = str . length ( ) ; int LCSRe [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; String res = "" ; int res_length = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) { LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ; if ( LCSRe [ i ] [ j ] > res_length ) { res_length = LCSRe [ i ] [ j ] ; index = Math . max ( i , index ) ; } } else { LCSRe [ i ] [ j ] = 0 ; } } } if ( res_length > 0 ) { for ( i = index - res_length + 1 ; i <= index ; i ++ ) { res += str . charAt ( i - 1 ) ; } } return res ; }

static int longestRepeatedSubstring ( String str ) { int n = str . length ( ) ; int [ ] [ ] LCSRe [ ] [ ] = new int [ n + 1 ] [ n + 1 ] [ ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= j ; j ++ ) { if ( LCSRe [ i ] [ j ] > res_length ) res_length =

static String longestRepeatedSubstring ( String str , int n ) { int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && LCSRe [ i ] [ j - 1 ] < ( j - i ) ) { LCSRe [ i ] [ j ] = LCSRe [ i ] [ j - 1 ] + 1 ; if ( LCSRe [ i ] [ j ] > res_length ) { res_length = LCSRe [ i ] [ j ] ; index = max ( i , index ) ; } else { LCSRe [ i ] [ j ] = 0 ; index = max ( i , index ) ; } } } if ( res_length > 0 ) { for i in range ( index - res_length + 1 , index + 1 ) { res = res + str [ i - 1 ] ; } } } return res ; }

14.32
23.35
42.28
47.58
def solveWordWrap ( arr , n , k ) : dp = [ 0 ] * n ans = [ 0 ] * n dp [ n - 1 ] = 0 ans [ n - 1 ] = n - 1 for i in range ( n - 2 , - 1 , - 1 ) : currlen = - 1 dp [ i ] = sys . maxsize for j in range ( i , n ) : currlen += ( arr [ j ] + 1 ) if ( currlen > k ) : break if ( j == n - 1 ) : cost = 0 else : cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) if ( cost < dp [ i ] ) : dp [ i ] = cost ans [ i ] = j i = 0 while ( i < n ) : print ( i + 1 , ans [ i ] + 1 , end = "" ) i = ans [ i ] + 1

static void solveWordWrap ( int arr [ ] , int n , int k ) { int i , j ; int currlen ; int cost ; int dp [ ] = new int [ n ] ; int ans [ ] = new int [ n ] ; dp [ n - 1 ] = 0 ; ans [ n - 1 ] = n - 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { currlen = - 1 ; dp [ i ] = Integer . MAX_VALUE ; for ( j = i ; j < n ; j ++ ) { currlen += ( arr [ j ] + 1 ) ; if ( currlen > k ) break ; if ( j == n - 1 ) cost = 0 ; else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } } i = 0 ; while ( i < n ) { System . out . print ( ( i + 1 ) + " " + ( ans [ i ] + 1 ) + " " ) ; i = ans [ i ] + 1 ; } }

static void solveWordWrap ( int arr [ ] , int k ) { int dp [ ] = new int [ n - 2 ] ; int ans [ ] = new int [ n - 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int currlen = - 1 ; for ( int j = i ; j < n ; j ++ ) { if ( currlen > k ) { break if ( j == n - 1 ) {

static void solveWordWrap ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int currlen = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { currlen += arr [ j ] + 1 ; if ( currlen > k ) { break ; } if ( j == n - 1 ) { cost = 0 ; } else : cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } } return ; }

14.39
25.48
46.07
47.67
def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : sum1 , sum2 , sum3 = 0 , 0 , 0 for i in range ( n1 ) : sum1 += stack1 [ i ] for i in range ( n2 ) : sum2 += stack2 [ i ] for i in range ( n3 ) : sum3 += stack3 [ i ] top1 , top2 , top3 = 0 , 0 , 0 ans = 0 while ( 1 ) : if ( top1 == n1 or top2 == n2 or top3 == n3 ) : return 0 if ( sum1 == sum2 and sum2 == sum3 ) : return sum1 if ( sum1 >= sum2 and sum1 >= sum3 ) : sum1 -= stack1 [ top1 ] top1 = top1 + 1 elif ( sum2 >= sum3 and sum2 >= sum3 ) : sum2 -= stack2 [ top2 ] top2 = top2 + 1 elif ( sum3 >= sum2 and sum3 >= sum1 ) : sum3 -= stack3 [ top3 ] top3 = top3 + 1

public static int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum1 += stack1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum2 += stack2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum3 += stack3 [ i ] ; int top1 = 0 , top2 = 0 , top3 = 0 ; int ans = 0 ; while ( true ) { if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ; if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ] ; else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ] ; else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ] ; } }

static int maxSum ( int stack1 , int stack2 , int stack3 , int n1 , int n2 , int n3 ) { int sum1 , sum2 , sum3 ; for ( int i = 0 ; i < stack1 . length ; i ++ ) { sum1 += stack1 [ i ] ; for ( int i = 0 ; i < stack2 . length ; i ++ ) { sum2 += stack2 [ i ] ; for ( int i =

static int maxSum ( int stack1 , int stack2 , int stack3 , int n1 , int n2 , int n3 ) { int sum1 = 0 ; int sum2 = 0 ; int sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { sum1 += stack1 [ i ] ; sum2 += stack2 [ i ] ; sum3 += stack3 [ i ] ; } if ( sum1 >= sum2 && sum1 >= sum3 ) { sum2 -= stack2 [ i ] ; } if ( sum2 >= sum3 && sum2 >= sum1 ) { sum2 -= stack2 [ i ] ; } if ( sum3 >= sum2 && sum3 >= sum1 ) { sum3 -= stack3 [ i ] ; } if ( sum1 >= sum2 && sum1 >= sum3 ) { sum1 -= stack1 [ i ] ; } if ( sum2 >= sum3 && sum2 >= sum1 ) { sum2 -= stack2 [ i ] ; } if ( sum3 >= sum2 && sum3 >= sum1 ) { sum3 -= stack3 [ i ] ; } if ( sum1 >= sum2 && sum1 >= sum

14.4
31.61
56.93
52.37
def maxSumBitonicSubArr ( arr , n ) : msis = [ None ] * n msds = [ None ] * n max_sum = 0 msis [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ i - 1 ] ) : msis [ i ] = msis [ i - 1 ] + arr [ i ] else : msis [ i ] = arr [ i ] msds [ n - 1 ] = arr [ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : msds [ i ] = msds [ i + 1 ] + arr [ i ] else : msds [ i ] = arr [ i ] for i in range ( n ) : if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) return max_sum

static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = Integer . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }

static long maxSumBitonicSubArr ( long [ ] arr , int n ) { long [ ] msis = new long [ n ] ; long [ ] msds = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msds [ i ] = arr

static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int msis [ ] = new int [ n ] ; int msds [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { msis [ i ] = msis [ i - 1 ] + arr [ i ] ; } else if ( arr [ i ] > arr [ i + 1 ] ) { msis [ i ] = msis [ i + 1 ] + arr [ i ] ; } else if ( arr [ i ] > arr [ i + 1 ] ) { msds [ i ] = msds [ i + 1 ] + arr [ i ] ; } else if ( arr [ i ] > arr [ i + 1 ] ) { msds [ i ] = msds [ i + 1 ] + arr [ i ] ; } else if ( arr [ i ] > arr [ i + 1 ] ) { msds [ i ] = msds [ i + 1 ] + arr [ i ] ; } else if ( arr [ i ] > arr [ i + 1 ] ) { msds

14.53
31.2
49.91
45.33
def bestFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : bestIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if bestIdx == - 1 : bestIdx = j elif blockSize [ bestIdx ] > blockSize [ j ] : bestIdx = j if bestIdx != - 1 : allocation [ i ] = bestIdx blockSize [ bestIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )

static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == - 1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != - 1 ) { allocation [ i ] = bestIdx ; blockSize [ bestIdx ] -= processSize [ i ] ; } } System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( "Not Allocated" ) ; System . out . println ( ) ; } }

static void bestFit ( int blockSize [ ] , int processSize [ ] , int n ) { int bestIdx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( blockSize [ i ] >= processSize [ i ] ) { if ( allocation [ i ] != - 1 ) { print ( allocation [ i ] + 1 , "" , blockSize [ i ] , end = "" ) ; } else { if ( bestIdx != - 1 ) {

static void bestFit ( int blockSize , int m , int processSize , int n ) { int bestIdx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { bestIdx = i ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == - 1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; if ( bestIdx == - 1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != - 1 ) { print ( i + 1 , "" , processSize [ i ] , end = "" ) ; if ( allocation [ i ] != - 1 ) { print ( allocation [ i ] + 1 ) ; } else { print ( "NotAllocated" ) ; } } } } return ; }

14.82
21.28
24.87
30.07
def findLIS ( A , n ) : hash = dict ( ) LIS_size , LIS_index = 1 , 0 hash [ A [ 0 ] ] = 1 for i in range ( 1 , n ) : if A [ i ] - 1 not in hash : hash [ A [ i ] - 1 ] = 0 hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 if LIS_size < hash [ A [ i ] ] : LIS_size = hash [ A [ i ] ] LIS_index = A [ i ] print ( "LIS_size=" , LIS_size ) print ( "LIS:" , end = "" ) start = LIS_index - LIS_size + 1 while start <= LIS_index : print ( start , end = "" ) start += 1

static void findLIS ( int A [ ] , int n ) { Map < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; int LIS_size = 1 ; int LIS_index = 0 ; hash . put ( A [ 0 ] , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { hash . put ( A [ i ] , hash . get ( A [ i ] - 1 ) == null ? 1 : hash . get ( A [ i ] - 1 ) + 1 ) ; if ( LIS_size < hash . get ( A [ i ] ) ) { LIS_size = hash . get ( A [ i ] ) ; LIS_index = A [ i ] ; } } System . out . println ( "LIS_size = " + LIS_size ) ; System . out . print ( "LIS : " ) ; int start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { System . out . print ( start + " " ) ; start ++ ; } }

static void findLIS ( int [ ] A , int n ) { int LIS_size = 1 ; int LIS_index = 1 ; int hash [ ] = new int [ A [ 0 ] ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( hash [ A [ i ] - 1 ] == 0 ) hash [ A [ i ] - 1 ] = 1 ; else hash [ A [ i ] - 1 ] ++ ;

static void findLIS ( int [ ] A , int n ) { int hash [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] - 1 not in hash ) hash [ A [ i ] - 1 ] = 0 ; hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ; if ( LIS_size < hash [ A [ i ] ] ) LIS_size = hash [ A [ i ] ] ; LIS_index = A [ i ] ; } }

14.89
27.78
46.28
48.62
def perfectSquare ( s ) : n = len ( s ) ans = - 1 num = "" for i in range ( 1 , ( 1 << n ) ) : str = "" for j in range ( 0 , n ) : if ( ( i >> j ) & 1 ) : str = str + s [ j ] if ( str [ 0 ] != '0' ) : temp = 0 for j in range ( 0 , len ( str ) ) : temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) k = int ( math . sqrt ( temp ) ) if ( k * k == temp ) : if ( ans < len ( str ) ) : ans = len ( str ) num = str if ( ans == - 1 ) : return ans else : print ( "{}" . format ( num ) , end = "" ) return n - ans

static int perfectSquare ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = "" ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { String str = "" ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str += s . charAt ( j ) ; } } if ( str . charAt ( 0 ) != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' ) ; int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . length ( ) ) { ans = ( int ) str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { System . out . print ( num + " " ) ; return n - ans ; } }

static int perfectSquare ( String s ) { int ans = - 1 ; String str = "" ; for ( int i = 0 ; i < n ; i ++ ) { String str = str + s [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( str [ j ] != '0' ) { temp = ( temp * 10 + ( str [ j ] - '0' ) ) ; } } } return ans ; }

static int perfectSquare ( String s ) { int n = s . length ( ) ; String str = "" ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { if ( ( i >> j ) & 1 ) str = str + s [ i ] ; if ( str [ 0 ] != '0' ) temp = 0 for ( int j = 0 ; j < n ; j ++ ) temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) k = int ( math . sqrt ( temp ) ) ; if ( k * k == temp ) { if ( ans < len ( str ) ) ans = len ( str ) ; num = str ; if ( ans == - 1 ) return n - ans ; } } } return - 1 ; }

14.93
27.04
42.0
42.7
def findAndPrintUncommonChars ( str1 , str2 ) : present = [ 0 ] * MAX_CHAR for i in range ( 0 , MAX_CHAR ) : present [ i ] = 0 l1 = len ( str1 ) l2 = len ( str2 ) for i in range ( 0 , l1 ) : present [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = 1 for i in range ( 0 , l2 ) : if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == - 1 ) : present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = - 1 else : present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = 2 for i in range ( 0 , MAX_CHAR ) : if ( present [ i ] == 1 or present [ i ] == 2 ) : print ( chr ( i + ord ( 'a' ) ) , end = "" )

static void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 . charAt ( i ) - 'a' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - 'a' ] == 1 || present [ str2 . charAt ( i ) - 'a' ] == - 1 ) { present [ str2 . charAt ( i ) - 'a' ] = - 1 ; } else { present [ str2 . charAt ( i ) - 'a' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { System . out . print ( ( char ) ( i + 'a' ) + " " ) ; } } }

static void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( present [ i ] == 1 or present [ i ] == 2 ) { print ( str1 [ i ] ) - ord ( '

static void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; int l1 = len ( str1 ) ; l2 = len ( str2 ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = 1 ; for ( int j = 0 ; j < l2 ; j ++ ) { if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 1 || present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == - 1 ) { present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = - 1 ; } else if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 2 ) { present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = 2 ; } else if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 2 ) { present [ ord ( str2 [ i ] )

15.01
25.18
29.73
41.81
def getMissingNo ( A ) : n = len ( A ) total = ( n + 1 ) * ( n + 2 ) / 2 sum_of_A = sum ( A ) return total - sum_of_A

static int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }

static int getMissingNo ( int A [ ] ) { int n = A . length ( ) ; int sum_of_A = sum ( A ) ; int sum_of_A = sum_of_A / 2 ; int sum_of_A = sum_of_A / 2 ; int sum_of_A = sum_of_A / 2 ; int sum_of_A = sum_of_A / 2 ; int sum_of_

public static int getMissingNo ( A [ ] A ) { int n = A . length ; int total = 0 ; int sum_of_A = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total += A [ i ] . length ; sum_of_A += A [ i ] . length ; } return total - sum_of_A ; }

15.1
18.75
36.32
38.5
def policeThief ( arr , n , k ) : i = 0 l = 0 r = 0 res = 0 thi = [ ] pol = [ ] while i < n : if arr [ i ] == 'P' : pol . append ( i ) elif arr [ i ] == 'T' : thi . append ( i ) i += 1 while l < len ( thi ) and r < len ( pol ) : if ( abs ( thi [ l ] - pol [ r ] ) <= k ) : res += 1 l += 1 r += 1 elif thi [ l ] < pol [ r ] : l += 1 else : r += 1 return res

static int policeThief ( char arr [ ] , int n , int k ) { int res = 0 ; ArrayList < Integer > thi = new ArrayList < Integer > ( ) ; ArrayList < Integer > pol = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 'P' ) pol . add ( i ) ; else if ( arr [ i ] == 'T' ) thi . add ( i ) ; } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi . get ( l ) < pol . get ( r ) ) l ++ ; else r ++ ; } return res ; }

static int policeThief ( char arr [ ] , int k ) { int i = 0 ; int l = 0 ; int r = 0 ; int res = 0 ; int thi = [ ] ; while ( l < len ( thi ) && r < len ( pol ) ) { if ( thi [ l ] < pol [ r ] ) res += 1 l += 1 ; else res += 1 while ( l < len ( pol ) && r < len (

static int policeThief ( String arr [ ] , int n , int k ) { int i = 0 ; int l = 0 ; int r = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 'P' ) { pol . append ( i ) ; } else if ( arr [ i ] == 'T' ) { pol . append ( i ) ; } else if ( arr [ i ] == 'P' ) { poli . append ( i ) ; } else if ( arr [ i ] == 'T' ) { poli . append ( i ) ; } else if ( arr [ i ] == 'P' ) { poli . append ( i ) ; } else if ( arr [ i ] == 'T' ) { poli . append ( i ) ; } else if ( arr [ i ] == 'P' ) { poli . append ( i ) ; } else if ( arr [ i ] == 'T' ) { poli . append ( i ) ; } } } return res ; }

15.14
29.08
45.49
50.45
def shortestSeq ( S : list , T : list ) : m = len ( S ) n = len ( T ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for i in range ( m + 1 ) : dp [ i ] [ 0 ] = 1 for i in range ( n + 1 ) : dp [ 0 ] [ i ] = MAX for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : ch = S [ i - 1 ] k = j - 1 while k >= 0 : if T [ k ] == ch : break k -= 1 if k == - 1 : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ans = dp [ m ] [ n ] if ans >= MAX : ans = - 1 return ans

static int shortestSeq ( char [ ] S , char [ ] T ) { int m = S . length , n = T . length ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; }

static int shortestSeq ( int S [ ] , int T [ ] ) { int m = S . length ( ) ; int n = T . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) break ; } } return

static int shortestSeq ( int S [ ] , int T [ ] ) { int m = len ( S ) ; int n = len ( T ) ; int dp [ ] [ ] = new int [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int ch = S [ i ] ; int k = j - 1 ; while ( k >= 0 ) { if ( T [ k ] == ch ) break ; k -- ; if ( k == - 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } return ans ; }

15.27
24.2
42.8
42.86
def findRepeatingNumber ( arr , n ) : sq = sqrt ( n ) range__ = int ( ( n / sq ) + 1 ) count = [ 0 for i in range ( range__ ) ] for i in range ( 0 , n + 1 , 1 ) : count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1 selected_block = range__ - 1 for i in range ( 0 , range__ - 1 , 1 ) : if ( count [ i ] > sq ) : selected_block = i break m = { i : 0 for i in range ( n ) } for i in range ( 0 , n + 1 , 1 ) : if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) : m [ arr [ i ] ] += 1 if ( m [ arr [ i ] ] > 1 ) : return arr [ i ] return - 1

static int findRepeatingNumber ( int [ ] arr , int n ) { int sq = ( int ) Math . sqrt ( n ) ; int range = ( n / sq ) + 1 ; int [ ] count = new int [ range ] ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m . put ( arr [ i ] , 1 ) ; if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; } } return - 1 ; }

static int findRepeatingNumber ( int arr [ ] , int n ) { int count [ ] = 0 ; int selected_block = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ int ( arr [ i ] - 1 ) / sq ) ] ++ ; if ( count [ int ( arr [ i ] - 1 ) / sq ) > 1 ) { selected_block = i ; } } return - 1 ; }

static int findRepeatingNumber ( int arr [ ] , int n ) { int sq = sqrt ( n ) ; int count [ int ( arr [ ] - 1 ) / sq ] += 1 ; selected_block = range__ - 1 for i in range ( 0 , range__ - 1 , 1 ) { if ( count [ i ] > sq ) selected_block = i break ; m = { i : 0 for i in range ( 0 , range__ - 1 , 1 ) } for ( i in range ( 0 , range__ - 1 , 1 ) ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) m [ arr [ i ] ] += 1 ; if ( m [ arr [ i ] ] > 1 ) return arr [ i ] ; } } return - 1 ; }

15.39
21.9
24.25
22.39
def costToBalance ( s ) : if ( len ( s ) == 0 ) : print ( 0 ) ans = 0 o = 0 c = 0 for i in range ( len ( s ) ) : if ( s [ i ] == '(' ) : o += 1 if ( s [ i ] == ')' ) : c += 1 if ( o != c ) : return - 1 a = [ 0 for i in range ( len ( s ) ) ] if ( s [ 0 ] == '(' ) : a [ 0 ] = 1 else : a [ 0 ] = - 1 if ( a [ 0 ] < 0 ) : ans += abs ( a [ 0 ] ) for i in range ( 1 , len ( s ) ) : if ( s [ i ] == '(' ) : a [ i ] = a [ i - 1 ] + 1 else : a [ i ] = a [ i - 1 ] - 1 if ( a [ i ] < 0 ) : ans += abs ( a [ i ] ) return ans

static int costToBalance ( String s ) { if ( s . length ( ) == 0 ) System . out . println ( 0 ) ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' ) o ++ ; if ( s . charAt ( i ) == ')' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == '(' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; }

static int costToBalance ( String s ) { int ans = 0 ; int o = 0 ; int c = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( s [ i ] == '(' ) o += 1 ; if ( s [ i ] == ')' ) c += 1 ; if ( o != c ) ans += 1 ; if ( s [ i ] == ')' ) c += 1 ; if ( s [ i ] < 0 ) ans +=

int costToBalance ( String s ) { int ans = 0 ; int o = 0 ; int c = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( s [ i ] == '(' ) { o += 1 ; } else if ( s [ i ] == ')' ) { c += 1 ; } else if ( s [ i ] == '(' ) { c += 1 ; } else if ( s [ i ] == ')' ) { c += 1 ; } else if ( s [ i ] == '(' ) { c += 1 ; } else if ( s [ i ] == ')' ) { c += 1 ; } else if ( s [ i ] == '(' ) { c += 1 ; } else if ( s [ i ] == ')' ) { c += 1 ; } else if ( s [ i ] == '(' ) { c += 1 ; } else if ( s [ i ] == ')' ) { c += 1 ; } else if ( s [ i ] == '(' ) { c += 1 ; } else if ( s [ i ] == ')' ) { c += 1 ; } else if ( s [ i ] == '(' ) { c += 1 ; } else if ( s [

15.47
31.65
72.86
73.56
def circumferenceparallelogram ( a , b ) : return ( ( 2 * a ) + ( 2 * b ) )

static float circumferenceparallelogram ( float a , float b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; }

static int circumferenceparallelogram ( int a , int b ) { int circumferenceparallelogram ( int a , int b ) ; return circumferenceparallelogram ( a , b ) ; }

public static int circumferenceparallelogram ( int a , int b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; }

15.5
19.55
32.66
33.53
def findFibSubset ( arr , n ) : m = max ( arr ) a = 0 b = 1 hash = [ ] hash . append ( a ) hash . append ( b ) while ( b < m ) : c = a + b a = b b = c hash . append ( b ) for i in range ( n ) : if arr [ i ] in hash : print ( arr [ i ] , end = "" )

public static void findFibSubset ( Integer [ ] x ) { Integer max = Collections . max ( Arrays . asList ( x ) ) ; List < Integer > fib = new ArrayList < Integer > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; Integer a = 0 ; Integer b = 1 ; while ( b < max ) { Integer c = a + b ; a = b ; b = c ; fib . add ( c ) ; } for ( Integer i = 0 ; i < x . length ; i ++ ) { if ( fib . contains ( x [ i ] ) ) { result . add ( x [ i ] ) ; } } System . out . println ( result ) ; }

static int findFibSubset ( int arr [ ] , int n ) { int hash [ ] = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] in hash ) { System . out . print ( arr [ i ] + " " + hash [ i ] + " " ) ; } else { System . out . print ( arr [ i ] + " " ) ; } } }

static void findFibSubset ( int arr [ ] , int n ) { int m = max ( arr ) ; int a = 0 ; int b = 1 ; int hash = [ ] ; hash . append ( a ) ; hash . append ( b ) ; while ( b < m ) { c = a + b a ; a = b ; b = c ; hash . append ( b ) ; } while ( a < m ) { c = a + b ; a = b ; b = c ; hash . append ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in hash ) { print ( arr [ i ] , end = "" ) ; } } } }

15.76
24.35
49.63
47.73
def minSum ( ar , n ) : if ( n <= 4 ) : return min ( ar ) sum = [ 0 for i in range ( n ) ] sum [ 0 ] = ar [ 0 ] sum [ 1 ] = ar [ 1 ] sum [ 2 ] = ar [ 2 ] sum [ 3 ] = ar [ 3 ] for i in range ( 4 , n ) : sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) return min ( sum [ n - 4 : n ] )

static int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) ; return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( ) ; }

static int minSum ( int ar [ ] , int n ) { int sum [ ] = new int [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) ; } return min ( sum ) ; }

static int minSum ( int ar [ ] , int n ) { int sum [ ] = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) ; } return min ( sum [ n - 4 : n ] ) ; }

15.77
32.02
13.8
27.07
def minTime ( n , k , a ) : a . sort ( reverse = True ) minTime = 0 for i in range ( 0 , n , k ) : minTime += ( 2 * a [ i ] ) return minTime

static int minTime ( int n , int k , int a [ ] ) { int temp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) { temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } } } int minTime = 0 ; for ( int i = 0 ; i < n ; i += k ) minTime += ( 2 * a [ i ] ) ; return minTime ; }

static long minTime ( int n , int k , int a [ ] ) { long minTime = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minTime += a [ i ] ; } return minTime ; }

static int minTime ( int n , int k ) { int minTime = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minTime += 2 * a [ i ] ; } return minTime ; }

15.78
22.66
95.34
95.44
def pentagonalNum ( n ) : return ( 3 * n * n - n ) / 2

int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }

def pentagonalNum ( n ) { return ( n

static int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }

15.98
27.49
40.29
38.86
def maxdiff ( arr , n ) : freq = defaultdict ( lambda : 0 ) for i in range ( n ) : freq [ arr [ i ] ] += 1 ans = 0 for i in range ( n ) : for j in range ( n ) : if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) return ans

static int maxdiff ( int arr [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; }

static int maxdiff ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] ) ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; } return ans ; }

static int maxdiff ( int arr [ ] , int n ) { int freq = defaultdict ( int ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }

16.05
29.82
63.83
52.92
def arrangeBraces ( n , pos , k ) : h = [ False for i in range ( N ) ] dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] for i in range ( k ) : h [ pos [ i ] ] = 1 dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , 2 * n + 1 ) : for j in range ( 2 * n + 1 ) : if ( h [ i ] ) : if ( j != 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 0 else : if ( j != 0 ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) else : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] return dp [ 2 * n ] [ 0 ]

static long arrangeBraces ( int n , int pos [ ] , int k ) { boolean h [ ] = new boolean [ N ] ; int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } else if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }

static int arrangeBraces ( int N , int [ ] pos , int k ) { int [ ] dp = [ [ 0 for i in range ( N ) ] ; for ( int i = 0 ; i < k ; i ++ ) { if ( h [ pos [ i ] ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else {

static int arrangeBraces ( int n , int pos , int k ) { boolean h [ ] = false ; for ( int i = 1 ; i < N ; i ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } else { dp [ i ] [ j ] = 0 ; } } else { if ( j != 0 ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } else { if ( j != 0 ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } else { dp [ i ] [ j ] = 0 ; } } } } return dp [ 2 * n ] [ 0 ] ; }

16.05
22.25
29.42
34.06
def firstnonrepeating ( Str ) : global MAX_CHAR q = Queue ( ) charCount = [ 0 ] * MAX_CHAR for i in range ( len ( Str ) ) : q . put ( Str [ i ] ) charCount [ ord ( Str [ i ] ) - ord ( 'a' ) ] += 1 while ( not q . empty ( ) ) : if ( charCount [ ord ( q . queue [ 0 ] ) - ord ( 'a' ) ] > 1 ) : q . get ( ) else : print ( q . queue [ 0 ] , end = "" ) break if ( q . empty ( ) ) : print ( - 1 , end = "" ) print ( )

static void firstNonRepeating ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; Queue < Character > q = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; q . add ( ch ) ; charCount [ ch - 'a' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( charCount [ q . peek ( ) - 'a' ] > 1 ) q . remove ( ) ; else { System . out . print ( q . peek ( ) + " " ) ; break ; } } if ( q . isEmpty ( ) ) System . out . print ( - 1 + " " ) ; } System . out . println ( ) ; }

static void firstnonrepeating ( String Str ) { int charCount [ ] ; for ( int i = 0 ; i < len ( Str ) ; i ++ ) { if ( charCount [ ord ( Str [ i ] ) - ord ( 'a' ) ] > 1 ) { q . get ( ) ; } else { if ( charCount [ ord ( Str [ i ] ) - ord ( 'a' ) ] > 1 ) { q . get ( ) ;

static void firstnonrepeating ( String Str ) { Queue q = new Queue ( ) ; charCount = new int [ ] * MAX_CHAR ; for ( int i = 0 ; i < len ( Str ) ; i ++ ) { q . put ( Str [ i ] ) charCount [ ord ( Str [ i ] ) - ord ( 'a' ) ] += 1 ; while ( ! q . empty ( ) ) { if ( charCount [ ord ( q . queue [ 0 ] ) - ord ( 'a' ) ] > 1 ) { q . get ( ) ; } else { print ( q . queue [ 0 ] , end = "" ) ; } } } }

16.06
30.5
46.4
47.69
def findRoots ( a , b , c ) : if a == 0 : print ( "Invalid" ) return - 1 d = b * b - 4 * a * c sqrt_val = math . sqrt ( abs ( d ) ) if d > 0 : print ( "Rootsarerealanddifferent" ) print ( ( - b + sqrt_val ) / ( 2 * a ) ) print ( ( - b - sqrt_val ) / ( 2 * a ) ) elif d == 0 : print ( "Rootsarerealandsame" ) print ( - b / ( 2 * a ) ) else : print ( "Rootsarecomplex" ) print ( - b / ( 2 * a ) , "+i" , sqrt_val ) print ( - b / ( 2 * a ) , "-i" , sqrt_val )

void findRoots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( "Invalid" ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( "Roots are real and different \n" ) ; System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + "\n" + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else { System . out . println ( "Roots are complex \n" ) ; System . out . println ( - ( double ) b / ( 2 * a ) + " + i" + sqrt_val + "\n" + - ( double ) b / ( 2 * a ) + " - i" + sqrt_val ) ; } }

static int findRoots ( int a , int b , int c ) { int d = b * b - 4 * a * c ; if ( d < 0 ) print ( "Rootsarerealanddifferent" ) print ( ( - b + sqrt_val ) / ( 2 * a ) ) ; else print ( "Rootsarerealandsame" ) print ( - b / ( 2 * a ) ) ; else print ( "Rootsarecomplex" ) print

static int findRoots ( int a , int b , int c ) { int d = b * b - 4 * a * c ; int sqrt_val = math . sqrt ( abs ( d ) ) ; if ( d > 0 ) { print ( "Rootsarerealanddifferent" ) print ( ( - b + sqrt_val ) / ( 2 * a ) ) ; print ( ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { print ( "Rootsarerealandsame" ) print ( - b / ( 2 * a ) ) ; else print ( "Rootsarecomplex" ) print ( - b / ( 2 * a ) , "+i" , sqrt_val ) ; print ( - b / ( 2 * a ) , "-i" , sqrt_val ) ; } }

16.1
23.88
14.26
22.58
def numberOfWays ( x ) : if x == 0 or x == 1 : return 1 else : return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )

static int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }

static int numberOfWays ( int x ) { if ( x == 1 ) return ( numberOfWays ( x - 2 ) + numberOfWays ( x - 1 ) * numberOfWays ( x - 2 ) ) / 2 ; else return ( numberOfWays ( x - 1 ) + numberOfWays ( x - 2 ) ) / 2 ; }

static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; }

16.17
28.55
37.89
42.21
def subsetDifference ( n ) : s = int ( n * ( n + 1 ) / 2 ) if n % 4 == 0 : print ( "Firstsubsetsum=" , int ( s / 2 ) ) print ( "Secondsubsetsum=" , int ( s / 2 ) ) print ( "Difference=" , 0 ) else : if n % 4 == 1 or n % 4 == 2 : print ( "Firstsubsetsum=" , int ( s / 2 ) ) print ( "Secondsubsetsum=" , int ( s / 2 ) + 1 ) print ( "Difference=" , 1 ) else : print ( "Firstsubsetsum=" , int ( s / 2 ) ) print ( "Secondsubsetsum=" , int ( s / 2 ) ) print ( "Difference=" , 0 )

static void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + s / 2 ) ; System . out . println ( "Difference = " + 0 ) ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + ( ( s / 2 ) + 1 ) ) ; System . out . println ( "Difference = " + 1 ) ; } else { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + s / 2 ) ; System . out . println ( "Difference = " + 0 ) ; } } }

static void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) print ( "Firstsubsetsum=" , int ( s / 2 ) ) print ( "Secondsubsetsum=" , int ( s / 2 ) + 1 ) print ( "Difference=" , 1 ) ; else { if ( n % 4 == 2 ) print ( "Firstsubsetsum=" , int ( s / 2 ) + 1 ) print ( "

static void subsetDifference ( int n ) { int s = int ( n * ( n + 1 ) / 2 ) ; if ( n % 4 == 0 ) { print ( "Firstsubsetsum=" , int ( s / 2 ) ) ; print ( "Secondsubsetsum=" , int ( s / 2 ) + 1 ) ; print ( "Difference=" , 1 ) ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { print ( "Firstsubsetsum=" , int ( s / 2 ) ) ; print ( "Secondsubsetsum=" , int ( s / 2 ) + 1 ) ; print ( "Difference=" , 1 ) ; } else { print ( "Firstsubsetsum=" , int ( s / 2 ) ) ; print ( "Secondsubsetsum=" , int ( s / 2 ) + 1 ) ; print ( "Difference=" , 0 ) ; } } }

16.3
25.14
24.0
34.02
def spiralPrint ( m , n , a ) : k = 0 l = 0 while ( k < m and l < n ) : for i in range ( l , n ) : print ( a [ k ] [ i ] , end = "" ) k += 1 for i in range ( k , m ) : print ( a [ i ] [ n - 1 ] , end = "" ) n -= 1 if ( k < m ) : for i in range ( n - 1 , ( l - 1 ) , - 1 ) : print ( a [ m - 1 ] [ i ] , end = "" ) m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : print ( a [ i ] [ l ] , end = "" ) l += 1

static void spiralPrint ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { System . out . print ( a [ k ] [ i ] + " " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { System . out . print ( a [ i ] [ n - 1 ] + " " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( a [ m - 1 ] [ i ] + " " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( a [ i ] [ l ] + " " ) ; } l ++ ; } } }

static void spiralPrint ( int m , int n ) { int k = 0 ; int l = 0 ; while ( k < m && l < n ) { for ( int i = 0 ; i < m ; i ++ ) { print ( a [ k ] [ i ] , end = "" ) k += 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int i = 0 ; i < m ; i ++ ) {

static void spiralPrint ( int m , int n , String [ ] a ) { int k = 0 ; int l = 0 ; while ( k < m && l < n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < m ; k ++ ) { for ( int i = 0 ; i < k ; i ++ ) a [ i ] [ j ] . print ( a [ k ] [ j ] , end = "" ) ; } } } }

16.31
19.17
14.18
16.52
def generateGrayarr ( n ) : if ( n <= 0 ) : return arr = list ( ) arr . append ( "0" ) arr . append ( "1" ) i = 2 j = 0 while ( True ) : if i >= 1 << n : break for j in range ( i - 1 , - 1 , - 1 ) : arr . append ( arr [ j ] ) for j in range ( i ) : arr [ j ] = "0" + arr [ j ] for j in range ( i , 2 * i ) : arr [ j ] = "1" + arr [ j ] i = i << 1 for i in range ( len ( arr ) ) : print ( arr [ i ] )

static void generateGrayarr ( int n ) { if ( n <= 0 ) return ; ArrayList < String > arr = new ArrayList < String > ( ) ; arr . add ( "0" ) ; arr . add ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . add ( arr . get ( j ) ) ; for ( j = 0 ; j < i ; j ++ ) arr . set ( j , "0" + arr . get ( j ) ) ; for ( j = i ; j < 2 * i ; j ++ ) arr . set ( j , "1" + arr . get ( j ) ) ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) System . out . println ( arr . get ( i ) ) ; }

static void generateGrayarr ( int n ) { int arr [ ] = new int [ n ] ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j >= 2 * i ) arr [ j ] = "0" + arr [ j ] ; for ( int j = i ; j <= 2 * i ) arr [ j ] = "1" + arr [ j ] ; j ++ ; } } return arr ; }

static void generateGrayarr ( int n ) { System . arraycopy ( arr , 0 , System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( ) ) , 0 ) , 0 ) , 0 ) , 0 ) , 0 , 2 * i ) ) , 0 , 2 * i ) ) , 0 , 2 * i ) ) , 0 , 2 * i ) ) ; i = i << 1 ; for ( i = 0 ; i < n ; i ++ ) { System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( System . arraycopy ( ) , 0 , 2 * i ) ) , 0 , 2 * i ) ) , 0 , 2 * i ) )

16.41
21.95
27.68
27.66
def isValidISBN ( isbn ) : if len ( isbn ) != 10 : return False _sum = 0 for i in range ( 9 ) : if 0 <= int ( isbn [ i ] ) <= 9 : _sum += int ( isbn [ i ] ) * ( 10 - i ) else : return False if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : return False _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] ) return ( _sum % 11 == 0 )

static boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit || 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != 'X' && ( last < '0' || last > '9' ) ) return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }

static boolean isValidISBN ( String isbn ) { int _sum = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) { if ( 0 <= int ( isbn [ i ] ) <= 9 ) _sum += int ( isbn [ i ] ) * ( 10 - i ) ; else return false ; } return true ; }

static boolean isValidISBN ( String isbn ) { if ( isbn . length ( ) != 10 ) return false ; int _sum = 0 ; for ( int i = 0 ; i < isbn . length ( ) ; i ++ ) { if ( isbn [ i ] != 'X' && 0 <= int ( isbn [ i ] ) <= 9 ) _sum += int ( isbn [ i ] ) * ( 10 - i ) ; else return false ; } return true ; }

16.61
24.2
34.06
35.04
def subset ( arr , n ) : mp = { i : 0 for i in range ( 10 ) } for i in range ( n ) : mp [ arr [ i ] ] += 1 res = 0 for key , value in mp . items ( ) : res = max ( res , value ) return res

static int subset ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; }

static int subset ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { mp [ arr [ i ] ] += 1 ; } return res ; }

static int subset ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { mp [ arr [ i ] ] += 1 ; res = 0 ; for ( int key = 0 ; key < arr . length ; key ++ ) { res = Math . max ( res , arr [ key ] ) ; } } return res ; }

16.67
22.19
35.39
34.9
def findInteger ( arr , n ) : hash = dict ( ) maximum = 0 for i in arr : if ( i < 0 ) : if abs ( i ) not in hash . keys ( ) : hash [ abs ( i ) ] = - 1 else : hash [ abs ( i ) ] -= 1 else : hash [ i ] = hash . get ( i , 0 ) + 1 for i in arr : if i in hash . keys ( ) and hash [ i ] > 0 : return i return - 1

static int findInteger ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) - 1 ) ; else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] ; return - 1 ; }

static int findInteger ( int arr [ ] , int n ) { int hash [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i < 0 ) hash [ i ] = - 1 ; else hash [ i ] = hash . get ( i , 0 ) + 1 ; else hash [ i ] = hash . get ( i , 0 ) + 1 ; } return - 1 ; }

static int findInteger ( int [ ] arr , int n ) { int hash = new int ( ) ; int maximum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i < 0 ) { if ( abs ( i ) not in hash . keys ( ) ) hash [ abs ( i ) ] = - 1 ; else hash [ abs ( i ) ] -= 1 ; else hash [ i ] = hash . get ( i , 0 ) + 1 ; } else hash [ i ] = hash . get ( i , 0 ) + 1 ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i < 0 ) { if ( abs ( i ) not in hash . keys ( ) ) hash [ abs ( i ) ] = - 1 ; else hash [ i ] -= 1 ; } else hash [ i ] = hash . get ( i , 0 ) + 1 ; } } return - 1 ; }

16.72
48.37
81.83
85.45
def sumOfSeries ( n ) : return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 )

static int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }

static int sumOfSeries ( int n ) { int sumOfSeries ( int n ) { int sumOfSeries ( int n * n + 1 ) ; int sumOfSeries ( int n * n + 1 ) ; int sumOfSeries ( int n * n + 1 ) ; int sumOfSeries ( int n * n + 1 ) ; int sumOfSeries ( int n ) ; int sumOfSeries ( int n ) ; int sumOfSeries ( int n ) ;

static int sumOfSeries ( int n ) { return Math . sum ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) ; }

16.78
31.51
54.48
65.94
def count_of_ways ( n ) : count = 0 count = ( n + 1 ) * ( n + 2 ) // 2 return count

static long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }

static int count_of_ways ( int n ) { int count = 0 ; while ( count < n ) count ++ ; }

static int count_of_ways ( int n ) { int count = 0 ; int count_of_ways = 1 ; int count = 0 ; count = ( n + 1 ) * ( n + 2 ) ; return count ; }

16.86
26.94
27.61
30.86
def nextGreater ( num1 ) : l = len ( num1 ) num = list ( num1 ) i = l - 1 while ( i >= 0 ) : if ( num [ i ] == '0' ) : num [ i ] = '1' break else : num [ i ] = '0' i -= 1 num1 = '' . join ( num ) if ( i < 0 ) : num1 = '1' + num1 return num1

static String nextGreater ( String num ) { int l = num . length ( ) ; int i ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '0' ) { num = num . substring ( 0 , i ) + '1' + num . substring ( i + 1 ) ; break ; } else { num = num . substring ( 0 , i ) + '0' + num . substring ( i + 1 ) ; } } if ( i < 0 ) { num = "1" + num ; } return num ; }

static String nextGreater ( String num1 ) { int l = num1 . length ( ) ; int i = l - 1 ; while ( i >= 0 ) { if ( num [ i ] == '1' ) num [ i ] = '0' ; i -= 1 } return num1 ; } return num1 ; }

static String nextGreater ( String num1 ) { int l = num1 . length ( ) ; int i = l - 1 ; while ( i >= 0 ) { if ( num [ i ] == '0' ) num [ i ] = '1' ; else num [ i ] = '0' ; i -- ; num1 = '' . join ( num ) ; if ( i < 0 ) num1 = '1' + num1 ; } return num1 ; }

16.9
24.05
34.19
34.87
def printFirstNegativeInteger ( arr , n , k ) : Di = deque ( ) for i in range ( k ) : if ( arr [ i ] < 0 ) : Di . append ( i ) for i in range ( k , n ) : if ( not Di ) : print ( 0 , end = '' ) else : print ( arr [ Di [ 0 ] ] , end = '' ) while Di and Di [ 0 ] <= ( i - k ) : Di . popleft ( ) if ( arr [ i ] < 0 ) : Di . append ( i ) if not Di : print ( 0 ) else : print ( arr [ Di [ 0 ] ] , end = "" )

static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { LinkedList < Integer > Di = new LinkedList < > ( ) ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) Di . add ( i ) ; for ( ; i < n ; i ++ ) { if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " " ) ; else System . out . print ( "0" + " " ) ; while ( ( ! Di . isEmpty ( ) ) && Di . peek ( ) < ( i - k + 1 ) ) Di . remove ( ) ; if ( arr [ i ] < 0 ) Di . add ( i ) ; } if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " " ) ; else System . out . print ( "0" + " " ) ; }

static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { int Di [ ] = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] < 0 ) Di . append ( i ) if ( ! Di ) { print ( 0 , end = '' ) ; while ( Di and Di [ 0 ] <= ( i - k ) ) Di . popleft ( ) if

static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { int [ ] Di = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; else if ( arr [ i ] == 0 ) Di . append ( i ) ; } }

17.02
18.65
14.53
19.33
def countCurrency ( amount ) : notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] print ( "CurrencyCount->" ) for i , j in zip ( notes , noteCounter ) : if amount >= i : j = amount // i amount = amount - j * i print ( i , ":" , j )

public static void countCurrency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 }; int [ ] noteCounter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } System . out . println ( "Currency Count ->" ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { System . out . println ( notes [ i ] + " : " + noteCounter [ i ] ) ; } } }

static void countCurrency ( int amount ) { int i = 0 ; int j = 0 ; for ( int i = 0 ; i < notes . length ; i ++ ) { int j = 0 ; if ( amount >= j ) j = amount - j * i ; if ( amount >= i ) j = amount - j * i ; if ( amount >= j ) j = amount - j * i ; if ( amount >= j ) j = amount - j * i ; if

static void countCurrency ( int amount ) { int notes [ ] = new int [ ] { 2000 , 500 , 200 , 200 , 100 , 50 , 20 , 20 , 20 , 10 , 5 , 1 , 1 } ; int noteCounter [ ] = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0

17.05
24.52
24.27
22.87
def countMinReversals ( expr ) : lenn = len ( expr ) if ( lenn % 2 ) : return - 1 s = [ ] for i in range ( lenn ) : if ( expr [ i ] == '' and len ( s ) ) : if ( s [ 0 ] == '' ) : s . pop ( 0 ) else : s . insert ( 0 , expr [ i ] ) else : s . insert ( 0 , expr [ i ] ) red_len = len ( s ) n = 0 while ( len ( s ) and s [ 0 ] == '' ) : s . pop ( 0 ) n += 1 return ( red_len // 2 + n % 2 )

static int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == '} ' && ! s . empty ( ) ) { if ( s . peek ( ) == '{ ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == '{ ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } public static void main ( String [ ] args ) { String expr = " } }

static int countMinReversals ( String expr ) { int lenn = expr . length ( ) ; int red_len = expr . length ( ) ; for ( int i = 0 ; i < lenn ; i ++ ) { if ( s [ 0 ] == '' ) s . pop ( 0 ) ; else s . insert ( 0 , expr [ i ] ) ; else s . insert ( 0 , '' ) ; } return - 1 ; }

static int countMinReversals ( String expr , int lenn ) { int red_len = len ( expr ) ; int n = 0 ; for ( int i = 0 ; i < lenn ; i ++ ) { if ( expr [ i ] == '' && len ( s ) ) { if ( s [ 0 ] == '' ) s . pop ( 0 ) ; else s . insert ( 0 , expr [ i ] ) ; } else s . insert ( 0 , expr [ i ] ) ; } return ( red_len // 2 + n % 2 ) ; }

17.13
25.94
19.31
26.11
def constructTree ( n , d , h ) : if d == 1 : if n == 2 and h == 1 : print ( "12" ) return 0 print ( "-1" ) return 0 if d > 2 * h : print ( "-1" ) return 0 for i in range ( 1 , h + 1 ) : print ( i , "" , i + 1 ) if d > h : print ( 1 , "" , h + 2 ) for i in range ( h + 2 , d + 1 ) : print ( i , "" , i + 1 ) for i in range ( d + 1 , n ) : k = 1 if d == h : k = 2 print ( k , "" , i + 1 )

static void constructTree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { System . out . println ( "1 2" ) ; return ; } System . out . println ( "-1" ) ; return ; } if ( d > 2 * h ) { System . out . println ( "-1" ) ; return ; } for ( int i = 1 ; i <= h ; i ++ ) System . out . println ( i + " " + ( i + 1 ) ) ; if ( d > h ) { System . out . println ( "1" + " " + ( h + 2 ) ) ; for ( int i = h + 2 ; i <= d ; i ++ ) { System . out . println ( i + " " + ( i + 1 ) ) ; } } for ( int i = d + 1 ; i < n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; System . out . println ( k + " " + ( i + 1 ) ) ; } }

static int constructTree ( int n , int d , int h ) { int k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( d > h ) { print ( 1 , "" , h + 2 ) ; for ( int i = 1 ; i <= h + 2 ; i ++ ) { if ( d > h ) { print ( 1 , "" , h + 2 ) ; for ( int i = 1 ; i <= n

static int constructTree ( int n , int d , int h ) { int k = 1 ; if ( d == 1 ) { k = 2 ; } else if ( d == h ) { k = 3 ; } else if ( d == h ) { k = 4 ; } else if ( d == h ) { k = 5 ; } else if ( d == h ) { k = 6 ; } else if ( d == h ) { k = 7 ; } else if ( d == h ) { k = 8 ; } else if ( d == h ) { k = 9 ; } else { k = 10 ; } print ( k , "" , i + 1 ) ; } } return 0 ; }

17.16
26.44
43.22
39.96
def printRepeating ( arr , size ) : xor = arr [ 0 ] n = size - 2 x = 0 y = 0 for i in range ( 1 , size ) : xor ^= arr [ i ] for i in range ( 1 , n + 1 ) : xor ^= i set_bit_no = xor & ~ ( xor - 1 ) for i in range ( 0 , size ) : if ( arr [ i ] & set_bit_no ) : x = x ^ arr [ i ] else : y = y ^ arr [ i ] for i in range ( 1 , n + 1 ) : if ( i & set_bit_no ) : x = x ^ i else : y = y ^ i print ( "Thetworepeating" , "elementsare" , y , x )

void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( "The two reppeated elements are :" ) ; System . out . println ( x + " " + y ) ; }

static void printRepeating ( int arr [ ] , int size ) { int set_bit_no = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) { x = x ^ arr [ i ] ; } else { y = y ^ arr [ i ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set

static void printRepeating ( int [ ] arr , int size ) { int xor = arr [ 0 ] ; int x = 0 ; int y = 0 ; for ( int i = 1 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) { x = x ^ arr [ i ] ; } else { x = x ^ i ; } y = y ^ i ; } for ( int i = 1 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) { x = x ^ arr [ i ] ; } else { y = y ^ i ; } for ( int i = 1 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) { x = x ^ arr [ i ] ; } else { y = y ^ i ; } } } } return ; }

17.19
23.41
75.86
76.32
def correlationCoefficient ( X , Y , n ) : sum_X = 0 sum_Y = 0 sum_XY = 0 squareSum_X = 0 squareSum_Y = 0 i = 0 while i < n : sum_X = sum_X + X [ i ] sum_Y = sum_Y + Y [ i ] sum_XY = sum_XY + X [ i ] * Y [ i ] squareSum_X = squareSum_X + X [ i ] * X [ i ] squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] i = i + 1 corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) return corr

static float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }

static float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 ; int sum_Y = 0 ; int sum_XY = 0 ; int sum_XY = 0 ; int sum_Y = 0 ; int squareSum_X = 0 ; int squareSum_Y = 0 ; int squareSum_Y = 0 ; int i = 0 ; while ( i < n ) { sum_X = sum_X +

static float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 ; sum_Y = 0 ; sum_XY = 0 ; squareSum_X = 0 ; squareSum_Y = 0 ; i = 0 ; while ( i < n ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] ; squareSum_X = squareSum_X + X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] ; i ++ ; } corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }

17.24
25.8
38.81
37.62
def printPath ( str ) : i = 0 curX = 0 curY = 0 while ( i < len ( str ) ) : nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 ) nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5 while ( curX > nextX ) : print ( "MoveUp" ) curX -= 1 while ( curY > nextY ) : print ( "MoveLeft" ) curY -= 1 while ( curX < nextX ) : print ( "MoveDown" ) curX += 1 while ( curY < nextY ) : print ( "MoveRight" ) curY += 1 print ( "PressOK" ) i += 1

static void printPath ( String str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { int nextX = ( str . charAt ( i ) - 'A' ) / 5 ; int nextY = ( str . charAt ( i ) - 'B' + 1 ) % 5 ; while ( curX > nextX ) { System . out . println ( "Move Up" ) ; curX -- ; } while ( curY > nextY ) { System . out . println ( "Move Left" ) ; curY -- ; } while ( curX < nextX ) { System . out . println ( "Move Down" ) ; curX ++ ; } while ( curY < nextY ) { System . out . println ( "Move Right" ) ; curY ++ ; } System . out . println ( "Press OK" ) ; i ++ ; } }

static void printPath ( String str ) { int i = 0 ; int nextX = 0 ; int nextY = 0 ; while ( i < len ( str ) ) { if ( curX > nextX ) { print ( "MoveDown" ) curY -= 1 while ( curY > nextY ) { print ( "MoveLeft" ) curX += 1 while ( curY < nextY ) { print ( "MoveRight" ) curY += 1 while (

static void printPath ( String str ) { int i = 0 ; int curX = 0 ; int curY = 0 ; while ( i < len ( str ) ) { int nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 ) nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5 ; while ( curX > nextX ) { print ( "MoveUp" ) curX -= 1 while ( curY > nextY ) { print ( "MoveLeft" ) curY -= 1 while ( curX < nextX ) { print ( "MoveDown" ) curX += 1 while ( curY < nextY ) { print ( "MoveRight" ) curY += 1 } } } } }

17.4
27.62
36.07
38.36
def minProductSubset ( a , n ) : if ( n == 1 ) : return a [ 0 ] max_neg = float ( '-inf' ) min_pos = float ( 'inf' ) count_neg = 0 count_zero = 0 prod = 1 for i in range ( 0 , n ) : if ( a [ i ] == 0 ) : count_zero = count_zero + 1 continue if ( a [ i ] < 0 ) : count_neg = count_neg + 1 max_neg = max ( max_neg , a [ i ] ) if ( a [ i ] > 0 ) : min_pos = min ( min_pos , a [ i ] ) prod = prod * a [ i ] if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : return 0 if ( count_neg == 0 ) : return min_pos if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) : prod = int ( prod / max_neg ) return prod

static int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = Integer . MIN_VALUE ; int posmin = Integer . MAX_VALUE ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; }

static int minProductSubset ( int [ ] a , int n ) { int count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_zero = count_zero + 1 ; else if ( a [ i ] < 0 ) count_neg = count_neg + 1 ; else max_neg = max ( max_neg , a [ i ] ) ; if (

int minProductSubset ( int a , int n ) { int max_neg = float ( '-inf' ) ; int min_pos = float ( 'inf' ) ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_neg = count_neg + 1 ; max_neg = max ( max_neg , a [ i ] ) ; if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ; if ( a [ i ] < 0 ) min_pos = min ( min_pos , a [ i ] ) ; if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ; } } return min_pos ; }

17.46
23.59
21.52
23.92
def divisibilityCheck ( arr , n ) : s = dict ( ) max_ele = - 10 ** 9 for i in range ( n ) : s [ arr [ i ] ] = 1 max_ele = max ( max_ele , arr [ i ] ) res = dict ( ) for i in range ( n ) : if ( arr [ i ] != 0 ) : for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : if ( j in s . keys ( ) ) : res [ j ] = 1 for x in res : print ( x , end = "" )

static void divisibilityCheck ( List < Integer > arr , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr . get ( i ) ) ; max_ele = Math . max ( max_ele , arr . get ( i ) ) ; } LinkedHashSet < Integer > res = new LinkedHashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) * 2 ; j <= max_ele ; j += arr . get ( i ) ) { if ( s . contains ( j ) ) res . add ( j ) ; } } List < Integer > list = new ArrayList < Integer > ( res ) ; Collections . reverse ( list ) ; for ( Integer temp : list ) System . out . print ( temp + " " ) ; }

static void divisibilityCheck ( int arr [ ] , int n ) { int s = new int ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) { if ( s . get ( x ) ) res [ x ] = 1 ; else res [ x ] = 0 ; for ( int i = 0 ; i < arr [ i ] ; i ++ ) { if (

static void divisibilityCheck ( int [ ] arr , int n ) { int max_ele = - 10 ** 9 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j < max_ele + 1 ; j ++ ) { if ( j in s . keys ( ) ) res [ j ] = 1 ; for ( int x = 0 ; x < res . length ; x ++ ) { res [ x ] = 1 ; } } } } } }

17.5
23.32
35.3
39.1
def sortString ( str ) : str = '' . join ( sorted ( str ) ) print ( str )

static void sortString ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . print ( String . valueOf ( arr ) ) ; }

static void sortString ( String str ) { if ( str != '' ) print ( str ) ; }

static void sortString ( String str ) { String str = "" . join ( sorted ( str ) ) ; System . out . println ( str ) ; }

17.51
24.16
32.04
38.81
def encodedChar ( str , k ) : expand = "" freq = 0 i = 0 while ( i < len ( str ) ) : temp = "" freq = 0 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) : temp += str [ i ] i += 1 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) i += 1 for j in range ( 1 , freq + 1 , 1 ) : expand += temp if ( freq == 0 ) : expand += temp return expand [ k - 1 ]

static char encodedChar ( String str , int k ) { String expand = "" ; String temp = "" ; int freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; ) { temp = "" ; freq = 0 ; while ( i < str . length ( ) && str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand . charAt ( k - 1 ) ; }

static String encodedChar ( String str , int k ) { String temp = "" ; int i = 0 ; int j = 0 ; while ( i < len ( str ) && ( ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) ) { freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) ; i ++ ; for ( int j =

static String encodedChar ( String str , int k ) { String expand = "" ; int freq = 0 ; int i = 0 ; while ( i < len ( str ) ) { temp = "" ; freq = 0 ; while ( i < len ( str ) && ord ( str [ i ] ) >= ord ( 'a' ) && ord ( str [ i ] ) <= ord ( 'z' ) ) { freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) ; i ++ ; } while ( i < len ( str ) && ord ( str [ i ] ) >= ord ( '1' ) && ord ( str [ i ] ) <= ord ( '9' ) ) { freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) ; i ++ ; } while ( i < len ( str ) && ord ( str [ i ] ) >= ord ( '1' ) && ord ( str [ i ] ) <= ord ( '9' ) ) { freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) ; i ++ ; } } expand += temp ; if ( freq == 0 )

17.76
26.52
33.0
39.17
def findFourElements ( arr , n ) : mp = dict ( ) for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : mp [ arr [ i ] + arr [ j ] ] = ( i , j ) d = - 10 ** 9 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : abs_diff = abs ( arr [ i ] - arr [ j ] ) if abs_diff in mp . keys ( ) : p = mp [ abs_diff ] if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : d = max ( d , max ( arr [ i ] , arr [ j ] ) ) return d

static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }

static int findFourElements ( int arr [ ] , int n ) { int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mp [ arr [ i ] + arr [ j ] ] != - 1 ) { d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; } }

static int findFourElements ( int arr [ ] , int n ) { int d = - 10 ** 9 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( abs_diff in mp . keys ( ) ) { p = mp [ abs_diff ] ; if ( p [ 0 ] != i && p [ 0 ] != j && p [ 1 ] != i && p [ 1 ] != j ) { d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }

17.77
33.55
39.52
35.78
def printMat ( degseq , n ) : mat = [ [ 0 ] * n for i in range ( n ) ] for i in range ( n ) : for j in range ( i + 1 , n ) : if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) : degseq [ i ] -= 1 degseq [ j ] -= 1 mat [ i ] [ j ] = 1 mat [ j ] [ i ] = 1 print ( "" , end = "" ) for i in range ( n ) : print ( "" , "(" , i , ")" , end = "" ) print ( ) print ( ) for i in range ( n ) : print ( "" , "(" , i , ")" , end = "" ) for j in range ( n ) : print ( "" , mat [ i ] [ j ] , end = "" ) print ( )

static void printMat ( int degseq [ ] , int n ) { int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -- ; degseq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } } System . out . print ( "\n" + setw ( 3 ) + " " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( setw ( 3 ) + "(" + i + ")" ) ; System . out . print ( "\n\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( setw ( 4 ) + "(" + i + ")" ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j ] ) ; System . out . print ( "\n" ) ; } }

static void printMat ( int [ ] degseq , int n ) { int [ ] mat [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 ) mat [ i ] [ j ] = 1 ; else mat [ i ] [ j ] = 1 ; } } }

static void printMat ( int degseq , int n ) { mat [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -= 1 ; degseq [ j ] -= 1 ; mat [ i ] [ j ] = 1 mat [ j ] [ i ] = 1 mat [ i ] [ j ] = 1 mat [ j ] [ i ] = 1 mat [ i ] [ j ] = 1 mat [ j ] [ i ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [ i ] [ j ] = 1 mat [

17.83
30.38
52.48
50.07
def kmax ( arr , k , n ) : for c in range ( k ) : max_so_far = - float ( "inf" ) max_here = 0 start = 0 end = 0 s = 0 for i in range ( n ) : max_here += arr [ i ] if ( max_so_far < max_here ) : max_so_far = max_here start = s end = i if ( max_here < 0 ) : max_here = 0 s = i + 1 print ( "Maximumnon-overlappingsub-arraysum" , c + 1 , ":" , max_so_far , ",startingindex:" , start , ",endingindex:" , end , "." , sep = "" ) for l in range ( start , end + 1 ) : arr [ l ] = - float ( "inf" ) print ( )

static void kmax ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_so_far = Integer . MIN_VALUE ; int max_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) { max_so_far = max_here ; start = s ; end = i ; } if ( max_here < 0 ) { max_here = 0 ; s = i + 1 ; } } System . out . println ( "Maximum non-overlapping sub-arraysum" + ( c + 1 ) + ": " + max_so_far + ", starting index: " + start + ", ending index: " + end + "." ) ; for ( int l = start ; l <= end ; l ++ ) arr [ l ] = Integer . MIN_VALUE ; } System . out . println ( ) ; }

static void kmax ( int arr [ ] , int k , int n ) { int max_so_far = - float ( "inf" ) ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) max_so_far = max_here ; start = s ; end = i ; if ( max_here < 0 ) max_here =

static void kmax ( int arr [ ] , int k , int n ) { int max_so_far = - float ( "inf" ) ; int max_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) max_so_far = max_here ; start = s ; end = i ; if ( max_here < 0 ) max_here = 0 ; start = i ; end = i + 1 ; if ( max_here < 0 ) max_here = 0 ; start = s ; end = i + 1 ; if ( max_here < 0 ) max_here = 0 ; } for ( int c = 0 ; c < k ; c ++ ) { int max_so_far = - float ( "inf" ) ; int max_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) max_so_far = max_here ; start = s ; end = i ; } } }

17.84
25.56
43.9
47.6
def match ( first , second ) : if len ( first ) == 0 and len ( second ) == 0 : return True if len ( first ) > 1 and first [ 0 ] == '*' and len ( second ) == 0 : return False if ( len ( first ) > 1 and first [ 0 ] == '?' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) : return match ( first [ 1 : ] , second [ 1 : ] ) ; if len ( first ) != 0 and first [ 0 ] == '*' : return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) return False

static boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) return false ; if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ; if ( first . length ( ) > 0 && first . charAt ( 0 ) == '*' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ; return false ; }

static boolean match ( String first , String second ) { if ( len ( first ) == 0 and second [ 0 ] == '*' ) return match ( first , second ) ; if ( len ( first ) == 0 and second [ 0 ] == '?' ) return match ( first , second ) ; if ( len ( first ) != 0 and second [ 0 ] == '?' ) return match ( first , second [ 1 : ] ) ; if ( len ( second ) != 0 and second [

static boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; return false ; }

17.84
25.87
44.42
41.42
def maxOverlap ( start , end ) : n = len ( start ) maxa = max ( start ) maxb = max ( end ) maxc = max ( maxa , maxb ) x = ( maxc + 2 ) * [ 0 ] cur = 0 idx = 0 for i in range ( 0 , n ) : x [ start [ i ] ] += 1 x [ end [ i ] + 1 ] -= 1 maxy = - 1 for i in range ( 0 , maxc + 1 ) : cur += x [ i ] if maxy < cur : maxy = cur idx = i print ( "Maximumvalueis:{0:d}" . format ( maxy ) , "atposition:{0:d}" . format ( idx ) )

public static void maxOverlap ( int [ ] start , int [ ] end , int n ) { int maxa = Arrays . stream ( start ) . max ( ) . getAsInt ( ) ; int maxb = Arrays . stream ( end ) . max ( ) . getAsInt ( ) ; int maxc = Math . max ( maxa , maxb ) ; int [ ] x = new int [ maxc + 2 ] ; Arrays . fill ( x , 0 ) ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = Integer . MIN_VALUE ; for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } System . out . println ( "Maximum value is:" + maxy + " at position: " + idx + "" ) ; }

static int maxOverlap ( int [ ] start , int [ ] end ) { int n = len ( start ) ; int maxc = max ( start ) ; int maxy = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( maxy < cur ) maxy = cur ; if ( maxy < cur ) maxy = cur ; for ( int i = 0 ; i < maxc ; i ++ ) { if ( max

static void maxOverlap ( int start , int end ) { int n = start . length ( ) ; int maxa = max . length ( ) ; int maxb = max . length ( ) ; int maxc = max . length ( ) ; int x = ( maxc + 2 ) * [ 0 ] ; cur = 0 ; idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x [ start [ i ] ] += x [ end [ i ] ] ; x [ end [ i ] + 1 ] -= x [ i ] ; maxy = - 1 for ( int i = 0 ; i < maxc + 1 ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) maxy = cur ; idx = i ; } } }

17.89
21.57
51.84
43.87
def countPair ( a , b ) : s = str ( b ) i = 0 while i < ( len ( s ) ) : if ( s [ i ] != '9' ) : break i += 1 result = 0 if ( i == len ( s ) ) : result = a * len ( s ) else : result = a * ( len ( s ) - 1 ) return result

static int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }

static int countPair ( int a , int b ) { int i = 0 ; while ( i < ( len ( s ) ) ) { if ( s [ i ] == '0' ) result ++ ; else result ++ ; } return result ; }

static int countPair ( int a , String b ) { String s = str ( b ) ; int i = 0 ; while ( i < ( len ( s ) ) { if ( s [ i ] != '9' ) break ; i ++ ; } result = 0 ; if ( i == len ( s ) ) result = a * ( len ( s ) - 1 ) ; else result = a * ( len ( s ) - 1 ) ; return result ; }

17.96
34.1
16.49
23.7
def canFormPalindrome ( strr ) : listt = [ ] for i in range ( len ( strr ) ) : if ( strr [ i ] in listt ) : listt . remove ( strr [ i ] ) else : listt . append ( strr [ i ] ) if ( len ( strr ) % 2 == 0 and len ( listt ) == 0 or \ ( len ( strr ) % 2 == 1 and len ( listt ) == 1 ) ) : return True else : return False

static boolean canFormPalindrome ( String str ) { List < Character > list = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( list . contains ( str . charAt ( i ) ) ) list . remove ( ( Character ) str . charAt ( i ) ) ; else list . add ( str . charAt ( i ) ) ; } if ( str . length ( ) % 2 == 0 && list . isEmpty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true ; else return false ; }

static boolean canFormPalindrome ( String strr ) { List < String > listt = new List < String > ( ) ; for ( int i = 0 ; i < len ( strr ) ; i ++ ) { if ( strr [ i ] in listt ) { listt . remove ( strr [ i ] ) ; } } return false ; }

static boolean canFormPalindrome ( String strr ) { String [ ] listt = new String [ ] ; for ( int i = 0 ; i < len ( strr ) ; i ++ ) { if ( strr [ i ] in listt ) listt . remove ( strr [ i ] ) ; else listt . append ( strr [ i ] ) ; } return true ; }

18.13
28.34
38.72
42.88
def printKDistinct ( arr , size , KthIndex ) : dict = { } vect = [ ] for i in range ( size ) : if ( arr [ i ] in dict ) : dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 else : dict [ arr [ i ] ] = 1 for i in range ( size ) : if ( dict [ arr [ i ] ] > 1 ) : continue else : KthIndex = KthIndex - 1 if ( KthIndex == 0 ) : return arr [ i ] return - 1

static int printKDistinct ( int arr [ ] , int n , int k ) { Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ; else h . put ( arr [ i ] , 1 ) ; } if ( h . size ( ) < k ) return - 1 ; int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . get ( arr [ i ] ) == 1 ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }

static int printKDistinct ( int arr [ ] , int size , int KthIndex ) { int [ ] dict = { } ; for ( int i = 0 ; i < size ; i ++ ) { if ( dict [ arr [ i ] ] > 1 ) { KthIndex = KthIndex - 1 ; if ( KthIndex == 0 ) return arr [ i ] ; } else { KthIndex = KthIndex - 1 ; if ( KthIndex ==

static int printKDistinct ( int arr [ ] , int size , int KthIndex ) { int [ ] vect = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] in dict ) { vect [ i ] = dict [ arr [ i ] ] + 1 ; } else { vect [ i ] = 1 ; } } for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] in dict ) { vect [ i ] = 1 ; } else { KthIndex = KthIndex - 1 ; if ( KthIndex == 0 ) return arr [ i ] ; } } return - 1 ; }

18.23
25.81
16.85
21.74
def mostFrequent ( arr , n ) : Hash = dict ( ) for i in range ( n ) : if arr [ i ] in Hash . keys ( ) : Hash [ arr [ i ] ] += 1 else : Hash [ arr [ i ] ] = 1 max_count = 0 res = - 1 for i in Hash : if ( max_count < Hash [ i ] ) : res = i max_count = Hash [ i ] return res

static int mostFrequent ( int arr [ ] , int n ) { Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . containsKey ( key ) ) { int freq = hp . get ( key ) ; freq ++ ; hp . put ( key , freq ) ; } else { hp . put ( key , 1 ) ; } } int max_count = 0 , res = - 1 ; for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) { if ( max_count < val . getValue ( ) ) { res = val . getKey ( ) ; max_count = val . getValue ( ) ; } } return res ; }

static int mostFrequent ( int arr [ ] , int n ) { int Hash [ ] = new int [ arr . length ] ; int res = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( max_count < Hash [ i ] ) res = i ; else max_count = Hash [ i ] ; } return res ; }

static int mostFrequent ( int arr [ ] , int n ) { int Hash [ ] = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] in Hash . keys ( ) ) Hash [ arr [ i ] ] ++ ; else Hash [ arr [ i ] ] = 1 ; } return res ; }

18.36
27.01
34.08
39.72
def findSum ( str1 ) : temp = "" Sum = 0 for ch in str1 : if ( ch . isdigit ( ) ) : temp += ch else : Sum += int ( temp ) temp = "0" return Sum + int ( temp )

static int findSum ( String str ) { String temp = "" ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . isDigit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = "0" ; } } return sum + Integer . parseInt ( temp ) ; }

static int findSum ( String str1 ) { int Sum = 0 ; String temp = "" ; for ( char ch in str1 ) if ( ch . isdigit ( ) ) { Sum += int ( temp ) ; temp = "0" } return Sum ; }

static int findSum ( String str ) { String temp = "" ; int Sum = 0 ; for ( char ch : str ) { if ( ch . isdigit ( ) ) { Sum += ch ; } else { Sum += int ( temp ) ; } temp = "0" ; return Sum + int ( temp ) ; } }

18.36
28.51
36.54
39.85
def totalNodes ( adjac , n , x , y ) : visited = [ 0 ] * ( n + 1 ) p = [ None ] * n q = queue . Queue ( ) q . put ( x ) visited [ x ] = True m = None while ( not q . empty ( ) ) : m = q . get ( ) for i in range ( len ( adjac [ m ] ) ) : h = adjac [ m ] [ i ] if ( not visited [ h ] ) : visited [ h ] = True p [ h ] = m q . put ( h ) count = 0 i = p [ y ] while ( i != x ) : count += 1 i = p [ i ] return count

static int totalNodes ( Vector < Integer > adjac [ ] , int n , int x , int y ) { Boolean visited [ ] = new Boolean [ n + 1 ] ; Arrays . fill ( visited , false ) ; int p [ ] = new int [ n ] ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( x ) ; visited [ x ] = true ; int m ; while ( ! q . isEmpty ( ) ) { m = q . peek ( ) ; q . poll ( ) ; for ( int i = 0 ; i < adjac [ m ] . size ( ) ; ++ i ) { int h = adjac [ m ] . get ( i ) ; if ( visited [ h ] != true ) { visited [ h ] = true ; p [ h ] = m ; q . add ( h ) ; } } } int count = 0 ; int i = p [ y ] ; while ( i != x ) { count ++ ; i = p [ i ] ; } return count ; }

static int totalNodes ( int [ ] adjac , int x , int y ) { int count = 0 ; int [ ] p = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int h = p [ x ] ; if ( ! visited [ h ] ) { visited [ h ] = true p [ x ] = m ; q . put ( h ) ; } } return count ; } }

static int totalNodes ( Queue < Integer > adjac , int n , int x , int y ) { Queue < Integer > q = new Queue < Integer > ( ) ; for ( int i = 0 ; i != x ; i ++ ) { int h = adjac [ i ] [ 0 ] ; if ( ! visited [ h ] ) { q . put ( h ) ; visited [ h ] = true ; p [ h ] = m ; q . put ( h ) ; } } count = 0 ; for ( int i = p [ y ] ; i != x ; i ++ ) { count += 1 i = p [ i ] ; } return count ; }

18.38
33.35
40.04
45.5
def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( "InvalidInput" ) return first = arr [ 0 ] for i in range ( 1 , arr_size ) : if ( arr [ i ] > first ) : first = arr [ i ] second = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > second and arr [ i ] < first ) : second = arr [ i ] third = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > third and arr [ i ] < second ) : third = arr [ i ] print ( "TheThirdLargest" , "elementis" , third )

static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " Invalid Input " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( "The third Largest " + "element is %d\n" , third ) ; }

static void thirdLargest ( int [ ] arr , int arr_size ) { int first = - sys . maxsize ; int second = - sys . maxsize ; int third = - sys . maxsize ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > third and arr [ i ] < first ) { third = arr [ i ] ; } } print ( "TheThirdLargest" , "elementis" ,

static void thirdLargest ( int arr [ ] , int arr_size ) { int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) first = arr [ i ] ; if ( arr [ i ] > second ) second = arr [ i ] ; if ( arr [ i ] > third ) third = arr [ i ] ; if ( arr [ i ] > third ) third = arr [ i ] ; if ( arr [ i ] < first ) first = arr [ i ] ; if ( arr [ i ] > second ) second = arr [ i ] ; if ( arr [ i ] > third ) third = arr [ i ] ; if ( arr [ i ] > third ) third = arr [ i ] ; if ( arr [ i ] > first ) first = arr [ i ] ; if ( arr [ i ] < first ) first = arr [ i ] ; if ( arr [ i ] > second ) second = arr [ i ] ; if ( arr [ i ] < third ) third = arr [ i ] ; } }

18.49
33.85
65.27
73.9
def isPowerOfTwo ( x ) : return ( x and ( not ( x & ( x - 1 ) ) ) )

static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }

static boolean isPowerOfTwo ( int x ) { return ( x

static boolean isPowerOfTwo ( int x ) { return ( x && ( ! ( x & ( x - 1 ) ) ) ; }

18.49
24.37
44.0
39.64
def decimalToBinary ( num , k_prec ) : binary = "" Integral = int ( num ) fractional = num - Integral while ( Integral ) : rem = Integral % 2 binary += str ( rem ) Integral //= 2 binary = binary [ : : - 1 ] binary += '.' while ( k_prec ) : fractional *= 2 fract_bit = int ( fractional ) if ( fract_bit == 1 ) : fractional -= fract_bit binary += '1' else : binary += '0' k_prec -= 1 return binary

static String decimalToBinary ( double num , int k_prec ) { String binary = "" ; int Integral = ( int ) num ; double fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += ( ( char ) ( rem + '0' ) ) ; Integral /= 2 ; } binary = reverse ( binary ) ; binary += ( '.' ) ; while ( k_prec -- > 0 ) { fractional *= 2 ; int fract_bit = ( int ) fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary += ( char ) ( 1 + '0' ) ; } else { binary += ( char ) ( 0 + '0' ) ; } } return binary ; }

static String decimalToBinary ( int num , int k_prec ) { String binary = "" ; int Integral = int ( num ) ; int fractional = int ( num ) ; int fract_bit = int ( fractional ) ; if ( fract_bit == 1 ) { binary += '0' } else { binary += '1' } k_prec -- ; } return binary ; }

static String decimalToBinary ( int num , int k_prec ) { String binary = "" ; int Integral = int ( num ) ; int fractional = num - Integral ; while ( Integral ) { int rem = Integral % 2 ; binary += str ( rem ) ; Integral //= 2 ; binary = binary [ : : - 1 ] ; binary = binary [ : : - 1 ] ; binary += '.' ; while ( fractional ) { fractional *= 2 ; fract_bit = int ( fractional ) ; if ( fract_bit == 1 ) fractional -= fract_bit binary += '1' ; else binary += '0' ; k_prec -- ; } } return binary ; }

18.65
28.3
48.27
54.45
def calculate ( s ) : ans = 6 for i in range ( 10 ) : for j in range ( 10 ) : for k in range ( 10 ) : for l in range ( 10 ) : for m in range ( 10 ) : for n in range ( 10 ) : if ( i + j + k == l + m + n ) : c = 0 if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : c += 1 if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : c += 1 if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : c += 1 if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : c += 1 if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : c += 1 if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : c += 1 if ( c < ans ) : ans = c return ans

static int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - '0' ) c ++ ; if ( j != s . charAt ( 1 ) - '0' ) c ++ ; if ( k != s . charAt ( 2 ) - '0' ) c ++ ; if ( l != s . charAt ( 3 ) - '0' ) c ++ ; if ( m != s . charAt ( 4 ) - '0' ) c ++ ; if ( n != s . charAt ( 5 ) - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }

static int calculate ( String s ) { int c = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 10 ; k ++ ) { for ( int m = 0 ; m < 10 ; m ++ ) { for ( int n = 0 ; n < 10 ; n ++ ) { if ( l + m + n == m +

static int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 10 ; k ++ ) { if ( i + j + k == l + m + n ) c = 0 ; if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) c += 1 ; if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) c += 1 ; if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) c += 1 ; if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) c += 1 ; if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) c += 1 ; if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) c += 1 ; if ( c < ans ) ans = c ; } } } return ans ; }

18.66
29.07
12.33
27.69
def findLength ( st , n ) : total = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ans = 0 l = 2 while ( l <= n ) : for i in range ( n - l + 1 ) : j = i + l - 1 if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : ans = max ( ans , l ) l = l + 2 return ans

static int findLength ( String str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int lsum = 0 , rsum = 0 ; while ( r < n && l >= 0 ) { lsum += str . charAt ( l ) - '0' ; rsum += str . charAt ( r ) - '0' ; if ( lsum == rsum ) { ans = Math . max ( ans , r - l + 1 ) ; } l -- ; r ++ ; } } return ans ; }

static int findLength ( int st [ ] , int n ) { int total [ ] = new int [ n + 1 ] + int ( st [ i ] ) - int ( '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( total [ i ] - total [ i ] == total [ i + l ] - total [ i ] + int ( st

int findLength ( int st [ ] , int n ) { int total [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ; } for ( int i = 1 ; i < n ; i ++ ) { total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ; } for ( int i = 1 ; i < n ; i ++ ) { total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ; } for ( int i = 1 ; i < n ; i ++ ) { total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ; } return ans ; }

18.68
26.77
31.94
31.54
def countSubarrWithEqualZeroAndOne ( arr , n ) : um = dict ( ) curr_sum = 0 for i in range ( n ) : curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) if um . get ( curr_sum ) : um [ curr_sum ] += 1 else : um [ curr_sum ] = 1 count = 0 for itr in um : if um [ itr ] > 1 : count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) if um . get ( 0 ) : count += um [ 0 ] return int ( count )

static int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um . put ( curr_sum , um . get ( curr_sum ) == null ? 1 : um . get ( curr_sum ) + 1 ) ; } int count = 0 ; for ( Map . Entry < Integer , Integer > itr : um . entrySet ( ) ) { if ( itr . getValue ( ) > 1 ) count += ( ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) / 2 ) ; } if ( um . containsKey ( 0 ) ) count += um . get ( 0 ) ; return count ; }

static int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { int um [ ] = new int [ arr . length ] ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . get ( curr_sum ) ) { um [ curr_sum ] += 1 ; } else { um [ curr_sum ] = 1 ; } } return int ( count ) ; } }

static int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) ; if ( um . get ( curr_sum ) ) um [ curr_sum ] += 1 ; else um [ curr_sum ] = 1 ; } } return count ; }

18.72
19.77
26.37
30.64
def checkPangram ( s ) : List = [ ] for i in range ( 26 ) : List . append ( False ) for c in s . lower ( ) : if not c == "" : List [ ord ( c ) - ord ( 'a' ) ] = True for ch in List : if ch == False : return False return True

public static boolean checkPangram ( String str ) { boolean [ ] mark = new boolean [ 26 ] ; int index = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) - 'A' ; else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) - 'a' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }

static boolean checkPangram ( String s ) { List [ ] = false ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( List [ i ] == false ) return false ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( List [ i ] == true ) return false ; } } return true ; }

public static boolean checkPangram ( String s ) { boolean List [ ] = new boolean [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { List . append ( false ) ; for ( int c in s . toLowerCase ( ) ) { if ( ! c . equals ( "a" ) ) List [ ord ( c ) - ord ( 'a' ) ] = true ; } for ( int ch in List ) if ( ch == false ) return false ; } return true ; }

18.73
38.93
13.43
35.26
def swap ( xp , yp ) : if ( xp [ 0 ] == yp [ 0 ] ) : return xp [ 0 ] = xp [ 0 ] + yp [ 0 ] yp [ 0 ] = xp [ 0 ] - yp [ 0 ] xp [ 0 ] = xp [ 0 ] - yp [ 0 ]

static void swap ( int xp , int yp ) { if ( xp == yp ) return ; xp = xp + yp ; yp = xp - yp ; xp = xp - yp ; }

static void swap ( int xp [ ] , int yp [ ] ) { if ( xp [ 0 ] == yp [ 0 ] ) return ; yp [ 0 ] = yp [ 0 ] + xp [ 0 ] ; xp [ 0 ] = xp [ 0 ] + yp [ 0 ] ; yp [ 0 ] = yp [ 0 ] - xp [ 0 ] ; } return ; }

static void swap ( int xp , int yp [ ] ) { if ( xp [ 0 ] == yp [ 0 ] ) return ; if ( xp [ 0 ] == yp [ 0 ] ) return ; if ( xp [ 0 ] == yp [ 0 ] ) return ; if ( xp [ 0 ] == yp [ 0 ] ) return ; if ( xp [ 0 ] == yp [ 0 ] ) return ; if ( xp [ 0 ] == yp [ 0 ] ) return ; if ( xp [ 0 ] == yp [ 0 ] ) return ; swap ( xp , yp ) ; }

18.88
28.1
28.64
34.56
def lineFromPoints ( P , Q ) : a = Q [ 1 ] - P [ 1 ] b = P [ 0 ] - Q [ 0 ] c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) if ( b < 0 ) : print ( "ThelinepassingthroughpointsPandQis:" , a , "x" , b , "y=" , c , "\n" ) else : print ( "ThelinepassingthroughpointsPandQis:" , a , "x+" , b , "y=" , c , "\n" )

static void lineFromPoints ( Pair P , Pair Q ) { int a = Q . second - P . second ; int b = P . first - Q . first ; int c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { System . out . println ( "The line passing through points P and Q is: " + a + "x " + b + "y = " + c ) ; } else { System . out . println ( "The line passing through points P and Q is: " + a + "x + " + b + "y = " + c ) ; } }

static void lineFromPoints ( int P [ ] , int Q [ ] ) { int a = P [ 0 ] - Q [ 0 ] ; int b = Q [ 1 ] - Q [ 1 ] ; int c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) ; if ( a < 0 ) { print ( "ThelinepassingthroughpointsPandQis:" , a , "x" , b , "y=" ,

static void lineFromPoints ( int P , int Q ) { int a = Q [ 1 ] - P [ 0 ] ; int b = P [ 0 ] - Q [ 0 ] ; c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) ; if ( b < 0 ) { print ( "ThelinepassingthroughpointsPandQis:" , a , "x" , b , "y=" , c , "\n" ) ; } else { print ( "ThelinepassingthroughpointsPandQis:" , a , "x+" , b , "y=" , c , "\n" ) ; } }

18.94
33.54
65.95
57.87
def findCommon ( mat ) : column = [ N - 1 ] * M min_row = 0 while ( column [ min_row ] >= 0 ) : for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : min_row = i eq_count = 0 for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) : if ( column [ i ] == 0 ) : return - 1 column [ i ] -= 1 else : eq_count += 1 if ( eq_count == M ) : return mat [ min_row ] [ column [ min_row ] ] return - 1

static int findCommon ( int mat [ ] [ ] ) { int column [ ] = new int [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return - 1 ; }

static int findCommon ( int mat [ ] [ ] , int N ) { int min_row = 0 ; int eq_count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { min_row = i ; eq_count ++ ; if ( eq_count == M ) return mat [ min_

int findCommon ( int mat [ ] [ ] , int column [ ] ) { int min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( int i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) { min_row = i ; eq_count = 0 for ( i in range ( M ) ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 column [ i ] -= 1 ; else else eq_count += 1 ; if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } } } } return - 1 ; }

18.94
25.94
49.98
43.79
def find_maximum ( a , n , k ) : b = dict ( ) for i in range ( n ) : x = a [ i ] d = min ( 1 + i , n - i ) if x not in b . keys ( ) : b [ x ] = d else : b [ x ] = min ( d , b [ x ] ) ans = 10 ** 9 for i in range ( n ) : x = a [ i ] if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) return ans

static int find_maximum ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . min ( 1 + i , n - i ) ; if ( ! b . containsKey ( x ) ) b . put ( x , d ) ; else { b . put ( x , Math . min ( d , b . get ( x ) ) ) ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ; } return ans ; }

static int find_maximum ( int [ ] a , int n , int k ) { int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int d = min ( 1 + i , n - i ) ; if ( x != k ) b [ x ] = max ( b [ x ] , b [ k - x ] ) ; else b [ x ] = max ( b [ x ] , b

static int find_maximum ( int [ ] a , int n , int k ) { int b = dict ( ) ; for ( int i = 0 ; i < n ; i ++ ) { x = a [ i ] d = min ( 1 + i , n - i ) ; if ( x not in b . keys ( ) ) b [ x ] = d ; else b [ x ] = min ( d , b [ x ] ) ; } ans = 10 ** 9 ; for ( int i = 0 ; i < n ; i ++ ) { x = a [ i ] d = min ( 1 + i , n - i ) ; if ( x != ( k - x ) && ( k - x ) in b . keys ( ) ) { ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) ; } } return ans ; }

19.07
24.65
45.99
63.53
def isMultipleOf10 ( n ) : return ( n % 15 == 0 )

static boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }

static boolean isMultipleOf10 ( int n ) { return

static boolean isMultipleOf10 ( int n ) { return ( n % 10 == 0 ) ; }

19.11
29.33
59.76
49.82
def Restore_Tree ( S , E ) : Identity = N * [ 0 ] for i in range ( N ) : Identity [ Start [ i ] ] = i parent = N * [ - 1 ] curr_parent = Identity [ 0 ] for j in range ( 1 , N ) : child = Identity [ j ] if End [ child ] - j > 1 : parent [ child ] = curr_parent curr_parent = child else : parent [ child ] = curr_parent while End [ child ] == End [ parent [ child ] ] : child = parent [ child ] curr_parent = parent [ child ] if curr_parent == Identity [ 0 ] : break for i in range ( N ) : parent [ i ] += 1 return parent

static int [ ] Restore_Tree ( int [ ] S , int [ ] End ) { int [ ] Identity = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Identity [ S [ i ] ] = i ; int [ ] parent = new int [ N ] ; Arrays . fill ( parent , - 1 ) ; int curr_parent = Identity [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) { int child = Identity [ j ] ; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_parent ; curr_parent = child ; } else { parent [ child ] = curr_parent ; while ( parent [ child ] > - 1 && End [ child ] == End [ parent [ child ] ] ) { child = parent [ child ] ; curr_parent = parent [ child ] ; if ( curr_parent == Identity [ 0 ] ) break ; } } } for ( int i = 0 ; i < N ; i ++ ) parent [ i ] += 1 ; return parent ; }

static void Restore_Tree ( int S , int E , int N ) { int Identity [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int child = Identity [ i ] ; if ( curr_parent == Identity [ 0 ] ) curr_parent = child ; else parent [ child ] = curr_parent ; for ( int j = 1 ; j <= N ; j ++ ) { parent [ child ] = curr_parent

static int Restore_Tree ( int S , int E ) { int Identity [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { Identity [ Start [ i ] ] = i ; parent = N * [ - 1 ] ; for ( int j = 1 ; j < N ; j ++ ) { child = Identity [ j ] ; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_parent ; curr_parent = child ; } else { parent [ child ] = curr_parent ; } } } for ( int i = 0 ; i < N ; i ++ ) { Identity [ Start [ i ] ] = i ; parent = N * [ - 1 ] ; for ( int j = 1 ; j < N ; j ++ ) { child = Identity [ j ] ; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_parent ; curr_parent = child ; } else { parent [ child ] = curr_parent ; } } } return parent ; }

19.21
36.34
45.4
47.48
def check ( s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] ) dp [ 0 ] [ 0 ] = True for i in range ( len ( s1 ) ) : for j in range ( len ( s2 ) + 1 ) : if ( dp [ i ] [ j ] ) : if ( ( j < len ( s2 ) and ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) : dp [ i + 1 ] [ j + 1 ] = True if ( s1 [ i ] . isupper ( ) == False ) : dp [ i + 1 ] [ j ] = True return ( dp [ n ] [ m ] )

static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }

static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] [ j ] == true ) dp [ i ] [ j ] = true ; if ( ( j < len ( s

static int check ( String s1 , String s2 ) { int n = len ( s1 ) ; int m = len ( s2 ) ; int dp [ ] [ 0 ] = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( ( j < len ( s2 ) && ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( s1 [ i ] . isupper ( ) == false ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }

19.36
27.56
40.06
39.74
def longLenSub ( arr , n ) : um = defaultdict ( lambda : 0 ) longLen = 0 for i in range ( n ) : len1 = 0 if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : len1 = um [ arr [ i ] - 1 ] if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : len1 = um [ arr [ i ] + 1 ] um [ arr [ i ] ] = len1 + 1 if longLen < um [ arr [ i ] ] : longLen = um [ arr [ i ] ] return longLen

static int longLenSub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }

static long longLenSub ( long [ ] arr , int n ) { longLen = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int len1 = 0 ; if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) { len1 = um [ arr [ i ] - 1 ] ; um [ arr [ i ] - 1 ] = len1 + 1 ; } } return longLen ; }

static int longLenSub ( int arr [ ] , int n ) { int [ ] um = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len1 = 0 ; if ( arr [ i - 1 ] in um && len1 < um [ arr [ i ] - 1 ] ) len1 = um [ arr [ i ] - 1 ] ; if ( arr [ i ] + 1 in um && len1 < um [ arr [ i ] + 1 ] ) len1 = um [ arr [ i ] + 1 ] ; if ( arr [ i ] + 1 in um && len1 < um [ arr [ i ] + 1 ] ) len1 = um [ arr [ i ] + 1 ] ; if ( arr [ i ] + 1 in um && len1 < um [ arr [ i ] + 1 ] ) len1 = um [ arr [ i ] + 1 ] ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } } return longLen ; }

19.37
26.48
51.68
45.43
def containsOdd ( G , src ) : global V colorArr = [ - 1 ] * V colorArr [ src ] = 1 q = queue . Queue ( ) q . put ( src ) while ( not q . empty ( ) ) : u = q . get ( ) if ( G [ u ] [ u ] == 1 ) : return True for v in range ( V ) : if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) : colorArr [ v ] = 1 - colorArr [ u ] q . put ( v ) elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) : return True return False

public static boolean containsOdd ( int G [ ] [ ] , int src ) { int colorArr [ ] = new int [ V ] ; for ( int i = 0 ; i < V ; ++ i ) colorArr [ i ] = - 1 ; colorArr [ src ] = 1 ; LinkedList < Integer > q = new LinkedList < Integer > ( ) ; q . add ( src ) ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; q . pop ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] == 1 && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] == 1 && colorArr [ v ] == colorArr [ u ] ) return true ; } } return false ; }

static boolean containsOdd ( int [ ] G , int src ) { int [ ] colorArr = new int [ V ] ; if ( G [ src ] [ src ] == - 1 ) { colorArr [ src ] = 1 - colorArr [ src ] ; } else { for ( int v = 0 ; v < V ; v ++ ) if ( G [ src ] [ v ] == - 1 ) { colorArr [ src ] = 1 - colorArr [ u ] ; } }

static boolean containsOdd ( int [ ] G , int src ) { int [ ] colorArr = new int [ V ] ; for ( int v = 0 ; v < V ; v ++ ) { if ( G [ u ] [ v ] && colorArr [ v ] == 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . put ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . put ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . put ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; } } return true ; }

19.52
30.35
33.96
45.24
def isPossible ( n , index , Sum , M , arr , dp ) : global MAX if index == n : if ( Sum % M ) == 0 : return True return False if dp [ index ] [ Sum ] != - 1 : return dp [ index ] [ Sum ] placeAdd = isPossible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp ) res = placeAdd or placeMinus dp [ index ] [ Sum ] = res return res

static boolean isPossible ( int n , int index , int sum , int M , int arr [ ] , int dp [ ] [ ] ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } else if ( sum < 0 || sum >= MAX ) return false ; if ( dp [ index ] [ sum ] != - 1 ) { if ( dp [ index ] [ sum ] == 0 ) return false ; return true ; } boolean placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , M , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) ; boolean res = ( placeAdd || placeMinus ) ; dp [ index ] [ sum ] = ( res ) ? 1 : 0 ; return res ; }

static boolean isPossible ( int n , int index , int Sum , int M , int [ ] arr , int [ ] dp ) { if ( dp [ index ] [ Sum ] != - 1 ) return dp [ index ] [ Sum ] ; return false ; }  static boolean isPossible ( int n , int index , int Sum , int M , int [ ] arr , int [ ] dp ) { boolean res = false ; dp [ index ] [ Sum ] = new

static boolean isPossible ( int n , int Sum , int M , int arr [ ] , int dp [ ] [ ] ) { boolean placeAdd = isPossible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp ) ; res = placeAdd || placeMinus ; dp [ index ] [ Sum ] = res ; return res ; }

19.54
36.43
80.48
74.3
def findMaxPath ( mat ) : res = - 1 for i in range ( M ) : res = max ( res , mat [ 0 ] [ i ] ) for i in range ( 1 , N ) : res = - 1 for j in range ( M ) : if ( j > 0 and j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) elif ( j > 0 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) elif ( j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) res = max ( mat [ i ] [ j ] , res ) return res

static int findMaxPath ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < M ; i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ; for ( int i = 1 ; i < N ; i ++ ) { res = - 1 ; for ( int j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; res = max ( mat [ i ] [ j ] , res ) ; } } return res ; }

static int findMaxPath ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < M ; j ++ ) if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ; else res =

int findMaxPath ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { res = - 1 for ( int j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) { mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ; } else if ( j > 0 ) { mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; } else if ( j < M - 1 ) { mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; } else if ( j < M - 1 ) { mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; } } } return res ; }

19.67
31.47
48.46
49.52
def minAdjustmentCost ( A , n , target ) : dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] for j in range ( M + 1 ) : dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) for i in range ( 1 , n ) : for j in range ( M + 1 ) : dp [ i ] [ j ] = 100000000 for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) res = 10000000 for j in range ( M + 1 ) : res = min ( res , dp [ n - 1 ] [ j ] ) return res

static int minAdjustmentCost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }

static int minAdjustmentCost ( int [ ] A , int M , int target ) { int [ ] dp = [ [ ] for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } return

static int minAdjustmentCost ( int A , int n , int target ) { int dp [ ] [ ] = new int [ M + 1 ] [ M + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ j ] = abs ( i - A [ i ] ) ; for ( int j = 0 ; j < M + 1 ; j ++ ) { dp [ i ] [ j ] = 10000000 for ( int k = max ( j - target , 0 ) , min ( M , j + target ) + 1 ) ; dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } return res ; }

19.68
27.15
30.37
36.21
def findSmallest ( m , s ) : if ( s == 0 ) : if ( m == 1 ) : print ( "Smallestnumberis0" ) else : print ( "Notpossible" ) return if ( s > 9 * m ) : print ( "Notpossible" ) return res = [ 0 for i in range ( m + 1 ) ] s -= 1 for i in range ( m - 1 , 0 , - 1 ) : if ( s > 9 ) : res [ i ] = 9 s -= 9 else : res [ i ] = s s = 0 res [ 0 ] = s + 1 print ( "Smallestnumberis" , end = "" ) for i in range ( m ) : print ( res [ i ] , end = "" )

static void findSmallest ( int m , int s ) { if ( s == 0 ) { System . out . print ( m == 1 ? "Smallest number is 0" : "Not possible" ) ; return ; } if ( s > 9 * m ) { System . out . println ( "Not possible" ) ; return ; } int [ ] res = new int [ m ] ; s -= 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( s > 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; System . out . print ( "Smallest number is " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; }

static void findSmallest ( int m , int s ) { if ( m == 1 ) return ; if ( s > 9 * m ) return ; if ( s > 9 * m ) return ; if ( s > 9 * m ) return ; if ( s > 9 * m ) return ; if ( s > 9 ) res [ 0 ] = 9 ; else res [ 0 ] = s + 1 ; else res [ 0 ] = 9 ; else res [ 0 ] =

static void findSmallest ( int m , int s ) { int res [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { res [ i ] = findSmallest ( m , s ) ; if ( res [ i ] == 0 ) res [ i ] = 9 ; else res [ i ] = 9 ; } for ( int i = 0 ; i < m ; i ++ ) { res [ i ] = findSmallest ( m , s ) ; } for ( int i = 0 ; i < m ; i ++ ) { res [ i ] = findSmallest ( m , s ) ; } for ( int i = 0 ; i < m ; i ++ ) { res [ i ] = findSmallest ( m , s ) ; } for ( int i = 0 ; i < m ; i ++ ) { res [ i ] = findSmallest ( m , s ) ; } for ( int i = 0 ; i < m ; i ++ ) { res [ i ] = findSmallest ( m , s ) ; } } return ; }

19.69
32.74
33.8
39.35
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : if ( k > n1 * n2 ) : print ( "kpairsdon'texist" ) return index2 = [ 0 for i in range ( n1 ) ] while ( k > 0 ) : min_sum = sys . maxsize min_index = 0 for i1 in range ( 0 , n1 , 1 ) : if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : min_index = i1 min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] print ( "(" , arr1 [ min_index ] , "," , arr2 [ index2 [ min_index ] ] , ")" , end = "" ) index2 [ min_index ] += 1 k -= 1

static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { System . out . print ( "k pairs don't exist" ) ; return ; } int index2 [ ] = new int [ n1 ] ; while ( k > 0 ) { int min_sum = Integer . MAX_VALUE ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } System . out . print ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) ; index2 [ min_index ] ++ ; k -- ; } }

static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int k ) { int index2 [ ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( index2 [ i ] < n2 ) min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; if ( min_sum < k

static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int k ) { for ( int i = 0 ; i < n1 ; i ++ ) { if ( index2 [ i ] < n2 and arr1 [ i ] + arr2 [ index2 [ i ] ] < min_sum ) { min_index = i ; min_sum = arr1 [ i ] + arr2 [ index2 [ i ] ] ; } print ( "(" , arr1 [ min_index ] , "," , arr2 [ index2 [ min_index ] ] , ")" , end = "" ) index2 [ min_index ] += 1 k -= 1 ; } } }

19.69
27.94
17.13
29.55
def splitString ( str ) : alpha = "" num = "" special = "" for i in range ( len ( str ) ) : if ( str [ i ] . isdigit ( ) ) : num = num + str [ i ] elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( str [ i ] >= 'a' and str [ i ] <= 'z' ) ) : alpha += str [ i ] else : special += str [ i ] print ( alpha ) print ( num ) print ( special )

static void splitString ( String str ) { StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ; else if ( Character . isAlphabetic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ; else special . append ( str . charAt ( i ) ) ; } System . out . println ( alpha ) ; System . out . println ( num ) ; System . out . println ( special ) ; }

static void splitString ( String str ) { String alpha = "" ; String num = "" ; String special = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] . isalpha ( ) ) { alpha = alpha + str [ i ] ; } else { num = num + str [ i ] ; } } return ; }

static void splitString ( String str ) { String alpha = "" ; String num = "" ; String special = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] . isdigit ( ) ) { num = num + str [ i ] ; } else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { alpha = alpha + str [ i ] ; } else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { alpha = alpha + str [ i ] ; } else if ( str [ i ] >= 'A' && str [ i ] <= 'A' ) { alpha = alpha + str [ i ] ; } else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { alpha = alpha + str [ i ] ; } else if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { alpha = alpha + str [ i ] ; } else if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { alpha = alpha + str [ i

19.71
30.13
51.4
57.15
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) if ( dis1 != dis2 ) : print ( "No" ) elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : print ( "No" ) else : print ( "Yes" )

static void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) System . out . print ( "No" ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( "No" ) ; else System . out . print ( "Yes" ) ; }

static void possibleOrNot ( double a1 , double a2 , double b1 , double b2 , double c1 , double c2 ) { double dis1 = ( pow ( a1 + a2 ) / 2.0 ) + pow ( a2 + c1 ) / 2.0 ) ; double dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) ; if ( dis1 != dis

static void possibleOrNot ( int a1 , int a2 , int b1 , int b2 , int c1 , int c2 ) { double dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) ; double dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) ; if ( dis1 != dis2 ) { print ( "No" ) ; } else if ( b1 == ( ( a1 + c1 ) // 2.0 ) && b2 == ( ( a2 + c2 ) // 2.0 ) ) { print ( "No" ) ; } else { print ( "Yes" ) ; } } }

19.87
27.29
31.58
34.92
def commonCharacters ( strings , n ) : prim = [ True ] * MAX_CHAR for i in range ( n ) : sec = [ False ] * MAX_CHAR for j in range ( len ( strings [ i ] ) ) : if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) : sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = True for i in range ( MAX_CHAR ) : prim [ i ] = sec [ i ] for i in range ( 26 ) : if ( prim [ i ] ) : print ( "%c" % ( i + ord ( 'a' ) ) , end = "" )

public static void commonCharacters ( String str [ ] , int n ) { Boolean [ ] prim = new Boolean [ MAX_CHAR ] ; Arrays . fill ( prim , new Boolean ( true ) ) ; for ( int i = 0 ; i < n ; i ++ ) { Boolean [ ] sec = new Boolean [ MAX_CHAR ] ; Arrays . fill ( sec , new Boolean ( false ) ) ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { if ( prim [ str [ i ] . charAt ( j ) - 'a' ] ) sec [ str [ i ] . charAt ( j ) - 'a' ] = true ; } System . arraycopy ( sec , 0 , prim , 0 , MAX_CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) { System . out . print ( Character . toChars ( i + 97 ) ) ; System . out . print ( " " ) ; } }

static void commonCharacters ( String [ ] strings , int n ) { boolean prim [ ] = new boolean [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { boolean sec [ ] = new boolean [ MAX_CHAR ] ; for ( int j = 0 ; j < len ( strings [ i ] ) ; j ++ ) { if ( sec [ i ] ) { print ( "%c" % ( i + ord ( 'a' ) ) ; } } } }

static void commonCharacters ( String [ ] strings , int n ) { String [ ] prim = new String [ n ] ; String [ ] sec = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) { prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = true ; prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = true ; prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) { prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = true ; prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = true ; prim [ ord ( strings [ i ] [

19.9
27.53
39.56
48.41
def checkPoint ( radius , x , y , percent , startAngle ) : endAngle = 360 / percent + startAngle polarradius = math . sqrt ( x * x + y * y ) Angle = math . atan ( y / x ) if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : print ( "Point(" , x , "," , y , ")" "existinthecirclesector" ) else : print ( "Point(" , x , "," , y , ")" "doesnotexistinthecirclesector" )

static void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; double polarradius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" ) ; else System . out . print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" ) ; }

static void checkPoint ( int radius , int x , int y , int percent ) { int startAngle = 360 / percent + startAngle ; int endAngle = 360 / percent + endAngle ; if ( Angle >= startAngle and Angle <= endAngle ) { print ( "Point(" , x , "," , y , ")" "doesnotexistinthecirclesector" ) } else { print ( "Point(" , x , "," , y , ")" "doesnotexist

static void checkPoint ( int radius , int x , int y , float percent , int startAngle ) { int endAngle = 360 / percent + startAngle ; int Angle = math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle ) { System . out . println ( "Point(" , radius , "," , y , ")" ) ; } else if ( Angle >= startAngle && Angle <= endAngle ) { System . out . println ( "Point(" , radius , "," , y , ")" "doesnotexistinthecirclesector" ) ; } else { System . out . println ( "Point(" , radius , "," , y , ")" "doesnotexistinthecirclesector" ) ; } }

20.06
27.33
23.04
28.38
def minOperation ( arr , n ) : Hash = defaultdict ( lambda : 0 ) for i in range ( 0 , n ) : Hash [ arr [ i ] ] += 1 max_count = 0 for i in Hash : if max_count < Hash [ i ] : max_count = Hash [ i ] return n - max_count

public static int minOperation ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; else hash . put ( arr [ i ] , 1 ) ; int max_count = 0 ; Set < Integer > s = hash . keySet ( ) ; for ( int i : s ) if ( max_count < hash . get ( i ) ) max_count = hash . get ( i ) ; return ( n - max_count ) ; }

static int minOperation ( int arr [ ] , int n ) { int Hash [ ] = new int [ arr . length ] ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_count < Hash [ i ] ) max_count = Hash [ i ] ; } return n - max_count ; }

static int minOperation ( int arr [ ] , int n ) { int Hash [ ] = new int [ n ] ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Hash [ arr [ i ] ] ++ ; if ( max_count < Hash [ i ] ) max_count = Hash [ i ] ; } return n - max_count ; }

20.07
28.52
30.78
39.1
def calculate ( a , n ) : a . sort ( ) s = [ ] i = 0 j = n - 1 while ( i < j ) : s . append ( ( a [ i ] + a [ j ] ) ) i += 1 j -= 1 mini = min ( s ) maxi = max ( s ) return abs ( maxi - mini )

static long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; }

static int calculate ( int [ ] a , int n ) { int i = 0 ; int j = a . length - 1 ; while ( i < j ) s . append ( ( a [ i ] + a [ j ] ) / 2 ) ; i ++ ; j -- ; } return 0 ; }

static int calculate ( int [ ] a , int n ) { int i = 0 ; int j = n - 1 ; while ( i < j ) { s . append ( ( a [ i ] + a [ j ] ) / 2 ) ; i ++ ; j -- ; } return Math . abs ( maxi - mini ) ; }

20.15
30.47
46.95
44.6
def printLevels ( graph , V , x ) : level = [ None ] * V marked = [ False ] * V que = queue . Queue ( ) que . put ( x ) level [ x ] = 0 marked [ x ] = True while ( not que . empty ( ) ) : x = que . get ( ) for i in range ( len ( graph [ x ] ) ) : b = graph [ x ] [ i ] if ( not marked [ b ] ) : que . put ( b ) level [ b ] = level [ x ] + 1 marked [ b ] = True print ( "Nodes" , "" , "Level" ) for i in range ( V ) : print ( "" , i , "-->" , level [ i ] )

static void printLevels ( Vector < Vector < Integer >> graph , int V , int x ) { int level [ ] = new int [ V ] ; boolean marked [ ] = new boolean [ V ] ; Queue < Integer > que = new LinkedList < Integer > ( ) ; que . add ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( que . size ( ) > 0 ) { x = que . peek ( ) ; que . remove ( ) ; for ( int i = 0 ; i < graph . get ( x ) . size ( ) ; i ++ ) { int b = graph . get ( x ) . get ( i ) ; if ( ! marked [ b ] ) { que . add ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } System . out . println ( "Nodes" + " " + "Level" ) ; for ( int i = 0 ; i < V ; i ++ ) System . out . println ( " " + i + " --> " + level [ i ] ) ; }

static void printLevels ( int [ ] graph , int V , int x ) { int [ ] level = new int [ V ] ; int marked [ ] = false ; for ( int i = 0 ; i < V ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . put ( b ) level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } }

static void printLevels ( Graph graph , int V , int x ) { int level [ ] = new int [ V ] ; int [ ] marked = new int [ V ] ; for ( int i = 0 ; i < V ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . put ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } for ( int i = 0 ; i < V ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . put ( b ) level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } for ( int i = 0 ; i < V ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . put ( b ) level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } return ; }

20.18
36.54
29.75
33.75
def checkStar ( mat ) : global size vertexD1 = 0 vertexDn_1 = 0 if ( size == 1 ) : return ( mat [ 0 ] [ 0 ] == 0 ) if ( size == 2 ) : return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) for i in range ( 0 , size ) : degreeI = 0 for j in range ( 0 , size ) : if ( mat [ i ] [ j ] ) : degreeI = degreeI + 1 if ( degreeI == 1 ) : vertexD1 = vertexD1 + 1 elif ( degreeI == size - 1 ) : vertexDn_1 = vertexDn_1 + 1 return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 )

static boolean checkStar ( int mat [ ] [ ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }

static boolean checkStar ( int mat [ ] [ ] ) { int degreeI = 0 ; int vertexDn_1 = 0 ; int vertexD1 = 0 ; int vertexDn_1 = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( mat [ i ] [ j ] == 0 ) vertexD1 = vertexD1 + 1 ; if ( degreeI == 1 ) vertexDn_1 = vertexDn_1 + 1 ;

static boolean checkStar ( int [ ] mat , int vertexD1 , int vertexDn_1 ) { if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; return ( mat [ 0 ] [ 0 ] == 0 ) ; }

20.3
29.63
34.53
40.0
def deleteElements ( arr , n , k ) : st = [ ] st . append ( arr [ 0 ] ) top = 0 count = 0 for i in range ( 1 , n ) : while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) : st . pop ( ) count += 1 top -= 1 st . append ( arr [ i ] ) top += 1 for i in range ( 0 , len ( st ) ) : print ( st [ i ] , "" , end = "" )

static void deleteElements ( int arr [ ] , int n , int k ) { Stack < Integer > s = new Stack < > ( ) ; s . push ( arr [ 0 ] ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . push ( arr [ i ] ) ; } int m = s . size ( ) ; Integer [ ] v = new Integer [ m ] ; while ( ! s . empty ( ) ) { v [ -- m ] = s . peek ( ) ; s . pop ( ) ; } for ( Integer x : v ) { System . out . print ( x + "" ) ; }; System . out . println ( "" ) ; }

static void deleteElements ( int arr [ ] , int n , int k ) { int st [ ] = new int [ arr . length - 1 ] ; int count = 0 ; int top = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( st [ i ] > arr [ i ] ) st . pop ( ) ; count += 1 ; top -=

static void deleteElements ( int arr [ ] , int n , int k ) { int st [ ] . append ( arr [ 0 ] ) ; int top = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( len ( st ) != 0 && count < k && st [ top ] < arr [ i ] ) st . pop ( ) ; count += 1 ; top -= 1 st . append ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { deleteElements ( arr [ i ] , k ) ; } }

20.31
32.67
42.62
41.95
def playGame ( arr , n ) : s = set ( ) for i in range ( n ) : s . add ( arr [ i ] ) return 1 if len ( s ) % 2 == 0 else 2

public static int playGame ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i : arr ) set . add ( i ) ; return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ; }

static int playGame ( int arr [ ] , int n ) { Set < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( s . contains ( arr [ i ] ) ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) return 1 ; if ( s . contains ( arr [

static int playGame ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; } return 1 ; }

20.39
30.19
27.97
33.51
def checkSorted ( n , q ) : st = [ ] expected = 1 fnt = None while ( not q . empty ( ) ) : fnt = q . queue [ 0 ] q . get ( ) if ( fnt == expected ) : expected += 1 else : if ( len ( st ) == 0 ) : st . append ( fnt ) elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) : return False else : st . append ( fnt ) while ( len ( st ) != 0 and st [ - 1 ] == expected ) : st . pop ( ) expected += 1 if ( expected - 1 == n and len ( st ) == 0 ) : return True return False

static boolean checkSorted ( int n ) { Stack < Integer > st = new Stack < Integer > ( ) ; int expected = 1 ; int fnt ; while ( q . size ( ) != 0 ) { fnt = q . peek ( ) ; q . poll ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . size ( ) == 0 ) { st . push ( fnt ) ; } else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) { return false ; } else st . push ( fnt ) ; } while ( st . size ( ) != 0 && st . peek ( ) == expected ) { st . pop ( ) ; expected ++ ; } } if ( expected - 1 == n && st . size ( ) == 0 ) return true ; return false ; }

static boolean checkSorted ( int n , Queue < int > q ) { int expected = 1 ; int st [ ] = new int [ n ] ; while ( fnt == expected ) { if ( len ( st ) == 0 ) st . append ( fnt ) ; else if ( expected - 1 == n ) st . pop ( ) ; else { if ( len ( st ) != 0 ) st . append ( fnt ) ; else if ( expected - 1 == n

static boolean checkSorted ( int n , Queue < Integer > q ) { int st [ ] = new int [ n ] ; int expected = 1 ; int fnt = null ; while ( ! q . empty ( ) ) { fnt = q . queue [ 0 ] ; q . get ( ) ; if ( fnt == expected ) st . append ( fnt ) ; else if ( fnt == expected ) st . append ( fnt ) ; else if ( fnt == expected ) st . append ( fnt ) ; else if ( fnt == expected ) st . append ( fnt ) ; else if ( fnt == expected ) st . append ( fnt ) ; else if ( fnt == expected ) st . append ( fnt ) ; else if ( fnt == expected ) st . append ( fnt ) ; else if ( fnt == expected ) st . append ( fnt ) ; } } return true ; }

20.44
24.8
35.18
36.78
def check ( s ) : if ( len ( s ) >= 10 ) : return True for i in range ( 1 , len ( s ) ) : for j in range ( i + 1 , len ( s ) ) : for k in range ( j + 1 , len ( s ) ) : s1 = s [ 0 : i ] s2 = s [ i : j - i ] s3 = s [ j : k - j ] s4 = s [ k : len ( s ) - k ] if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : return True return False

public static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . length ( ) ; k ++ ) { String s1 = "" , s2 = "" , s3 = "" , s4 = "" ; try { s1 = s . substring ( 0 , i ) ; s2 = s . substring ( i , j - i ) ; s3 = s . substring ( j , k - j ) ; s4 = s . substring ( k , s . length ( ) - k ) ; } catch ( StringIndexOutOfBoundsException e ) { } if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) && strcheck ( s1 , s4 ) && strcheck ( s2 , s3 ) && strcheck ( s2 , s4 ) && strcheck ( s3 , s4 ) ) return true ; } } } return false ; }

static boolean check ( String s ) { if ( s . length ( ) < 10 ) return false ; for ( int i = 1 ; i <= len ( s ) ; i ++ ) { for ( int j = 0 ; j < len ( s ) ; j ++ ) { if ( s . charAt ( i ) == 'a' ) return true ; for ( int k = 0 ; k < len ( s ) ; k ++ ) { if ( s . charAt ( j ) == 'a' ) return true ; } } }

static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < len ( s ) ; i ++ ) { for ( int j = 1 ; j < len ( s ) ; j ++ ) { for ( int k = 1 ; k < len ( s ) ; k ++ ) { s1 = s [ 0 : i ] s2 = s [ i : j - i ] s3 = s [ j : k - j ] s4 = s [ k : len ( s ) - k ] ; if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true ; } } return false ; }

20.48
30.26
27.19
37.1
def pairWiseConsecutive ( s ) : aux = [ ] while ( len ( s ) != 0 ) : aux . append ( s [ - 1 ] ) s . pop ( ) result = True while ( len ( aux ) > 1 ) : x = aux [ - 1 ] aux . pop ( ) y = aux [ - 1 ] aux . pop ( ) if ( abs ( x - y ) != 1 ) : result = False s . append ( x ) s . append ( y ) if ( len ( aux ) == 1 ) : s . append ( aux [ - 1 ] ) return result

static boolean pairWiseConsecutive ( Stack < Integer > s ) { Stack < Integer > aux = new Stack < Integer > ( ) ; while ( ! s . isEmpty ( ) ) { aux . push ( s . peek ( ) ) ; s . pop ( ) ; } boolean result = true ; while ( aux . size ( ) > 1 ) { int x = aux . peek ( ) ; aux . pop ( ) ; int y = aux . peek ( ) ; aux . pop ( ) ; if ( Math . abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . peek ( ) ) ; return result ; }

static boolean pairWiseConsecutive ( int [ ] s ) { int result = true ; while ( len ( s ) > 0 ) { int x = s [ - 1 ] ; s . pop ( ) if ( abs ( x - y ) != 1 ) { result = false s . append ( x ) s . append ( y ) if ( len ( aux ) > 1 ) { result = false s . append ( aux [ - 1 ] ) s . append ( y

static boolean pairWiseConsecutive ( int [ ] s ) { int [ ] aux = new int [ 1 ] ; while ( len ( s ) != 0 ) { aux . append ( s [ - 1 ] ) ; s . pop ( ) ; if ( abs ( x - y ) != 1 ) result = false s . append ( x ) ; s . append ( y ) ; if ( len ( aux ) == 1 ) s . append ( aux [ 0 ] ) ; } } return result ; }

20.48
26.21
32.87
36.36
def printDuo ( string ) : countChar = [ 0 for i in range ( MAX_CHAR ) ] n = len ( string ) for i in range ( n ) : countChar [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 str1 = "" str2 = "" for i in range ( MAX_CHAR ) : if ( countChar [ i ] > 1 ) : str2 = str2 + chr ( i + ord ( 'a' ) ) elif ( countChar [ i ] == 1 ) : str1 = str1 + chr ( i + ord ( 'a' ) ) print ( "Stringwithcharactersoccurringonce:" , "\n" , str1 ) print ( "Stringwithcharactersoccurring" , "multipletimes:" , "\n" , str2 )

static void printDuo ( String str ) { int countChar [ ] = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countChar [ str . charAt ( i ) - 'a' ] ++ ; } String str1 = "" , str2 = "" ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( countChar [ i ] > 1 ) { str2 = str2 + ( char ) ( i + 'a' ) ; } else if ( countChar [ i ] == 1 ) { str1 = str1 + ( char ) ( i + 'a' ) ; } } System . out . print ( "String with characters occurring " + "once:\n" ) ; System . out . print ( str1 + "\n" ) ; System . out . print ( "String with characters occurring " + "multiple times:\n" ) ; System . out . print ( str2 + "\n" ) ; System . out . print ( "" ) ; }

static void printDuo ( String string ) { int countChar [ ] = 0 ; int n = string . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countChar [ i ] > 1 ) str1 = str1 + chr ( i + ord ( 'a' ) ) ; else str2 = str2 + chr ( i + ord ( 'a' ) ) ; else str1 = str1 + chr ( i + ord ( 'a' ) ; } }

static void printDuo ( String string ) { int countChar = new int [ MAX_CHAR ] ; int n = len ( string ) ; for ( int i = 0 ; i < n ; i ++ ) { countChar [ ord ( string [ i ] ) - ord ( 'a' ) ] ++ ; if ( countChar [ i ] > 1 ) str2 = str2 + chr ( i + ord ( 'a' ) ) ; else if ( countChar [ i ] == 1 ) str1 = str1 + chr ( i + ord ( 'a' ) ) ; else str1 = str1 + chr ( i + ord ( 'a' ) ) ; str2 = str2 + chr ( i + ord ( 'a' ) ) ; } }

20.55
28.38
28.79
34.46
def findRepeating ( arr , n ) : return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 )

static int findRepeating ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum - ( ( ( n - 1 ) * n ) / 2 ) ; }

static int findRepeating ( int arr , int n ) { int sum = arr . sum ( ) ; int sum = arr . sum ( ) ; int sum = arr . sum ( ) ; int sum = arr . sum ( ) ; int sum = arr . sum ( ) ; int sum = arr . sum ( ) ; int sum = arr . sum ( ) ; return sum ; }

static int findRepeating ( int arr [ ] , int n ) { return sum ( arr ) - ( ( ( n - 1 ) * n ) ; }

20.83
24.11
39.77
43.44
def arrangeString ( string ) : char_count = [ 0 ] * MAX_CHAR s = 0 for i in range ( len ( string ) ) : if string [ i ] >= "A" and string [ i ] <= "Z" : char_count [ ord ( string [ i ] ) - ord ( "A" ) ] += 1 else : s += ord ( string [ i ] ) - ord ( "0" ) res = "" for i in range ( MAX_CHAR ) : ch = chr ( ord ( "A" ) + i ) while char_count [ i ] : res += ch char_count [ i ] -= 1 if s > 0 : res += str ( s ) return res

static String arrangeString ( String str ) { int char_count [ ] = new int [ MAX_CHAR ] ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) char_count [ str . charAt ( i ) - 'A' ] ++ ; else sum = sum + ( str . charAt ( i ) - '0' ) ; } String res = "" ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( 'A' + i ) ; while ( char_count [ i ] -- != 0 ) res = res + ch ; } if ( sum > 0 ) res = res + sum ; return res ; }

static String arrangeString ( String string ) { int char_count [ ] = 0 ; int s = 0 ; for ( int i = 0 ; i < len ( string ) ; i ++ ) { char_count [ ord ( string [ i ] ) - ord ( "A" ) ] ++ ; if ( char_count [ i ] > 0 ) res += ch ; char_count [ i ] -= 1 ; if ( s > 0 ) res += str ( s

static String arrangeString ( String string ) { int char_count [ ] = new int [ MAX_CHAR ] ; int s = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string [ i ] >= "A" && string [ i ] <= "Z" ) char_count [ ord ( string [ i ] ) - ord ( "A" ) ] += 1 ; else s += ord ( "0" ) ; } res = "" ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string [ i ] >= "A" && string [ i ] <= "Z" ) char_count [ ord ( string [ i ] ) - ord ( "A" ) ] += 1 ; else s += ord ( string [ i ] ) - ord ( "0" ) ; } return res ; }

20.86
30.67
59.4
52.87
def waysToArrange ( N , K , k ) : C = np . zeros ( ( N + 1 , N + 1 ) ) for i in range ( N + 1 ) : for j in range ( i + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) dp = np . zeros ( ( K + 1 ) ) count = 0 dp [ 0 ] = 1 for i in range ( K ) : dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) count += k [ i ] return dp [ K ]

static int waysToArrange ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }

static int waysToArrange ( int N , int K , int k ) { int C [ ] [ ] = new int [ N + 1 ] [ K + 1 ] [ K + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( j == 0 ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = (

static int waysToArrange ( int N , int K , int k ) { int C = np . zeros ( ( N + 1 , N + 1 ) ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 or j == i ) C [ i ] [ j ] = 1 ; else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }

20.9
29.08
55.77
51.38
def minAbsSumPair ( arr , arr_size ) : inv_count = 0 if arr_size < 2 : print ( "InvalidInput" ) return min_l = 0 min_r = 1 min_sum = arr [ 0 ] + arr [ 1 ] for l in range ( 0 , arr_size - 1 ) : for r in range ( l + 1 , arr_size ) : sum = arr [ l ] + arr [ r ] if abs ( min_sum ) > abs ( sum ) : min_sum = sum min_l = l min_r = r print ( "Thetwoelementswhosesumisminimumare" , arr [ min_l ] , "and" , arr [ min_r ] )

static void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { System . out . println ( "Invalid Input" ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } System . out . println ( " The two elements whose " + "sum is minimum are " + arr [ min_l ] + " and " + arr [ min_r ] ) ; }

static void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int min_l = 0 ; int min_r = 1 ; int min_sum = arr [ 0 ] + arr [ 1 ] ; for ( int l = 0 ; l < arr_size - 1 ; l ++ ) { for ( int r = 0 ; r < arr_size ; r ++ ) { if ( min_sum > abs (

static void minAbsSumPair ( int arr [ ] , int arr_size ) { int min_l = 0 ; int min_r = 1 ; int min_sum = arr [ 0 ] + arr [ 1 ] ; for ( int l = 1 ; l < arr_size ; l ++ ) { for ( int r = 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } for ( int l = 0 ; l < arr_size - 1 ; l ++ ) { for ( int r = 0 ; r < arr_size - 1 ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } } } return ; }

20.91
36.84
26.87
48.82
def doublefactorial ( n ) : if ( n == 0 or n == 1 ) : return 1 return n * doublefactorial ( n - 2 )

static long doublefactorial ( long n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; }

static double factorial ( int n ) { int doublefactorial ( int n ) ; return doublefactorial ( n - 1 ) ; }

static int doublefactorial ( int n ) { return n * doublefactorial ( n - 1 ) ; }

20.98
27.58
36.32
36.08
def countPS ( i , j ) : if ( i >= n or j < 0 ) : return 0 if ( dp [ i ] [ j ] != - 1 ) : return dp [ i ] [ j ] if ( abs ( i - j ) == 1 ) : if ( str [ i ] == str [ j ] ) : dp [ i ] [ j ] = 3 return dp [ i ] [ j ] else : dp [ i ] [ j ] = 2 return dp [ i ] [ j ] if ( i == j ) : dp [ 1 ] [ j ] = 1 return dp [ 1 ] [ j ] elif ( str [ i ] == str [ j ] ) : dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) return dp [ i ] [ j ] else : dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) return dp [ i ] [ j ]

static int countPS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( ( i - j == 1 ) || ( i - j == - 1 ) ) { if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = 3 ; else return dp [ i ] [ j ] = 2 ; } if ( i == j ) return dp [ 1 ] [ j ] = 1 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }

static int countPS ( int i , int j ) { if ( i == j ) return dp [ i ] [ j ] + 1 ; if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] + 1 ; if ( i == j ) return dp [ i ] [ j ] + 1 ; if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] + 1 ; if ( i == j )

int countPS ( int i , int j ) { if ( i >= n || j >= n ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] == - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] == - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] == - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] == - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] == - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] == - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] == - 1 ) return dp [ i ] [ j ] ; if ( dp [ i ] [ j ] ==

21.06
35.38
40.4
44.57
def maxAverageOfPath ( cost , N ) : dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , N ) : dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] for i in range ( 1 , N ) : for j in range ( 1 , N ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )

public static double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }

static int maxAverageOfPath ( int [ ] cost , int N ) { int [ ] dp = new int [ N + 1 ] [ ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } }

static int maxAverageOfPath ( double [ ] cost , int N ) { double dp [ ] [ ] = new double [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + cost [ i ] [ j ] ; } return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; } }

21.07
31.17
51.14
47.78
def makePermutation ( a , n ) : count = dict ( ) for i in range ( n ) : if count . get ( a [ i ] ) : count [ a [ i ] ] += 1 else : count [ a [ i ] ] = 1 next_missing = 1 for i in range ( n ) : if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : count [ a [ i ] ] -= 1 while count . get ( next_missing ) : next_missing += 1 a [ i ] = next_missing count [ next_missing ] = 1

static void makePermutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . put ( next_missing , 1 ) ; } } }

static int makePermutation ( int [ ] a , int n ) { int count = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( count . get ( a [ i ] ) == 0 ) count [ a [ i ] ] += 1 ; else count [ a [ i ] ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . get ( a

static void makePermutation ( int [ ] a , int n ) { int count = new int [ n ] ; int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . get ( a [ i ] ) ) { count [ a [ i ] ] += 1 ; } else { count [ a [ i ] ] = 1 ; } next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . get ( a [ i ] ) ) { count [ a [ i ] ] += 1 ; } else { count [ a [ i ] ] = 1 ; } next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . get ( a [ i ] ) ) { count [ a [ i ] ] += 1 ; } else { count [ a [ i ] ] = 1 ; } } } } }

21.09
25.42
32.62
37.38
def manipulated_seive ( N ) : isprime [ 0 ] = isprime [ 1 ] = False for i in range ( 2 , N ) : if isprime [ i ] == True : prime . append ( i ) SPF [ i ] = i j = 0 while ( j < len ( prime ) and i * prime [ j ] < N and prime [ j ] <= SPF [ i ] ) : isprime [ i * prime [ j ] ] = False SPF [ i * prime [ j ] ] = prime [ j ] j += 1

static void manipulated_seive ( int N ) { isprime . set ( 0 , false ) ; isprime . set ( 1 , false ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( isprime . get ( i ) ) { prime . add ( i ) ; SPF . set ( i , i ) ; } for ( int j = 0 ; j < prime . size ( ) && i * prime . get ( j ) < N && prime . get ( j ) <= SPF . get ( i ) ; j ++ ) { isprime . set ( i * prime . get ( j ) , false ) ; SPF . set ( i * prime . get ( j ) , prime . get ( j ) ) ; } } }

static void manipulated_seive ( int N ) { bool isprime [ ] = false SPF [ ] = 0 ; int j = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { isprime [ i ] = true SPF [ i ] = 0 ; for ( int j = 0 ; j < len ( prime ) && i * prime [ j ] <= SPF [ i ] ; j ++ ) { isprime [ i ] =

static void manipulated_seive ( int N ) { isprime [ 0 ] = false ; isprime [ 1 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( isprime [ i ] == true ) { prime . append ( i ) SPF [ i ] = i ; j = 0 ; while ( j < len ( prime ) && i * prime [ j ] < N && prime [ j ] <= SPF [ i ] ) { isprime [ i * prime [ j ] ] = false SPF [ i * prime [ j ] ] = prime [ j ] ; j ++ ; } } } }

21.23
33.69
23.83
34.02
def findTwoscomplement ( str ) : n = len ( str ) i = n - 1 while ( i >= 0 ) : if ( str [ i ] == '1' ) : break i -= 1 if ( i == - 1 ) : return '1' + str k = i - 1 while ( k >= 0 ) : if ( str [ k ] == '1' ) : str = list ( str ) str [ k ] = '0' str = '' . join ( str ) else : str = list ( str ) str [ k ] = '1' str = '' . join ( str ) k -= 1 return str

static String findTwoscomplement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return "1" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , "0" ) ; else str . replace ( k , k + 1 , "1" ) ; } return str . toString ( ) ; }

static String findTwoscomplement ( String str ) { int n = str . length ( ) ; int i = n - 1 ; while ( i >= 0 ) { if ( str [ i ] == '0' ) str = list ( str ) str [ i ] = '0' str = '' . join ( str ) ; k -= 1 ; } return str ; }

static String findTwoscomplement ( String str ) { int n = str . length ( ) ; int i = n - 1 ; while ( i >= 0 ) { if ( str [ i ] == '1' ) { str = list ( str ) ; str [ i ] = '0' ; str [ i ] = '1' ; str = '' . join ( str ) ; } else { str = list ( str ) ; str [ i ] = '1' ; str = '' . join ( str ) ; } k = i - 1 ; while ( k >= 0 ) { if ( str [ k ] == '1' ) { str = list ( str ) ; str [ k ] = '0' ; str = '' . join ( str ) ; } else { str = list ( str ) ; str [ k ] = '1' ; str = '' . join ( str ) ; } k -= 1 ; } } return str ; }

21.26
36.71
61.07
66.09
def lcs ( dp , arr1 , n , arr2 , m , k ) : if k < 0 : return - ( 10 ** 7 ) if n < 0 or m < 0 : return 0 ans = dp [ n ] [ m ] [ k ] if ans != - 1 : return ans ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) if arr1 [ n - 1 ] == arr2 [ m - 1 ] : ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) return ans

static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }

static int lcs ( int [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { int ans ; if ( arr1 [ n ] == arr2 [ m ] ) ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; else ans = max ( ans , 1 + lcs ( dp , arr1 , n

int lcs ( int dp , int arr1 , int n , int arr2 , int m , int k ) { int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) { ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; } if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) { ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; } if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) { ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; } if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) { ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; } }

21.32
29.41
49.88
45.87
def longestSubsequence ( a , n ) : mp = { i : 0 for i in range ( 13 ) } dp = [ 0 for i in range ( n ) ] maximum = - sys . maxsize - 1 index = - 1 for i in range ( n ) : if ( ( a [ i ] - 1 ) in mp ) : lastIndex = mp [ a [ i ] - 1 ] - 1 dp [ i ] = 1 + dp [ lastIndex ] else : dp [ i ] = 1 mp [ a [ i ] ] = i + 1 if ( maximum < dp [ i ] ) : maximum = dp [ i ] index = i for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) : print ( curr , end = "" )

public static void longestSubsequence ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; int [ ] dp = new int [ n ] ; int maximum = Integer . MIN_VALUE ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] - 1 ) != null ) { int lastIndex = mp . get ( a [ i ] - 1 ) - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else dp [ i ] = 1 ; mp . put ( a [ i ] , i + 1 ) ; if ( maximum < dp [ i ] ) { maximum = dp [ i ] ; index = i ; } } for ( int curr = a [ index ] - maximum + 1 ; curr <= a [ index ] ; curr ++ ) System . out . print ( curr + " " ) ; }

static int longestSubsequence ( int [ ] a , int n ) { int [ ] dp = new int [ 13 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] - 1 ) in mp ) { int lastIndex = mp [ a [ i ] - 1 ] - 1 ] ; dp [ i ] = 1 + dp [ lastIndex ] ; } } return maximum ; }

static void longestSubsequence ( int a [ ] , int n ) { int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] - 1 ) in mp ) { lastIndex = mp [ a [ i ] - 1 ] - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else { dp [ i ] = 1 + dp [ lastIndex ] ; } } if ( maximum < dp [ index ] ) maximum = dp [ index ] ; index = i ; for ( int curr = a [ index ] - maximum + 1 ; curr < a [ index ] + 1 ; curr ++ ) { print ( curr , end = "" ) ; } } return ; }

21.36
30.72
27.38
32.85
def maxLower ( str ) : n = len ( str ) i = 0 for i in range ( n ) : if str [ i ] >= 'A' and str [ i ] <= 'Z' : i += 1 break maxCount = 0 count = [ ] for j in range ( MAX_CHAR ) : count . append ( 0 ) for j in range ( i , n ) : if str [ j ] >= 'A' and str [ j ] <= 'Z' : currCount = 0 for k in range ( MAX_CHAR ) : if count [ k ] > 0 : currCount += 1 maxCount = max ( maxCount , currCount ) for y in count : y = 0 if str [ j ] >= 'a' and str [ j ] <= 'z' : count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1 return maxCount

static int maxLower ( String str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ ] = new int [ MAX_CHAR ] ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; Arrays . fill ( count , 0 ) ; } if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { count [ str . charAt ( i ) - 'a' ] ++ ; } } return maxCount ; }

static int maxLower ( String str ) { int i = 0 ; int n = str . length ( ) ; int count [ ] = new int [ MAX_CHAR ] ; for ( int j = 0 ; j < n ; j ++ ) { int currCount = 0 ; for ( int k = 0 ; k < MAX_CHAR ; k ++ ) { if ( count [ k ] > 0 ) { maxCount = max ( maxCount , currCount ) ; for (

static int maxLower ( String str ) { int n = str . length ( ) ; int i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ; else if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) i ++ ;

21.37
36.87
55.72
59.47
def first ( str , i ) : if ( str [ i ] == '\0' ) : return 0 if ( str [ i ] . isupper ( ) ) : return str [ i ] return first ( str , i + 1 )

static char first ( String str , int i ) { if ( str . charAt ( i ) == '\0' ) return 0 ; if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }

static int first ( String str , int i ) { if ( str [ i ] . isalpha ( ) ) return str [ i ] . toUpperCase ( ) ; if ( str [ i ] . islower ( ) ) return str [ i ] . toLowerCase ( ) ; if ( str [ i ] . islower ( ) ) return str [ i ] ; if ( str [ i ] . islower ( ) ) return str [ i ] ; if ( str [ i ] .

static int first ( String str , int i ) { if ( str [ i ] == '\0' ) return 0 ; if ( str [ i ] . isupper ( ) ) return str [ i ] ; return first ( str , i + 1 ) ; }

21.43
39.55
67.99
57.46
def printDistance ( mat ) : global N , M ans = [ [ None ] * M for i in range ( N ) ] for i in range ( N ) : for j in range ( M ) : ans [ i ] [ j ] = 999999999999 for i in range ( N ) : for j in range ( M ) : for k in range ( N ) : for l in range ( M ) : if ( mat [ k ] [ l ] == 1 ) : ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) for i in range ( N ) : for j in range ( M ) : print ( ans [ i ] [ j ] , end = "" ) print ( )

static void printDistance ( int mat [ ] [ ] ) { int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

static void printDistance ( int mat [ ] [ ] ) { int [ ] ans = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j -

static void printDistance ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { ans [ i ] [ j ] = 999999999999 ; for ( int k = 0 ; k < N ; k ++ ) { for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) { ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) ; } } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { ans [ i ] [ j ] = 999999999999 ; for ( int k = 0 ; k < N ; k ++ ) { if ( mat [ k ] [ l ] == 1 ) { ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) ; } } } } } }

21.43
29.55
56.51
48.46
def sumofoddFactors ( n ) : res = 1 while n % 2 == 0 : n = n // 2 for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : count = 0 curr_sum = 1 curr_term = 1 while n % i == 0 : count += 1 n = n // i curr_term *= i curr_sum += curr_term res *= curr_sum if n >= 2 : res *= ( 1 + n ) return res

static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }

static int sumofoddFactors ( int n ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) count += 1 ; n = n // i ; curr_sum *= i ; } return res ; }

static int sumofoddFactors ( int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { count = 0 ; curr_sum = 1 ; curr_term = 1 ; while ( n % i == 0 ) count ++ ; n = n // i curr_term *= i ; curr_sum += curr_term ; res *= curr_sum ; if ( n >= 2 ) res *= ( 1 + n ) ; } return res ; }

21.45
32.94
53.64
57.16
def cocktailSort ( a ) : n = len ( a ) swapped = True start = 0 end = n - 1 while ( swapped == True ) : swapped = False for i in range ( start , end ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True if ( swapped == False ) : break swapped = False end = end - 1 for i in range ( end - 1 , start - 1 , - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True start = start + 1

void cocktailSort ( int a [ ] ) { boolean swapped = true ; int start = 0 ; int end = a . length ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i < end - 1 ; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; swapped = false ; end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } start = start + 1 ; } }

static int cocktailSort ( int [ ] a ) { int n = a . length ; int start = 0 ; int end = n - 1 ; while ( swapped == True ) { swapped = false ; for ( int i = 0 ; i < end ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i +

; int n = a . length ; int swapped = true ; int start = 0 ; int end = n - 1 ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i <= end ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] ; swapped = true ; } start = n - 1 ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i <= end ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] ; swapped = true ; } } start = n - 1 ; end = n - 1 ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i <= end ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ]

21.45
25.85
54.72
65.53
def shuffleArray ( a , n ) : i , q , k = 0 , 1 , n while ( i < n ) : j = k while ( j > i + q ) : a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] j -= 1 i += 1 k += 1 q += 1

static void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }

static void shuffleArray ( int [ ] a , int n ) { int i , q , k ; i = 0 ; q = 1 ; k = 1 ; } while ( i < n ) { a [ i ] = a [ i ] , a [ i ] = a [ i ] , a [ i ] , a [ i ] , a [ i ] = a [ i ] , a [ i ] , a [ i ] , a [ i ] ; i +=

static void shuffleArray ( int a [ ] , int n ) { int i = 0 ; int q = 1 , k = n ; while ( i < n ) { int j = k ; while ( j > i + q ) { a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] ; a [ j ] = a [ j ] , a [ j - 1 ] ; j -= 1 ; i ++ ; q ++ ; } } }

21.51
34.82
48.18
52.09
def MatrixChainOrder ( p , n ) : m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] for i in range ( 1 , n ) : m [ i ] [ i ] = 0 for L in range ( 2 , n ) : for i in range ( 1 , n - L + 1 ) : j = i + L - 1 m [ i ] [ j ] = sys . maxint for k in range ( i , j ) : q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] if q < m [ i ] [ j ] : m [ i ] [ j ] = q return m [ 1 ] [ n - 1 ]

static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }

static int MatrixChainOrder ( int [ ] p , int n ) { int [ ] m = new int [ n ] [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { int q = m [ i ] [ j ] + p [ i - 1 ] * p [ j ] ; if ( q < m [ i ] [ j ] ) { m

static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int q = m [ i ] [ j ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } return m [ 1 ] [ n - 1 ] ; }

21.53
25.74
33.32
34.43
def getOddOccurrence ( arr , size ) : Hash = dict ( ) for i in range ( size ) : Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 for i in Hash : if ( Hash [ i ] % 2 != 0 ) : return i return - 1

static int getOddOccurrence ( int arr [ ] , int n ) { HashMap < Integer , Integer > hmap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hmap . containsKey ( arr [ i ] ) ) { int val = hmap . get ( arr [ i ] ) ; hmap . put ( arr [ i ] , val + 1 ) ; } else hmap . put ( arr [ i ] , 1 ) ; } for ( Integer a : hmap . keySet ( ) ) { if ( hmap . get ( a ) % 2 != 0 ) return a ; } return - 1 ; }

static int getOddOccurrence ( int [ ] arr , int size ) { int Hash [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 ; } return - 1 ; }

public static int getOddOccurrence ( int arr [ ] , int size ) { int Hash [ ] = new int [ size ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 ; for ( int j = 0 ; j < Hash . length ; j ++ ) { Hash [ arr [ j ] ] = Hash . get ( arr [ j ] , 0 ) + 1 ; } return - 1 ; } }

21.74
25.97
34.28
35.98
def isdivisible7 ( num ) : n = len ( num ) if ( n == 0 and num [ 0 ] == '\n' ) : return 1 if ( n % 3 == 1 ) : num = str ( num ) + "00" n += 2 elif ( n % 3 == 2 ) : num = str ( num ) + "0" n += 1 GSum = 0 p = 1 for i in range ( n - 1 , - 1 , - 1 ) : group = 0 group += ord ( num [ i ] ) - ord ( '0' ) i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 GSum = GSum + group * p p *= ( - 1 ) return ( GSum % 7 == 0 )

static boolean isDivisible7 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; n = num . length ( ) ; int gSum = 0 , p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; gSum = gSum + group * p ; p = p * - 1 ; } return ( gSum % 7 == 0 ) ; }

static int isdivisible7 ( String num ) { int n = num . length ( ) ; if ( n == 0 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 ; i -= 1 ; group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 ; p *= (

static int isdivisible7 ( String num ) { int n = num . length ( ) ; int GSum = 0 ; int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; for ( int j = 0 ; j < n ; j ++ ) { group += ord ( num [ i ] ) - ord ( '0' ) ; i -= 1 ; group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 ; i -= 1 ; group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 ; GSum = GSum + group * p ; p *= ( - 1 ) ; } } return ( GSum % 7 == 0 ) ? 1 : 0 ; }

21.76
40.13
63.52
59.23
def ZigZag ( rows , columns , numbers ) : k = 0 arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] for i in range ( rows ) : if ( i % 2 == 0 ) : j = 0 while j < columns and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j += 1 else : j = columns - 1 while j >= 0 and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j -= 1 for i in arr : for j in i : print ( j , end = "" ) print ( )

public static void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int [ ] [ ] arr = new int [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

static void ZigZag ( int rows , int columns , int [ ] numbers ) { int k = 0 ; int arr [ ] [ ] = new int [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) { if ( numbers [ k ] > 0 ) arr [ i ] [ j ] = k + 1 ; numbers [ k ] -= 1 ; if (

static void ZigZag ( int rows , int columns , int numbers ) { int k = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { j = 0 ; while ( j < columns && numbers [ k ] > 0 ) arr [ i ] [ j ] = k + 1 ; numbers [ k ] -= 1 ; if ( numbers [ k ] == 0 ) k ++ ; } else { j = columns - 1 ; while ( j >= 0 && numbers [ k ] > 0 ) arr [ i ] [ j ] = k + 1 ; numbers [ k ] -= 1 ; if ( numbers [ k ] == 0 ) k ++ ; } } for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { j = 0 ; while ( j < columns && numbers [ k ] > 0 ) arr [ i ] [ j ] = k + 1 ; numbers [ k ] -= 1 ; if ( numbers [ k ] == 0 ) k ++ ; } else arr [ i ] [ j ] = k + 1 ; numbers [ k ] = 0 ; } } }

21.8
29.0
44.84
41.93
def findString ( str , n , k ) : if ( k == 0 ) : print ( str ) return str2 = str p = 0 for i in range ( 0 , n , 1 ) : if ( str2 [ i ] != 'a' ) : str2 = str2 . replace ( str2 [ i ] , 'a' ) p += 1 if ( p == k ) : break if ( p < k ) : i = n - 1 while ( i >= 0 ) : if ( str [ i ] == 'a' ) : str2 = str2 . replace ( str2 [ i ] , 'b' ) p += 1 if ( p == k ) : break i -= 1 print ( str2 )

static void findString ( String str , int n , int k ) { if ( k == 0 ) { System . out . println ( str ) ; ; return ; } String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 . charAt ( i ) != 'a' ) { str2 = str2 . substring ( 0 , i ) + 'a' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == 'a' ) { str2 = str2 . substring ( 0 , i ) + 'b' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } System . out . println ( str2 ) ; }

static void findString ( String str , int n , int k ) { String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 [ i ] != 'a' ) str2 = str2 . replace ( str2 [ i ] , 'a' ) p += 1 if ( p == k ) break ; if ( p < k ) str2 = str2 . replace ( str2

static void findString ( String str , int n , int k ) { String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 [ i ] != 'a' ) str2 = str2 . replace ( str2 [ i ] , 'a' ) ; p += 1 ; if ( p == k ) { break ; } } if ( p < k ) { i = n - 1 ; while ( i >= 0 ) { if ( str [ i ] == 'a' ) str2 = str2 . replace ( str2 [ i ] , 'b' ) ; p += 1 ; if ( p == k ) { break ; } i -- ; } } }

21.81
34.87
71.83
66.2
def minproduct ( a , b , n , k ) : diff = 0 res = 0 for i in range ( n ) : pro = a [ i ] * b [ i ] res = res + pro if ( pro < 0 and b [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] elif ( pro < 0 and a [ i ] < 0 ) : temp = ( a [ i ] - 2 * k ) * b [ i ] elif ( pro > 0 and a [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] elif ( pro > 0 and a [ i ] > 0 ) : temp = ( a [ i ] - 2 * k ) * b [ i ] d = abs ( pro - temp ) if ( d > diff ) : diff = d return res - diff

static int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }

static int minproduct ( int [ ] a , int [ ] b , int k ) { int d = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro > 0 and b [ i ] > 0 ) { temp = ( a [ i ] + 2 * k ) * b [ i ] ; } else {

static int minproduct ( int a [ ] , int b [ ] , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else temp = ( a [ i ] - 2 * k ) * b [ i ] ; else temp = ( a [ i ] - 2 * k ) * b [ i ]

22.01
27.47
34.43
33.27
def longSubarrWthSumDivByK ( arr , n , k ) : um = { i : 0 for i in range ( 8 ) } mod_arr = [ 0 for i in range ( n ) ] max = 0 curr_sum = 0 for i in range ( n ) : curr_sum += arr [ i ] mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k for i in range ( n ) : if ( mod_arr [ i ] == 0 ) : max = i + 1 elif ( mod_arr [ i ] in um ) : um [ mod_arr [ i ] ] = i else : if ( max < ( i - um [ mod_arr [ i ] ] ) ) : max = i - um [ mod_arr [ i ] ] return max

static int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int mod_arr [ ] = new int [ n ] ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( um . containsKey ( mod_arr [ i ] ) == false ) um . put ( mod_arr [ i ] , i ) ; else if ( max < ( i - um . get ( mod_arr [ i ] ) ) ) max = i - um . get ( mod_arr [ i ] ) ; } return max ; }

static long longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { int um [ ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( um [ mod_arr [ i ] ] == 0 ) { um [ mod_arr [ i ] ] = i + 1 ; else {

longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( mod_arr [ i ] in um ) um [ mod_arr [ i ] ] = i ; else if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i - um [ mod_arr [ i ] ] ; } return max ; }

22.03
28.08
26.43
28.15
def bitonicGenerator ( arr , n ) : evenArr = [ ] oddArr = [ ] for i in range ( n ) : if ( ( i % 2 ) == 0 ) : evenArr . append ( arr [ i ] ) else : oddArr . append ( arr [ i ] ) evenArr = sorted ( evenArr ) oddArr = sorted ( oddArr ) oddArr = oddArr [ : : - 1 ] i = 0 for j in range ( len ( evenArr ) ) : arr [ i ] = evenArr [ j ] i += 1 for j in range ( len ( oddArr ) ) : arr [ i ] = oddArr [ j ] i += 1

static void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < Integer > ( ) ; Vector < Integer > oddArr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } Collections . sort ( evenArr ) ; Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr . get ( j ) ; } }

static void bitonicGenerator ( int arr [ ] , int n ) { int i = 0 ; int evenArr = [ ] ; int oddArr = [ ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % 2 ) == 0 ) evenArr . append ( arr [ i ] ) ; else oddArr . append ( arr [ i ] ) ; else evenArr . append ( arr [ i ] ) ; } return ; }

static void bitonicGenerator ( int arr [ ] , int n ) { int evenArr [ ] = new int [ n ] ; int oddArr [ ] = new int [ n ] ; int i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] = evenArr [ j ] ; i ++ ; } for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] = oddArr [ j ] ; i ++ ; } }

22.08
32.17
21.06
30.68
def waysToIncreaseLCSBy1 ( str1 , str2 ) : m = len ( str1 ) n = len ( str2 ) position = [ [ ] for i in range ( M ) ] for i in range ( 1 , n + 1 , 1 ) : position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i ) lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] lcsr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] for i in range ( 1 , m + 1 , 1 ) : for j in range ( 1 , n + 1 , 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] else : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) for i in range ( m , 0 , - 1 ) : for j in range ( n , 0 , - 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] else : lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ways = 0 for i in range ( 0 , m + 1 , 1 ) : for C in range ( 0 , 26 , 1 ) : for j in range ( 0 , len ( position [ C ] ) , 1 ) : p = position [ C ] [ j ] if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : ways += 1 return ways

static int waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; Vector < Integer > [ ] position = new Vector [ M ] ; for ( int i = 0 ; i < M ; i ++ ) position [ i ] = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) position [ str2 . charAt ( i - 1 ) - 'a' ] . add ( i ) ; int [ ] [ ] lcsl = new int [ m + 2 ] [ n + 2 ] ; int [ ] [ ] lcsr = new int [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = Math . max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = Math . max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( char d = 0 ; d < 26 ; d ++ ) { for ( int j = 0 ; j < position [ d ] . size ( ) ; j ++ ) { int p = position [ d ] . elementAt ( j ) ; if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) ways ++ ; } } } return ways ; }

static void waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int M = str1 . length ( ) ; int n = str2 . length ( ) ; int position [ ] = new int [ M ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] , lcsr [ i ] [ j ] , lcsr [ i ] [ j - 1 ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = m ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsl [ i ] = 1 + lcsl [ i ] [ j ] ; } else lcsr [ i ] [ j ] = lcsr [ j ] ; } } } for ( int j = 0 ; j < n ; j ++ )

int waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int m = len ( str1 ) ; int n = len ( str2 ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) { lcsl [ i ] [ j ] = 1 + lcsl [ i ] [ j - 1 ] ; } else { lcsl [ i ] [ j ] = 1 + lcsl [ i ] [ j - 1 ] ; } } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) { lcsl [ i ] [ j ] = 1 + lcsl [ i ] [ j - 1 ] ; } else { lcsl [ i ] [ j ] = max ( lcsl [ i ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = 0 ; i < n ;

22.15
38.27
85.71
88.29
def sumOfSeries ( n ) : return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) )

static double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }

static double sumOfSeries ( int n ) { double sumOfSeries = sumOfSeries(int n); double sumOfSeries(int n); double sumOfSeries(int n);double sumOfSeries(int n);double sumOfSeries(int n);double sumOfSeries(int n);double sumOfSeries(int n);double sumOfSeries(int n);double sumOfSeries(int n);double sumOfSeries(int n);double sumOfSeries

static int sumOfSeries ( int n ) { return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }

22.19
59.77
61.76
60.25
def bin ( n ) : if ( n > 1 ) : bin ( n >> 1 ) print ( n & 1 , end = "" )

static void bin ( Integer n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . printf ( "%d" , n & 1 ) ; }

static void bin ( int n ) { if ( n > 0 ) bin ( n >> 1 ) ; if ( n & 1 ) print ( n >> 1 , end = "" ) ; if ( n > 1 ) bin ( n >> 1 ) ; if ( n > 0 ) bin ( n >> 1 ) ; if ( n > 1 ) bin ( n >> 1 ) ; if ( n > 0 ) bin ( n >> 1 ) ; else print ( n & 1 ) ;

static void bin ( int n ) { if ( n > 1 ) { System . out . print ( n >> 1 ) ; System . out . print ( n & 1 ) ; } }

22.21
37.01
35.13
46.08
def getRemainder ( num , divisor ) : if ( divisor == 0 ) : return False if ( divisor < 0 ) : divisor = - divisor if ( num < 0 ) : num = - num i = 1 product = 0 while ( product <= num ) : product = divisor * i i += 1 return num - ( product - divisor )

static int getRemainder ( int num , int divisor ) { if ( divisor == 0 ) { System . out . println ( "Error: divisor " + "can't be zero \n" ) ; return - 1 ; } if ( divisor < 0 ) divisor = - divisor ; if ( num < 0 ) num = - num ; int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i ++ ; } return num - ( product - divisor ) ; }

static boolean getRemainder ( int num , int divisor ) { int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i += 1 ; } return false ; }

static boolean getRemainder ( int num , int divisor ) { if ( divisor == 0 ) return false ; if ( num <= 0 ) return false ; int product = 0 ; while ( product <= num ) { product ++ ; } return num - ( product - divisor ) ; }

22.38
29.3
33.7
43.12
def spiralFill ( m , n , a ) : val = 1 k , l = 0 , 0 while ( k < m and l < n ) : for i in range ( l , n ) : a [ k ] [ i ] = val val += 1 k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = val val += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : a [ m - 1 ] [ i ] = val val += 1 m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : a [ i ] [ l ] = val val += 1 l += 1

static void spiralFill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k ] [ i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = val ++ ; } l ++ ; } } }

static void spiralFill ( int m , int n , int [ ] a ) { int k , l ; for ( k = 0 ; k < m ; l ++ ) { for ( int i = 0 ; i < n ; i ++ ) { a [ k ] [ i ] = val val += 1 k += 1 ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] [ l ] = val val += 1 l +=

static void spiralFill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 ; int l = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] [ k ] = val ; a [ i ] [ n - 1 ] = val ; a [ i ] [ l ] = val ; a [ i ] [ k ] = val ; } } }

22.42
26.98
25.99
30.17
def areElementsContiguous ( arr ) : us = set ( ) for i in arr : us . add ( i ) count = 1 curr_ele = arr [ 0 ] - 1 while curr_ele in us : count += 1 curr_ele -= 1 curr_ele = arr [ 0 ] + 1 while curr_ele in us : count += 1 curr_ele += 1 return ( count == len ( us ) )

static Boolean areElementsContiguous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ( ) ) ) ; }

static boolean areElementsContiguous ( int [ ] arr ) { int count = 0 ; int curr_ele = 0 ; while ( curr_ele <= arr [ 0 ] ) { count ++ ; curr_ele = arr [ 0 ] - 1 ; while ( curr_ele <= arr [ 0 ] ; curr_ele ++ ; } return ( count == len ( arr ) ) ; }

static boolean areElementsContiguous ( int arr [ ] ) { int us . set ( ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( curr_ele in us ) count ++ ; curr_ele -= 1 ; curr_ele += 1 ; while ( curr_ele in us ) count ++ ; curr_ele += 1 ; return ( count == len ( us ) ) ; }

22.44
34.0
62.4
57.92
def countStrs ( n ) : dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ] for i in range ( 0 , 26 ) : dp [ 1 ] [ i ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 0 , 26 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) sum = 0 for i in range ( 0 , 26 ) : sum = sum + dp [ n ] [ i ] return sum

static long countStrs ( int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < 27 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i <= 25 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) { sum = ( sum + dp [ n ] [ i ] ) ; } return sum ; }

static int countStrs ( int n ) { int [ ] dp = new int [ 26 ] [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; for ( int i = 0 ; j < 26 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } return sum ; }

static int countStrs ( int n ) { int dp [ ] [ ] = new int [ 26 ] [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } return sum ; }

22.48
34.75
38.6
43.53
def eggDrop ( n , k ) : eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : eggFloor [ i ] [ 1 ] = 1 eggFloor [ i ] [ 0 ] = 0 for j in range ( 1 , k + 1 ) : eggFloor [ 1 ] [ j ] = j for i in range ( 2 , n + 1 ) : for j in range ( 2 , k + 1 ) : eggFloor [ i ] [ j ] = INT_MAX for x in range ( 1 , j + 1 ) : res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) if res < eggFloor [ i ] [ j ] : eggFloor [ i ] [ j ] = res return eggFloor [ n ] [ k ]

static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }

static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { int res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] , egg

static int eggDrop ( int n , int k ) { int [ ] eggFloor = new int [ n ] [ k ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { int res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } return eggFloor [ n ] [ k ] ; }

22.51
32.43
47.54
48.28
def firstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : allocation [ i ] = j blockSize [ j ] -= processSize [ i ] break print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( "" , i + 1 , "" , processSize [ i ] , "" , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )

static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } } System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( "Not Allocated" ) ; System . out . println ( ) ; } }

static void firstFit ( int [ ] blockSize , int [ ] processSize , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; } else { allocation [ i ] = - 1 ; } } print ( "

static void firstFit ( int blockSize , int m , int processSize , int n ) { int [ ] allocation = new int [ n ] * n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; } } } }

22.63
26.81
32.55
35.76
def findPairs ( arr , n ) : Hash = { } for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum = arr [ i ] + arr [ j ] if sum in Hash . keys ( ) : prev = Hash . get ( sum ) print ( str ( prev ) + "and(%d,%d)" % ( arr [ i ] , arr [ j ] ) ) return True else : Hash [ sum ] = ( arr [ i ] , arr [ j ] )

boolean findPairs ( int arr [ ] ) { HashMap < Integer , pair > map = new HashMap < Integer , pair > ( ) ; int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( ! map . containsKey ( sum ) ) map . put ( sum , new pair ( i , j ) ) ; else { pair p = map . get ( sum ) ; System . out . println ( "(" + arr [ p . first ] + ", " + arr [ p . second ] + ") and (" + arr [ i ] + ", " + arr [ j ] + ")" ) ; return true ; } } } return false ; }

static boolean findPairs ( int arr [ ] , int n ) { int Hash [ int ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum in Hash . keys ( ) ) Hash [ sum ] = ( arr [ i ] , arr [ j ] ) ; else Hash [ sum ] = ( arr [ i ] , arr [ j ] ) ; } return

static boolean findPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum in Hash . keys ( ) ) { int prev = Hash . get ( sum ) ; print ( str ( prev ) + "and(%d,%d)" % ( arr [ i ] , arr [ j ] ) ) ; return true ; } else { Hash [ sum ] = ( arr [ i ] , arr [ j ] ) ; } } return false ; }

22.64
32.34
30.98
35.13
def countWords ( stri , n ) : m = dict ( ) for i in range ( n ) : m [ stri [ i ] ] = m . get ( stri [ i ] , 0 ) + 1 res = 0 for i in m . values ( ) : if i == 2 : res += 1 return res

static int countWords ( String str [ ] , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( str [ i ] ) ) { int get = m . get ( str [ i ] ) ; m . put ( str [ i ] , get + 1 ) ; } else { m . put ( str [ i ] , 1 ) ; } } int res = 0 ; for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) { if ( it . getValue ( ) == 2 ) res ++ ; } return res ; }

static int countWords ( String [ ] stri , int n ) { Map < String , int > m = new Map < String , int > ( ) ; for ( int i = 0 ; i < stri . length ; i ++ ) { m [ stri [ i ] ] = m . get ( stri [ i ] , 0 ) + 1 ; } return res ; }

static int countWords ( String [ ] stri , int n ) { HashMap < String , Integer > m = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < stri . length ; i ++ ) { m . put ( stri [ i ] , m . get ( stri [ i ] , 0 ) + 1 ) ; } return res ; }

22.67
32.88
55.41
61.65
def findMaxGCD ( arr , n ) : high = 0 i = 0 while i < n : high = max ( high , arr [ i ] ) i = i + 1 divisors = [ 0 ] * ( high + 1 ) i = 0 while i < n : j = 1 while j <= math . sqrt ( arr [ i ] ) : if ( arr [ i ] % j == 0 ) : divisors [ j ] = divisors [ j ] + 1 if ( j != arr [ i ] / j ) : divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] + 1 j = j + 1 i = i + 1 i = high while i >= 1 : if ( divisors [ i ] > 1 ) : return i i = i - 1 return 1

public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int divisors [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; }

static int findMaxGCD ( int [ ] arr , int n ) { int high = 0 ; int i = 0 ; while ( i < n ) { int j = 1 ; while ( j <= arr [ i ] / j ) { if ( j != arr [ i ] / j ) { divisors [ j ] = divisors [ j ] + 1 ; if ( j != arr [ i ] / j ) { divisors [ j ] = div

static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; int i = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = 1 ; while ( j <= math . sqrt ( arr [ i ] ) ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] = divisors [ j ] + 1 ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] + 1 ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] + 1 ; } j = j + 1 i = i + 1 i = high ; while ( i >= 1 ) { if ( divisors [ i ] > 1 ) return i ; i = i - 1 ; } } } return - 1 ; }

22.7
30.55
42.24
44.73
def factorize ( n ) : count = 0 while ( ( n % 2 > 0 ) == False ) : n >>= 1 count += 1 if ( count > 0 ) : print ( 2 , count ) for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : count = 0 while ( n % i == 0 ) : count += 1 n = int ( n / i ) if ( count > 0 ) : print ( i , count ) i += 2 if ( n > 2 ) : print ( n , 1 )

static void factorize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) { System . out . println ( "2" + " " + count ) ; } for ( long i = 3 ; i <= ( long ) Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) { System . out . println ( i + " " + count ) ; } } if ( n > 2 ) { System . out . println ( n + " " + "1" ) ; } }

static void factorize ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; n = int ( n / 2 ) ; if ( count > 1 ) { print ( i , count ) i += 2 if ( n > 2 ) { print ( n , 1 ) ; i += 2 if ( n > 3 ) { print ( n , 2 ) ; i += 2 if ( n > 2 ) { print ( n , 2 ) ;

static void factorize ( int n ) { int count = 0 ; while ( ( n % 2 > 0 ) == false ) { n >>= 1 ; count += 1 ; if ( count > 0 ) { print ( 2 , count ) ; } } for ( int i = 0 ; i < 3 ; i ++ ) { count = 0 ; while ( n % i == 0 ) { count += 1 ; n = int ( n / i ) ; if ( count > 0 ) { print ( i , count ) ; i += 2 ; } } } }

22.71
32.53
57.9
58.37
def MAXMIN ( arr , n ) : MIN = 10 ** 9 MAX = - 10 ** 9 for i in range ( n ) : for j in range ( n // 2 + 1 ) : if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : if ( MIN > arr [ i ] [ n - j - 1 ] ) : MIN = arr [ i ] [ n - j - 1 ] if ( MAX < arr [ i ] [ j ] ) : MAX = arr [ i ] [ j ] else : if ( MIN > arr [ i ] [ j ] ) : MIN = arr [ i ] [ j ] if ( MAX < arr [ i ] [ n - j - 1 ] ) : MAX = arr [ i ] [ n - j - 1 ] print ( "MAXimum=" , MAX , ",MINimum=" , MIN )

static void maxMin ( int arr [ ] [ ] , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } System . out . print ( "Maximum = " + max + ", Minimum = " + min ) ; }

static void MAXMIN ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] [ j ] < arr [ i ] [ j ] ) { if ( MIN > arr [ i ] [ j ] ) { MIN = arr [ i ] [ j ] ; if ( MAX < arr [ i ] [ j ] ) { MAX = arr [ i ] [ j ] ; if ( MIN <

static void MAXMIN ( int arr [ ] [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( MIN > arr [ i ] [ n - j - 1 ] ) { MIN = arr [ i ] [ n - j - 1 ] ; if ( MAX < arr [ i ] [ n - j - 1 ] ) { MAX = arr [ i ] [ n - j - 1 ] ; } } } if ( MIN > arr [ i ] [ n - j - 1 ] ) { MIN = arr [ i ] [ n - j - 1 ] ; if ( MAX < arr [ i ] [ n - j - 1 ] ) { MAX = arr [ i ] [ n - j - 1 ] ; } } if ( MAX < arr [ i ] [ n - j - 1 ] ) { MAX = arr [ i ] [ n - j - 1 ] ; } } } } }

22.78
32.87
50.84
50.76
def longestPrefixSuffix ( s ) : n = len ( s ) lps = [ 0 ] * n l = 0 i = 1 while ( i < n ) : if ( s [ i ] == s [ l ] ) : l = l + 1 lps [ i ] = l i = i + 1 else : if ( l != 0 ) : l = lps [ l - 1 ] else : lps [ i ] = 0 i = i + 1 res = lps [ n - 1 ] if ( res > n / 2 ) : return n // 2 else : return res

static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int lps [ ] = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }

static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int l = 0 ; int i = 0 ; while ( i < n ) { if ( l != 0 ) l = lps [ l - 1 ] ; else lps [ i ] = 0 ; i = i + 1 ; } return - 1 ; }

static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int l = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ l ] ) l = l + 1 ; lps [ i ] = l ; i ++ ; else if ( l != 0 ) l = lps [ l - 1 ] ; else lps [ i ] = 0 ; i ++ ; } res = lps [ n - 1 ] ; if ( res > n / 2 ) return n / 2 ; else return res ; }

22.84
41.72
46.74
51.27
def isMagicSquare ( mat ) : s = 0 for i in range ( 0 , N ) : s = s + mat [ i ] [ i ] s2 = 0 for i in range ( 0 , N ) : s2 = s2 + mat [ i ] [ N - i - 1 ] if ( s != s2 ) : return False for i in range ( 0 , N ) : rowSum = 0 for j in range ( 0 , N ) : rowSum += mat [ i ] [ j ] if ( rowSum != s ) : return False for i in range ( 0 , N ) : colSum = 0 for j in range ( 0 , N ) : colSum += mat [ j ] [ i ] if ( s != colSum ) : return False return True

static boolean isMagicSquare ( int mat [ ] [ ] ) { int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( sum != colSum ) return false ; } return true ; }

static boolean isMagicSquare ( int mat [ ] [ ] ) { int s = 0 ; int s2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int s2 = s2 + mat [ i ] [ N - i - 1 ] ; if ( s != s2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; j ++ ; if ( colSum !=

static boolean isMagicSquare ( int [ ] mat ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) { s = s + mat [ i ] [ i ] ; s2 = s2 + mat [ i ] [ N - i - 1 ] ; if ( s != s2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { s = s + mat [ i ] [ N - i - 1 ] ; s2 = s2 + mat [ i ] [ N - i - 1 ] ; if ( s != s2 ) return false for ( int i = 0 ; i < N ; i ++ ) { s = s + mat [ i ] [ N - i - 1 ] ; s2 = s2 + mat [ i ] [ N - i - 1 ] ; if ( s != s2 ) return false ; } } return true ; }

22.84
54.89
59.94
61.63
def interchangeFirstLast ( mat , n , m ) : rows = n for i in range ( n ) : t = mat [ 0 ] [ i ] mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] mat [ rows - 1 ] [ i ] = t

static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }

static void interchangeFirstLast ( int mat [ ] [ ] , int n , int m ) { int rows = mat . length ; for ( int i = 0 ; i < n ; i ++ ) { int t = mat [ 0 ] [ i ] ; mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] ; mat [ rows - 1 ] [ i ] = mat [ rows ] [ i ] ; mat [ rows ] [ i ] = t ; mat [ rows ] [ i ] = mat [ rows - 1 ] [ i ] ; mat [ rows ] [ i ] = mat [ rows - 1 ] [ i ] ; for ( int i = 0 ; i < m ; i ++ ) mat [ i ] = mat [ rows - 1 ] [ i ] ; mat [ rows - 1 ] [ i ] = mat [ rows - 1 ] [ i ] ; mat [ rows ] [ i ] = mat [ rows ] [ i ] = mat [ rows ] [ i ] ; mat [ rows ] [ i ] ; mat [ rows ] [ i ] = mat [ rows - 1 ] [ i ] ; } for ( int i = i ; i < m ; i ++ ) mat [ i ]

interchangeFirstLast ( int [ ] mat , int n , int m ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { t = mat [ 0 ] [ i ] ; mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] ; mat [ rows - 1 ] [ i ] = t ; } }

22.86
33.55
74.17
69.81
def maxRevenue ( m , x , revenue , n , t ) : maxRev = [ 0 ] * ( m + 1 ) nxtbb = 0 for i in range ( 1 , m + 1 ) : if ( nxtbb < n ) : if ( x [ nxtbb ] != i ) : maxRev [ i ] = maxRev [ i - 1 ] else : if ( i <= t ) : maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) else : maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) nxtbb += 1 else : maxRev [ i ] = maxRev [ i - 1 ] return maxRev [ m ]

static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }

static int maxRevenue ( int m , int x [ ] , int revenue [ ] , int t ) { int maxRev [ ] = new int [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { if ( revenue [ nxtbb ] != 0 ) maxRev [ i ] = max ( maxRev [ i - 1 ] + revenue [ nxtbb ] , maxRev [ i - t - 1 ] + re

static int maxRevenue ( int m , int x , int revenue , int n , int t ) { int maxRev [ ] = new int [ m + 1 ] ; int nxtbb = 0 ; for ( int i = 1 ; i < m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else if ( i <= t ) maxRev [ i - t - 1 ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } return maxRev [ m ] ; }

22.91
27.08
49.13
56.21
def psuedoBinary ( n ) : while ( n > 0 ) : temp = n m = 0 p = 1 while ( temp ) : rem = temp % 10 temp = int ( temp / 10 ) if ( rem != 0 ) : m += p p *= 10 print ( m , end = "" ) n = n - m

public static void psuedoBinary ( int n ) { while ( n != 0 ) { int temp = n , m = 0 , p = 1 ; while ( temp != 0 ) { int rem = temp % 10 ; temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } System . out . print ( m + " " ) ; n = n - m ; } System . out . println ( " " ) ; }

static int psuedoBinary ( int n ) { int m = 0 ; int p = 1 ; while ( n > 0 ) { int rem = 0 ; while ( rem != 0 ) { m += p p *= 10 ; } } return n ; }

static void psuedoBinary ( int n ) { int temp = n ; int m = 0 ; int p = 1 ; while ( temp > 0 ) { int rem = temp % 10 ; temp = int ( temp / 10 ) ; if ( rem != 0 ) m += p ; p *= 10 ; if ( m != 0 ) m += p ; } }

22.92
40.06
75.5
77.54
def hexagonArea ( s ) : return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 )

public static double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }

static int hexagonArea ( int s ) { int hexagonArea = ( s * s ) / 2 ; return hexagonArea ; }

static int hexagonArea ( int s ) { return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }

23.03
49.46
62.96
78.32
def findMaximumPieces ( n ) : return int ( 1 + n * ( n + 1 ) / 2 )

static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }

static int findMaximumPieces ( int n) {  int findMaximumPieces ( int n) { return findMaximumPieces(n-1); }

static int findMaximumPieces ( int n ) { return Math . max ( 1 , n * ( n + 1 ) / 2 ) ; }

23.1
29.96
31.8
37.83
def longestCommonSum ( arr1 , arr2 , n ) : maxLen = 0 presum1 = presum2 = 0 diff = { } for i in range ( n ) : presum1 += arr1 [ i ] presum2 += arr2 [ i ] curr_diff = presum1 - presum2 if curr_diff == 0 : maxLen = i + 1 elif curr_diff not in diff : diff [ curr_diff ] = i else : length = i - diff [ curr_diff ] maxLen = max ( maxLen , length ) return maxLen

static int longestCommonSum ( int n ) { int maxLen = 0 ; int preSum1 = 0 , preSum2 = 0 ; int diff [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < diff . length ; i ++ ) { diff [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { preSum1 += arr1 [ i ] ; preSum2 += arr2 [ i ] ; int curr_diff = preSum1 - preSum2 ; int diffIndex = n + curr_diff ; if ( curr_diff == 0 ) maxLen = i + 1 ; else if ( diff [ diffIndex ] == - 1 ) diff [ diffIndex ] = i ; else { int len = i - diff [ diffIndex ] ; if ( len > maxLen ) maxLen = len ; } } return maxLen ; }

static int longestCommonSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int maxLen = 0 ; int presum1 = 0 ; int presum2 = 0 ; int presum2 = 0 ; int diff [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int length = arr1 [ i ] - arr2 [ i ] ; diff [ curr_diff ] = i ; } return maxLen ;

static int longestCommonSum ( int arr1 , int arr2 , int n ) { int maxLen = 0 ; int presum1 = 0 ; int presum2 = 0 ; int diff = { } ; for ( int i = 0 ; i < n ; i ++ ) { int curr_diff = presum1 - presum2 ; if ( curr_diff == 0 ) { maxLen = i + 1 ; } else if ( curr_diff not in diff ) { diff [ curr_diff ] = i ; } else { maxLen = i + 1 ; } } return maxLen ; }

23.16
27.07
32.63
35.01
def findMajority ( arr , size ) : m = { } for i in range ( size ) : if arr [ i ] in m : m [ arr [ i ] ] += 1 else : m [ arr [ i ] ] = 1 count = 0 for key in m : if m [ key ] > size / 2 : count = 1 print ( "Majorityfound:-" , key ) break if ( count == 0 ) : print ( "NoMajorityelement" )

private static void findMajority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length / 2 ) { System . out . println ( "Majority found :- " + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( " No Majority element" ) ; }

static void findMajority ( int arr [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( m [ arr [ i ] ] > size / 2 ) { count = 1 ; for ( int key in m ) if ( m [ key ] > size / 2 ) { count = 1 ; for ( int key in m ) if ( m [ key ] > size / 2 ) {

static void findMajority ( int arr [ ] , int size ) { int m [ ] = new int [ size ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] in m ) m [ arr [ i ] ] ++ ; else m [ arr [ i ] ] ++ ; } if ( m [ arr [ arr . length - 1 ] ] > size / 2 ) count = 1 ; for ( int key in m ) if ( m [ key ] > size / 2 ) count = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) findMajority ( arr [ i ] , size ) ; }

23.22
30.04
39.68
42.74
def findDiff ( arr , n ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 max_count = 0 min_count = n for key , values in mp . items ( ) : max_count = max ( max_count , values ) min_count = min ( min_count , values ) return max_count - min_count

static int findDiff ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int max_count = 0 , min_count = n ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { max_count = Math . max ( max_count , x . getValue ( ) ) ; min_count = Math . min ( min_count , x . getValue ( ) ) ; } return ( max_count - min_count ) ; }

static int findDiff ( int arr [ ] , int n ) { int max_count = 0 ; int min_count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( key == arr [ i ] ) { max_count = max ( max_count , values ) min_count = min ( min_count , values ) ; } } return

static int findDiff ( int arr [ ] , int n ) { int mp = new int [ n ] ; int max_count = 0 ; int min_count = n ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] += 1 ; max_count = Math . max ( max_count , mp . get ( arr [ i ] ) ) ; min_count = Math . min ( min_count , mp . get ( arr [ i ] ) ) ; } return max_count - min_count ; }

23.23
38.97
67.91
58.37
def countPS ( str ) : N = len ( str ) cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] for i in range ( N ) : cps [ i ] [ i ] = 1 for L in range ( 2 , N + 1 ) : for i in range ( N ) : k = L + i - 1 if ( k < N ) : if ( str [ i ] == str [ k ] ) : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) else : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) return cps [ 0 ] [ N - 1 ]

static int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }

static int countPS ( String str ) { int N = str . length ( ) ; int cps [ ] [ ] = new int [ N + 2 ] [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) { cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + c

static int countPS ( String str ) { int N = str . length ( ) ; int cps [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int k = j + i - 1 ; if ( k < N ) if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) ; else cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) ; } } return cps [ 0 ] [ N - 1 ] ; }

23.34
35.63
52.09
60.62
def maxHamming ( arr , n ) : brr = [ 0 ] * ( 2 * n + 1 ) for i in range ( n ) : brr [ i ] = arr [ i ] for i in range ( n ) : brr [ n + i ] = arr [ i ] maxHam = 0 for i in range ( 1 , n ) : currHam = 0 k = 0 for j in range ( i , i + n ) : if brr [ j ] != arr [ k ] : currHam += 1 k = k + 1 if currHam == n : return n maxHam = max ( maxHam , currHam ) return maxHam

static int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . max ( maxHam , currHam ) ; } return maxHam ; }

static int maxHamming ( int arr [ ] , int n ) { int currHam = 0 ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( brr [ i ] != arr [ k ] ) currHam += 1 ; k = k + 1 ; if ( currHam == n ) return n ; } return maxHam ; } }

static int maxHamming ( int arr [ ] , int n ) { int [ ] brr = new int [ n ] * ( 2 * n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { brr [ i ] = arr [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { brr [ j ] = arr [ i ] ; if ( brr [ j ] != arr [ k ] ) { currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } } } return n ; }

23.36
29.85
42.6
48.23
def maxSubArraySum ( a , size ) : max_so_far = - maxsize - 1 max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( 0 , size ) : max_ending_here += a [ i ] if max_so_far < max_ending_here : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 print ( "Maximumcontiguoussumis%d" % ( max_so_far ) ) print ( "StartingIndex%d" % ( start ) ) print ( "EndingIndex%d" % ( end ) )

static void maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } System . out . println ( "Maximum contiguous sum is " + max_so_far ) ; System . out . println ( "Starting index " + start ) ; System . out . println ( "Ending index " + end ) ; }

static int maxSubArraySum ( int [ ] a , int maxsize ) { int max_so_far = - maxsize - 1 ; int s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { int max_ending_here = a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; s = i ; if ( max_ending_here < 0 ) max_ending_here =

static void maxSubArraySum ( int a , int size ) { int max_so_far = - maxsize - 1 ; int max_ending_here = 0 ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_so_far += a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; start = s ; end = i ; if ( max_ending_here < 0 ) max_ending_here = 0 ; start = s ; end = i ; } }

23.36
36.3
27.05
44.96
def reversingString ( str , start , end ) : while ( start < end ) : str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) start += 1 end -= 1 return str

static String reversingString ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . valueOf ( str ) ; }

static String reversingString ( String str , int start , int end ) { for ( int i = 0 ; i < end ; i ++ ) { if ( str [ start ] == 'a' ) str = ( str [ : start ] + 'a' ) + str [ start + 1 : ] ) str = ( str [ : start ] + 'a' ) + str [ start + 1 : ] ) ; else str = str [ : start ] + 'a

static String reversingString ( String str , int start , int end ) { while ( start < end ) { str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; } str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; }

23.41
27.84
55.07
60.28
def isRotated ( str1 , str2 ) : if ( len ( str1 ) != len ( str2 ) ) : return False clock_rot = "" anticlock_rot = "" l = len ( str2 ) anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] return ( str1 == clock_rot or str1 == anticlock_rot )

static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = "" ; String anticlock_rot = "" ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ; return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ; }

static boolean isRotated ( String str1 , String str2 ) { int l = str1 . length ( ) ; if ( l < 2 ) return false ; clock_rot = ( clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] ) ; anticlock_rot = ( anticlock_rot + str2 [ 0 : 2 ] ) ; clock_rot = ( clock_rot + str2 [ 2 : ] + str

static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = "" ; String anticlock_rot = "" ; int l = str2 . length ( ) ; clock_rot = ( clock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) ; anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) ; return ( str1 == clock_rot || str1 == anticlock_rot ) ; }

23.42
31.24
31.71
42.37
def countRotations ( n ) : l = len ( n ) if ( l == 1 ) : oneDigit = ( int ) ( n [ 0 ] ) if ( oneDigit % 4 == 0 ) : return 1 return 0 count = 0 for i in range ( 0 , l - 1 ) : twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 return count

static int countRotations ( String n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }

static int countRotations ( int [ ] n ) { int l = n . length ; int oneDigit = ( int ) ( n [ 0 ] ) * 10 + ( int ) ( n [ l - 1 ] ) ; if ( oneDigit % 4 == 0 ) count = count + 1 ; for ( int i = 0 ; i < l ; i ++ ) { int twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n

static int countRotations ( int n [ ] ) { int l = n . length ; for ( int i = 0 ; i < l ; i ++ ) { int twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) ; if ( twoDigit % 4 == 0 ) { count = count + 1 ; twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) ; if ( twoDigit % 4 == 0 ) { count = count + 1 ; twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) ; if ( twoDigit % 4 == 0 ) { count = count + 1 ; twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) ; if ( twoDigit % 4 == 0 ) { count = count + 1 ; } } } } } return count ; }

23.44
32.99
9.62
19.28
def printArray ( matrix ) : rowCount = len ( matrix ) if rowCount == 0 : return columnCount = len ( matrix [ 0 ] ) if columnCount == 0 : return row_output_format = "" . join ( [ "%s" ] * columnCount ) printed = { } for row in matrix : routput = row_output_format % tuple ( row ) if routput not in printed : printed [ routput ] = True print ( routput )

public static void printArray ( int arr [ ] [ ] , int row , int col ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { String s = "" ; for ( int j = 0 ; j < col ; j ++ ) s += String . valueOf ( arr [ i ] [ j ] ) ; if ( ! set . contains ( s ) ) { set . add ( s ) ; System . out . println ( s ) ; } } }

static void printArray ( int [ ] matrix ) { int rowCount = matrix . length ; int columnCount = matrix . length ; if ( rowCount == 0 ) return ; for ( int i = 0 ; i < rowCount ; i ++ ) { int routput = row_output_format % tuple ( row [ i ] ) ; if ( routput not in printed ) printed [ routput ] = true print ( routput ) ; } if ( columnCount == 0 ) return ; for (

static void printArray ( int rowCount , int columnCount ) { String row_output_format = "" . join ( [ "%s" ] * columnCount ) ; String routput = row_output_format % tuple ( matrix [ 0 ] ) ; if ( routput not in printed ) printed [ routput ] = true print ( routput ) ; } }

23.49
38.57
21.22
30.42
def checkStackPermutation ( ip , op , n ) : Input = Queue ( ) for i in range ( n ) : Input . put ( ip [ i ] ) output = Queue ( ) for i in range ( n ) : output . put ( op [ i ] ) tempStack = [ ] while ( not Input . empty ( ) ) : ele = Input . queue [ 0 ] Input . get ( ) if ( ele == output . queue [ 0 ] ) : output . get ( ) while ( len ( tempStack ) != 0 ) : if ( tempStack [ - 1 ] == output . queue [ 0 ] ) : tempStack . pop ( ) output . get ( ) else : break else : tempStack . append ( ele ) return ( Input . empty ( ) and len ( tempStack ) == 0 )

static boolean checkStackPermutation ( int ip [ ] , int op [ ] , int n ) { Queue < Integer > input = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { input . add ( ip [ i ] ) ; } Queue < Integer > output = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { output . add ( op [ i ] ) ; } Stack < Integer > tempStack = new Stack < > ( ) ; while ( ! input . isEmpty ( ) ) { int ele = input . poll ( ) ; if ( ele == output . peek ( ) ) { output . poll ( ) ; while ( ! tempStack . isEmpty ( ) ) { if ( tempStack . peek ( ) == output . peek ( ) ) { tempStack . pop ( ) ; output . poll ( ) ; } else break ; } } else { tempStack . push ( ele ) ; } } return ( input . isEmpty ( ) && tempStack . isEmpty ( ) ) ; }

static boolean checkStackPermutation ( int ip [ ] , int op [ ] , int n ) { Queue input = Queue ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Queue output = Queue ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . queue [ i ] == op [ i ] ) { output . put ( ip [ i ] ) ; } } return ( Input . empty ( ) ) ; }

static boolean checkStackPermutation ( int ip [ ] , int op [ ] , int n ) { Queue Queue Queue = new Queue ( ) ; while ( ! Input . empty ( ) ) { int ele = Input . queue [ 0 ] ; Input . get ( ) ; if ( ele == output . queue [ 0 ] ) { output . get ( ) ; while ( tempStack . length != 0 ) { if ( tempStack [ - 1 ] == output . queue [ 0 ] ) { tempStack . pop ( ) ; } } } } return false ; }

23.55
28.51
57.84
43.62
def printMaxSum ( arr , n ) : dp = [ 0 for i in range ( n ) ] for i in range ( n ) : dp [ i ] = arr [ i ] maxi = 0 for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : if ( dp [ j - 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : maxi = dp [ ( i + 1 ) // j - 1 ] dp [ i ] += maxi for i in range ( n ) : print ( dp [ i ] , end = '' )

static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }

static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] > maxi ) maxi = dp [ i ] ; for ( int j = 1 ; j <= i ; j ++ ) if ( dp [ i ] > maxi ) maxi = dp [ i ] ; if ( dp [ i ] > maxi ) max

static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] > maxi ) { maxi = dp [ i ] ; if ( dp [ ( i + 1 ) // j - 1 ] > maxi ) { maxi = dp [ ( i + 1 ) // j - 1 ] ; if ( dp [ ( i + 1 ) // j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) // j - 1 ] ; if ( dp [ ( i + 1 ) // j - 1 ] > maxi ) { maxi = dp [ ( i + 1 ) // j - 1 ] ; if ( dp [ ( i + 1 ) // j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) // j - 1 ] ; } dp [ i ] += maxi ; } } } }

23.59
30.0
40.44
38.01
def checkDivisibility ( num ) : length = len ( num ) if ( length == 1 and num [ 0 ] == '0' ) : return True if ( length % 3 == 1 ) : num = str ( num ) + "00" length += 2 elif ( length % 3 == 2 ) : num = str ( num ) + "0" length += 1 sum = 0 p = 1 for i in range ( length - 1 , - 1 , - 1 ) : group = 0 group += ord ( num [ i ] ) - ord ( '0' ) i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 sum = sum + group * p p *= ( - 1 ) sum = abs ( sum ) return ( sum % 13 == 0 )

static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }

static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; int sum = 0 ; int p = 1 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i % 3 == 0 ) sum = sum + ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 ; i -= 1 ; p *= ( - 1 ) ; } return ( sum % 13 == 0 ) ; }

static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; int sum = 0 ; int p = 1 ; for ( int i = 0 ; i < length ; i ++ ) { int group = 0 ; group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 ; i -= 1 ; group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; sum = sum + group * p ; p *= ( - 1 ) ; sum = sum + group * p ; } return ( sum % 13 == 0 ) ; }

23.6
37.08
55.93
54.75
def possibleWays ( n , m , k ) : dp = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] presum = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] for i in range ( 1 , n + 1 ) : dp [ 0 ] [ i ] = 0 presum [ 0 ] [ i ] = 1 for i in range ( 0 , m + 1 ) : presum [ i ] [ 0 ] = 1 dp [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = presum [ i - 1 ] [ j ] if j > k : dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] for j in range ( 1 , n + 1 ) : presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] return dp [ m ] [ n ]

static int possibleWays ( int n , int m , int k ) { int [ ] [ ] dp = new int [ N ] [ N ] ; int [ ] [ ] presum = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; presum [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = 0 ; presum [ 0 ] [ i ] = 1 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ; if ( j > k ) { dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ; } } for ( int j = 1 ; j < n + 1 ; j ++ ) { presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }

static int possibleWays ( int n , int m , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; int presum [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j > k ) presum [ i ] [ j ] -= dp [ i - 1 ] [ j ] += presum [ i ] [ j ] -= dp [ i - 1 ] [ j - k - 1 ] ; } return dp [ m ] [ n ] [ k ] ; } }

static int possibleWays ( int n , int m , int k ) { int dp [ ] [ ] = new int [ 10 ] ; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; presum [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ; if ( j > k ) dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ; for ( j in range ( 1 , n + 1 ) ) { presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ; } } } } return dp [ m ] [ n ] ; }

23.64
29.68
52.67
46.59
def findMaxGuests ( arrl , exit , n ) : arrl . sort ( ) exit . sort ( ) guests_in = 1 max_guests = 1 time = arrl [ 0 ] i = 1 j = 0 while ( i < n and j < n ) : if ( arrl [ i ] <= exit [ j ] ) : guests_in = guests_in + 1 if ( guests_in > max_guests ) : max_guests = guests_in time = arrl [ i ] i = i + 1 else : guests_in = guests_in - 1 j = j + 1 print ( "MaximumNumberofGuests=" , max_guests , "attime" , time )

static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( "Maximum Number of Guests = " + max_guests + " at time " + time ) ; }

static void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) { int guests_in = 1 ; int max_guests = 1 ; int time = arrl [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in = guests_in - 1 ; if ( guests_in > max_guest

static void findMaxGuests ( int arrl [ ] , int exit [ ] ) { int guests_in = 1 ; int max_guests = 1 ; int time = arrl [ 0 ] ; int i = 1 ; int j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in = guests_in + 1 if ( guests_in > max_guests ) { max_guests = guests_in + 1 if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] i = i + 1 ; } else { guests_in = guests_in - 1 ; time = arrl [ i ] i = i + 1 ; } } else { guests_in = guests_in - 1 j = j + 1 ; } } } return max_guests ; }

23.65
30.51
21.58
27.69
def smallestKFreq ( arr , n , k ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 res = sys . maxsize res1 = sys . maxsize for key , values in mp . items ( ) : if values == k : res = min ( res , key ) return res if res != res1 else - 1

public static int smallestKFreq ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ; else m . put ( a [ i ] , 1 ) ; int res = Integer . MAX_VALUE ; Set < Integer > s = m . keySet ( ) ; for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ; return ( res != Integer . MAX_VALUE ) ? res : - 1 ; }

static int smallestKFreq ( int arr [ ] , int n , int k ) { int res = 0 ; int res1 = res ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( arr [ i ] ) == k ) res1 = min ( res1 , key ) ; for ( int key = 0 ; key < arr . length ; key ++ ) { if ( values == k ) res = min ( res ,

int smallestKFreq ( int arr [ ] , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] += 1 ; res = sys . maxsize ; for ( int key , int values in mp . items ( ) ) { if ( values == k ) res = min ( res , key ) ; if ( res != res1 ) return res ; } } return - 1 ; }

23.66
35.31
58.45
56.85
def printDistSum ( arr , n ) : Sum = sum ( arr ) dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : dp [ i ] [ arr [ i - 1 ] ] = True for j in range ( 1 , Sum + 1 ) : if ( dp [ i - 1 ] [ j ] == True ) : dp [ i ] [ j ] = True dp [ i ] [ j + arr [ i - 1 ] ] = True for j in range ( Sum + 1 ) : if ( dp [ n ] [ j ] == True ) : print ( j , end = "" )

static void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " " ) ; }

static void printDistSum ( int arr [ ] , int n ) { int dp [ ] [ ] = [ False for i in range ( 1 , Sum + 1 ) ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ j ] == true ) dp [ i ] [ j + arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= Sum ; j ++ ) { if (

static void printDistSum ( int arr [ ] , int n ) { int Sum = sum ( arr ) ; int dp [ ] [ 0 ] = true ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = true ; for ( int j = 1 ; j < Sum ; j ++ ) { if ( dp [ i ] [ j ] == true ) dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = true ; for ( int j = 1 ; j < Sum ; j ++ ) { if ( dp [ i ] [ j ] == true ) dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } for ( int j = 1 ; j < Sum ; j ++ ) { if ( dp [ i ] [ j ] == true ) dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } return ; }

23.79
34.11
35.31
41.95
def arraySortedOrNot ( arr ) : n = len ( arr ) if n == 1 or n == 0 : return True return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] )

static int arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 1 || n == 0 ) return 1 ; if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0 ; return arraySortedOrNot ( arr , n - 1 ) ; }

static boolean arraySortedOrNot ( int arr [ ] ) { int n = arr . length ; if ( n > 1 ) return false ; return arraySortedOrNot ( arr [ 0 ] ) ; }

static boolean arraySortedOrNot ( int [ ] arr ) { int n = arr . length ; if ( n == 1 || n == 0 ) return true ; return arr [ 0 ] <= arr [ 1 ] && arraySortedOrNot ( arr [ 1 : ] ) ; }

23.88
31.45
33.24
38.0
def printFirstRepeating ( arr , n ) : Min = - 1 myset = dict ( ) for i in range ( n - 1 , - 1 , - 1 ) : if arr [ i ] in myset . keys ( ) : Min = i else : myset [ arr [ i ] ] = 1 if ( Min != - 1 ) : print ( "Thefirstrepeatingelementis" , arr [ Min ] ) else : print ( "Therearenorepeatingelements" )

static void printFirstRepeating ( int arr [ ] ) { int min = - 1 ; HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { if ( set . contains ( arr [ i ] ) ) min = i ; else set . add ( arr [ i ] ) ; } if ( min != - 1 ) System . out . println ( "The first repeating element is " + arr [ min ] ) ; else System . out . println ( "There are no repeating elements" ) ; }

static void printFirstRepeating ( int arr [ ] , int n ) { int Min = - 1 ; int myset [ arr [ i ] ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( myset [ arr [ i ] ] == 1 ) { print ( "Thefirstrepeatingelementis" , arr [ i ] ) ; } else { print ( "Therearenorepeatingelements" ) ; } }

static void printFirstRepeating ( int arr [ ] , int n ) { int Min = - 1 ; int myset = dict ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in myset . keys ( ) ) Min = i ; else myset [ arr [ i ] ] = 1 ; if ( Min != - 1 ) { printFirstRepeating ( arr [ Min ] , n ) ; } else if ( Min != - 1 ) { print ( "Thefirstrepeatingelementis" , arr [ Min ] ) ; } else { print ( "Therearenorepeatingelements" ) ; } } }

23.93
31.96
86.7
88.61
def breakSum ( n ) : if ( n == 0 or n == 1 ) : return n return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n )

static int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }

static int breakSum ( int n ) { int breakSum ( int n ) { return breakSum ( n // 1 ) + breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) + breakSum ( n // 5 ) + breakSum ( n // 6 ) + breakSum ( n // 5 ) + breakSum ( n // 7 ) + breakSum ( n // 5 ) + breakSum ( n // 5 ) +

static int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return max ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) , n ) ; }

24.0
36.07
51.61
48.42
def productArray ( arr , n ) : if ( n == 1 ) : print ( 0 ) return left = [ 0 ] * n right = [ 0 ] * n prod = [ 0 ] * n left [ 0 ] = 1 right [ n - 1 ] = 1 for i in range ( 1 , n ) : left [ i ] = arr [ i - 1 ] * left [ i - 1 ] for j in range ( n - 2 , - 1 , - 1 ) : right [ j ] = arr [ j + 1 ] * right [ j + 1 ] for i in range ( n ) : prod [ i ] = left [ i ] * right [ i ] for i in range ( n ) : print ( prod [ i ] , end = '' )

void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int prod [ ] = new int [ n ] ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) prod [ i ] = left [ i ] * right [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " " ) ; return ; }

static void productArray ( int arr [ ] , int n ) { int prod [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == n - 1 ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; for ( int j = 0 ; j < n ; j ++ ) { right [ j ] = arr [ j + 1 ] * right [ j +

static void productArray ( int arr [ ] , int n ) { int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int prod [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { left [ i ] = arr [ j ] * left [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { right [ j ] = arr [ j + 1 ] * right [ j ] ; for ( int i = 0 ; i < n ; i ++ ) { prod [ i ] = left [ i ] * right [ i ] ; } } } } }

24.04
36.02
84.59
75.95
def carAssembly ( a , t , e , x ) : NUM_STATION = len ( a [ 0 ] ) T1 = [ 0 for i in range ( NUM_STATION ) ] T2 = [ 0 for i in range ( NUM_STATION ) ] T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] for i in range ( 1 , NUM_STATION ) : T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] )

static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) { int T1 [ ] = new int [ NUM_STATION ] ; int T2 [ ] = new int [ NUM_STATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }

static int carAssembly ( int [ ] a , int [ ] t , int [ ] e , int [ ] x ) { int NUM_STATION = a . length ( ) ; for ( int i = 0 ; i < NUM_STATION ; i ++ ) { T1 [ i ] = e [ i ] + a [ 0 ] [ i ] ; T2 [ i ] = min ( T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] + x [ i ] ; } return T1 [ NUM_STATION - 1 ] ; }

static int carAssembly ( int [ ] a , int t [ ] , int e [ ] , int x [ ] ) { int NUM_STATION = len ( a [ 0 ] ) ; int T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; int T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( int i = 1 ; i < NUM_STATION ; i ++ ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }

24.06
29.74
29.34
30.01
def minSum ( A ) : min_val = min ( A ) ; return min_val * ( len ( A ) - 1 )

static int minSum ( int [ ] A , int n ) { int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return ( min_val * ( n - 1 ) ) ; }

static double minSum ( int [ ] A ) { double min_val = min ( A ) ; return min_val ; }  def minSum ( int [ ] A ) { double min_val = min ( A ) ; return min_val ; }

static int minSum ( int A ) { int min_val = min ( A ) ; return min_val * ( len ( A ) - 1 ) ; }

24.1
31.13
48.13
48.43
def kthLargestSum ( arr , n , k ) : sum = [ ] sum . append ( 0 ) sum . append ( arr [ 0 ] ) for i in range ( 2 , n + 1 ) : sum . append ( sum [ i - 1 ] + arr [ i - 1 ] ) Q = [ ] heapq . heapify ( Q ) for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : x = sum [ j ] - sum [ i - 1 ] if len ( Q ) < k : heapq . heappush ( Q , x ) else : if Q [ 0 ] < x : heapq . heappop ( Q ) heapq . heappush ( Q , x ) return Q [ 0 ]

static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . add ( x ) ; else { if ( Q . peek ( ) < x ) { Q . poll ( ) ; Q . add ( x ) ; } } } } return Q . poll ( ) ; }

static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= j ; j ++ ) { if ( Q [ 0 ] < x ) heapq . heappush ( Q , x ) ; else if ( Q [ 0 ] > x ) heapq . he

static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n ] ; sum . append ( 0 ) ; sum . append ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { sum . append ( sum [ i - 1 ] + arr [ i - 1 ] ) ; for ( int j = 1 ; j < n ; j ++ ) { sum . append ( sum [ j ] - sum [ i - 1 ] ) ; if ( len ( Q ) < k ) heapq . heappush ( Q , x ) ; else if ( Q [ 0 ] < x ) heapq . heappop ( Q ) heapq . heappush ( Q , x ) ; } } return Q [ 0 ] ; }

24.12
26.74
53.96
46.6
def isDivisible999 ( num ) : n = len ( num ) ; if ( n == 0 or num [ 0 ] == '0' ) : return true if ( ( n % 3 ) == 1 ) : num = "00" + num if ( ( n % 3 ) == 2 ) : num = "0" + num gSum = 0 for i in range ( 0 , n , 3 ) : group = 0 group += ( ord ( num [ i ] ) - 48 ) * 100 group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 group += ( ord ( num [ i + 2 ] ) - 48 ) gSum += group if ( gSum > 1000 ) : num = str ( gSum ) n = len ( num ) gSum = isDivisible999 ( num ) return ( gSum == 999 )

static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num . charAt ( i ++ ) - '0' ) * 100 ; group += ( num . charAt ( i ++ ) - '0' ) * 10 ; group += num . charAt ( i ) - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = Integer . toString ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ? 1 : 0 ; } return ( gSum == 999 ) ; }

static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( ord ( num [ i ] ) - 48 ) * 10 ; group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 ; gSum += ( ord ( num [ i + 2 ] ) - 48 ) * 10

static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 || num [ 0 ] == '0' ) return true ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; for ( int i = 0 ; i < n ; i ++ ) { group += ( ord ( num [ i ] ) - 48 ) * 100 ; group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 ; group += ( ord ( num [ i + 2 ] ) - 48 ) * 10 ; gSum += group ; if ( gSum > 1000 ) num = str ( gSum ) ; n = len ( num ) ; gSum = isDivisible999 ( num ) ; if ( gSum == 999 ) return true ; } } return false ; }

24.16
31.39
39.98
38.78
def recursiveReverse ( str , i = 0 ) : n = len ( str ) if i == n // 2 : return str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] recursiveReverse ( str , i + 1 )

static void recursiveReverse ( char [ ] str , int i ) { int n = str . length ; if ( i == n / 2 ) return ; swap ( str , i , n - i - 1 ) ; recursiveReverse ( str , i + 1 ) ; }

static void recursiveReverse ( String str , int i = 0 ) { int n = str . length ( ) ; if ( i == n // 2 ) return str [ i ] , str [ n - i - 1 ] ; str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] ; str [ n - i - 1 ] = str [ n - i - 1 ] ; str [ n - i -

static int recursiveReverse ( String str , int i ) { int n = str . length ( ) ; if ( i == n // 2 ) return str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] ; else str [ i ] = str [ n - i - 1 ] ; recursiveReverse ( str , i + 1 ) ; }

24.19
31.13
45.83
54.69
def vol_tetra ( side ) : volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) return round ( volume , 2 )

static double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }

static float vol_tetra ( int side ) { float volume = vol_tetra ( side ) ; return volume ; }

static int vol_tetra ( int side ) { int volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ; return round ( volume , 2 ) ; }

24.2
30.2
42.74
46.43
def minStringValue ( str , k ) : l = len ( str ) if ( k >= l ) : return 0 frequency = [ 0 ] * MAX_CHAR for i in range ( 0 , l ) : frequency [ ord ( str [ i ] ) - 97 ] += 1 q = PriorityQueue ( ) for i in range ( 0 , MAX_CHAR ) : q . put ( - frequency [ i ] ) while ( k > 0 ) : temp = q . get ( ) temp = temp + 1 q . put ( temp , temp ) k = k - 1 result = 0 ; while not q . empty ( ) : temp = q . get ( ) temp = temp * ( - 1 ) result += temp * temp return result

static int minStringValue ( String str , int k ) { int l = str . length ( ) ; if ( k >= l ) return 0 ; int [ ] frequency = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) frequency [ str . charAt ( i ) - 'a' ] ++ ; Comparator < Integer > c = new IntCompare ( ) ; PriorityQueue < Integer > q = new PriorityQueue < > ( c ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( frequency [ i ] != 0 ) q . add ( frequency [ i ] ) ; } while ( k != 0 ) { int temp = q . peek ( ) ; q . poll ( ) ; temp = temp - 1 ; q . add ( temp ) ; k -- ; } int result = 0 ; while ( ! q . isEmpty ( ) ) { int temp = q . peek ( ) ; result += temp * temp ; q . poll ( ) ; } return result ; }

static int minStringValue ( String str , int k ) { int l = str . length ( ) ; int [ ] frequency = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) { frequency [ i ] += 1 ; for ( int i = 0 ; i < l ; i ++ ) { if ( frequency [ i ] >= 0 ) { q . put ( - frequency [ i ] ) ; } } return 0 ; }

static int minStringValue ( String str , int k ) { int l = str . length ( ) ; int frequency [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) { frequency [ ord ( str [ i ] ) - 97 ] += 1 ; q . put ( - frequency [ i ] ) ; } while ( k > 0 ) { temp = q . get ( ) ; temp = temp + 1 ; q . put ( temp , temp ) ; k -- ; } result = 0 ; while ( ! q . empty ( ) ) { temp = q . get ( ) ; temp = temp * ( - 1 ) result += temp * temp ; } return result ; }

24.35
35.48
30.32
36.16
def solveQuery ( start , end , arr ) : frequency = dict ( ) for i in range ( start , end + 1 ) : if arr [ i ] in frequency . keys ( ) : frequency [ arr [ i ] ] += 1 else : frequency [ arr [ i ] ] = 1 count = 0 for x in frequency : if x == frequency [ x ] : count += 1 return count

static int solveQuery ( int start , int end , int arr [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = start ; i <= end ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int count = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) if ( entry . getKey ( ) == entry . getValue ( ) ) count ++ ; return count ; }

static int solveQuery ( int start , int end , int [ ] arr ) { int count = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( arr [ i ] in frequency . keys ( ) ) { count += 1 ; } else { count += 1 ; } } return count ; } }

static int solveQuery ( int start , int end , int arr [ ] ) { int frequency [ ] = new int ( ) ; for ( int i = start ; i < end ; i ++ ) { if ( arr [ i ] in frequency . keys ( ) ) frequency [ arr [ i ] ] ++ ; else frequency [ arr [ i ] ] = 1 ; } return count ; }

24.39
33.16
36.06
55.34
def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low if x > arr [ high ] : return - 1 mid = ( low + high ) / 2 if arr [ mid ] == x : return mid elif arr [ mid ] < x : if mid + 1 <= high and x <= arr [ mid + 1 ] : return mid + 1 else : return ceilSearch ( arr , mid + 1 , high , x ) else : if mid - 1 >= low and x > arr [ mid - 1 ] : return mid else : return ceilSearch ( arr , low , mid - 1 , x )

static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }

static int ceilSearch ( int [ ] arr , int low , int high , int x ) { if ( arr [ low ] <= x ) return low ; if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; if ( arr [ high ] <= x ) return high ; if ( arr [ low ] <= x ) return low ; if ( arr [ high ] <= x ) return high ; if ( arr [ mid ]

static int ceilSearch ( int arr , int low , int high , int x ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid + 1 ] == x ) return mid + 1 ; return ceilSearch ( arr , mid + 1 , high , x ) ; }

24.49
33.29
17.87
30.9
def findLeft ( str ) : n = len ( str ) - 1 while ( n > 0 ) : if ( str [ n ] == 'd' ) : str = str [ 0 : n ] + 'c' + str [ n + 1 : ] break if ( str [ n ] == 'b' ) : str = str [ 0 : n ] + 'a' + str [ n + 1 : ] break if ( str [ n ] == 'a' ) : str = str [ 0 : n ] + 'b' + str [ n + 1 : ] elif ( str [ n ] == 'c' ) : str = str [ 0 : n ] + 'd' + str [ n + 1 : ] n -= 1 return str

static StringBuilder findLeft ( StringBuilder str ) { int n = str . length ( ) ; while ( n > 0 ) { n -- ; if ( str . charAt ( n ) == 'd' ) { str . setCharAt ( n , 'c' ) ; break ; } if ( str . charAt ( n ) == 'b' ) { str . setCharAt ( n , 'a' ) ; break ; } if ( str . charAt ( n ) == 'a' ) str . setCharAt ( n , 'b' ) ; else if ( str . charAt ( n ) == 'c' ) str . setCharAt ( n , 'd' ) ; } return str ; }

static String findLeft ( String str ) { int n = str . length ( ) ; while ( n >= 0 ) { if ( str [ n ] == 'a' ) str = str [ 0 : n ] + 'b' + str [ n + 1 : ] break ; if ( str [ n ] == 'b' ) str = str [ 0 : n ] + 'c' + str [ n + 1 : ] break ; } return str ; }

static String findLeft ( String str ) { int n = str . length ( ) - 1 ; while ( n > 0 ) { if ( str [ n ] == 'd' ) str = str [ 0 : n ] + 'c' + str [ n + 1 ] ; break ; if ( str [ n ] == 'b' ) str = str [ 0 : n ] + 'a' + str [ n + 1 ] ; break ; if ( str [ n ] == 'a' ) str = str [ 0 : n ] + 'b' + str [ n + 1 ] ; break ; if ( str [ n ] == 'a' ) str = str [ 0 : n ] + 'a' + str [ n + 1 ] ; break ; if ( str [ n ] == 'b' ) str = str [ 0 : n ] + 'b' + str [ n + 1 ] ; break ; if ( str [ n ] == 'c' ) str = str [ 0 : n ] + 'd' + str [ n + 1 ] ; break ; } if ( str [ n ] == 'd' ) str = str [ 0 : n ] + 'c' + str [ n +

24.49
28.78
24.19
28.13
def printEqualSumSets ( arr , n ) : sum_array = sum ( arr ) if ( sum_array & 1 ) : print ( "-1" ) return k = sum_array >> 1 dp = np . zeros ( ( n + 1 , k + 1 ) ) for i in range ( 1 , k + 1 ) : dp [ 0 ] [ i ] = False for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : for currSum in range ( 1 , k + 1 ) : dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) set1 , set2 = [ ] , [ ] if ( not dp [ n ] [ k ] ) : print ( "-1" ) return i = n currSum = k while ( i > 0 and currSum >= 0 ) : if ( dp [ i - 1 ] [ currSum ] ) : i -= 1 set2 . append ( arr [ i ] ) elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) : i -= 1 currSum -= arr [ i ] set1 . append ( arr [ i ] ) print ( "Set1elements:" , end = "" ) for i in range ( len ( set1 ) ) : print ( set1 [ i ] , end = "" ) print ( "\nSet2elements:" , end = "" ) for i in range ( len ( set2 ) ) : print ( set2 [ i ] , end = "" )

static void printEqualSumSets ( int [ ] arr , int n ) { int i , currSum , sum = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; if ( ( sum & 1 ) == 1 ) { System . out . print ( "-1" ) ; return ; } int k = sum >> 1 ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ; for ( i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ i ] = false ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ; } } List < Integer > set1 = new ArrayList < Integer > ( ) ; List < Integer > set2 = new ArrayList < Integer > ( ) ; if ( ! dp [ n ] [ k ] ) { System . out . print ( "-1\n" ) ; return ; } i = n ; currSum = k ; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i -- ; set2 . add ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) { i -- ; currSum -= arr [ i ] ; set1 . add ( arr [ i ] ) ; } } System . out . print ( "Set 1 elements: " ) ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) System . out . print ( set1 . get ( i ) + " " ) ; System . out . print ( "\nSet 2 elements: " ) ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) System . out . print ( set2 . get ( i ) + " " ) ; }

static void printEqualSumSets ( int arr [ ] , int n ) { int k = sum_array >> 1 ; int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int currSum = 1 ; currSum <= k ; currSum ++ ) { if ( arr [ i - 1 ] <= currSum ) { dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] = ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] [ currSum ] = new int [ n + 1 ] [ k ] ; } } for ( int i = 1 ; i <= k ; i ++ ) { for ( int currSum = 1 ; currSum >= 0 ; currSum -- ) { if ( dp [ i - 1 ] <= currSum ) { if ( dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] == currSum ] == 0 ) { if ( dp [ i ] [ currSum ] == 0 ) { for ( int i

static void printEqualSumSets ( int arr [ ] , int n ) { int sum_array = sum ( arr ) ; int k = sum_array >> 1 ; dp [ 0 ] [ 0 ] = false ; for ( int i = 1 ; i < n ; i ++ ) { for ( int currSum in range ( 1 , k + 1 ) ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) { dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) ; } } } for ( int i = 1 ; i < n ; i ++ ) { for ( int currSum in range ( 1 , k + 1 ) ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) { dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) ; } }

24.5
28.49
43.83
40.17
def sum ( a , n ) : cnt = dict ( ) ans = 0 pre_sum = 0 for i in range ( n ) : ans += ( i * a [ i ] ) - pre_sum pre_sum += a [ i ] if ( a [ i ] - 1 ) in cnt : ans -= cnt [ a [ i ] - 1 ] if ( a [ i ] + 1 ) in cnt : ans += cnt [ a [ i ] + 1 ] if a [ i ] not in cnt : cnt [ a [ i ] ] = 0 cnt [ a [ i ] ] += 1 return ans

public static int sum ( int a [ ] , int n ) { Map < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt . containsKey ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 ) ; if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) ; if ( cnt . containsKey ( a [ i ] ) ) { cnt . put ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) ; } else { cnt . put ( a [ i ] , 1 ) ; } } return ans ; }

static int sum ( int [ ] a , int n ) { int ans = 0 ; int pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] - 1 ) in cnt : ans -= cnt [ a [ i ] - 1 ] ; if ( a [ i ] + 1 ) in cnt : ans += cnt [ a [ i ] ] ; if ( a [ i ] > 0 ) { cnt [ a

static int sum ( int a [ ] , int n ) { int ans = 0 ; int pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += i * a [ i ] ; pre_sum += a [ i ] ; if ( a [ i ] - 1 ) in cnt : ans -= cnt [ a [ i ] - 1 ] ; if ( a [ i ] + 1 ) in cnt : ans += cnt [ a [ i ] + 1 ] ; if ( a [ i ] not in cnt ) cnt [ a [ i ] ] = 0 cnt [ a [ i ] ] ++ ; } return ans ; }

24.7
38.54
52.73
51.48
def findLargestd ( S , n ) : found = False S . sort ( ) for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( 0 , n ) : if ( i == j ) : continue for k in range ( j + 1 , n ) : if ( i == k ) : continue for l in range ( k + 1 , n ) : if ( i == l ) : continue if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = True return S [ i ] if ( found == False ) : return - 1

static int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }

static int findLargestd ( int [ ] S , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } return - 1 ; } }

static int findLargestd ( int S [ ] , int n ) { int found = false ; for ( int i = 0 ; i < S . length ; i ++ ) { for ( int j = 0 ; j < S . length ; j ++ ) { for ( int k = 0 ; k < S . length ; k ++ ) { if ( i == j ) continue for ( int l = 0 ; l < S . length ; l ++ ) { if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) found = true ; return S [ i ] ; } } } } return - 1 ; }

24.72
37.39
73.75
68.0
def maxLength ( s , n ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n - 1 ) : if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) : dp [ i ] [ i + 1 ] = 2 for l in range ( 2 , n ) : i = - 1 for j in range ( l , n ) : i += 1 if ( s [ i ] == '(' and s [ j ] == ')' ) : dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] for k in range ( i , j ) : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) return dp [ 0 ] [ n - 1 ]

static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }

static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) { dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; } return dp [ 0 ] [ n - 1 ] ; }

static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { i ++ ; if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i + 1 ; k < n ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }

24.79
32.18
43.63
35.06
def countWords ( string ) : state = OUT wc = 0 for i in range ( len ( string ) ) : if ( string [ i ] == '' or string [ i ] == '\n' or string [ i ] == '\t' ) : state = OUT elif state == OUT : state = IN wc += 1 return wc

static int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == ' ' || str . charAt ( i ) == '\n' || str . charAt ( i ) == '\t' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }

static int countWords ( String string ) { int wc = 0 ; for ( int i = 0 ; i < len ( string ) ; i ++ ) { if ( state == IN ) { state = OUT wc += 1 ; } else { state = IN } } return wc ; }

static int countWords ( String string ) { int wc = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string [ i ] == '' || string [ i ] == '\n' || string [ i ] == '\t' ) state = OUT ; else if ( state == OUT ) state = IN ; else state = IN ; wc ++ ; } return wc ; }

24.82
31.44
59.69
54.01
def printClosest ( ar1 , ar2 , m , n , x ) : diff = sys . maxsize l = 0 r = n - 1 while ( l < m and r >= 0 ) : if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : res_l = l res_r = r diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) if ar1 [ l ] + ar2 [ r ] > x : r = r - 1 else : l = l + 1 print ( "Theclosestpairis[" , ar1 [ res_l ] , "," , ar2 [ res_r ] , "]" )

void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" ) ; }

static void printClosest ( int [ ] ar1 , int [ ] ar2 , int m , int n , int x ) { int res_l = 0 ; int res_r = 0 ; while ( l < m and r >= 0 ) { if ( ar1 [ l ] + ar2 [ r ] - x < diff ) res_l = l + 1 ; else res_r = r - 1 ; if ( ar1 [ l ] + ar2

static void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int res_l = l ; int res_r = r ; while ( l < m && r >= 0 ) { if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) res_l = r ; res_r = r ; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ; if ( ar1 [ l ] + ar2 [ r ] > x ) r = r - 1 ; else if ( ar1 [ l ] + ar2 [ r ] > x ) r = r - 1 ; else l = l + 1 ; else r = r - 1 ; } }

24.87
30.33
57.1
62.63
def isDvisibleBy12 ( num ) : if ( len ( num ) >= 3 ) : d1 = int ( num [ len ( num ) - 1 ] ) if ( d1 % 2 != 0 ) : return False d2 = int ( num [ len ( num ) - 2 ] ) sum = 0 for i in range ( 0 , len ( num ) ) : sum += int ( num [ i ] ) return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) else : number = int ( num ) return ( number % 12 == 0 )

static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } }

static boolean isDvisibleBy12 ( String num ) { int d1 = 0 ; int d2 = 0 ; int d1 = int ( num [ len ( num ) - 1 ] ) ; int d2 = int ( num [ len ( num ) - 2 ] ) ; int d1 = int ( num [ len ( num ) - 1 ] ) ; int d2 = int ( num [ len ( num ) - 2 ] ) ; return ( d2 * 10 + d1 ) % 4 == 0 ) ; }

static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = int ( num [ len ( num ) - 1 ] ) ; if ( d1 % 2 != 0 ) return false ; d2 = int ( num [ len ( num ) - 2 ] ) ; sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { sum += num [ i ] ; } return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } return false ; }

24.91
36.24
56.54
51.88
def findLength ( string ) : n = len ( string ) maxlen = 0 Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( 0 , n ) : Sum [ i ] [ i ] = int ( string [ i ] ) for length in range ( 2 , n + 1 ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 k = length // 2 Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : maxlen = length return maxlen

static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; int sum [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; int k = len / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ; } } return maxlen ; }

static int findLength ( String string ) { int n = string . length ( ) ; int [ ] [ ] Sum = new int [ n ] [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] ) { if ( length %

int findLength ( String string ) { int n = string . length ( ) ; int [ ] Sum = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) ; if ( length % 2 == 0 && Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] ) { if ( length % 2 == 0 && Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] ) { maxlen = length ; } } } } } return maxlen ; }

25.11
35.93
59.58
53.74
def MaximumPath ( Mat ) : result = 0 dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] for i in range ( N ) : for j in range ( 1 , N + 1 ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \ Mat [ i ] [ j - 1 ] for i in range ( N + 1 ) : result = max ( result , dp [ N - 1 ] [ i ] ) return result

static int MaximumPath ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }

static int MaximumPath ( int Mat [ ] , int N ) { int result = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) + \ Mat [ i ] [ j - 1 ] ; } return result ; }

static int MaximumPath ( Mat Mat ) { int result = 0 ; int dp [ ] = new int [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \ Mat [ i ] [ j - 1 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) + \ Mat [ i ] [ j ] ; } } return result ; }

25.18
33.73
28.99
43.17
def bitonicGenerator ( arr , n ) : i = 1 j = n - 1 if ( j % 2 != 0 ) : j = j - 1 while ( i < j ) : arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ] i = i + 2 j = j - 2 arr_f = [ ] arr_s = [ ] for i in range ( int ( ( n + 1 ) / 2 ) ) : arr_f . append ( arr [ i ] ) i = int ( ( n + 1 ) / 2 ) while ( i < n ) : arr_s . append ( arr [ i ] ) i = i + 1 arr_f . sort ( ) arr_s . sort ( reverse = True ) for i in arr_s : arr_f . append ( i ) return arr_f

static void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { arr = swap ( arr , i , j ) ; i += 2 ; j -= 2 ; } Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ; Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ; int low = ( n + 1 ) / 2 , high = n - 1 ; while ( low < high ) { Integer temp = arr [ low ] ; arr [ low ] = arr [ high ] ; arr [ high ] = temp ; low ++ ; high -- ; } }

static int bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n ; while ( i < j ) { arr [ i ] = arr [ i ] , arr [ i ] = arr [ i ] , arr [ i ] ; i = i + 1 ; arr_s . sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr_f . append ( arr [ i ] ) i = i + 1 ; } } return arr ; }

static int bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; while ( i < j ) { arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] ; i = i + 2 ; j = j - 2 ; while ( i < j ) { arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] ; i = i + 2 ; j = j - 2 ; } arr_f . append ( arr [ i ] ) ; i = int ( ( n + 1 ) / 2 ) ; while ( i < n ) { arr_f . append ( arr [ i ] ) ; i = i + 1 arr_s . append ( arr [ i ] ) ; i = i + 1 arr_f . sort ( ) arr_s . sort ( reverse = true ) ; for i in arr_f ) arr_f . append ( i ) ; } arr_f . sort ( ) ; arr_s . sort ( reverse = true ) ; } return arr_f ; }

25.21
41.05
41.48
39.8
def arcLength ( diameter , angle ) : if angle >= 360 : print ( "Anglecannotbeformed" ) return 0 else : arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) return arc

static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( "Angle cannot" + " be formed" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }

static double arcLength ( double diameter , double angle ) { double arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) ; return arc ; }

static int arcLength ( int diameter , int angle ) { int arc = 0 ; if ( angle >= 360 ) { arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) ; } else { arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) ; } return arc ; }

25.34
26.98
32.71
36.73
def translate ( st ) : l = len ( st ) if ( l < 2 ) : return i = 0 j = 0 while ( j < l - 1 ) : if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) : j += 2 st [ i ] = 'C' i += 1 continue st [ i ] = st [ j ] i += 1 j += 1 if ( j == l - 1 ) : st [ i ] = st [ j ] i += 1 st [ i ] = '' st [ l - 1 ] = ''

static void translate ( char str [ ] ) { int len = str . length ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) { j = j + 2 ; str [ i ++ ] = 'C' ; continue ; } str [ i ++ ] = str [ j ++ ] ; } if ( j == len - 1 ) str [ i ++ ] = str [ j ] ; str [ i ] = ' ' ; str [ len - 1 ] = ' ' ; }

static void translate ( String st ) { int i = 0 ; int j = 0 ; while ( j < l ) { if ( st [ j ] == 'A' ) j ++ ; if ( st [ j ] == 'B' ) j ++ ; if ( st [ j ] == 'C' ) j ++ ; if ( st [ j ] == 'D' ) j ++ ; if ( j == l - 1 ) st [ i ] = 'D' ;

static void translate ( String st [ ] , int i , int l ) { int i = 0 ; int j = 0 ; while ( j < l - 1 ) { if ( st [ j ] == 'A' && st [ j + 1 ] == 'B' ) { j ++ ; st [ i ] = 'C' ; i ++ ; continue st [ i ] = st [ j ] ; i ++ ; st [ i ] = st [ j ] ; i ++ ; st [ i ] = st [ j ] ; i ++ ; } st [ i ] = st [ j ] ; i ++ ; st [ j ] = '' ; st [ i ] = '' ; st [ j ] = '' ; st [ i ] = '' ; st [ l - 1 ] = '' ; } }

25.36
28.41
20.24
29.51
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

static int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }

static int factorial ( int n ) { return 1 if ( n == 0 ) return 1 ; }  def factorial ( int n ) { return 1 ; }

static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return n * factorial ( n - 1 ) ; } }

25.36
28.41
20.24
29.51
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

static int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }

static int factorial ( int n ) { return 1 if ( n == 0 ) return 1 ; }  def factorial ( int n ) { return 1 ; }

static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return n * factorial ( n - 1 ) ; } }

25.4
35.99
66.0
61.26
def largestSumOfAverages ( A , K ) : n = len ( A ) pre_sum = [ 0 ] * ( n + 1 ) pre_sum [ 0 ] = 0 for i in range ( n ) : pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] dp = [ 0 ] * n sum = 0 for i in range ( n ) : dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) for k in range ( K - 1 ) : for i in range ( n ) : for j in range ( i + 1 , n ) : dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) return int ( dp [ 0 ] )

static double largestSumOfAverages ( int [ ] A , int K ) { int n = A . length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }

static int largestSumOfAverages ( int A [ ] , int K ) { int n = A . length ; int pre_sum [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ i ] ) ; } } }

static int largestSumOfAverages ( int A , int K ) { int n = A . length ; int [ ] pre_sum = new int [ n + 1 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { pre_sum [ i ] = pre_sum [ i ] + A [ i ] ; for ( int k = 0 ; k < K ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; } } return int ( dp [ 0 ] ) ; } } return - 1 ; }

25.44
33.17
66.25
62.67
def sumoflength ( arr , n ) : s = [ ] j = 0 ans = 0 for i in range ( n ) : while ( j < n and ( arr [ j ] not in s ) ) : s . append ( arr [ j ] ) j += 1 ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 s . remove ( arr [ i ] ) return ans

public static int sumoflength ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }

static int sumoflength ( int arr [ ] , int n ) { int s = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { while ( j < n ) s . append ( arr [ j ] ) j += 1 ; } return ans ; }

static int sumoflength ( int arr [ ] , int n ) { int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && arr [ j ] != null ) { s . append ( arr [ j ] ) ; j ++ ; ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; } s . remove ( arr [ i ] ) ; } return ans ; }

25.47
31.46
30.15
40.39
def sumAtKthLevel ( tree , k , i , level ) : if ( tree [ i [ 0 ] ] == '(' ) : i [ 0 ] += 1 if ( tree [ i [ 0 ] ] == ')' ) : return 0 sum = 0 if ( level == k ) : sum = int ( tree [ i [ 0 ] ] ) i [ 0 ] += 1 leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) i [ 0 ] += 1 rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) i [ 0 ] += 1 return sum + leftsum + rightsum

static int sumAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == '(' ) { if ( tree . charAt ( i ) == ')' ) return 0 ; int sum = 0 ; if ( level == k ) sum = tree . charAt ( i ) - '0' ; ++ i ; int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return sum + leftsum + rightsum ; } return Integer . MIN_VALUE ; }

static int sumAtKthLevel ( int tree , int k , int i , int level ) { int sum = 0 ; if ( level == k ) sum = int ( tree [ i [ 0 ] ] ) ; else sum = int ( tree [ i [ 0 ] ] ) ; i [ 0 ] ++ ; if ( level == k ) sum = int ( tree [ i [ 0 ] ] ) ; i [ 0 ] ++ ; if ( level == k ) sum =

static int sumAtKthLevel ( String tree , int k , int [ ] i , int level ) { int sum = 0 ; if ( level == k ) { sum = int ( tree [ i [ 0 ] ] ) ; i [ 0 ] += 1 ; leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] += 1 rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] += 1 ; } else { sum = 0 ; if ( level == k ) { sum = int ( tree [ i [ 0 ] ] ) ; i [ 0 ] += 1 ; leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] += 1 rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] += 1 ; } } return sum ; }

25.51
33.47
77.97
79.07
def vol_of_octahedron ( side ) : return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) )

static double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }

static int vol_of_octahedron ( int side ) { int vol_of_octahedron = vol_of_octahedron ( int side ) ; return vol_of_octahedron * ( side * side ) ; }

static int vol_of_octahedron ( int side ) { return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) ; }

25.58
35.97
57.74
59.04
def pre_compute ( a , n , index , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n ) : if a [ i ] > a [ 0 ] : dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] else : dp [ 0 ] [ i ] = a [ i ] for i in range ( 1 , n ) : for j in range ( n ) : if a [ j ] > a [ i ] and j > i : if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return dp [ index ] [ k ]

static int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }

static double pre_compute ( double a [ ] , int index , int k ) { double dp [ ] [ ] = new double [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ i ] [ j ] = dp [ i ] [ i ] + a [ 0 ] ; else dp [ i ] [ j ] = dp [ i ] [ i ] ; } return dp [ index ] [ k ] ; }

static int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] > a [ j ] && j > i ; if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }

25.61
32.82
24.44
27.99
def countPairs ( arr , n ) : mp = dict ( ) for i in range ( n ) : if arr [ i ] in mp . keys ( ) : mp [ arr [ i ] ] += 1 else : mp [ arr [ i ] ] = 1 ans = 0 for it in mp : count = mp [ it ] ans += ( count * ( count - 1 ) ) // 2 return ans

public static int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; else hm . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) { int count = it . getValue ( ) ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }

static int countPairs ( int arr [ ] , int n ) { int mp = dict ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in mp . keys ( ) ) { mp [ arr [ i ] ] += 1 ; } else { mp [ arr [ i ] ] = 1 ; } } return 0 ; }

static int countPairs ( int arr [ ] , int n ) { int mp = new int ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] in mp . keys ( ) ) mp [ arr [ i ] ] ++ ; else mp [ arr [ i ] ] = 1 ; } return ans ; }

25.63
29.0
24.69
30.06
def minProduct ( arr , n , k ) : heapq . heapify ( arr ) count = 0 ans = 1 while ( arr ) and count < k : x = heapq . heappop ( arr ) ans = ans * x count = count + 1 return ans

public static int minProduct ( int [ ] arr , int n , int k ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) pq . add ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( pq . isEmpty ( ) == false && count < k ) { ans = ans * pq . element ( ) ; pq . remove ( ) ; count ++ ; } return ans ; }

static int minProduct ( int arr [ ] , int n , int k ) { int count = 0 ; while ( arr ) { int x = heapq . heappop ( arr ) ; if ( count < k ) ans = ans * x + 1 ; else ans = ans * x + 1 ; count = count + 1 ; } return ans ; }

static int minProduct ( int arr , int n , int k ) { int ans = 1 ; while ( arr != null && count < k ) { int x = heapq . heapify ( arr ) ; ans = ans * x ; count ++ ; } return ans ; }

25.79
33.47
54.01
45.63
def isPath ( arr ) : arr [ 0 ] [ 0 ] = 1 for i in range ( 1 , row ) : if ( arr [ i ] [ 0 ] != - 1 ) : arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] for j in range ( 1 , col ) : if ( arr [ 0 ] [ j ] != - 1 ) : arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] for i in range ( 1 , row ) : for j in range ( 1 , col ) : if ( arr [ i ] [ j ] != - 1 ) : arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) return ( arr [ row - 1 ] [ col - 1 ] == 1 )

static boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }

static boolean isPath ( int [ ] arr ) { int i = 1 ; int j = 1 ; for ( int i = 1 ; i <= row ; i ++ ) { if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; } return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ;

static boolean isPath ( int [ ] arr , int row , int col ) { int [ ] arr [ ] [ 0 ] = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = arr [ i ] [ j - 1 ] ; if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = arr [ i ] [ j - 1 ] ; if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = arr [ i ] [ j - 1 ] ; if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; } } return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }

25.82
35.8
27.91
34.44
def findLargestPlus ( mat ) : left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] top = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] bottom = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] for i in range ( N ) : top [ 0 ] [ i ] = mat [ 0 ] [ i ] bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] left [ i ] [ 0 ] = mat [ i ] [ 0 ] right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] for i in range ( N ) : for j in range ( 1 , N ) : if ( mat [ i ] [ j ] == 1 ) : left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 else : left [ i ] [ j ] = 0 if ( mat [ j ] [ i ] == 1 ) : top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 else : top [ j ] [ i ] = 0 j = N - 1 - j if ( mat [ j ] [ i ] == 1 ) : bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 else : bottom [ j ] [ i ] = 0 if ( mat [ i ] [ j ] == 1 ) : right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 else : right [ i ] [ j ] = 0 j = N - 1 - j n = 0 for i in range ( N ) : for j in range ( N ) : l = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) if ( l > n ) : n = l if ( n ) : return 4 * ( n - 1 ) + 1 return 0

static int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; }

static void findLargestPlus ( int mat [ ] [ ] , int N ) { int [ ] left = [ [ 0 for x in range ( N ) ] ; int right [ ] [ ] = mat [ 0 ] [ N ] ; int [ ] bottom = [ [ 0 for x in range ( N ) ] ; int i = 0 ; for ( int j = 1 ; j <= N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { bottom [ i ] [ j ] = 0 ; } else { left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { if ( mat [ j ] == 1 ) { if ( mat [ i ] [ j ] == 1 ) { right [ i ] = right [ j ] = right [ j ] [ i ] = 0 ; } else { right [ i ] [ j ] + 1 ; } } for ( int j = N - 1 ; i ++ ) { if ( mat [

static void findLargestPlus ( int [ ] mat , int [ ] left , int [ ] right , int [ ] bottom , int [ ] top , int [ ] bottom ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ]

25.86
29.53
49.61
45.55
def maxLen ( arr ) : hash_map = { } max_len = 0 curr_sum = 0 for i in range ( len ( arr ) ) : curr_sum += arr [ i ] if arr [ i ] is 0 and max_len is 0 : max_len = 1 if curr_sum is 0 : max_len = i + 1 if curr_sum in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum ] ) else : hash_map [ curr_sum ] = i return max_len

static int maxLen ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; Integer prev_i = hM . get ( sum ) ; if ( prev_i != null ) max_len = Math . max ( max_len , i - prev_i ) ; else hM . put ( sum , i ) ; } return max_len ; }

static int maxLen ( int arr [ ] ) { int max_len = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < len ( arr ) ; i ++ ) { if ( curr_sum in hash_map ) max_len = max ( max_len , i - hash_map [ curr_sum ] ) ; else max_len = i + 1 ; if ( curr_sum in hash_map ) { max_len =

static int maxLen ( int arr [ ] ) { int max_len = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { curr_sum += arr [ i ] ; if ( arr [ i ] is 0 && max_len is 0 ) max_len = 1 ; if ( curr_sum is 0 ) max_len = 1 ; if ( curr_sum in hash_map ) max_len = max ( max_len , i - hash_map [ curr_sum ] ) ; else max_len = i + 1 ; } return max_len ; }

25.87
31.28
36.71
36.37
def findSubarraySum ( arr , n , Sum ) : prevSum = defaultdict ( lambda : 0 ) res = 0 currsum = 0 for i in range ( 0 , n ) : currsum += arr [ i ] if currsum == Sum : res += 1 if ( currsum - Sum ) in prevSum : res += prevSum [ currsum - Sum ] prevSum [ currsum ] += 1 return res

static int findSubarraySum ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . containsKey ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ; Integer count = prevSum . get ( currsum ) ; if ( count == null ) prevSum . put ( currsum , 1 ) ; else prevSum . put ( currsum , count + 1 ) ; } return res ; }

static int findSubarraySum ( int arr [ ] , int n , int Sum ) { int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( currsum - Sum ) in prevSum : res += prevSum [ currsum - Sum ] ; prevSum [ currsum ] += 1 ; } } return res ; }

static int findSubarraySum ( int arr [ ] , int Sum ) { int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == Sum ) res += 1 ; if ( currsum - Sum ) in prevSum ) res += prevSum [ currsum - Sum ] ; prevSum [ currsum ] ++ ; } return res ; }

25.89
36.03
74.31
74.02
def findWinner ( x , y , n ) : dp = [ 0 for i in range ( n + 1 ) ] dp [ 0 ] = False dp [ 1 ] = True for i in range ( 2 , n + 1 ) : if ( i - 1 >= 0 and not dp [ i - 1 ] ) : dp [ i ] = True elif ( i - x >= 0 and not dp [ i - x ] ) : dp [ i ] = True elif ( i - y >= 0 and not dp [ i - y ] ) : dp [ i ] = True else : dp [ i ] = False return dp [ n ]

static boolean findWinner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }

static int findWinner ( int x , int y , int n ) { int dp [ ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { if ( i - x >= 0 and not dp [ i - x ] ) { dp [ i ] = true ; } else { dp [ i ] = false ; } } return dp [ n ] ; }

private static boolean findWinner ( int x , int y , int n ) { boolean dp [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i - 1 >= 0 && ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - y >= 0 && ! dp [ i - y ] ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }

25.92
29.89
49.98
53.66
def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] start = 0 i = 1 while i <= n : while curr_sum > sum and start < i - 1 : curr_sum = curr_sum - arr [ start ] start += 1 if curr_sum == sum : print ( "Sumfoundbetweenindexes" ) print ( "%dand%d" % ( start , i - 1 ) ) return 1 if i < n : curr_sum = curr_sum + arr [ i ] i += 1 print ( "Nosubarrayfound" ) return 0

int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { int p = i - 1 ; System . out . println ( "Sum found between indexes " + start + " and " + p ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } System . out . println ( "No subarray found" ) ; return 0 ; }

static int subArraySum ( int arr [ ] , int n , int sum ) { int start = 0 ; int i = 1 ; while ( curr_sum < sum ) curr_sum = curr_sum - arr [ start ] start += 1 if ( curr_sum == sum ) { print ( "Sumfoundbetweenindexes" ) print ( "%dand%d" % ( start , i - 1 ) ) return 1 if ( i < n ) curr_sum =

static int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] ; int start = 1 ; int i = 1 ; while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; if ( curr_sum == sum ) return 1 ; if ( curr_sum == sum ) return 1 ; if ( i < n ) curr_sum = curr_sum + arr [ i ] ; i ++ ; } return 0 ; }

25.95
27.54
33.9
34.39
def MaxSumDifference ( a , n ) : np . sort ( a ) j = 0 finalSequence = [ 0 for x in range ( n ) ] for i in range ( 0 , int ( n / 2 ) ) : finalSequence [ j ] = a [ i ] finalSequence [ j + 1 ] = a [ n - i - 1 ] j = j + 2 MaximumSum = 0 for i in range ( 0 , n - 1 ) : MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) print ( MaximumSum )

static int MaxSumDifference ( Integer [ ] a , int n ) { List < Integer > finalSequence = new ArrayList < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return MaximumSum ; }

static void MaxSumDifference ( int [ ] a , int n ) { int j = 0 ; int finalSequence [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { finalSequence [ j ] = a [ i ] ; finalSequence [ j + 1 ] = a [ n - i - 1 ] ; j = j + 2 ; } for ( int i = 0 ; i < n ; i ++ ) { MaximumSum = ( MaximumSum +

static void MaxSumDifference ( int a , int n ) { int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { finalSequence [ j ] = a [ i ] ; finalSequence [ j + 1 ] = a [ i + 1 ] ; j ++ ; } MaximumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { finalSequence [ j ] = a [ i ] ; finalSequence [ j + 1 ] = a [ i ] ; j ++ ; } MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) ; MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) ; } return MaximumSum ; }

25.96
29.11
58.33
53.23
def bestApproximate ( x , y , n ) : sum_x = 0 sum_y = 0 sum_xy = 0 sum_x2 = 0 for i in range ( 0 , n ) : sum_x += x [ i ] sum_y += y [ i ] sum_xy += x [ i ] * y [ i ] sum_x2 += pow ( x [ i ] , 2 ) m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) c = ( float ) ( sum_y - m * sum_x ) / n print ( "m=" , m ) print ( "c=" , c )

static void bestApproximate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; System . out . println ( "m = " + m ) ; System . out . println ( "c = " + c ) ; }

static void bestApproximate ( float x [ ] , float y [ ] , int n ) { float sum_x = 0 ; float sum_y = 0 ; float sum_xy = 0 ; float sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] * y [ i ] ; sum_xy += x [ i ] * y [ i ] ; } for ( int i =

static void bestApproximate ( int x , int y , int n ) { int sum_x = 0 ; sum_y = 0 sum_xy = 0 sum_x2 = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; sum_xy = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; c = ( float ) ( sum_y - m * sum_x ) / ( n

25.96
30.13
24.73
29.75
def longestString ( str1 , str2 ) : count1 = [ 0 ] * 26 count2 = [ 0 ] * 26 for i in range ( len ( str1 ) ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( str2 ) ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 result = "" for i in range ( 26 ) : for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : result = result + chr ( ord ( 'a' ) + i ) print ( result )

static void longestString ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ str2 . charAt ( i ) - 'a' ] ++ ; } String result = "" ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( 'a' + i ) ; } } System . out . println ( result ) ; }

static String longestString ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < count1 [ i ] ; j ++ ) { result = result + chr ( 'a' ) + j ; } } return result ; }

static String longestString ( String str1 , String str2 ) { int count1 = [ 0 ] * 26 ; int count2 = [ 0 ] * 26 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] ++ ; count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] ++ ; result = result + chr ( ord ( 'a' ) + i ) ; } return result ; }

26.01
32.45
61.89
55.86
def maxProductSubset ( a , n ) : if n == 1 : return a [ 0 ] max_neg = - 999999999999 count_neg = 0 count_zero = 0 prod = 1 for i in range ( n ) : if a [ i ] == 0 : count_zero += 1 continue if a [ i ] < 0 : count_neg += 1 max_neg = max ( max_neg , a [ i ] ) prod = prod * a [ i ] if count_zero == n : return 0 if count_neg & 1 : if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : return 0 prod = int ( prod / max_neg ) return prod

static int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_neg = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) { return 0 ; } if ( count_neg % 2 == 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) { return 0 ; } prod = prod / max_neg ; } return prod ; }

static int maxProductSubset ( int [ ] a , int n ) { int max_neg = - 999999999999 ; int count_zero = 0 ; int count_neg = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) max_neg = max ( max_neg , a [ i ] ) ; prod = prod * a [ i ] ; if ( count_neg

static int maxProductSubset ( int [ ] a , int n ) { int max_neg = - 999999999999 ; int count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) max_neg = max ( max_neg , a [ i ] ) ; prod = prod * a [ i ] ; if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = int ( prod / max_neg ) ; } } return 0 ; }

26.04
41.97
45.72
50.04
def maxProfit ( prices , n , k ) : profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , k + 1 ) : max_so_far = 0 for l in range ( i ) : max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) return profit [ n - 1 ] [ k ]

static int maxProfit ( int [ ] price , int n , int k ) { int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_so_far = 0 ; for ( int m = 0 ; m < j ; m ++ ) max_so_far = Math . max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , max_so_far ) ; } } return profit [ k ] [ n - 1 ] ; }

static int maxProfit ( int [ ] prices , int n , int k ) { int [ ] profit [ ] [ ] = new int [ n ] [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { int max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) ; } return profit ; } }

static int maxProfit ( int prices [ ] , int n , int k ) { int profit [ ] [ ] = new int [ n ] [ k ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { int max_so_far = 0 for ( int l = i ; l <= j ; l ++ ) { max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) ; profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) ; } } return profit [ n - 1 ] [ k ] ; }

26.08
32.93
73.67
60.69
def findMaxProduct ( arr , n ) : ans = - float ( 'inf' ) maxval = 1 minval = 1 for i in range ( 0 , n ) : if arr [ i ] > 0 : maxval = maxval * arr [ i ] minval = min ( 1 , minval * arr [ i ] ) elif arr [ i ] == 0 : minval = 1 maxval = 0 elif arr [ i ] < 0 : prevMax = maxval maxval = minval * arr [ i ] minval = prevMax * arr [ i ] ans = max ( ans , maxval ) if maxval <= 0 : maxval = 1 return ans

static int findMaxProduct ( int arr [ ] , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxval = 1 ; int minval = 1 ; int prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; }

static int findMaxProduct ( int arr [ ] , int n ) { int ans = - float ( 'inf' ) ; int maxval = 1 ; int minval = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { minval = min ( 1 , minval * arr [ i ] ) ; } } return ans ; }

static int findMaxProduct ( int arr [ ] , int n ) { int ans = - float ( 'inf' ) ; int maxval = 1 ; int minval = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } } return ans ; }

26.24
37.13
69.58
69.01
def countDigits ( a , b ) : if ( a == 0 or b == 0 ) : return 1 return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1

public static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }

static int countDigits ( int a , int b ) { if ( a == 0 ) return 0 ; return countDigits ( a , b ) ; } return 0 ; }

static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return Math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 ; }

26.3
38.94
29.15
44.92
def floorSearch ( arr , low , high , x ) : if ( low > high ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )

static int floorSearch ( int arr [ ] , int n , int x ) { if ( x >= arr [ n - 1 ] ) return n - 1 ; if ( x < arr [ 0 ] ) return - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ; return - 1 ; }

static int floorSearch ( int [ ] arr , int low , int high , int x ) { int mid = int ( low + high ) / 2 ; if ( x < arr [ mid ] ) return mid + 1 ; if ( x > arr [ mid - 1 ] ) return mid + 1 ; if ( x > arr [ mid ] ) return mid ; if ( x < arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return mid ;

static int floorSearch ( int arr , int low , int high , int x ) { int mid = int ( ( low + high ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return mid + 1 ; return floorSearch ( arr , low , high , x ) ; }

26.31
32.59
62.68
60.25
def numofAP ( a , n ) : minarr = + 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( minarr , a [ i ] ) maxarr = max ( maxarr , a [ i ] ) dp = [ 0 for i in range ( n + 1 ) ] ans = n + 1 for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : sum = [ 0 for i in range ( MAX + 1 ) ] for i in range ( n ) : dp [ i ] = 1 if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : dp [ i ] += sum [ a [ i ] - d ] ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] return ans

static int numofAP ( int a [ ] , int n ) { int minarr = + 2147483647 ; int maxarr = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { minarr = Math . min ( minarr , a [ i ] ) ; maxarr = Math . max ( maxarr , a [ i ] ) ; } int dp [ ] = new int [ n ] ; int sum [ ] = new int [ MAX ] ; int ans = n + 1 ; for ( int d = ( minarr - maxarr ) ; d <= ( maxarr - minarr ) ; d ++ ) { Arrays . fill ( sum , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } } return ans ; }

static int numofAP ( int [ ] a , int MAX ) { int [ ] dp = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] sum = new int [ MAX + 1 ] ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( a [ i ] - d >= 0 and a [ i ] - d <= 1000000 ) { dp [ i ] += sum [ a [ i ] ; } } return ans ; }

static int numofAP ( int a [ ] , int n ) { int minarr = + 2147483647 maxarr = - 2147483648 for ( int i = 0 ; i < n ; i ++ ) { int minarr = min ( minarr , a [ i ] ) ; int maxarr = max ( maxarr , a [ i ] ) ; int dp = [ 0 for i in range ( n + 1 ) ] ; for ( int d = 0 ; d < ( maxarr - minarr ) ; d ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) { dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] ; } } } return ans ; }

26.32
37.99
58.85
56.79
def discreteLogarithm ( a , b , m ) : n = int ( math . sqrt ( m ) + 1 ) an = 1 for i in range ( n ) : an = ( an * a ) % m value = [ 0 ] * m cur = an for i in range ( 1 , n + 1 ) : if ( value [ cur ] == 0 ) : value [ cur ] = i cur = ( cur * an ) % m cur = b for i in range ( n + 1 ) : if ( value [ cur ] > 0 ) : ans = value [ cur ] * n - i if ( ans < m ) : return ans cur = ( cur * a ) % m return - 1

static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }

static int discreteLogarithm ( int a , int b , int m ) { int an = 0 ; int cur = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return - 1 ; cur = ( cur * b ) % m ; } } return an ; }

static int discreteLogarithm ( int a , int b , int m ) { int n = int ( math . sqrt ( m + 1 ) ) ; int an = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int cur = an ; for ( int j = 1 ; j < n ; j ++ ) { if ( value [ cur ] == 0 ) { value [ cur ] = i ; cur = ( cur * an ) % m ; if ( value [ cur ] > 0 ) { ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; cur = ( cur * a ) % m ; } } } } return - 1 ; }

26.33
32.01
40.83
59.11
def snoob ( x ) : next = 0 if ( x ) : rightOne = x & - ( x ) nextHigherOneBit = x + int ( rightOne ) rightOnesPattern = x ^ int ( nextHigherOneBit ) rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) rightOnesPattern = int ( rightOnesPattern ) >> 2 next = nextHigherOneBit | rightOnesPattern return next

static int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }

static int snoob ( int x ) { int next = 0 ; int nextHigherOneBit = int ( x ) ; int rightOne = int ( x ) ; int rightOnesPattern = int ( rightOnesPattern ) / int ( rightOne ) ; int nextHigherOneBit = int ( nextHigherOneBit ) ; int next = int ( nextHigherOneBit ) ; int rightOnesPattern = int ( rightOnesPattern ) >>

static int snoob ( int x ) { int next = 0 ; int rightOne = x & - ( x ) ; int nextHigherOneBit = x + int ( rightOne ) ; rightOnesPattern = x ^ int ( nextHigherOneBit ) ; rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) ; rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) ; rightOnesPattern = ( int ( rightOnesPattern ) >> 2 ) ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }

26.37
35.11
61.6
59.42
def timeToMeet ( s , v ) : V = 3 * v / 2 time = s / V print ( time )

static void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; }

static void timeToMeet ( float s , float v ) { float time = s / V ; print ( time ) ; }

static void timeToMeet ( int s , int v ) { long V = 3 * v / 2 ; time = s / V ; System . out . println ( time ) ; }

26.43
41.48
51.27
60.81
def unique ( mat , n , m ) : maximum = 0 flag = 0 for i in range ( 0 , n ) : for j in range ( 0 , m ) : if ( maximum < mat [ i ] [ j ] ) : maximum = mat [ i ] [ j ] uniqueElementDict = [ 0 ] * ( maximum + 1 ) for i in range ( 0 , n ) : for j in range ( 0 , m ) : uniqueElementDict [ mat [ i ] [ j ] ] += 1 for key in range ( maximum + 1 ) : if uniqueElementDict [ key ] == 1 : print ( key , end = "" ) flag = 1 if ( flag == 0 ) : print ( "Nouniqueelementinthematrix" )

static void unique ( int mat [ ] [ ] , int n , int m ) { int maximum = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; int b [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) b [ mat [ i ] [ j ] ] ++ ; for ( int i = 1 ; i <= maximum ; i ++ ) if ( b [ i ] == 1 ) System . out . print ( i + " " ) ; flag = 1 ; if ( flag == 0 ) { System . out . println ( "No unique element " + "in the matrix" ) ; } }

static void unique ( int mat [ ] [ ] , int n , int m ) { int maximum = 0 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( uniqueElementDict [ mat [ i ] [ j ] ] == 1 ) flag = 1 ; for ( int key = 0 ; key < n ; key ++ ) { if ( uniqueElement

static void unique ( int [ ] mat , int n , int m ) { int maximum = 0 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; uniqueElementDict [ mat [ i ] [ j ] ] ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; uniqueElementDict [ mat [ i ] [ j ] ] ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; uniqueElementDict [ mat [ i ] [ j ] ] ++ ; } } } }

26.52
46.45
65.34
70.56
def find_extra_element_index ( arrA , arrB ) : extra_element = sum ( arrA ) - sum ( arrB ) return arrA . index ( extra_element )

static int find_extra_element_index ( int [ ] arrA , int [ ] arrB ) { int extra_element = sum ( arrA ) - sum ( arrB ) ; return indexOf ( arrA , extra_element ) ; }

static int find_extra_element_index ( int arrA , int arrB ) { int extra_element = arrA . index ( arrB ) - arrB . index ( extra_element ) ; return extra_element ; }  def find_extra_element_index ( int arrA , int arrB ) { int extra_element = arrB . index ( extra_element ) ; return extra_element ; }

static int find_extra_element_index ( int arrA , int arrB ) { int extra_element = sum ( arrA ) - sum ( arrB ) ; return arrA . index ( extra_element ) ; }

26.59
32.66
30.54
46.17
def countSubstrs ( str , i , j , n ) : if ( n == 1 ) : return 1 if ( n <= 0 ) : return 0 res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) if ( str [ i ] == str [ j ] ) : res += 1 return res

static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }

static int countSubstrs ( String str , int i , int j , int n ) { int res = 0 ; if ( str [ i ] == str [ j ] ) res += 1 ; if ( str [ i ] == str [ j ] ) res += 1 ; if ( str [ i ] == str [ j ] ) res += 1 ; if ( str [ i ] == str [ j ] ) res += 1 ; if ( str [ i ] == str [ j

static int countSubstrs ( String str , int i , int j , int n ) { int res = countSubstrs ( str , i + 1 , j , n - 1 ) ; if ( str [ i ] == str [ j ] ) { res ++ ; } else if ( str [ i ] == str [ j ] ) { res ++ ; } else if ( str [ i ] == str [ j ] ) { res ++ ; } else if ( str [ i ] == str [ j ] ) { res ++ ; } else if ( str [ i ] == str [ j ] ) { res ++ ; } else if ( str [ i ] == str [ j ] ) { res ++ ; } } return res ; }

26.67
25.16
59.31
66.51
def getArea ( a ) : area = ( math . pi * a * a ) / 4 return area

static float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }

static int getArea ( int a ) { int area = 0 ; return area ; }

static int getArea ( int a ) { int area = ( math . pi * a * a ) / 4 ; return area ; }

26.67
35.59
37.95
44.92
def PowerOFPINnfactorial ( n , p ) : ans = 0 temp = p while ( temp <= n ) : ans += n / temp temp = temp * p return ans

static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = 0 , temp = i ; while ( temp % p == 0 ) { count ++ ; temp = temp / p ; } ans += count ; } return ans ; }

static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; while ( temp <= n ) { ans += n / temp ; } return ans ; }

static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }

26.73
34.3
38.56
44.42
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : s = set ( ) for i in range ( n1 ) : s . add ( a1 [ i ] ) for i in range ( n2 ) : for j in range ( n3 ) : if sum - a2 [ i ] - a3 [ j ] in s : return True return False

static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { s . add ( a1 [ i ] ) ; } ArrayList < Integer > al = new ArrayList < > ( s ) ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al . get ( al . size ( ) - 1 ) ) { return true ; } } } return false ; }

static boolean findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) { Set < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( sum - a1 [ i ] - a2

static boolean findTriplet ( int a1 , int a2 , int a3 , int n1 , int n2 , int n3 , int sum ) { Set s = new HashSet ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { s . add ( a1 [ i ] ) ; for ( int j = 0 ; j < n2 ; j ++ ) { if ( sum - a2 [ i ] - a3 [ j ] in s ) return true ; } } return false ; }

26.77
33.84
57.87
63.11
def pageFaults ( pages , n , capacity ) : s = set ( ) indexes = Queue ( ) page_faults = 0 for i in range ( n ) : if ( len ( s ) < capacity ) : if ( pages [ i ] not in s ) : s . add ( pages [ i ] ) page_faults += 1 indexes . put ( pages [ i ] ) else : if ( pages [ i ] not in s ) : val = indexes . queue [ 0 ] indexes . get ( ) s . remove ( val ) s . add ( pages [ i ] ) indexes . put ( pages [ i ] ) page_faults += 1 return page_faults

static int pageFaults ( int pages [ ] , int n , int capacity ) { HashSet < Integer > s = new HashSet < > ( capacity ) ; Queue < Integer > indexes = new LinkedList < > ( ) ; int page_faults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( ! s . contains ( pages [ i ] ) ) { s . add ( pages [ i ] ) ; page_faults ++ ; indexes . add ( pages [ i ] ) ; } } else { if ( ! s . contains ( pages [ i ] ) ) { int val = indexes . peek ( ) ; indexes . poll ( ) ; s . remove ( val ) ; s . add ( pages [ i ] ) ; indexes . add ( pages [ i ] ) ; page_faults ++ ; } } } return page_faults ; }

static int pageFaults ( int [ ] pages , int n , Queue < int > indexes ) { int page_faults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( pages [ i ] ) ) { int val = indexes . queue [ 0 ] ; s . remove ( val ) s . add ( pages [ i ] ) page_faults ++ ; } else { if ( len ( s ) <

static int pageFaults ( int pages [ ] , int capacity ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( len ( s ) < capacity ) { if ( pages [ i ] not in s ) s . add ( pages [ i ] ) page_faults ++ ; indexes . put ( pages [ i ] ) ; } else if ( pages [ i ] not in s ) { val = indexes . queue [ 0 ] ; indexes . get ( ) s . remove ( val ) ; s . add ( pages [ i ] ) ; indexes . put ( pages [ i ] ) ; page_faults ++ ; } } return page_faults ; }

26.79
30.42
53.24
52.86
def subsetGraph ( C ) : global N vertices = set ( ) for i in range ( N ) : vertices . add ( i ) while ( len ( vertices ) != 0 ) : if ( len ( vertices ) == 1 ) : return 1 someone_removed = False for x in vertices : values = set ( ) for y in vertices : if ( y != x ) : values . add ( C [ x ] [ y ] ) if ( len ( values ) == 1 ) : vertices . remove ( x ) someone_removed = True break if ( not someone_removed ) : break return len ( vertices )

static int subsetGraph ( int C [ ] [ ] ) { HashSet < Integer > vertices = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { vertices . add ( i ) ; } while ( ! vertices . isEmpty ( ) ) { if ( vertices . size ( ) == 1 ) { return 1 ; } boolean someone_removed = false ; for ( int x : vertices ) { HashSet < Integer > values = new HashSet < > ( ) ; for ( int y : vertices ) { if ( y != x ) { values . add ( C [ x ] [ y ] ) ; } } if ( values . size ( ) == 1 ) { vertices . remove ( x ) ; someone_removed = true ; break ; } } if ( ! someone_removed ) { break ; } } return ( vertices . size ( ) ) ; }

static int subsetGraph ( int [ ] C , int N ) { HashSet < int > vertices = new HashSet < int > ( ) ; while ( len ( vertices ) != 0 ) { boolean someone_removed = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != x ) { values . add ( C [ x ] [ i ] ) ; if ( ! someone_removed ) { vertices . remove ( x ) ; someone_removed =

; } static int subsetGraph ( int N ) { int vertices = set ( ) ; for ( int i = 0 ; i < N ; i ++ ) { vertices . add ( i ) ; } while ( vertices . size ( ) != 0 ) { if ( vertices . size ( ) == 1 ) return 1 ; boolean someone_removed = false ; for ( int x in vertices ) { if ( y != x ) { values . add ( C [ x ] [ y ] ) ; if ( len ( values ) == 1 ) vertices . remove ( x ) ; someone_removed = true break ; } if ( len ( values ) == 1 ) vertices . remove ( x ) ; } } return - 1 ; }

26.79
29.73
24.58
29.07
def canRepresentBST ( pre ) : s = [ ] root = INT_MIN for value in pre : if value < root : return False while ( len ( s ) > 0 and s [ - 1 ] < value ) : root = s . pop ( ) s . append ( value ) return True

boolean canRepresentBST ( int pre [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; int root = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( pre [ i ] < root ) { return false ; } while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) { root = s . peek ( ) ; s . pop ( ) ; } s . push ( pre [ i ] ) ; } return true ; }

static boolean canRepresentBST ( int pre [ ] ) { int root = INT_MIN ; int s [ ] = new int [ pre . length ] ; for ( int value = root ; value < root ; value ++ ) { if ( s . pop ( ) < value ) { root = s . pop ( ) ; s . append ( value ) ; } } return false ; }

static boolean canRepresentBST ( int [ ] pre , int root ) { int [ ] s = new int [ 1 ] ; for ( int value = 0 ; value < root ; value ++ ) { if ( s . length > 0 && s [ - 1 ] < value ) return false ; while ( s . length > 0 && s [ - 1 ] < value ) s . pop ( ) ; } return true ; }

26.97
28.75
41.2
42.17
def amendSentence ( string ) : string = list ( string ) for i in range ( len ( string ) ) : if string [ i ] >= 'A' and string [ i ] <= 'Z' : string [ i ] = chr ( ord ( string [ i ] ) + 32 ) if i != 0 : print ( "" , end = "" ) print ( string [ i ] , end = "" ) else : print ( string [ i ] , end = "" )

public static void amendSentence ( String sstr ) { char [ ] str = sstr . toCharArray ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) System . out . print ( " " ) ; System . out . print ( str [ i ] ) ; } else System . out . print ( str [ i ] ) ; } }

static void amendSentence ( String string ) { int i = 0 ; for ( int i = 0 ; i < len ( string ) ; i ++ ) { if ( string [ i ] >= 'a' and string [ i ] <= 'z' ) string [ i ] = chr ( string [ i ] - 'a' ) + 32 ; else string [ i ] = chr ( string [ i ] - 'a' ) + 32 ; else string [ i ] =

static void amendSentence ( String string ) { for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string [ i ] >= 'A' && string [ i ] <= 'Z' ) string [ i ] = chr ( ord ( string [ i ] ) + 32 ) ; if ( i != 0 ) print ( string [ i ] , end = "" ) ; else print ( string [ i ] , end = "" ) ; } }

27.01
38.73
51.45
55.58
def printFibonacciNumbers ( n ) : f1 = 0 f2 = 1 if ( n < 1 ) : return for x in range ( 0 , n ) : print ( f2 , end = "" ) next = f1 + f2 f1 = f2 f2 = next

static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( f2 + " " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }

static void printFibonacciNumbers ( int n ) { int f1 = 0 ; int f2 = 1 ; for ( int x = 0 ; x < n ; x ++ ) { print ( f1 + f2 , end = "" ) ; } }

static void printFibonacciNumbers ( int n ) { int f1 = 0 ; int f2 = 1 ; if ( n < 1 ) return ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( f1 ) ; System . out . print ( f2 ) ; } System . out . print ( " " ) ; }

27.01
34.79
34.07
47.77
def nextWord ( s ) : if ( s == "" ) : return "a" i = len ( s ) - 1 while ( s [ i ] == 'z' and i >= 0 ) : i -= 1 if ( i == - 1 ) : s = s + 'a' else : s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) return s

public static String nextWord ( String str ) { if ( str == "" ) return "a" ; int i = str . length ( ) - 1 ; while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + 'a' ; else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ; return str ; }

static String nextWord ( String s ) { int i = len ( s ) ; while ( s . charAt ( i ) == 'a' ) i -- ; if ( i == - 1 ) s = s + 'a' ; else s = s . replace ( s [ i ] , 'a' , 1 ) ; if ( i == - 1 ) s = s + 'a' ; else s = s . replace ( s [ i ] , 'a' ,

static String nextWord ( String s ) { int i = s . length ( ) - 1 ; while ( s [ i ] == 'a' && i >= 0 ) i -- ; if ( i == - 1 ) s = s + 'a' ; else s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) ; return s ; }

27.02
35.47
55.8
53.28
def longestSubseqWithDiffOne ( arr , n ) : dp = [ 1 for i in range ( n ) ] for i in range ( n ) : for j in range ( i ) : if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) result = 1 for i in range ( n ) : if ( result < dp [ i ] ) : result = dp [ i ] return result

static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }

static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = [ 1 for i in range ( n ) ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] < arr [ j ] ) { dp [ i ] = max ( dp [ i ] , dp [ j ] - 1 ) ; } } return 0 ; }

static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } return result ; }

27.02
34.22
57.59
50.81
def findMaxSegment ( s , k ) : seg_len = len ( s ) - k res = 0 for i in range ( seg_len ) : res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) seg_len_pow = pow ( 10 , seg_len - 1 ) curr_val = res for i in range ( 1 , len ( s ) - seg_len ) : curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) res = max ( res , curr_val ) return res

static int findMaxSegment ( String s , int k ) { int seg_len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_len ; i ++ ) res = res * 10 + ( s . charAt ( i ) - '0' ) ; int seg_len_pow = ( int ) Math . pow ( 10 , seg_len - 1 ) ; int curr_val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_len ) ; i ++ ) { curr_val = curr_val - ( s . charAt ( i - 1 ) - '0' ) * seg_len_pow ; curr_val = curr_val * 10 + ( s . charAt ( i + seg_len - 1 ) - '0' ) ; res = Math . max ( res , curr_val ) ; } return res ; }

static int findMaxSegment ( String s , int k ) { int res = 0 ; int seg_len = s . length ( ) ; int curr_val = res ; for ( int i = 1 ; i <= k ; i ++ ) { res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) * seg_len_pow ; curr_val = ( curr_val * 10 + ( ord ( s [ i +

static int findMaxSegment ( String s , int k ) { int seg_len = s . length ( ) ; int res = 0 ; for ( int i = 1 ; i < len ( s ) ; i ++ ) { res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) * seg_len_pow ; curr_val = res ; for ( int i = 1 ; i < len ( s ) - seg_len ; i ++ ) { curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow ; curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) ; res = max ( res , curr_val ) ; } } return res ; }

27.06
33.64
35.53
41.79
def minimumCostOfBreaking ( X , Y , m , n ) : res = 0 X . sort ( reverse = True ) Y . sort ( reverse = True ) hzntl = 1 vert = 1 i = 0 j = 0 while ( i < m and j < n ) : if ( X [ i ] > Y [ j ] ) : res += X [ i ] * vert hzntl += 1 i += 1 else : res += Y [ j ] * hzntl vert += 1 j += 1 total = 0 while ( i < m ) : total += X [ i ] i += 1 res += total * vert total = 0 while ( j < n ) : total += Y [ j ] j += 1 res += total * hzntl return res

static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }

static int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; int hzntl = 1 ; int vert = 1 ; int i = 0 ; int j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) res += X [ i ] * vert hzntl + 1 i += 1 ; else res += Y [ j

static int minimumCostOfBreaking ( int X , int Y , int m , int n ) { int res = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] > Y [ j ] ) res += X [ i ] * vert ; else res += Y [ j ] * vert ; } for ( int j = 0 ; j < n ; j ++ ) { if ( X [ i ] > Y [ j ] ) res += X [ i ] * vert ; else res += Y [ j ] * hzntl ; } for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] > Y [ j ] ) res += X [ i ] * vert ; else res += Y [ j ] * vert ; } for ( int j = 0 ; j < n ; j ++ ) { if ( Y [ j ] > X [ i ] ) res += X [ i ] * vert ; else res += Y [ j ] * hzntl ; } } return res ; }

27.17
32.96
41.92
39.78
def getOddOccurrence ( arr ) : res = 0 for element in arr : res = res ^ element return res

int getOddOccurrence ( int ar [ ] , int ar_size ) { int i ; int res = 0 ; for ( i = 0 ; i < ar_size ; i ++ ) { res = res ^ ar [ i ] ; } return res ; }

static int getOddOccurrence ( int arr [ ] ) { int res = 0 ; for ( int element in arr : res = res ^ element ; res = res ^ element ; }

static int getOddOccurrence ( int arr [ ] ) { int res = 0 ; for ( int element ; element ; element ++ ) { res = res ^ element ; } return res ; }

27.17
40.35
61.22
63.45
def maxSumIS ( arr , n ) : max = 0 msis = [ 0 for x in range ( n ) ] for i in range ( n ) : msis [ i ] = arr [ i ] for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : msis [ i ] = msis [ j ] + arr [ i ] for i in range ( n ) : if max < msis [ i ] : max = msis [ i ] return max

static int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }

static int maxSumIS ( int arr [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ j ] and max < msis [ j ] + arr [ i ] ) { max = msis [ j ] + arr [ i ] ; } } return max ; }

static int maxSumIS ( int arr [ ] , int n ) { int max = 0 ; int msis [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { msis [ i ] = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) { msis [ i ] = msis [ j ] + arr [ i ] ; } } } return max ; }

27.18
26.39
40.04
44.19
def findthepath ( S , v ) : result [ 0 ] = v for i in range ( 1 , len ( S ) ) : if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) ] [ v ] ) : v = ord ( S [ i ] ) - ord ( 'A' ) elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) : v = ord ( S [ i ] ) - ord ( 'A' ) + 5 else : return False result . append ( v ) return True

static boolean findthepath ( char [ ] S , int v ) { result [ 0 ] = ( char ) ( v + '0' ) ; for ( int i = 1 ; i < ( int ) S . length ; i ++ ) { if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] [ v ] ) { v = S [ i ] - 'A' ; } else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i ] - 'A' + 5 ] [ v ] ) { v = S [ i ] - 'A' + 5 ; } else return false ; result [ i ] = ( char ) ( v + '0' ) ; } return true ; }

static boolean findthepath ( char [ ] S , char [ ] result [ ] ) { int i = 0 ; for ( int i = 0 ; i < len ( S ) ; i ++ ) { if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) { v = ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) ; } else {

static boolean findthepath ( String S , String v ) { int result [ 0 ] = v ; for ( int i = 1 ; i < len ( S ) ; i ++ ) { if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) { v = ord ( S [ i ] ) - ord ( 'A' ) ; } else if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) { v = ord ( S [ i ] ) - ord ( 'A' ) + 5 ; } else if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) { v = ord ( S [ i ] ) - ord ( 'A' ) + 5 ; } else { return false ; } result . append ( v ) ; } } return true ; }

27.29
36.03
56.46
49.67
def sumOfDigitsFrom1ToN ( n ) : if ( n < 10 ) : return ( n * ( n + 1 ) / 2 ) d = ( int ) ( math . log10 ( n ) ) a = [ 0 ] * ( d + 1 ) a [ 0 ] = 0 a [ 1 ] = 45 for i in range ( 2 , d + 1 ) : a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) msd = n // p return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) )

static int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }

static int sumOfDigitsFrom1ToN ( int n ) { int d = ( int ) ( math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; for ( int i = 1 ; i <= d ; i ++ ) { a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) ; } return (

static int sumOfDigitsFrom1ToN ( int n ) { int d = ( int ) ( math . log10 ( n ) ) ; int a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 1 ; i <= d ; i ++ ) { a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) ; } return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }

27.38
32.11
33.61
43.52
def removeConsecutiveSame ( v ) : st = [ ] for i in range ( len ( v ) ) : if ( len ( st ) == 0 ) : st . append ( v [ i ] ) else : Str = st [ - 1 ] if ( Str == v [ i ] ) : st . pop ( ) else : st . append ( v [ i ] ) return len ( st )

static int removeConsecutiveSame ( Vector < String > v ) { Stack < String > st = new Stack < > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v . get ( i ) ) ; else { String str = st . peek ( ) ; if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ; else st . push ( v . get ( i ) ) ; } } return st . size ( ) ; }

static int removeConsecutiveSame ( String [ ] v ) { String [ ] st = new String [ len ( v ) ] ; for ( int i = 0 ; i < len ( v ) ; i ++ ) { String [ ] Str = st [ - 1 ] ; if ( Str == v [ i ] ) st . pop ( ) ; else st . append ( v [ i ] ) ; } return 0 ; }

static int removeConsecutiveSame ( String [ ] v ) { int st [ ] = new int [ v . length ] ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( st . length == 0 ) st . append ( v [ i ] ) ; else if ( Str == v [ i ] ) st . pop ( ) ; else st . append ( v [ i ] ) ; } return len ( st ) ; }

27.43
43.89
59.07
75.38
def checkReverse ( arr , n ) : if ( n == 1 ) : return True i = 1 for i in range ( 1 , n ) : if arr [ i - 1 ] < arr [ i ] : if ( i == n ) : return True j = i while ( arr [ j ] < arr [ j - 1 ] ) : if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : return False j += 1 if ( j == n ) : return True k = j if ( arr [ k ] < arr [ i - 1 ] ) : return False while ( k > 1 and k < n ) : if ( arr [ k ] < arr [ k - 1 ] ) : return False k += 1 return True

static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ++ ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }

static boolean checkReverse ( int arr [ ] , int n ) { int i = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) return false ; if ( arr [ i ] < arr [ i - 2 ] ) return false ; for ( int j = i ; j <= n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) return

static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int i = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] ) { if ( i > 1 && arr [ i ] < arr [ i - 2 ] ) return false ; if ( i > 1 && arr [ i ] < arr [ i - 1 ] ) return false ; if ( i > 1 && arr [ i ] < arr [ i - 2 ] ) return false ; i ++ ; } if ( i == n ) return true ; int j = i ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ j - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; int k = j ; if ( arr [ k ] < arr [ k - 1 ] ) return false ; while ( k > 1 && arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; }

27.43
34.19
45.86
43.72
def findLength ( string , n ) : Sum = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) ) ans = 0 for length in range ( 2 , n + 1 , 2 ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length // 2 ] ) : ans = max ( ans , length ) return ans

static int findLength ( String str , int n ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ; int ans = 0 ; for ( int len = 2 ; len <= n ; len += 2 ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ; } } return ans ; }

static int findLength ( String string , int n ) { int Sum [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( Sum [ i ] - Sum [ j ] == 0 ) { ans = max ( ans , length ) ; } else { ans = max ( ans , length ) ; } } return ans ; } }

int findLength ( String string , int n ) { int Sum [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) ) ; } int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length // 2 ] ) { ans = max ( ans , length ) ; break ; } } } return ans ; }

27.47
33.88
30.41
34.32
def calcAngle ( h , m ) : if ( h < 0 or m < 0 or h > 12 or m > 60 ) : print ( 'Wronginput' ) if ( h == 12 ) : h = 0 if ( m == 60 ) : m = 0 hour_angle = 0.5 * ( h * 60 + m ) minute_angle = 6 * m angle = abs ( hour_angle - minute_angle ) angle = min ( 360 - angle , angle ) return angle

static int calcAngle ( double h , double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }

static int calcAngle ( int h , int m ) { int angle = 0 ; if ( h == 0 ) h = 0 ; if ( m == 0 ) m = 0 ; if ( m == 60 ) m = 0 ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; if ( m == 0 ) m = 0 ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; if

static int calcAngle ( int h , int m ) { int angle ; if ( h < 0 || m < 0 || h > 12 || m > 60 ) throw new IllegalArgumentException ( "Wronginput" ) ; if ( h < 0 || m < 0 || m > 60 ) throw new IllegalArgumentException ( "Wronginput" ) ; if ( h > 12 || m > 60 ) throw new IllegalArgumentException ( "Wronginput" ) ; if ( m < 0 || m > 60 ) throw new IllegalArgumentException ( "Wronginput" ) ; if ( h > 12 ) throw new IllegalArgumentException ( "Wronginput" ) ; if ( m < 0 || m > 60 ) throw new IllegalArgumentException ( "Wronginput" ) ; return angle ; }

27.47
37.97
50.45
67.68
def exponentiation ( bas , exp ) : t = 1 while ( exp > 0 ) : if ( exp % 2 != 0 ) : t = ( t * bas ) % N bas = ( bas * bas ) % N exp = int ( exp / 2 ) return t % N

static long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; }

static int exponentiation ( int bas , int exp ) { int t = 1 ; while ( ( t * bas ) % N != 0 ) t = ( t * bas ) % N ; } return t ; }

public static int exponentiation ( int bas , int exp ) { int t = 1 ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * bas ) % N ; bas = ( bas * bas ) % N ; exp = int ( exp / 2 ) ; } return t ; }

27.6
40.82
58.01
62.9
def getMedian ( ar1 , ar2 , n ) : i = 0 j = 0 m1 = - 1 m2 = - 1 count = 0 while count < n + 1 : count += 1 if i == n : m1 = m2 m2 = ar2 [ 0 ] break elif j == n : m1 = m2 m2 = ar1 [ 0 ] break if ar1 [ i ] < ar2 [ j ] : m1 = m2 m2 = ar1 [ i ] i += 1 else : m1 = m2 m2 = ar2 [ j ] j += 1 return ( m1 + m2 ) / 2

static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] < ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }

static int getMedian ( int [ ] ar1 , int [ ] ar2 , int n ) { int i = 0 ; int j = 0 ; int m1 = - 1 ; int m2 = - 1 ; while ( i < n ) { if ( ar1 [ i ] < ar2 [ j ] ) m1 = m2 m2 = ar1 [ i ] ; i += 1 else : m1 = m2 m2 = ar2 [ j

static int getMedian ( int ar1 , int ar2 , int n ) { int i = 0 ; int j = 0 ; int m1 = - 1 ; int m2 = - 1 ; int count = 0 ; while ( count < n + 1 ) { count ++ ; if ( i == n ) m1 = m2 m2 = ar1 [ 0 ] ; else if ( j == n ) m1 = m2 m2 = ar2 [ 0 ] ; else if ( ar1 [ i ] < ar2 [ j ] ) m1 = m2 m2 = ar1 [ i ] ; else m1 = m2 m2 = ar2 [ j ] ; } return ( m1 + m2 ) / 2 ; }

27.61
37.49
58.37
57.65
def maximumSum ( arr , n , k ) : for i in range ( 1 , k + 1 ) : min = + 2147483647 index = - 1 for j in range ( n ) : if ( arr [ j ] < min ) : min = arr [ j ] index = j if ( min == 0 ) : break arr [ index ] = - arr [ index ] sum = 0 for i in range ( n ) : sum += arr [ i ] return sum

static int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }

static int maximumSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { if ( arr [ i ] > - 2147483647 ) { sum = arr [ i ] ; index = i ; } } return sum ; }

static int maximumSum ( int arr [ ] , int n , int k ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } }

27.64
42.42
77.59
78.89
def editDistDP ( str1 , str2 , m , n ) : dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if i == 0 : dp [ i ] [ j ] = j elif j == 0 : dp [ i ] [ j ] = i elif str1 [ i - 1 ] == str2 [ j - 1 ] : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) return dp [ m ] [ n ]

static int editDistDP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

static int editDistDP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str1 [ i ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = 1 + min

static int editDistDP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = i ; else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

27.64
51.75
94.39
96.65
def findSumSubsets ( n ) : return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) )

static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }

static int findSumSubsets ( int n ) { int sumSubsets = findSumSubsets ( n - 1 ) ; int sumSubsets = findSumSubsets ( n - 1 ) ; int sumSubsets = findSumSubsets ( n - 1 ) ; return sumSubsets ; }

static int findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }

27.74
34.02
37.18
40.28
def findSubarraySum ( arr , n ) : res = 0 m = dict ( ) for i in range ( n ) : Sum = 0 for j in range ( i , n ) : Sum += arr [ j ] m [ Sum ] = m . get ( Sum , 0 ) + 1 for x in m : if m [ x ] == 1 : res += x return res

static int findSubarraySum ( int [ ] arr , int n ) { int res = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( m . containsKey ( sum ) ) { m . put ( sum , m . get ( sum ) + 1 ) ; } else { m . put ( sum , 1 ) ; } } } for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) if ( x . getValue ( ) == 1 ) res += x . getKey ( ) ; return res ; }

static int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int Sum = 0 ; for ( int j = i ; j < n ; j ++ ) { Sum += arr [ j ] ; m [ Sum ] = m . get ( Sum , 0 ) + 1 ; } } return res ; }

static int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; int m = new int ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int Sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { Sum += arr [ j ] ; m [ Sum ] = m . get ( Sum , 0 ) + 1 ; for ( int x in m ) if ( m [ x ] == 1 ) res ++ ; } } return res ; }

27.8
49.57
28.06
53.29
def printSorted ( arr , start , end ) : if start > end : return printSorted ( arr , start * 2 + 1 , end ) print ( arr [ start ] , end = "" ) printSorted ( arr , start * 2 + 2 , end )

private static void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }

static void printSorted ( int arr [ ] , int start * 2 + 1 , int end ) { System . out . print ( arr [ start ] ) ; System . out . print ( arr [ start ] ) ; System . out . print ( arr [ start ] ) ; System . out . print ( arr [ start ] ) ; System . out . print ( arr [ start ] ) ; System . out . print ( arr [ start ] ) ; System . out . print ( arr

static void printSorted ( int arr [ ] , int start , int end ) { System . out . print ( arr [ start * 2 + 1 ] ) ; System . out . print ( arr [ start * 2 + 2 ] ) ; System . out . print ( arr [ start * 2 + 3 ] ) ; System . out . print ( arr [ start * 2 + 4 ] ) ; System . out . print ( arr [ start * 2 + 5 ] ) ; System . out . print ( arr [ start * 2 + 6 ] ) ; }

27.82
36.55
52.33
47.98
def pairSum ( mat , n , sum ) : for i in range ( n ) : mat [ i ] . sort ( ) for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : left = 0 right = n - 1 while ( left < n and right >= 0 ) : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : print ( "(" , mat [ i ] [ left ] , "," , mat [ j ] [ right ] , ")," , end = "" ) left += 1 right -= 1 else : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : left += 1 else : right -= 1

static void pairSum ( int mat [ ] [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( mat [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { System . out . print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } } } }

static void pairSum ( int [ ] mat , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( mat [ i ] [ left ] + mat [ j ] [ right ] == sum ) { print ( "(" , mat [ i ] [ left ] , "," , mat [ j ] [ right ] , ")," , end = "" ) } } }

; for ( int i = 0 ; i < n ; i ++ ) { int left = 0 ; int right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { print ( "(" , mat [ i ] [ left ] , "," , mat [ j ] [ right ] , ")," , end = "" ) ; left ++ ; right -- ; } else if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } }

27.84
39.11
72.56
75.14
def compute ( a , b ) : AM = ( a + b ) / 2 GM = math . sqrt ( a * b ) HM = ( GM * GM ) / AM return HM

static double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }

static double compute ( double a , double b ) { double HM = ( HM * HM ) / AM ; return HM ; }  def compute ( double a , double b ) { double HM = ( HM * HM ) / AM ; double HM = ( GM * GM ) / AM ; double HM = ( HM * HM ) / AM ; double HM = ( HM * HM ) / AM ;

static int compute ( int a , int b ) { int AM = ( a + b ) / 2 ; int GM = math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }

27.92
35.63
56.71
55.09
def findTriplets ( arr , n ) : found = False arr . sort ( ) for i in range ( 0 , n - 1 ) : l = i + 1 r = n - 1 x = arr [ i ] while ( l < r ) : if ( x + arr [ l ] + arr [ r ] == 0 ) : print ( x , arr [ l ] , arr [ r ] ) l += 1 r -= 1 found = True elif ( x + arr [ l ] + arr [ r ] < 0 ) : l += 1 else : r -= 1 if ( found == False ) : print ( "NoTripletFound" )

static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { System . out . print ( x + " " ) ; System . out . print ( arr [ l ] + " " ) ; System . out . println ( arr [ r ] + " " ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) System . out . println ( " No Triplet Found" ) ; }

static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; int i = 0 ; while ( i < arr . length ) { if ( found == false ) { for ( int l = 0 ; l < r ; l ++ ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { found = true ; } else { if ( x + arr [ l ] + arr [ r ] == 0 ) { found

static void findTriplets ( int arr [ ] , int n ) { int l = 0 ; int r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { print ( x , arr [ l ] , arr [ r ] ) ; l += 1 ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l += 1 ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l += 1 ; else else r -= 1 ; } if ( found == false ) { print ( "NoTripletFound" ) ; } } return ; }

27.95
31.14
30.74
38.37
def check ( num ) : digitSum = 0 while num > 0 : rem = num % 10 digitSum = digitSum + rem num = num // 10 return ( digitSum % 3 == 0 )

static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }

static boolean check ( int num ) { int digitSum = 0 ; while ( num > 0 ) { if ( digitSum % 3 == 0 ) return ( digitSum % 3 == 0 ) return ( digitSum % 3 == 0 ) return ( digitSum % 3 == 0 ) return ( digitSum % 3 == 0 ) ; } return false ; }

static boolean check ( int num ) { int digitSum = 0 ; while ( num > 0 ) { int rem = num % 10 ; digitSum = digitSum + rem ; digitSum = digitSum + rem ; num = num / 10 ; return ( digitSum % 3 == 0 ) && ( digitSum % 3 == 0 ) ; } }

28.03
39.78
57.0
54.34
def MaximumHeight ( a , n ) : return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2

static int MaximumHeight ( int a [ ] , int n ) { return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; }

static int MaximumHeight ( int a , int n ) { int a = int ( a ) ; int n = int ( a ) ; int n = int ( n ) ; return ( a + n ) / 2 ; }

private static int MaximumHeight ( int a , int n ) { return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ; }

28.07
26.48
35.73
39.86
def evenlength ( n ) : res = n for j in range ( len ( n ) - 1 , - 1 , - 1 ) : res += n [ j ] return res

static String evenlength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; }

static int evenlength ( int n ) { int res = 0 ; for ( int j = 0 ; j < len ( n ) ; j ++ ) { res += n [ j ] ; } return res ; }

static int evenlength ( int n ) { int res = n ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { res += n [ i ] ; } return res ; }

28.09
31.48
65.41
60.96
def mirrorImage ( a , b , c , x1 , y1 ) : temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) x = temp * a + x1 y = temp * b + y1 return ( x , y )

static pair mirrorImage ( double a , double b , double c , double x1 , double y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return new pair ( x , y ) ; }

static int mirrorImage ( int a , int b , int c , int x1 , int y1 ) { int x = temp * a + x1 ; int y = temp * b + y1 ; return ( x , y ) ; }

static int mirrorImage ( int a , int b , int c , int x , int y ) { int temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; x = temp * a + x1 ; y = temp * b + y1 ; return ( x , y ) ; }

28.09
33.82
100.0
100.0
def getRemainder ( num , divisor ) : return ( num - divisor * ( num // divisor ) )

static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }

def getRemainder ( num , divisor ) { return ( num - divisor

static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }

28.15
26.99
41.91
35.67
def HalfDiagonalSums ( mat , n ) : diag1_left = 0 diag1_right = 0 diag2_left = 0 diag2_right = 0 i = 0 j = n - 1 while i < n : if ( i < n // 2 ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ j ] [ i ] elif ( i > n // 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] i += 1 j -= 1 return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )

static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }

static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 ; int diag1_right = 0 ; int diag2_left = 0 ; int diag2_right = 0 ; while ( i < n ) { if ( i > n // 2 ) diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } return ( diag1

static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 ; int diag1_right = 0 ; int diag2_left = 0 ; int diag2_right = 0 ; i = 0 ; j = n - 1 ; while ( i < n ; i ++ ) { if ( i < n // 2 ) diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; else if ( i > n // 2 ) diag1_right += mat [ i ] [ i ] ; else if ( i > n // 2 ) diag1_right += mat [ i ] [ i ] ; else if ( i > n // 2 ) diag1_right += mat [ i ] [ i ] ; else if ( i > n // 2 ) diag1_right += mat [ i ] [ i ] ; else if ( i > n // 2 ) diag1_right += mat [ j ] [ i ] ; else if ( i > n // 2 ) diag2_right += mat [ j ] [ i ] ; else if ( i > n // 2 ) diag2_right += mat [

28.21
40.39
63.14
60.63
def minCost ( a , n , k ) : dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : for m in range ( i - 1 , - 1 , - 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) return dp [ n ] [ k ]

static int minCost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }

static double minCost ( double [ ] a , int n , int k ) { double dp [ ] [ ] = new double [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { if ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) * ( a

static int minCost ( int a [ ] [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < k ; j ++ ) { for ( int m = i - 1 ; m >= 0 ; m -- ) { dp [ i ] [ j ] = minCost ( a [ i - 1 ] [ m ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; } } return dp [ n ] [ k ] ; }

28.29
26.66
81.15
81.26
def numberOfTriangles ( n ) : ans = 2 * ( pow ( 3 , n ) ) - 1 return ans

public static double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }

static int numberOfTriangles ( int n ) { int ans = 0 ; return ans ; }

static int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }

28.31
37.22
51.5
61.7
def lcsOf3 ( i , j , k ) : if ( i == - 1 or j == - 1 or k == - 1 ) : return 0 if ( dp [ i ] [ j ] [ k ] != - 1 ) : return dp [ i ] [ j ] [ k ] if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) return dp [ i ] [ j ] [ k ] else : dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) return dp [ i ] [ j ] [ k ]

static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) { return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } }

static int lcsOf3 ( int i , int j , int k ) { if ( i == j ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; return dp [ i ] [ j ] [ k ] ; }

int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) { dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j , k - 1 ) ; return dp [ i ] [ j ] [ k ] ; } if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) { dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j , k - 1 ) ; return dp [ i ] [ j ] [ k ] ; } if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) { dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j , k - 1 ) ; return dp [ i ] [ j ] [ k ] ; } return 0 ; }

28.31
32.17
50.51
44.89
def calculate ( a ) : maximum = max ( a ) frequency = [ 0 for x in range ( maximum + 1 ) ] for i in a : frequency [ i ] += 1 answer = 0 for i in frequency : answer = answer + i * ( i - 1 ) // 2 return answer

static int calculate ( int a [ ] , int n ) { int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int frequency [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }

static int calculate ( int [] a ) { int maximum = max ( a ) ; int [ ] frequency = new int [ maximum + 1 ] ; for ( int i = 0 ; i < maximum ; i ++ ) { answer = answer + i * ( i - 1 ) / 2 ; } return answer ; }

static int calculate ( int a [ ] ) { int maximum = a . length ; int frequency [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < maximum ; i ++ ) { frequency [ i ] += 1 ; answer = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { frequency [ i ] += 1 ; } } return answer ; }

28.64
30.28
45.73
45.56
def countSubarrWithEqualZeroAndOne ( arr , n ) : mp = dict ( ) Sum = 0 count = 0 for i in range ( n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 Sum += arr [ i ] if ( Sum == 0 ) : count += 1 if ( Sum in mp . keys ( ) ) : count += mp [ Sum ] mp [ Sum ] = mp . get ( Sum , 0 ) + 1 return count

static int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( myMap . containsKey ( sum ) ) count += myMap . get ( sum ) ; if ( ! myMap . containsKey ( sum ) ) myMap . put ( sum , 1 ) ; else myMap . put ( sum , myMap . get ( sum ) + 1 ) ; } return count ; }

static int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { int Sum = 0 ; int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = - 1 ; mp [ Sum ] = mp . get ( Sum , 0 ) + 1 ; } } return count ; }

static int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { int Sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; if ( Sum == 0 ) count += 1 ; if ( Sum in mp . keys ( ) ) count += mp [ Sum ] ; mp [ Sum ] = mp . get ( Sum , 0 ) + 1 ; } return count ; }

28.68
30.12
29.01
35.91
def printkthnode ( adj , wt , n , k ) : for i in range ( n ) : adj [ i ] . sort ( ) for i in range ( n ) : if ( len ( adj [ i ] ) >= k ) : print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = "" ) else : print ( "-1" , end = "" )

static void printkthnode ( Vector < pair > adj [ ] , int wt [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) Collections . sort ( adj [ i ] , new Comparator < pair > ( ) { public int compare ( pair p1 , pair p2 ) { return p1 . first - p2 . first ; } } ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) System . out . print ( adj [ i ] . get ( adj [ i ] . size ( ) - k ) . second + " " ) ; else System . out . print ( "-1" ) ; } }

static void printkthnode ( int [ ] [ ] [ ] [ ] , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( len ( adj [ i ] ) >= k ) { print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = "" ) ; } else { print ( "-1" , end = "" ) ; } } }for ( int i =

static void printkthnode ( double [ ] adj , int wt , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . length >= k ) { print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = "" ) ; } else { print ( "-1" , end = "" ) ; } } }

28.75
38.25
46.09
49.92
def countDivisbleby4 ( s ) : n = len ( s ) count = 0 for i in range ( 0 , n , 1 ) : if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : count += 1 for i in range ( 0 , n - 1 , 1 ) : h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) if ( h % 4 == 0 ) : count = count + i + 1 return count

static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++ ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; }

static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '4' ) { count = count + i + 1 ; } else { count = count + i + 1 ; } } return count ; }

static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) ; if ( h % 4 == 0 ) { count = count + i + 1 ; } } return count ; }

28.83
43.09
50.93
51.77
def longOddEvenIncSeq ( arr , n ) : lioes = list ( ) maxLen = 0 for i in range ( n ) : lioes . append ( 1 ) i = 1 for i in range ( n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : lioes [ i ] = lioes [ j ] + 1 for i in range ( n ) : if maxLen < lioes [ i ] : maxLen = lioes [ i ] return maxLen

public static int longOddEvenIncSeq ( int arr [ ] , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }

static int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] > arr [ j ] ) { lioes [ i ] = lioes [ j ] + 1 ; } else { lioes [ i ] = lioes [ j ] + 1 ; } } return maxLen ; }

static int longOddEvenIncSeq ( int arr [ ] , int n ) { int maxLen = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) { lioes [ i ] = lioes [ j ] + 1 ; } } } return maxLen ; }

28.87
36.86
40.4
43.0
def equilibrium ( arr ) : total_sum = sum ( arr ) leftsum = 0 for i , num in enumerate ( arr ) : total_sum -= num if leftsum == total_sum : return i leftsum += num return - 1

int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }

static int equilibrium ( int arr [ ] ) { int leftsum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( leftsum == total_sum ) return i ; } return - 1 ; }

static int equilibrium ( int arr [ ] ) { int total_sum = sum ( arr ) ; int leftsum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { total_sum -= num ; if ( leftsum == total_sum ) return i ; leftsum += num ; } return - 1 ; }

28.87
34.66
21.32
30.36
def lenOfLongestGP ( sett , n ) : if n < 2 : return n if n == 2 : return ( sett [ 1 ] % sett [ 0 ] == 0 ) sett . sort ( ) L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] llgp = 1 for i in range ( 0 , n ) : if sett [ n - 1 ] % sett [ i ] == 0 : L [ i ] [ n - 1 ] = 2 else : L [ i ] [ n - 1 ] = 1 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while i >= 0 and k <= n - 1 : if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : k += 1 elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 if L [ i ] [ j ] > llgp : llgp = L [ i ] [ j ] i -= 1 k + 1 while i >= 0 : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 return llgp

static int lenOfLongestGP ( int set [ ] , int n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) ; } Arrays . sort ( set ) ; int L [ ] [ ] = new int [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) { llgp = L [ i ] [ j ] ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } } return llgp ; }

static int lenOfLongestGP ( int [ ] sett , int n ) { int llgp = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( sett [ i ] % sett [ i ] == 0 ) llgp = L [ i ] [ j ] + 1 ; else L [ i ] [ j ] = L [ i ] [ j ] + 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] + 1 ; if ( L [ i ] [ j ] > llgp ) { if ( L [ i ] % sett [ j ] == 0 ) llgp = L [ i ] [ j ] + 1 ; else L [ i ] [ j ] = L [ j ] [ j ] + 1 ; for ( int j = j - 1 ; j <= n ; j ++ ) { if ( L [ j ] > llgp ) llgp = L [ j ] [ j ] + 1 ; if ( L [ j ] > llgp ) { if ( L [ j ] > llgp ) L [ j ] % sett [ j

int lenOfLongestGP ( int sett [ ] , int n ) { int llgp = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sett [ i ] * sett [ i ] < sett [ j ] * sett [ j ] ) k += 1 ; else if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] ) k += 1 ; else if ( sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] ) if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] ) k += 1 else if ( sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] ) if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] ) k += 1 else if ( sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] ) if ( sett [ i ] * sett [ k ] % sett [ j ] == 0 ) L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 k + 1

28.89
35.1
53.56
56.85
def minRemovalsDP ( arr , n ) : longest_start = - 1 longest_end = 0 for start in range ( n ) : min = sys . maxsize max = - sys . maxsize for end in range ( start , n ) : val = arr [ end ] if ( val < min ) : min = val if ( val > max ) : max = val if ( 2 * min <= max ) : break if ( end - start > longest_end - longest_start or longest_start == - 1 ) : longest_start = start longest_end = end if ( longest_start == - 1 ) : return n return ( n - ( longest_end - longest_start + 1 ) )

static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start || longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; }

static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 ; int longest_end = 0 ; for ( int start = 0 ; start < arr . length ; start ++ ) { int val = arr [ start ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( val > max ) max = val ; if ( val > max ) max = val ; if (

static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 ; int longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int val = arr [ start ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) return n ; if ( longest_start == - 1 ) return n ; if ( longest_end == - 1 ) return n ; if ( longest_start == - 1 ) return n ; if ( longest_end == - 1 ) return n ; return ( n - ( longest_end - longest_start + 1 ) ) ; } }

28.91
31.92
56.01
53.93
def binarySearch ( arr , l , r , x ) : while l <= r : mid = l + ( r - l ) // 2 if arr [ mid ] == x : return mid elif arr [ mid ] < x : l = mid + 1 else : r = mid - 1 return - 1

int binarySearch ( int arr [ ] , int x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }

static int binarySearch ( int arr [ ] , int l , int r , int x ) { for ( int mid = l ; mid <= r ; mid ++ ) { if ( arr [ mid ] == x ) return mid + 1 ; } return - 1 ; } }

int binarySearch ( int arr , int l , int r , int x ) { int mid = l + ( r - l ) / 2 ; while ( l <= r ) { if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) return mid + 1 ; else r = mid - 1 ; } return - 1 ; }

28.92
35.02
56.56
67.68
def fitOrNotFit ( R , r , x , y , rad ) : val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) if ( val + rad <= R and val - rad >= R - r ) : print ( "Fits\n" ) else : print ( "Doesn'tFit" )

static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( "Fits" ) ; else System . out . println ( "Doesn't Fit" ) ; }

static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { int val ; if ( val + rad <= R ) { print ( "Fits\n" ) ; } else { print ( "Doesn'tFit" ) ; } }

static void fitOrNotFit ( int R , int r , float x , float y , float rad ) { int val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) { print ( "Fits\n" ) ; } else { print ( "Doesn'tFit" ) ; } } }

28.93
36.51
53.32
55.39
def printInSortedOrder ( arr , n ) : index = [ 0 ] * n for i in range ( n ) : index [ i ] = i for i in range ( n - 1 ) : min = i for j in range ( i + 1 , n ) : if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : min = j if ( min != i ) : index [ min ] , index [ i ] = index [ i ] , index [ min ] for i in range ( n ) : print ( arr [ index [ i ] ] , end = "" )

static void printInSortedOrder ( String arr [ ] , int n ) { int index [ ] = new int [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) { min = j ; } } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ index [ i ] ] + " " ) ; } }

static void printInSortedOrder ( int arr [ ] , int n ) { int index [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ index [ i ] ] > arr [ index [ j ] ] ) { min = i ; for ( int j = i ; j < n ; j ++ ) { if ( min != i ) index [ i ] , index [ j ] = index [ i ] , index

static void printInSortedOrder ( int arr [ ] , int index [ ] ) { int index [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) { min = j ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) { min = j ; } if ( min != i ) index [ min ] , index [ i ] = index [ i ] , index [ min ] ; } } } } }

28.98
33.74
43.95
51.18
def isPossible ( n , index , modulo , M , arr , dp ) : modulo = ( ( modulo % M ) + M ) % M if ( index == n ) : if ( modulo == 0 ) : return 1 return 0 if ( dp [ index ] [ modulo ] != - 1 ) : return dp [ index ] [ modulo ] placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) res = bool ( placeAdd or placeMinus ) dp [ index ] [ modulo ] = res return res

static int isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) { return 1 ; } return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) { return dp [ index ] [ modulo ] ; } int placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; int res = placeAdd ; dp [ index ] [ modulo ] = res ; return res ; }

static int isPossible ( int n , int index , int M , int [ ] arr , int [ ] dp ) { int res = false ; if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ] ; dp [ index ] [ modulo ] = bool ( placeAdd ) ; dp [ index ] [ modulo ] = bool ( placeMinus ) ; dp [ index ] [ modulo ] = bool ( placeAdd ) ; dp [ index ] [ modulo ] = bool

static int isPossible ( int n , int index , int modulo , int arr [ ] , int [ ] dp ) { boolean placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; res = bool ( placeAdd || placeMinus ) ; dp [ index ] [ modulo ] = res ; return res ; }

29.03
34.13
57.07
54.19
def minJumps ( arr , n ) : jumps = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] == 0 ) : jumps [ i ] = float ( 'inf' ) elif ( arr [ i ] >= n - i - 1 ) : jumps [ i ] = 1 else : min = float ( 'inf' ) for j in range ( i + 1 , n ) : if ( j <= arr [ i ] + i ) : if ( min > jumps [ j ] ) : min = jumps [ j ] if ( min != float ( 'inf' ) ) : jumps [ i ] = min + 1 else : jumps [ i ] = min return jumps [ 0 ]

static int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }

static int minJumps ( int arr [ ] , int n ) { int jumps [ ] = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( jumps [ i ] == 0 ) jumps [ i ] = 1 ; else jumps [ i ] = jumps [ i ] + 1 ; else jumps [ i ] = jumps [ i ] + 1 ; } return jumps [ 0 ] ; }

static int minJumps ( int arr [ ] , int n ) { int jumps [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { jumps [ i ] = float ( 'inf' ) ; } else if ( arr [ i ] >= n - i - 1 ) { jumps [ i ] = 1 ; } else { min = jumps [ i ] ; if ( min > jumps [ j ] ) { min = jumps [ j ] ; if ( min != float ( 'inf' ) ) { jumps [ i ] = min + 1 ; } else jumps [ i ] = min ; } } } return jumps [ 0 ] ; }

29.08
35.47
55.57
58.92
def checkPair ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : sum += arr [ i ] if sum % 2 != 0 : return False sum = sum / 2 for i in range ( n ) : val = sum - arr [ i ] if arr [ i ] not in s : s . add ( arr [ i ] ) if val in s : print ( "Pairelementsare" , arr [ i ] , "and" , int ( val ) )

static boolean checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( "Pair elements are %d and %d\n" , arr [ i ] , val ) ; return true ; } s . add ( arr [ i ] ) ; } return false ; }

static boolean checkPair ( int arr [ ] , int n ) { Set s = new HashSet ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in s ) s . remove ( arr [ i ] ) ; if ( val == 0 ) return false ; s . add ( arr [ i ] ) ; if ( val == 1 ) s . add ( arr [ i ] ) ; if (

static boolean checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; sum = sum / 2 ; for ( int i = 0 ; i < n ; i ++ ) { val = sum - arr [ i ] ; if ( arr [ i ] != 0 ) s . add ( arr [ i ] ) ; if ( val in s ) { print ( "Pairelementsare" , arr [ i ] , "and" , int ( val ) ) ; } } } return true ; }

29.11
44.48
87.21
90.07
def isPrime ( n , i = 2 ) : if ( n <= 2 ) : return True if ( n == 2 ) else False if ( n % i == 0 ) : return False if ( i * i > n ) : return true return isPrime ( n , i + 1 )

static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }

static boolean isPrime ( int n , int i ) { if ( n <= i ) return true if ( n % i == 0 ) return false if ( n % i == 0 ) return true if ( n % i == 0 ) return true if ( n % i == 0 ) return false if ( n % i == 0 ) return true if ( n % i == 0 ) return true if ( n % i == 0 ) return false if ( n % i == 0 ) return

static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return true ; if ( n == 2 ) return true ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }

29.18
44.11
78.42
80.63
def findMod ( a , b ) : if ( a < 0 ) : a = - a if ( b < 0 ) : b = - b mod = a while ( mod >= b ) : mod = mod - b if ( a < 0 ) : return - mod return mod

static double findMod ( double a , double b ) { if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; double mod = a ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }

static int findMod ( int a , int b ) { int mod ; while ( mod >= a ) { mod = mod - a if ( mod < b ) { mod = mod - b if ( a < 0 ) return - mod if ( b < 0 ) return - mod if ( mod >= b ) { mod = mod - b if ( mod >= a ) { mod = mod - a if ( mod >= b ) { mod = mod - b if ( mod < 0

static int findMod ( int a , int b ) { if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; int mod = a ; while ( mod >= b ) { mod = mod - b ; if ( a < 0 ) return - mod ; } return mod ; }

29.23
36.35
41.72
35.51
def printOtherSides ( n ) : if ( n & 1 ) : if ( n == 1 ) : print ( - 1 ) else : b = ( n * n - 1 ) // 2 c = ( n * n + 1 ) // 2 print ( "b=" , b , ",c=" , c ) else : if ( n == 2 ) : print ( - 1 ) else : b = n * n // 4 - 1 c = n * n // 4 + 1 print ( "b=" , b ",c=" , c )

static void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( "-1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( "b = " + b + ", c = " + c ) ; } } else { if ( n == 2 ) System . out . println ( "-1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( "b = " + b + ", c = " + c ) ; } } }

static void printOtherSides ( int n ) { if ( n & 2 ) { if ( n == 1 ) { print ( - 1 ) ; } else { if ( n == 2 ) { print ( - 1 ) ; } else { if ( n == 3 ) { if ( n == 4 ) { print ( - 1 ) ; } else { b = n * n - 1 ; c = n * n + 1 ; } } } else { if ( n ==

static void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) { print ( - 1 ) ; } else { b = ( n * n - 1 ) // 2 c = ( n * n + 1 ) // 2 ; print ( "b=" , b , ",c=" , c ) ; } } else { if ( n == 2 ) { print ( - 1 ) ; } else { b = n * n // 4 - 1 c = n * n // 4 + 1 ; print ( "b=" , b , ",c=" , c ) ; } } }

29.52
58.74
48.97
59.68
def maxProd ( n ) : if ( n == 2 or n == 3 ) : return ( n - 1 ) res = 1 while ( n > 4 ) : n -= 3 res *= 3 return ( n * res )

static int maxProd ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }

static int maxProd ( int n ) { int res = 1 ; while ( n > 2 ) n -= 3 res *= 3 ; while ( n > 3 ) res *= 3 ; while ( n > 4 ) res *= 3 ; while ( n > 2 ) res *= 3 ; while ( n > 3 ) res *= 3 ; while ( n > 2 ) res *= 3 ; while ( n > 3 ) res *= 3 ; } return res ; }

static int maxProd ( int n ) { int res = 1 ; while ( n > 0 ) { n -- ; res *= 3 ; } return ( n * res ) ; }

29.55
34.52
59.36
53.11
def countWaysToJump ( arr , n ) : count_jump = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] >= n - i - 1 ) : count_jump [ i ] += 1 j = i + 1 while ( j < n - 1 and j <= arr [ i ] + i ) : if ( count_jump [ j ] != - 1 ) : count_jump [ i ] += count_jump [ j ] j += 1 if ( count_jump [ i ] == 0 ) : count_jump [ i ] = - 1 for i in range ( n ) : print ( count_jump [ i ] , end = "" )

static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + " " ) ; }

static int countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = [ 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( count_jump [ i ] != - 1 ) count_jump [ i ] += count_jump [ i ] ; j ++ ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = 0 ; for ( int j =

static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] += 1 ; if ( count_jump [ i ] != - 1 ) count_jump [ i ] += count_jump [ i ] ; } if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] += 1 ; } if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) countWaysToJump ( arr [ i ] , n ) ; } return ; }

29.55
40.32
68.19
59.77
def answer ( n ) : dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] if ( n == 1 ) : return 10 for j in range ( 10 ) : dp [ 1 ] [ j ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 10 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] elif ( j == 9 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) sum = 0 for j in range ( 1 , 10 ) : sum = sum + dp [ n ] [ j ] return sum

static long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }

static int answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } return

int answer ( int n ) { int dp [ ] [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } sum = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } sum = sum + dp [ i - 1 ] [ j ] ; } return sum ; }

29.63
33.68
43.66
44.32
def substringConversions ( s , k , b ) : l = len ( s ) for i in range ( l ) : if ( ( i + k ) < l + 1 ) : sub = s [ i : i + k ] sum , counter = 0 , 0 for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) counter += 1 print ( sum , end = "" )

static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " " ) ; } }

static int substringConversions ( String s , int k , int b ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( i + k ) < l ) { for ( int i = 0 ; i < l ; i ++ ) { if ( ( i + k ) < l ) { sum = sum + ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b

static void substringConversions ( String s , int k , int b ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( i + k ) < l + 1 ) { sub = s [ i ] ; sum , counter = 0 , 0 ; for ( i = 0 ; i < len ( sub ) - 1 ; i ++ ) { sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ; counter ++ ; } } } }

29.8
34.41
55.3
53.96
def SieveOfSundaram ( n ) : nNew = int ( ( n - 2 ) / 2 ) marked = [ 0 ] * ( nNew + 1 ) for i in range ( 1 , nNew + 1 ) : j = i while ( ( i + j + 2 * i * j ) <= nNew ) : marked [ i + j + 2 * i * j ] = 1 j += 1 if ( n > 2 ) : print ( 2 , end = "" ) for i in range ( 1 , nNew + 1 ) : if ( marked [ i ] == 0 ) : print ( ( 2 * i + 1 ) , end = "" )

static int SieveOfSundaram ( int n ) { int nNew = ( n - 2 ) / 2 ; boolean marked [ ] = new boolean [ nNew + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + " " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + " " ) ; return - 1 ; }

static void SieveOfSundaram ( int n ) { int nNew = int ( ( n - 2 ) / 2 ) + 1 ) ; int marked [ ] = 0 ; for ( int i = 1 ; i <= nNew ; i ++ ) { if ( marked [ i + 2 * i * j ] == 0 ) marked [ i + 2 * i * j ] = 1 ; else marked [ i + 2 * i * j ] = 1 ; } }

static void SieveOfSundaram ( int n ) { int nNew = int ( n - 2 ) / 2 ; int marked [ ] = new int [ nNew + 1 ] ; for ( int i = 1 ; i < nNew ; i ++ ) { int j = i ; while ( ( i + j + 2 * j ) <= nNew ) marked [ i + j + 2 * j ] = 1 ; j ++ ; } if ( n > 2 ) { print ( 2 , end = "" ) ; for ( int i = 1 ; i < nNew ; i ++ ) { if ( marked [ i ] == 0 ) { print ( ( 2 * i + 1 ) , end = "" ) ; } } } }

29.83
47.17
32.11
41.06
def volumeOfEllipsoid ( r1 , r2 , r3 ) : return 1.33 * math . pi * r1 * r2 * r3

public static float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }

static float volumeOfEllipsoid ( float r1, float r2, float r3)  def volumeOfEllipsoid ( ) { return 1.33 * math . pi * r1 * r2 * r3 * r3

public static double volumeOfEllipsoid ( int r1 , int r2 , int r3 ) { return 1.33 * math . pi * r1 * r2 * r3 ; }

29.83
32.98
30.41
42.88
def SternSequenceFunc ( BrocotSequence , n ) : for i in range ( 1 , n ) : considered_element = BrocotSequence [ i ] precedent = BrocotSequence [ i - 1 ] BrocotSequence . append ( considered_element + precedent ) BrocotSequence . append ( considered_element ) for i in range ( 0 , 15 ) : print ( BrocotSequence [ i ] , end = "" )

static void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence . get ( i ) ; int precedent = BrocotSequence . get ( i - 1 ) ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( BrocotSequence . get ( i ) + " " ) ; }

static void SternSequenceFunc ( int BrocotSequence [ ] , int n ) { int considered_element = BrocotSequence [ 0 ] + precedent ; BrocotSequence . append ( considered_element + precedent ) ; for ( int i = 1 ; i <= n ; i ++ ) { print ( BrocotSequence [ i ] + precedent , end = "" ) ; for ( int i = 1 ; i <= 15 ;

static void SternSequenceFunc ( char [ ] BrocotSequence , int n ) { for ( int i = 1 ; i < n ; i ++ ) { char considered_element = BrocotSequence [ i ] ; precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . append ( considered_element + precedent ) ; BrocotSequence . append ( considered_element ) ; } }

29.85
52.53
20.73
45.89
def mergeTwoHalf ( A , n ) : A . sort ( )

static void mergeTwoHalf ( int [ ] A , int n ) { Arrays . sort ( A ) ; }

static void mergeTwoHalf ( List A , int n ) { for ( int i = 0 ; i < n ; i ++ ) mergeTwoHalf ( A , n ) ; }

; int mergeTwoHalf ( int A , int n ) { A . sort ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { mergeTwoHalf ( A [ i ] , n ) ; } }

29.86
36.07
60.71
62.65
def getMinNumberForPattern ( seq ) : n = len ( seq ) if ( n >= 9 ) : return "-1" result = [ None ] * ( n + 1 ) count = 1 for i in range ( n + 1 ) : if ( i == n or seq [ i ] == 'I' ) : for j in range ( i - 1 , - 2 , - 1 ) : result [ j + 1 ] = int ( '0' + str ( count ) ) count += 1 if ( j >= 0 and seq [ j ] == 'I' ) : break return result

static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return "-1" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == 'I' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ; } } } return new String ( result ) ; }

static int getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; int i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j >= 0 and seq [ j ] == 'I' ) { result [ j + 1 ] = int ( '0' + str ( count ) ) ; count ++ ; if ( j >= 0 ) result [ j + 1 ] = int ( '0' + str

int getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; int [ ] result = new int [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == n || seq [ i ] == 'I' ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { result [ j + 1 ] = int ( '0' + str ( count ) ) ; count ++ ; if ( j >= 0 && seq [ j ] == 'I' ) { break ; } } } } return - 1 ; }

29.88
32.18
53.54
50.71
def countSub ( ss ) : last = [ - 1 for i in range ( MAX_CHAR + 1 ) ] n = len ( ss ) dp = [ - 2 for i in range ( n + 1 ) ] dp [ 0 ] = 1 for i in range ( 1 , n + 1 ) : dp [ i ] = 2 * dp [ i - 1 ] if last [ ord ( ss [ i - 1 ] ) ] != - 1 : dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ] last [ ord ( ss [ i - 1 ] ) ] = i - 1 return dp [ n ]

static int countSub ( String str ) { int [ ] last = new int [ MAX_CHAR ] ; Arrays . fill ( last , - 1 ) ; int n = str . length ( ) ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( int ) str . charAt ( i - 1 ) ] ] ; last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ; } return dp [ n ] ; }

static int countSub ( String ss ) { int last [ ] = new int [ MAX_CHAR + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = dp [ last [ ord ( ss [ i - 1 ] ) ] + dp [ last [ ord ( ss [ i - 1 ] ) ] ] ; last [ ord ( ss [ i - 1 ] ) ] = i - 1 ] ; } return dp [ n ] ; }

static int countSub ( String ss [ ] ) { int last [ ] = new int [ MAX_CHAR + 1 ] ; int [ ] dp = new int [ n + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ ord ( ss [ i - 1 ] ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ] ] ; if ( last [ ord ( ss [ i - 1 ] ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ] ; last [ ord ( ss [ i - 1 ] ) ] = i - 1 ; } return dp [ n ] ; }

29.95
40.05
52.17
43.83
def printDistinct ( Str ) : n = len ( Str ) count = [ 0 for i in range ( MAX_CHAR ) ] index = [ n for i in range ( MAX_CHAR ) ] for i in range ( n ) : x = ord ( Str [ i ] ) count [ x ] += 1 if ( count [ x ] == 1 and x != '' ) : index [ x ] = i if ( count [ x ] == 2 ) : index [ x ] = n index = sorted ( index ) for i in range ( MAX_CHAR ) : if index [ i ] == n : break print ( Str [ index [ i ] ] , end = "" )

static void printDistinct ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR && index [ i ] != n ; i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ; }

static void printDistinct ( String Str ) { int n = Str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ord ( Str [ i ] ) ; count [ x ] += 1 ; if ( count [ x ] == 1 ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = i ; if (

static void printDistinct ( String Str ) { int n = len ( Str ) ; int index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ord ( Str [ i ] ) ; count [ x ] += 1 ; if ( count [ x ] == 1 && x != '' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { x = ord ( Str [ i ] ) ; count [ x ] += 1 ; if ( count [ x ] == 1 && x != '' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } } return ; }

30.03
61.14
100.0
100.0
def countPaths ( n , m ) : if ( n == 0 or m == 0 ) : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )

static int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }

static int countPaths ( int n , int m ) { int countPaths ( int n , int m ) { int countPaths ( int n , int m ) ; return ( countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths ( n , m - 1 ) + countPaths

static int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }

30.12
36.64
40.92
44.94
def findMaxAverage ( arr , n , k ) : if k > n : return - 1 csum = [ 0 ] * n csum [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : csum [ i ] = csum [ i - 1 ] + arr [ i ] max_sum = csum [ k - 1 ] max_end = k - 1 for i in range ( k , n ) : curr_sum = csum [ i ] - csum [ i - k ] if curr_sum > max_sum : max_sum = curr_sum max_end = i return max_end - k + 1

static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }

static int findMaxAverage ( int arr [ ] , int k ) { int max_sum = 0 ; int max_end = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) max_sum = curr_sum ; max_end = i ; } return max_end - k + 1 ; }

static int findMaxAverage ( int arr [ ] , int n , int k ) { int max_sum = csum [ 0 ] * n ; int max_end = k - 1 ; for ( int i = 1 ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - 1 ] ; if ( curr_sum > max_sum ) max_sum = curr_sum ; max_end = i ; } return max_end - k + 1 ; }

30.13
38.51
28.85
45.1
def minSpacePreferLarge ( w , m , n ) : num_m = 0 num_n = 0 rem = w p = 0 q = 0 r = 0 while ( w >= n ) : p = w / m r = w % m if ( r <= rem ) : num_m = p num_n = q rem = r q += 1 w -= n print ( str ( int ( num_m ) ) + "" + str ( num_n ) + "" + str ( rem ) )

static void minSpacePreferLarge ( int wall , int m , int n ) { int num_m = 0 , num_n = 0 , min_empty = wall ; int p = 0 , q = 0 , rem ; while ( wall >= n ) { p = wall / m ; rem = wall % m ; if ( rem <= min_empty ) { num_m = p ; num_n = q ; min_empty = rem ; } q += 1 ; wall = wall - n ; } System . out . println ( num_m + " " + num_n + " " + min_empty ) ; }

static void minSpacePreferLarge ( int w , int m , int n ) { int num_m = 0 ; int num_n = 0 ; int rem = w ; while ( w >= m ) { int p = 0 ; int q = 0 ; int r = 0 ; while ( r <= rem ) { num_m = p num_n = q ; rem = r ; q += 1 ; w -= m ; } } return ; }

static void minSpacePreferLarge ( int w , int m , int n ) { int num_m = 0 ; int num_n = 0 ; int rem = w ; while ( w >= n ) { p = w / m r = w % m ; if ( r <= rem ) num_m = p num_n = q rem = r ; q += 1 ; w -= n ; } }

30.16
31.6
39.75
43.52
def numofArray ( n , m ) : dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] di = [ [ ] for i in range ( MAX ) ] mu = [ [ ] for i in range ( MAX ) ] for i in range ( 1 , m + 1 ) : for j in range ( 2 * i , m + 1 , i ) : di [ j ] . append ( i ) mu [ i ] . append ( j ) di [ i ] . append ( i ) for i in range ( 1 , m + 1 ) : dp [ 1 ] [ i ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 1 , m + 1 ) : dp [ i ] [ j ] = 0 for x in di [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] for x in mu [ j ] : dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ans = 0 for i in range ( 1 , m + 1 ) : ans += dp [ n ] [ i ] di [ i ] . clear ( ) mu [ i ] . clear ( ) return ans

static int numofArray ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > [ ] mu = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new Vector < > ( ) ; mu [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }

static int numofArray ( int n , int m ) { int [ ] dp = new int [ n + 1 ] [ m + 1 ] ; int [ ] di = new int [ n + 1 ] [ m + 1 ] ; int [ ] mu = new int [ n + 1 ] [ m + 1 ] ; int [ ] di = new int [ n + 1 ] [ m + 1 ] ; int [ ] mu [ ] = new int [ n + 1 ] [ ] ; for ( i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int i = 0 ; j < m ; j ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int i = di [ j ] ; } ; for ( int j = 0 ; j < m ; j ++ ) { for ( int i = 0 ; j < m ; j ++ ) { for ( int i = i ; j ++ ) { for ( int x = di [ j ] ;

static int numofArray ( int n , int m ) { int dp [ ] [ ] = new int [ MAX ] ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 for ( int x = 0 ; x < dp [ i ] [ j ] ; x ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } for ( int x = 0 ; x < dp [ i ] [ j ] ; x ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } for ( int i = 1 ; i <= m ; i ++ ) { dp [ i ] [ j ] = 0 for ( int x = 0 ; x < dp [ i ] [ j ] ; x ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } for ( int x = 0 ; x < dp [ i ] [ j ] ; x ++ ) { dp [ i ] [ j ] += dp [ i - 1 ]

30.23
32.12
54.37
48.66
def countPattern ( s ) : length = len ( s ) oneSeen = False count = 0 for i in range ( length ) : if ( s [ i ] == '1' and oneSeen ) : if ( s [ i - 1 ] == '0' ) : count += 1 if ( s [ i ] == '1' and oneSeen == 0 ) : oneSeen = True if ( s [ i ] != '0' and s [ i ] != '1' ) : oneSeen = False return count

static int countPattern ( String str ) { int len = str . length ( ) ; boolean oneSeen = false ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ; if ( getChar == '1' && oneSeen == true ) { if ( str . charAt ( i - 1 ) == '0' ) count ++ ; } if ( getChar == '1' && oneSeen == false ) oneSeen = true ; if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false ; } return count ; }

static int countPattern ( String s ) { int length = s . length ( ) ; boolean oneSeen = false ; for ( int i = 0 ; i < length ; i ++ ) { if ( s [ i ] == '1' ) { oneSeen = true if ( s [ i - 1 ] == '0' ) count += 1 if ( s [ i ] == '1' and oneSeen == 0 ) count += 1 if ( s [ i ] != '

static int countPattern ( String s ) { int length = s . length ( ) ; boolean oneSeen = false ; int count = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( s [ i ] == '1' && oneSeen ) { if ( s [ i - 1 ] == '0' ) count ++ ; if ( s [ i ] == '1' && oneSeen == 0 ) oneSeen = true ; if ( s [ i ] != '0' && s [ i ] != '1' ) oneSeen = false ; } } return count ; }

30.31
39.11
26.26
30.59
def findArea ( a , b , c ) : if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : print ( 'Notavalidtrianglen' ) return s = ( a + b + c ) / 2 area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 print ( 'Areaofatraingleis%f' % area )

static float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { System . out . println ( "Not a valid triangle" ) ; System . exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }

static void findArea ( int a , int b , int c ) { int area = 0 ; if ( a + b <= c ) area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 ; else area = ( s * s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 ; return ; }  static void findArea ( int a , int

static void findArea ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 ; print ( "Areaofatraingleis%f" % area ) ; }

30.39
38.92
57.29
56.17
def minimumSquare ( m , n ) : vertical_min = 10000000000 horizontal_min = 10000000000 if m == n : return 1 if dp [ m ] [ n ] != 0 : return dp [ m ] [ n ] for i in range ( 1 , m // 2 + 1 ) : horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) for j in range ( 1 , n // 2 + 1 ) : vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) return dp [ m ] [ n ]

static int minimumSquare ( int m , int n ) { int vertical_min = Integer . MAX_VALUE ; int horizontal_min = Integer . MAX_VALUE ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] != 0 ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = Math . min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = Math . min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = Math . min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; }

static int minimumSquare ( int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { vertical_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , vertical_min ) ; dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) ; } return 1 ; }

static int minimumSquare ( int m , int n ) { int vertical_min = 10000000000 ; int horizontal_min = 10000000000 ; for ( int i = 1 ; i < m ; i ++ ) { horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; for ( int j = 1 ; j < n ; j ++ ) { vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) ; } return dp [ m ] [ n ] ; }

30.46
38.73
33.05
39.21
def areElementsContiguous ( arr , n ) : max1 = max ( arr ) min1 = min ( arr ) m = max1 - min1 + 1 if ( m > n ) : return False visited = [ 0 ] * m for i in range ( 0 , n ) : visited [ arr [ i ] - min1 ] = True for i in range ( 0 , m ) : if ( visited [ i ] == False ) : return False return True

static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }

static boolean areElementsContiguous ( int arr [ ] , int n ) { int max1 = arr . length ; int min1 = arr [ 0 ] - min1 ; int m = arr . length ; if ( m > n ) return false ; visited [ arr [ i ] - min1 ] = true ; for ( int i = 0 ; i < m ; i ++ ) { if ( visited [ arr [ i ] - min1 ] == true ) return false ;

static boolean areElementsContiguous ( int arr [ ] , int n ) { int max1 = max ( arr ) ; int min1 = min ( arr ) ; int m = max1 - min1 + 1 ; if ( m > n ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min1 ] == true ) visited [ arr [ i ] - min1 ] = true ; } return true ; }

30.51
42.76
55.28
55.44
def solve ( X , Y , l , r , k , dp ) : if k == 0 : return 0 if l < 0 or r < 0 : return 1000000000 if dp [ l ] [ r ] [ k ] != - 1 : return dp [ l ] [ r ] [ k ] cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) ) dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] ) return dp [ l ] [ r ] [ k ]

static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) { if ( k == 0 ) { return 0 ; } if ( l < 0 | r < 0 ) { return ( int ) 1e9 ; } if ( dp [ l ] [ r ] [ k ] != - 1 ) { return dp [ l ] [ r ] [ k ] ; } int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ; return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ; }

static int solve ( int X [ ] , int r , int k ) { int dp [ ] [ ] = new int [ l ] [ r ] [ k ] ; if ( dp [ l ] [ r ] [ k ] == - 1 ) return dp [ l ] [ r ] [ k ] ; dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) ] ) ; }

int solve ( X , Y , int l , int r , int k , int dp [ ] [ ] ) { int cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) ) ; dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) ] ) ; return dp [ l ] [ r ] [ k ] ; }

30.59
40.99
65.65
66.04
def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) return math . floor ( x ) + 1

static long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; }

static int findDigits ( int n ) { int x = ( n * math . log10 ( n / math . e ) + math . log10 ( n / math . e ) / 2.0 ) + math . log10 ( n / math . e ) / 2.0 ) + math . floor ( x ) + 1 ; return 0 ; }  def findDigits ( int n ) { int x = ( n * math . log10 ( n / math .

static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; int x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; return math . floor ( x ) + 1 ; }

30.6
33.06
36.83
41.33
def findDivision ( str , a , b ) : lenn = len ( str ) lr = [ 0 ] * ( lenn + 1 ) lr [ 0 ] = ( int ( str [ 0 ] ) ) % a for i in range ( 1 , lenn ) : lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str [ i ] ) ) % a rl = [ 0 ] * ( lenn + 1 ) rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b power10 = 10 for i in range ( lenn - 2 , - 1 , - 1 ) : rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b power10 = ( power10 * 10 ) % b for i in range ( 0 , lenn - 1 ) : if ( lr [ i ] != 0 ) : continue if ( rl [ i + 1 ] == 0 ) : print ( "YES" ) for k in range ( 0 , i + 1 ) : print ( str [ k ] , end = "" ) print ( "," , end = "" ) for i in range ( i + 1 , lenn ) : print ( str [ k ] , end = "" ) return print ( "NO" )

static void findDivision ( String str , int a , int b ) { int len = str . length ( ) ; int [ ] lr = new int [ len + 1 ] ; lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a ; for ( int i = 1 ; i < len ; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str . charAt ( i ) - ( int ) '0' ) ) % a ; int [ ] rl = new int [ len + 1 ] ; rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int ) '0' ) % b ; int power10 = 10 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i ) - ( int ) '0' ) * power10 ) % b ; power10 = ( power10 * 10 ) % b ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { System . out . println ( "YES" ) ; for ( int k = 0 ; k <= i ; k ++ ) System . out . print ( str . charAt ( k ) ) ; System . out . print ( ", " ) ; for ( int k = i + 1 ; k < len ; k ++ ) System . out . print ( str . charAt ( k ) ) ; return ; } } System . out . println ( "NO" ) ; }

static void findDivision ( String str , int a , int b ) { int lenn = str . length ( ) ; int lr [ ] = ( int ( str [ 0 ] ) * a + int ( str [ i ] ) * a ) % a ; int rl [ ] = ( int ( str [ i ] ) * a + int ( str [ i ] ) * b ) % a ; int power10 = ( power10 * 10 ) % b ; for ( i = 0 ; i < lenn ; i ++ ) { if ( lr [ i ] != 0 ) { for ( int i = 0 ; i < lenn - 1 ] * 10 ) % a + int ( str [ i ] ) * a ) % b ; } } int rl [ ] = int ( str [ i ] ) * a + int ( str [ i ] ) % b ) % b ; int power10 = ( power10 * 10 ) % b ; for ( int i = 0 ; i < lenn ; i ++ ) { if ( rl [ i ] == 0 ) { if ( rl [ i ] == 0 ) { for ( i < lenn ; i ++ ) ; } } ; } return ; } return ; }

static void findDivision ( String str , int a , int b ) { int lenn = len ( str ) ; int [ ] lr = new int [ lenn + 1 ] ; int [ ] rl = new int [ lenn + 1 ] ; for ( int i = 0 ; i < lenn ; i ++ ) { lr [ i ] = ( ( lr [ i ] * 10 ) % a + int ( str [ i ] ) * power10 ) % b ; rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b ; } for ( int i = 0 ; i < lenn ; i ++ ) { if ( lr [ i ] != 0 ) { continue ; } if ( rl [ i + 1 ] == 0 ) { print ( "YES" ) for ( int k = 0 ; k < str . length ( ) ; k ++ ) { if ( str [ k ] == str [ k ] ) { print ( str [ k ] , end = "" ) ; print ( "," , end = "" ) for ( i in range ( i + 1 , lenn ) ) { print ( str [ k ] , end = "" ) ; }

30.6
40.22
65.53
74.29
def negCyclefloydWarshall ( graph ) : dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ] for i in range ( V ) : for j in range ( V ) : dist [ i ] [ j ] = graph [ i ] [ j ] for k in range ( V ) : for i in range ( V ) : for j in range ( V ) : if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] for i in range ( V ) : if ( dist [ i ] [ i ] < 0 ) : return True return False

static boolean negCyclefloydWarshall ( int graph [ ] [ ] ) { int dist [ ] [ ] = new int [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( i = 0 ; i < V ; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; }

static boolean negCyclefloydWarshall ( int V , int [ ] graph [ ] [ ] ) { int [ ] dist = new int [ V + 1 ] [ ] ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ j ] < 0 ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } return false ; }

static boolean negCyclefloydWarshall ( int graph [ ] [ ] ) { int dist [ ] [ ] = new int [ V ] [ ] ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( int k = 0 ; k < V ; k ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { dist [ i ] [ j ] = graph [ i ] [ j ] ; if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } } return true ; }

30.64
39.53
25.25
31.06
def moveSpaceInFront ( s ) : i = len ( s ) - 1 for j in range ( i , - 1 , - 1 ) : if ( s [ j ] != '' ) : s = s [ : i ] + s [ j ] + s [ i + 1 : ] i -= 1 while ( i >= 0 ) : s = s [ : i ] + '' + s [ i + 1 : ] i -= 1 return s

static void moveSpaceInFront ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ' ; }

static String moveSpaceInFront ( String s ) { int i = s . length ( ) - 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( s [ j ] != ' ' ) s = s [ : i ] + ' ' + s [ i + 1 : ] ; i -= 1 ; while ( i >= 0 ) { s = s [ : i ] + ' ' + s [ i + 1 : ] ; i -=

static String moveSpaceInFront ( String s ) { int i = s . length ( ) - 1 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] != '' ) s = s [ : i ] + s [ j ] + s [ i + 1 ] ; i -= 1 ; while ( i >= 0 ) s = s [ : i ] + '' + s [ i + 1 : ] i -= 1 ; } return s ; }

30.64
32.41
31.94
32.07
def removeConsecutiveSame ( v ) : n = len ( v ) i = 0 while ( i < n - 1 ) : if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) : v = v [ : i ] v = v [ : i ] if ( i > 0 ) : i -= 1 n = n - 2 else : i += 1 return len ( v [ : i - 1 ] )

static int removeConsecutiveSame ( Vector < String > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v . get ( i ) . equals ( v . get ( i + 1 ) ) ) { v . remove ( i ) ; v . remove ( i ) ; if ( i > 0 ) i -- ; n = n - 2 ; } else i ++ ; } return v . size ( ) ; }

static int removeConsecutiveSame ( int [ ] v ) { int i = 0 ; int n = v . length ; while ( i < n ) { if ( v [ i ] == v [ i + 1 ] ) { v = v [ : i ] ; if ( i > 0 ) { i -= 1 n = n - 2 } else : i += 1 ; } } return 0 ; } }

static int removeConsecutiveSame ( char [ ] v , int i ) { int n = len ( v ) ; while ( i < n ) { if ( v [ i ] == v [ i + 1 ] ) v = v [ : i ] ; v = v [ : i ] ; if ( i > 0 ) i -= 1 ; n = n - 2 ; else i += 1 ; } return len ( v [ : i - 1 ] ) ; }

30.73
34.65
56.55
50.75
def areKAnagrams ( str1 , str2 , k ) : n = len ( str1 ) if ( len ( str2 ) != n ) : return False hash_str1 = [ 0 ] * ( MAX_CHAR ) for i in range ( n ) : hash_str1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 count = 0 for i in range ( n ) : if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] > 0 ) : hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] -= 1 else : count += 1 if ( count > k ) : return False return True

static boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 . charAt ( i ) - 'a' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 . charAt ( i ) - 'a' ] > 0 ) hash_str1 [ str2 . charAt ( i ) - 'a' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }

static boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; int hash_str1 [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] > 0 ) { hash_str1 [ ord ( str2 [

static boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; int hash_str1 = [ 0 ] * ( MAX_CHAR ) ; for ( int i = 0 ; i < n ; i ++ ) { hash_str1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 ; count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] > 0 ) { hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] -= 1 ; count ++ ; } } if ( count > k ) return false ; return true ; }

30.85
33.6
56.1
51.82
def jumpSearch ( arr , x , n ) : step = math . sqrt ( n ) prev = 0 while arr [ int ( min ( step , n ) - 1 ) ] < x : prev = step step += math . sqrt ( n ) if prev >= n : return - 1 while arr [ int ( prev ) ] < x : prev += 1 if prev == min ( step , n ) : return - 1 if arr [ int ( prev ) ] == x : return prev return - 1

public static int jumpSearch ( int [ ] arr , int x ) { int n = arr . length ; int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ; int prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += ( int ) Math . floor ( Math . sqrt ( n ) ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }

static int jumpSearch ( int arr [ ] , int x , int n ) { int prev = 0 ; int step = math . sqrt ( n ) ; while ( arr [ int ( prev ) ] > x ) { prev = step step += math . sqrt ( n ) ; if ( prev == n ) return - 1 ; if ( arr [ int ( prev ) ] == x ) return prev ; } return - 1 ; }

static int jumpSearch ( int arr [ ] , int x , int n ) { int step = math . sqrt ( n ) ; int prev = 0 ; while ( arr [ int ( step ) ] < x ) { prev = step ; step += math . sqrt ( n ) ; if ( prev >= n ) return - 1 ; while ( arr [ int ( prev ) ] < x ) prev ++ ; if ( prev == min ( step , n ) ) return prev ; if ( prev == min ( step , n ) ) return prev ; if ( arr [ int ( prev ) ] == x ) return prev ; } return - 1 ; }

30.93
37.24
62.96
57.91
def lis ( arr ) : n = len ( arr ) lis = [ 1 ] * n for i in range ( 1 , n ) : for j in range ( 0 , i ) : if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : lis [ i ] = lis [ j ] + 1 maximum = 0 for i in range ( n ) : maximum = max ( maximum , lis [ i ] ) return maximum

static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }

static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] ) { lis [ i ] = lis [ j ] + 1 ; } } return maximum ; }

static int lis ( int arr [ ] , int lis [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) maximum = max ( maximum , lis [ i ] ) ; } } return maximum ; }

30.93
37.24
62.96
57.91
def lis ( arr ) : n = len ( arr ) lis = [ 1 ] * n for i in range ( 1 , n ) : for j in range ( 0 , i ) : if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : lis [ i ] = lis [ j ] + 1 maximum = 0 for i in range ( n ) : maximum = max ( maximum , lis [ i ] ) return maximum

static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }

static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] ) { lis [ i ] = lis [ j ] + 1 ; } } return maximum ; }

static int lis ( int arr [ ] , int lis [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) maximum = max ( maximum , lis [ i ] ) ; } } return maximum ; }

30.94
33.51
47.88
41.87
def sortByPattern ( str , pat ) : global MAX_CHAR count = [ 0 ] * MAX_CHAR for i in range ( 0 , len ( str ) ) : count [ ord ( str [ i ] ) - 97 ] += 1 index = 0 str = "" for i in range ( 0 , len ( pat ) ) : j = 0 while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] ) : str += pat [ i ] j = j + 1 index += 1 return str

static void sortByPattern ( char [ ] str , char [ ] pat ) { int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ; i ++ ) { count [ str [ i ] - 'a' ] ++ ; } int index = 0 ; for ( int i = 0 ; i < pat . length ; i ++ ) { for ( int j = 0 ; j < count [ pat [ i ] - 'a' ] ; j ++ ) { str [ index ++ ] = pat [ i ] ; } } }

static String sortByPattern ( String str , String pat ) { int index = 0 ; int count = [ 0 ] * MAX_CHAR ; for ( int i = 0 ; i < len ( str ) ; i ++ ) { int j = 0 ; while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] ) str += pat [ i ] ; j = j + 1 ; index ++ ; } return str ; }

private static String sortByPattern ( String str , String pat ) { int index = 0 ; int str = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < count [ ord ( str [ i ] ) - 97 ] ; j ++ ) { str += pat [ i ] ; if ( j < count [ ord ( str [ i ] ) - ord ( 'a' ) ] ) str += pat [ i ] ; } index ++ ; } return str ; }

31.1
30.53
38.59
51.32
def isMultipleOf3 ( n ) : odd_count = 0 even_count = 0 if ( n < 0 ) : n = - n if ( n == 0 ) : return 1 if ( n == 1 ) : return 0 while ( n ) : if ( n & 1 ) : odd_count += 1 if ( n & 2 ) : even_count += 1 n = n >> 2 return isMultipleOf3 ( abs ( odd_count - even_count ) )

static int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) odd_count ++ ; if ( ( n & 2 ) != 0 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ; }

static int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; while ( n ) { if ( n & 3 ) odd_count += 1 if ( n & 4 ) even_count += 1 if ( n & 8 ) even_count += 1 if ( n & 16 ) odd_count += 1 if ( n & 4 ) even_count += 1 if ( n & 8 ) even_count += 1 if (

static int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; while ( n > 0 ) { if ( n & 1 ) { odd_count ++ ; if ( n & 2 ) { even_count ++ ; } } } return isMultipleOf3 ( abs ( odd_count - even_count ) ) ; }

31.14
39.11
59.87
77.0
def getTotalNumberOfSequences ( m , n ) : if m < n : return 0 if n == 0 : return 1 res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) return res

static int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }

static int getTotalNumberOfSequences ( int m , int n ) { int res = 0 ; if ( m == 0 ) res = 1 ; return res ; } return 0 ; }

public static int getTotalNumberOfSequences ( int m , int n ) { int res = 0 ; if ( m < n ) return res ; if ( m == 0 ) return 0 ; if ( n == 0 ) return 1 ; res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) ; return res ; }

31.15
41.97
66.76
66.46
def maxProfit ( price , n ) : profit = [ 0 ] * n max_price = price [ n - 1 ] for i in range ( n - 2 , 0 , - 1 ) : if price [ i ] > max_price : max_price = price [ i ] profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) min_price = price [ 0 ] for i in range ( 1 , n ) : if price [ i ] < min_price : min_price = price [ i ] profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) result = profit [ n - 1 ] return result

static int maxProfit ( int price [ ] , int n ) { int profit [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) profit [ i ] = 0 ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; return result ; }

static int maxProfit ( int price [ ] , int n ) { int result = 0 ; int profit [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } return result ; }

int maxProfit ( int price [ ] , int n ) { int profit [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( price [ i ] > profit [ i ] ) profit [ i ] = max ( profit [ i + 1 ] , profit [ i ] + ( price [ i ] - profit [ i ] ) ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ] ; profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } return result ; }

31.28
52.7
39.1
65.34
def isOverflow ( a , b ) : if ( a == 0 or b == 0 ) : return False result = a * b if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : result = 0 if ( a == ( result // b ) ) : print ( result // b ) return False else : return True

static Boolean isOverflow ( long a , long b ) { if ( a == 0 || b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }

static boolean isOverflow ( int a , int b ) { int result ; if ( a == 0 ) return false ; if ( b == 0 ) return false ; result = a * b ; if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) { result = 0 ; if ( result == 0 ) return false ; if ( a == ( result // b ) ) return false ; if

public static boolean isOverflow ( int a , int b ) { if ( a == 0 || b == 0 ) return false ; int result = a * b ; if ( result >= 9223372036854775807 || result <= - 9223372036854775808 ) result = 0 ; if ( result >= 9223372036854775807 || result <= - 9223372036854775808 ) result = 0 ; if ( a == ( result // b ) ) return false ; return true ; }

31.29
31.46
58.14
52.05
def findArea ( a ) : area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4 return area

static float findArea ( float a ) { float area ; area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4 ; return area ; }

static int findArea ( int a ) { int area = 0 ; for ( int i = 0 ; i < a ; i ++ ) { area += ( sqrt ( 5 ) * a * a ) / ( sqrt ( 5 ) ) ; } return area ; }

static int findArea ( int a ) { int area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) * a * a ) / 4 ; return area ; }

31.3
35.66
37.23
38.58
def checkCount ( arr , n , k ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 for key , values in mp . items ( ) : if values > 2 * k : return False return True

static boolean checkCount ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , 0 ) ; hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; } for ( Map . Entry x : hash . entrySet ( ) ) if ( ( int ) x . getValue ( ) > 2 * k ) return false ; return true ; }

static boolean checkCount ( int arr [ ] , int k ) { int mp = defaultdict ( lambda : 0 ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( mp [ arr [ i ] ] > k ) return false ; for ( int key = 0 ; key < arr . length ; key ++ ) { if ( values > k ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if

static boolean checkCount ( int arr [ ] , int n , int k ) { HashMap < String , Integer > mp = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; if ( mp [ arr [ i ] ] > 2 * k ) return false ; } return true ; }

31.36
34.23
54.82
58.41
def prevPermutation ( str ) : n = len ( str ) - 1 i = n while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : i -= 1 if ( i <= 0 ) : return False j = i - 1 while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : j += 1 str = list ( str ) temp = str [ i - 1 ] str [ i - 1 ] = str [ j ] str [ j ] = temp str = '' . join ( str ) str [ : : - 1 ] return True , str

static boolean prevPermutation ( char [ ] str ) { int n = str . length - 1 ; int i = n ; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) { i -- ; } if ( i <= 0 ) { return false ; } int j = i - 1 ; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) { j ++ ; } swap ( str , i - 1 , j ) ; StringBuilder sb = new StringBuilder ( String . valueOf ( str ) ) ; sb . reverse ( ) ; str = sb . toString ( ) . toCharArray ( ) ; return true ; }

static boolean prevPermutation ( String str ) { int n = str . length ( ) - 1 ; int i = str . length ( ) - 1 ; int j = str . length ( ) - 1 ; while ( i > 0 and str [ i - 1 ] <= str [ j ] ) { j -= 1 ; if ( j <= 0 ) return false ; str [ i - 1 ] = str [ j ] ; str [ j ] = str [ j ] ; }

static boolean prevPermutation ( String str ) { int n = str . length ( ) - 1 ; int i = n ; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) { i -- ; if ( i <= 0 ) return false ; j = i - 1 ; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++ ; str = list ( str ) ; temp = str [ i - 1 ] str [ i - 1 ] str [ i - 1 ] = str [ j ] str [ j ] = temp ; str [ i - 1 ] = str [ j ] str [ j ] = temp ; } return true , str ; }

31.37
36.08
57.04
56.15
def calculateSum ( n ) : if ( n <= 0 ) : return 0 fibo = [ 0 ] * ( n + 1 ) fibo [ 1 ] = 1 sm = fibo [ 0 ] + fibo [ 1 ] for i in range ( 2 , n + 1 ) : fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] sm = sm + fibo [ i ] return sm

static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }

static int calculateSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; } return sm ; }

static int calculateSum ( int n ) { int sm = 0 ; int [ ] fibo = new int [ n + 1 ] ; int [ ] fibo = new int [ n + 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sm = sm + fibo [ i ] ; } return sm ; }

31.38
42.98
43.82
56.28
def isAnBn ( str ) : n = len ( str ) for i in range ( n ) : if ( str [ i ] != 'a' ) : break if ( i * 2 != n ) : return False for j in range ( i , n ) : if ( str [ j ] != 'b' ) : return False return True

public static boolean isAnBn ( String s ) { int l = s . length ( ) ; if ( l % 2 == 1 ) { return false ; } int i = 0 ; int j = l - 1 ; while ( i < j ) { if ( s . charAt ( i ) != 'a' || s . charAt ( j ) != 'b' ) { return false ; } i ++ ; j -- ; } return true ; }

static boolean isAnBn ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != 'a' ) return false ; for ( int j = i ; j < n ; j ++ ) { if ( str [ j ] != 'b' ) return false ; } } return true ; }

static boolean isAnBn ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != 'a' ) return false ; for ( int j = 0 ; j < n ; j ++ ) { if ( str . charAt ( j ) != 'b' ) return false ; } } return true ; }

31.44
35.73
52.25
46.14
def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 1 ) : s = set ( ) curr_sum = sum - A [ i ] for j in range ( i + 1 , arr_size ) : if ( curr_sum - A [ j ] ) in s : print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , curr_sum - A [ j ] ) return True s . add ( A [ j ] ) return False

static boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int curr_sum = sum - A [ i ] ; for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( s . contains ( curr_sum - A [ j ] ) && curr_sum - A [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( "Triplet is %d, %d, %d" , A [ i ] , A [ j ] , curr_sum - A [ j ] ) ; return true ; } s . add ( A [ j ] ) ; } } return false ; }

static boolean find3Numbers ( int [ ] A , int arr_size , int sum ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr_size ; i ++ ) { for ( int j = i ; j < arr_size ; j ++ ) if ( curr_sum - A [ j ] ) in s ) return true ; s . add ( A [ j ] ) ; } return false ;

static boolean find3Numbers ( int A , int arr_size , int sum ) { int i = 0 ; int arr_size = A . length ; for ( int j = 0 ; j < arr_size ; j ++ ) { int curr_sum = sum - A [ j ] ; for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( curr_sum - A [ j ] ) { if ( curr_sum - A [ j ] ) { if ( curr_sum - A [ j ] ) { if ( curr_sum - A [ j ] ) { print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , curr_sum - A [ j ] ) ; return true ; } } } } } return false ; }

31.48
32.37
53.2
50.17
def patternCount ( str ) : last = str [ 0 ] i = 1 counter = 0 while ( i < len ( str ) ) : if ( str [ i ] == '0' and last == '1' ) : while ( str [ i ] == '0' ) : i += 1 if ( str [ i ] == '1' ) : counter += 1 last = str [ i ] i += 1 return counter

static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }

static int patternCount ( String str ) { int i = 1 ; int counter = 0 ; while ( i < len ( str ) ) { while ( str [ i ] == '0' ) { counter ++ ; last = str [ i ] i += 1 if ( str [ i ] == '1' ) { counter ++ ; } } } return counter ; }

static int patternCount ( String str ) { int last = str . length ( ) ; int counter = 0 ; while ( i < len ( str ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; last = str [ i ] i ++ ; } } return counter ; }

31.51
37.42
35.83
40.45
def SectorArea ( radius , angle ) : pi = 22 / 7 if angle >= 360 : print ( "Anglenotpossible" ) return else : sector = ( pi * radius ** 2 ) * ( angle / 360 ) print ( sector ) return

static void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( "Angle not possible" ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }

static void SectorArea ( int radius , int angle ) { int pi = 3 / 7 ; if ( radius <= 0 ) return ; else sector = ( pi * radius ** 2 ) * ( angle / 360 ) ; else sector = ( pi * radius ** 2 ) * ( radius / 360 ) ; print ( sector ) ; } }

static void SectorArea ( int radius , int angle ) { int pi = 22 / 7 ; if ( angle >= 360 ) { sector = ( pi * radius ** 2 ) * ( angle / 360 ) ; } else { sector = ( pi * radius ** 2 ) * ( angle / 360 ) ; } }

31.56
37.58
48.29
48.07
def printUnion ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and j < n : if arr1 [ i ] < arr2 [ j ] : print ( arr1 [ i ] ) i += 1 elif arr2 [ j ] < arr1 [ i ] : print ( arr2 [ j ] ) j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1 while i < m : print ( arr1 [ i ] ) i += 1 while j < n : print ( arr2 [ j ] ) j += 1

static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " " ) ; else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " " ) ; else { System . out . print ( arr2 [ j ++ ] + " " ) ; i ++ ; } } while ( i < m ) System . out . print ( arr1 [ i ++ ] + " " ) ; while ( j < n ) System . out . print ( arr2 [ j ++ ] + " " ) ; return 0 ; }

static void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i , j ; i = 0 ; j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i += 1 ; else print ( arr1 [ i ] ) j += 1 ; else print ( arr2 [ j ] ) j += 1 ; while ( j < n ) {

static void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i += 1 ; else if ( arr2 [ j ] < arr1 [ i ] ) i += 1 ; else if ( arr1 [ i ] > arr2 [ j ] ) i += 1 ; else if ( arr2 [ j ] > arr1 [ i ] ) i += 1 ; else if ( arr2 [ j ] < arr1 [ i ] ) i += 1 ; else if ( arr2 [ j ] < arr1 [ i ] ) i += 1 ; else if ( arr2 [ j ] < arr1 [ i ] ) i += 1 ; else print ( arr2 [ j ] ) ; } }

31.56
36.13
49.62
44.48
def findTriplets ( arr , n ) : found = True for i in range ( 0 , n - 2 ) : for j in range ( i + 1 , n - 1 ) : for k in range ( j + 1 , n ) : if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : print ( arr [ i ] , arr [ j ] , arr [ k ] ) found = True if ( found == False ) : print ( "notexist" )

static void findTriplets ( int [ ] arr , int n ) { boolean found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { System . out . print ( arr [ i ] ) ; System . out . print ( " " ) ; System . out . print ( arr [ j ] ) ; System . out . print ( " " ) ; System . out . print ( arr [ k ] ) ; System . out . print ( "\n" ) ; found = true ; } } } } if ( found == false ) System . out . println ( " not exist " ) ; }

static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { if ( found == false ) { print ( arr [ i ] , arr [ j ] , arr [ k ] ) ; found = true

static void findTriplets ( int arr [ ] , int n ) { boolean found = true ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { for ( int k = 0 ; k < arr . length ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { found = true ; break ; } } if ( found == true ) { print ( arr [ i ] , arr [ j ] , arr [ k ] ) ; found = true ; } } } } return ; }

31.71
35.39
49.62
54.16
def shufleArray ( a , f , l ) : if ( l > f ) : return if ( l - f == 1 ) : return mid = int ( ( f + l ) / 2 ) temp = mid + 1 mmid = int ( ( f + mid ) / 2 ) for i in range ( mmid + 1 , mid + 1 ) : ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) temp += 1 shufleArray ( a , f , mid ) shufleArray ( a , mid + 1 , l )

static void shufleArray ( int a [ ] , int f , int l ) { if ( l > f ) return ; if ( l - f == 1 ) return ; int mid = ( f + l ) / 2 ; int temp = mid + 1 ; int mmid = ( f + mid ) / 2 ; for ( int i = mmid + 1 ; i <= mid ; i ++ ) { int temp1 = a [ i ] ; a [ i ] = a [ temp ] ; a [ temp ++ ] = temp1 ; } shufleArray ( a , f , mid ) ; shufleArray ( a , mid + 1 , l ) ; }

static void shufleArray ( int [ ] a , int f , int l ) { int temp = mid ; int mmid = int ( ( f + mid ) / 2 ) ; for ( int i = 0 ; i < mmid ; i ++ ) { ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) + ( a [ temp ] , a [ i ] ) + ( a [ temp ] , a

static void shufleArray ( int [ ] a , int f , int l ) { int mid = int ( ( f + l ) / 2 ) ; int temp = mid + 1 ; int mmid = int ( ( f + mid ) / 2 ) ; for ( int i = 0 ; i < mid ; i ++ ) { ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) ; temp ++ ; } shufleArray ( a , f , mid ) ; }

31.73
35.9
54.75
53.17
def printPairs ( arr , n ) : v = [ ] for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : v . append ( abs ( arr [ i ] ) ) if ( len ( v ) == 0 ) : return ; v . sort ( ) for i in range ( len ( v ) ) : print ( - v [ i ] , "" , v [ i ] , end = "" )

public static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " " + v . get ( i ) ) ; }

static void printPairs ( int arr [ ] , int n ) { int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ j ] ) v . append ( arr [ i ] ) ; for ( int j = i + 1 , n ) { if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) { v . append ( 0

static void printPairs ( int arr [ ] , int n ) { int v [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . append ( Math . abs ( arr [ i ] ) ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . append ( Math . abs ( arr [ i ] ) ) ; } } }

31.76
37.94
38.02
43.08
def minOperation ( arr ) : ans = 0 for i in range ( N - 1 , - 1 , - 1 ) : for j in range ( M - 1 , - 1 , - 1 ) : if ( arr [ i ] [ j ] == 0 ) : ans += 1 for k in range ( i + 1 ) : for h in range ( j + 1 ) : if ( arr [ k ] [ h ] == 1 ) : arr [ k ] [ h ] = 0 else : arr [ k ] [ h ] = 1 return ans

static int minOperation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }

static int minOperation ( int arr [ ] [ ] ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) arr [ i ] [ j ] = 0 ; else arr [ i ] [ j ] = 1 ; } } return ans ; }

static int minOperation ( int arr [ ] [ ] [ ] ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] == 0 ) ans ++ ; if ( arr [ i ] [ j ] == 1 ) arr [ i ] [ j ] = 0 ; else arr [ i ] [ j ] = 1 ; } } return ans ; }

31.79
43.04
74.5
63.98
def countNonDecreasing ( n ) : dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] for i in range ( 10 ) : dp [ i ] [ 1 ] = 1 for digit in range ( 10 ) : for len in range ( 2 , n + 1 ) : for x in range ( digit + 1 ) : dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] count = 0 for i in range ( 10 ) : count += dp [ i ] [ n ] return count

static int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }

static int countNonDecreasing ( int n ) { int [ ] dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( dp [ i ] [ n ] == 1 ) { for ( int i = 0 ; i < n ; i ++ ) { for (

static int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit < 10 ; digit ++ ) { for ( int len = 2 ; len < n + 1 ; len ++ ) { dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { count += dp [ i ] [ n ] ; } } return count ; }

31.8
43.62
65.43
79.75
def findSum ( n ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = abs ( i - j ) sum = 0 for i in range ( n ) : for j in range ( n ) : sum += arr [ i ] [ j ] return sum

static int findSum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }

static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; } return sum ; }

static int findSum ( int n ) { int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = abs ( i - j ) ; arr [ i ] [ j ] = Math . abs ( i - j ) ; } sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = Math . abs ( i - j ) ; sum += arr [ i ] [ j ] ; } } return sum ; } }

31.81
33.5
52.23
47.24
def printSubsequences ( str ) : n = len ( str ) opsize = int ( pow ( 2 , n - 1 ) ) for counter in range ( opsize ) : for j in range ( n ) : print ( str [ j ] , end = "" ) if ( counter & ( 1 << j ) ) : print ( "" , end = "" ) print ( "\n" , end = "" )

static void printSubsequences ( String s ) { char [ ] str = s . toCharArray ( ) ; int n = str . length ; int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " " ) ; } System . out . println ( ) ; } }

static void printSubsequences ( String str , int opsize ) { int n = str . length ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) print ( "" , end = "" ) ; if ( counter & ( 1 << j ) ) print ( "\n" , end = "" ) if ( counter & ( 1 << j ) ) print ( "\n" , end = "" ) if

static void printSubsequences ( String str ) { int n = str . length ( ) ; int opsize = int ( pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < n ; counter ++ ) { for ( int j = 0 ; j < opsize ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = str [ i ] ; if ( counter & ( 1 << j ) ) print ( str [ j ] , end = "" ) ; if ( counter & ( 1 << j ) ) print ( "" , end = "" ) ; } } } }

31.84
44.67
31.27
44.09
def parabola ( a , b , c ) : print ( "Vertex:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) , ")" , sep = "" ) print ( "Focus:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , ")" , sep = "" ) print ( "Directrix:y=" , c - ( ( b * b ) + 1 ) * 4 * a , sep = "" )

static void parabola ( float a , float b , float c ) { System . out . println ( "Vertex: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) + ")" ) ; System . out . println ( "Focus: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + ")" ) ; System . out . println ( "Directrix:" + " y=" + ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) ) ; }

static void parabola ( int a , int b , int c ) { System . out . print ( "Vertex:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , ")" , sep = "" ) ; System . out . print ( "Focus:(" , ( - b / ( 2 * a ) ) , "," ,

static void parabola ( int a , int b , int c ) { print ( "Vertex:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , ")" , sep = "" ) ; print ( "Focus:y=" , c - ( ( b * b ) + 1 ) * 4 * a , sep = "" ) ; }

31.86
49.91
51.19
58.0
def findIndex ( n ) : fibo = 2.078087 * math . log ( n ) + 1.672276 return round ( fibo )

static int findIndex ( int n ) { float fibo = 2.078087F * ( float ) Math . log ( n ) + 1.672276F ; return Math . round ( fibo ) ; }

static int findIndex ( int n ) { float fibo = 2.078087 * math.log(n) + 1.672276;float round(fibo);float round(fibo);float round(fibo);float round(fibo);float round(fibo);float round(fibo);float round(fibo);float round(fibo);float round(fibo);float round

static int findIndex ( int n ) { int fibo = 2.078087 + math . log ( n ) + 1.672276 ; return round ( fibo ) ; }

31.86
35.78
35.53
44.65
def findpos ( n ) : i = 0 j = len ( n ) pos = 0 while ( i < j ) : if ( n [ i ] == '4' ) : pos = pos * 2 + 1 if ( n [ i ] == '7' ) : pos = pos * 2 + 2 i = i + 1 return pos

static int findpos ( String n ) { int k = 0 , pos = 0 , i = 0 ; while ( k != n . length ( ) ) { switch ( n . charAt ( i ) ) { case '4' : pos = pos * 2 + 1 ; break ; case '7' : pos = pos * 2 + 2 ; break ; } i ++ ; k ++ ; } return pos ; }

static int findpos ( String n ) { int i = 0 ; int j = n . length ( ) ; while ( i < j ) { if ( n [ i ] == '5' ) pos = pos * 2 + 1 if ( n [ i ] == '6' ) pos = pos * 2 + 1 if ( n [ i ] == '8' ) pos = pos * 2 + 1 if ( n [ i ] == '9' ) pos = pos

static int findpos ( String n ) { int i = 0 ; int j = n . length ( ) ; int pos = 0 ; while ( i < j ) { if ( n [ i ] == '4' ) pos = pos * 2 + 1 ; if ( n [ i ] == '7' ) pos = pos * 2 + 2 ; if ( n [ i ] == '4' ) pos = pos * 2 + 1 ; if ( n [ i ] == '7' ) pos = pos * 2 + 2 ; } return pos ; }

31.89
39.72
54.65
59.23
def minInsertionStepToSortArray ( arr , N ) : lis = [ 0 ] * N for i in range ( N ) : lis [ i ] = 1 for i in range ( 1 , N ) : for j in range ( i ) : if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 max = 0 for i in range ( N ) : if ( max < lis [ i ] ) : max = lis [ i ] return ( N - max )

static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }

static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int max = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } return ( N - 1 ) ; }

static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ ] = new int [ N ] ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } } return ( N - max ) ; }

31.91
34.59
60.06
54.11
def minJumps ( arr , n ) : jumps = [ 0 for i in range ( n ) ] if ( n == 0 ) or ( arr [ 0 ] == 0 ) : return float ( 'inf' ) jumps [ 0 ] = 0 for i in range ( 1 , n ) : jumps [ i ] = float ( 'inf' ) for j in range ( i ) : if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) : jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) break return jumps [ n - 1 ]

private static int minJumps ( int [ ] arr , int n ) { int jumps [ ] = new int [ n ] ; int i , j ; if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE ; jumps [ 0 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) { jumps [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX_VALUE ) { jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } } return jumps [ n - 1 ] ; }

static float minJumps ( int arr [ ] , int n ) { int jumps [ ] = float ( 'inf' ) ; for ( int i = 1 ; i <= arr [ 0 ] ; i ++ ) { if ( i <= j + arr [ j ] ) { jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) ; } } return jumps [ 0 ] ; }

static int minJumps ( int arr [ ] , int n ) { int jumps [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { jumps [ i ] = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { if ( i <= j + arr [ j ] ) { if ( jumps [ j ] != float ( 'inf' ) ) { jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) ; } } } } return jumps [ n - 1 ] ; }

31.99
39.17
31.61
38.83
def findDimen ( H , A ) : if H * H < 4 * A : print ( "NotPossible" ) return apb = sqrt ( H * H + 4 * A ) asb = sqrt ( H * H - 4 * A ) print ( "P=" , "%.2f" % ( ( apb - asb ) / 2.0 ) ) print ( "B=" , "%.2f" % ( ( apb + asb ) / 2.0 ) )

static void findDimen ( int H , int A ) { if ( H * H < 4 * A ) { System . out . println ( "Not Possible" ) ; return ; } double apb = Math . sqrt ( H * H + 4 * A ) ; double asb = Math . sqrt ( H * H - 4 * A ) ; System . out . println ( "P = " + Math . round ( ( ( apb - asb ) / 2.0 ) * 100.0 ) / 100.0 ) ; System . out . print ( "B = " + Math . round ( ( ( apb + asb ) / 2.0 ) * 100.0 ) / 100.0 ) ; }

static void findDimen ( int H , int A ) { int apb = sqrt ( H * H + 4 * A ) ; int asb = sqrt ( H * H - 4 * A ) ; print ( "A=" , "%.2f" % ( ( apb - asb ) / 2.0 ) ) ; print ( "P=" , "%.2f" % ( ( apb + asb ) / 2.0 ) ) ; print ( "

static void findDimen ( int H , int A ) { int apb = sqrt ( H * H + 4 * A ) ; int asb = sqrt ( H * H - 4 * A ) ; print ( "P=" , "%.2f" % ( ( apb - asb ) / 2.0 ) ) ; print ( "B=" , "%.2f" % ( ( apb + asb ) / 2.0 ) ) ; }

32.02
41.31
59.02
59.46
def find3Numbers ( A , arr_size , sum ) : A . sort ( ) for i in range ( 0 , arr_size - 2 ) : l = i + 1 r = arr_size - 1 while ( l < r ) : if ( A [ i ] + A [ l ] + A [ r ] == sum ) : print ( "Tripletis" , A [ i ] , ',' , A [ l ] , ',' , A [ r ] ) return True elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : l += 1 else : r -= 1 return False

boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; quickSort ( A , 0 , arr_size - 1 ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { System . out . print ( "Triplet is " + A [ i ] + ", " + A [ l ] + ", " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }

static boolean find3Numbers ( int [ ] A , int arr_size , int sum ) { int i = 0 ; int l = 0 ; int r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { print ( "Tripletis" , A [ i ] , ',' , A [ l ] , ',' , A [ r ] ) return true ; } }

static boolean find3Numbers ( int A , int arr_size , int sum ) { int l = i + 1 ; int r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { print ( "Tripletis" , A [ i ] , ',' , A [ l ] , ',' , A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] == sum ) { print ( "Tripletis" , A [ i ] , ',' , A [ l ] , ',' , A [ r ] ) ; return true ; } else { r -- ; } } return false ; }

32.1
41.7
74.14
50.06
def binarySearch ( arr , l , r , x ) : if r >= l : mid = l + ( r - l ) // 2 if arr [ mid ] == x : return mid elif arr [ mid ] > x : return binarySearch ( arr , l , mid - 1 , x ) else : return binarySearch ( arr , mid + 1 , r , x ) else : return - 1

int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }

static int binarySearch ( int arr [ ] , int l , int r , int x ) { for ( int mid = l ; mid <= r ; mid ++ ) if ( arr [ mid ] == x ) return mid ; } return - 1 ; }

static int binarySearch ( int arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) // 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] > x ) return mid ; else return binarySearch ( arr , l , mid + 1 , x ) ; } else { return - 1 ; } }

32.11
40.51
48.89
53.33
def getMinDiff ( arr , n , k ) : if ( n == 1 ) : return 0 arr . sort ( ) ans = arr [ n - 1 ] - arr [ 0 ] small = arr [ 0 ] + k big = arr [ n - 1 ] - k if ( small > big ) : small , big = big , small for i in range ( 1 , n - 1 ) : subtract = arr [ i ] - k add = arr [ i ] + k if ( subtract >= small or add <= big ) : continue if ( big - subtract <= add - small ) : small = subtract else : big = add return min ( ans , big - small )

static int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; int temp = 0 ; if ( small > big ) { temp = small ; small = big ; big = temp ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }

static int getMinDiff ( int arr [ ] , int n , int k ) { int ans = 0 ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] + k ; if ( small > big ) small , big = big , small ; for ( int i = 1 ; i <= n ; i ++ ) { if ( big - subtract >= add - small ) { continue if ( small - add <= big ) { continue if ( add

static int getMinDiff ( int arr [ ] , int n , int k ) { int ans = arr . length - 1 ; int small = arr . length - 1 ; int big = arr . length - 1 ; for ( int i = 1 ; i < n ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) { continue ; } if ( big - subtract <= add - small ) { small = subtract ; } else { big = add ; } return min ( ans , small - subtract ) ; } }

32.17
34.09
14.08
22.21
def cost ( a , n ) : return ( ( n - 1 ) * min ( a ) )

static int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }

static int cost ( int a , int n ) { int min = min ( a ) ; int min = min ( a ) ; int min = min ( a ) ; return ( n - 1 ) * min ( a ) ; }

static int cost ( int a , int n ) { return ( ( n - 1 ) * min ( a ) ) ; }

32.26
38.87
57.18
66.95
def findCount ( n , sum ) : start = math . pow ( 10 , n - 1 ) end = math . pow ( 10 , n ) - 1 count = 0 i = start while ( i <= end ) : cur = 0 temp = i while ( temp != 0 ) : cur += temp % 10 temp = temp // 10 if ( cur == sum ) : count = count + 1 i += 9 else : i = i + 1 print ( count )

private static void findCount ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; }

static int findCount ( int n , int sum ) { int count = 0 ; int i = start ; while ( i <= end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { if ( cur == sum ) count = count + 1 ; else i ++ ; } } return count ; }

static int findCount ( int n , int sum ) { int start = math . pow ( 10 , n - 1 ) ; int end = math . pow ( 10 , n - 1 ) - 1 ; int count = 0 ; for ( int i = start ; i <= end ; i ++ ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; if ( cur == sum ) count = count + 1 i += 9 ; else : i = i + 1 ; } if ( cur == sum ) count = count + 1 i += 9 ; else : i = i + 1 ; } return count ; }

32.32
38.76
47.21
44.87
def arekAnagrams ( str1 , str2 , k ) : n = len ( str1 ) if ( len ( str2 ) != n ) : return False count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR for i in range ( n ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 count = 0 for i in range ( MAX_CHAR ) : if ( count1 [ i ] > count2 [ i ] ) : count = count + abs ( count1 [ i ] - count2 [ i ] ) return ( count <= k )

static boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }

static boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count1 [ i ] > count2 [ i ] ) { count = count + abs ( count1 [ i ] - count2 [ i ] ) ; } return ( count <= k ) ; } return ( false ; }

static boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; int count1 = [ 0 ] * MAX_CHAR ; int count2 = [ 0 ] * MAX_CHAR ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] ++ ; count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] ++ ; if ( count1 [ i ] > count2 [ i ] ) { count = count + abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; } } return false ; }

32.36
45.36
46.93
53.17
def maxSubsequenceSubstring ( x , y , n , m ) : dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if ( x [ j - 1 ] == y [ i - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ans = 0 for i in range ( 1 , m + 1 ) : ans = max ( ans , dp [ i ] [ n ] ) return ans

static int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; }

static int maxSubsequenceSubstring ( int x [ ] , int y [ ] , int n , int m ) { int [ ] dp = [ [ ] for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } } return 0 ; }

static int maxSubsequenceSubstring ( int x , int y , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) { dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] ; } } } return ans ; }

32.4
33.46
58.53
54.59
def minimalSteps ( s , n ) : dp = [ INT_MAX for i in range ( n ) ] s1 = "" s2 = "" dp [ 0 ] = 1 s1 += s [ 0 ] for i in range ( 1 , n ) : s1 += s [ i ] s2 = s [ i + 1 : i + 1 + i + 1 ] dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) if ( s1 == s2 ) : dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) return dp [ n - 1 ]

static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = Integer . MAX_VALUE ; String s1 = "" , s2 = "" ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; }

static int minimalSteps ( String s , int n ) { int dp [ ] = [ INT_MAX + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { s1 += s [ i ] ; s2 = s [ i + 1 : i + 1 + i + 1 ] ; if ( s1 == s2 ) { dp [ i ] = min ( dp [ i ] + 1 , dp [ i ] + 1 ) ; } } return dp [ n - 1 ] ; }

static int minimalSteps ( String s , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; s1 += s [ i ] ; s2 = s [ i + 1 : i + 1 + i + 1 + i + 1 ] ; dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) { dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; }

32.4
38.28
44.23
51.43
def computeTotient ( n ) : phi = [ ] for i in range ( n + 2 ) : phi . append ( 0 ) for i in range ( 1 , n + 1 ) : phi [ i ] = i for p in range ( 2 , n + 1 ) : if ( phi [ p ] == p ) : phi [ p ] = p - 1 for i in range ( 2 * p , n + 1 , p ) : phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) for i in range ( 1 , n + 1 ) : print ( "Totientof" , i , "is" , phi [ i ] )

static void computeTotient ( int n ) { long phi [ ] = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( "Totient of " + i + " is " + phi [ i ] ) ; }

static void computeTotient ( int n ) { int [ ] phi = new int [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( phi [ i ] == 0 ) { for ( int p = 2 ; p <= n ; p ++ ) { for ( int i = 0 ; i < n + 2 ; i ++ ) { if ( phi [ i ] % p == 0 ) { phi [ i ] = (

static void computeTotient ( int n ) { int phi [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { phi . append ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { phi [ i ] = i ; for ( int p = 2 ; p < n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int p = 2 ; p < n ; p ++ ) { phi [ p ] = ( phi [ p ] // p ) * ( p - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) ; } } }

32.46
32.0
53.39
58.41
def decToBinary ( n ) : for i in range ( 31 , - 1 , - 1 ) : k = n >> i if ( k & 1 ) : print ( "1" , end = "" ) else : print ( "0" , end = "" )

public void decToBinary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n >> i ; if ( ( k & 1 ) > 0 ) System . out . print ( "1" ) ; else System . out . print ( "0" ) ; } }

static void decToBinary ( int n ) { int i = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( k & 2 ) { print ( "0" , end = "" ) ; } else { print ( "1" , end = "" ) ; } } return ; }

static void decToBinary ( int n ) { for ( int i = 0 ; i < 31 ; i ++ ) { int k = n >> i ; if ( k & 1 ) { print ( "1" , end = "" ) ; } else { print ( "0" , end = "" ) ; } } }

32.47
32.58
46.91
53.07
def countSubarrays ( arr , n ) : difference = 0 ans = 0 hash_positive = [ 0 ] * ( n + 1 ) hash_negative = [ 0 ] * ( n + 1 ) hash_positive [ 0 ] = 1 for i in range ( n ) : if ( arr [ i ] & 1 == 1 ) : difference = difference + 1 else : difference = difference - 1 if ( difference < 0 ) : ans += hash_negative [ - difference ] hash_negative [ - difference ] = hash_negative [ - difference ] + 1 else : ans += hash_positive [ difference ] hash_positive [ difference ] = hash_positive [ difference ] + 1 return ans

static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }

static int countSubarrays ( int arr [ ] , int n ) { int ans = 0 ; int hash_positive [ ] = 0 ; int hash_negative [ ] = 0 ; int hash_positive [ ] = 1 ; int hash_negative [ ] = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] & 1 == 1 ) { difference = difference + 1 ; } else { difference = difference -

static int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int hash_positive = [ 0 ] * ( n + 1 ) ; int hash_negative = [ 0 ] * ( n + 1 ) ; int hash_positive = [ 0 ] * ( n + 1 ) ; int hash_negative = [ 0 ] * ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference = difference + 1 ; else difference = difference - 1 ; if ( difference < 0 ) ans += hash_negative [ - difference ] hash_negative [ - difference ] = hash_negative [ - difference ] + 1 ; else ans += hash_positive [ difference ] ; hash_positive [ difference ] = hash_positive [ difference ] + 1 ; } return ans ; }

32.48
39.07
70.58
78.66
def maxPrimeFactors ( n ) : maxPrime = - 1 while n % 2 == 0 : maxPrime = 2 n >>= 1 for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : while n % i == 0 : maxPrime = i n = n / i if n > 2 : maxPrime = n return int ( maxPrime )

static long maxPrimeFactors ( long n ) { long maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) maxPrime = n ; return maxPrime ; }

static int maxPrimeFactors ( int n ) { int maxPrime = - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) maxPrime = 2 ; n = n / i ; } return int ( maxPrime ) ; } return int ( maxPrime ) ; }

static int maxPrimeFactors ( int n ) { int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; for ( int i = 3 ; i < int ( math . sqrt ( n ) + 1 , 2 ) ; ) { while ( n % i == 0 ) maxPrime = i ; n = n / i ; if ( n > 2 ) maxPrime = n ; } } return maxPrime ; }

32.59
38.96
56.02
57.17
def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 for i in range ( 0 , n - 1 ) : sum = - 1 if ( arr [ i ] == 0 ) else 1 for j in range ( i + 1 , n ) : sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 if ( sum == 0 and maxsize < j - i + 1 ) : maxsize = j - i + 1 startindex = i if ( maxsize == - 1 ) : print ( "Nosuchsubarray" ) else : print ( startindex , "to" , startindex + maxsize - 1 ) return maxsize

int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( "No such subarray" ) ; else System . out . println ( startindex + " to " + endindex ) ; return maxsize ; }

static int findSubArray ( int arr [ ] , int n ) { int maxsize = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( arr [ i ] == 0 ) { sum = sum + ( - 1 ) ; if ( arr [ j ] == 0 ) { sum = sum + ( - 1 ) ; if ( arr [

static int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( - 1 ) ; if ( arr [ i ] == 0 ) sum = sum + ( - 1 ) ; if ( arr [ j ] == 0 ) sum = sum + ( - 1 ) ; if ( sum == 0 ) sum = sum + ( - 1 ) ; if ( maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; if ( maxsize == - 1 ) { print ( "Nosuchsubarray" ) ; } else { startindex = startindex + maxsize - 1 ; } } } } return maxsize ; }

32.7
39.46
35.71
33.02
def getPairsCount ( arr , n , sum ) : m = [ 0 ] * 1000 for i in range ( 0 , n ) : m [ arr [ i ] ] m [ arr [ i ] ] += 1 twice_count = 0 for i in range ( 0 , n ) : twice_count += m [ sum - arr [ i ] ] if ( sum - arr [ i ] == arr [ i ] ) : twice_count -= 1 return int ( twice_count / 2 )

static int getPairsCount ( int n , int sum ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , 0 ) ; hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; } int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . get ( sum - arr [ i ] ) != null ) twice_count += hm . get ( sum - arr [ i ] ) ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; }

static int getPairsCount ( int arr [ ] , int n , int sum ) { int m [ ] = new int [ arr [ n ] ] ; for ( int i = 0 ; i < n ; i ++ ) { int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sum - arr [ i ] == arr [ i ] ) { twice_count += m [ arr [ i ] ] ; if (

static int getPairsCount ( int arr [ ] , int n , int sum ) { int m [ ] = new int [ arr . length ] * 1000 ; for ( int i = 0 ; i < arr . length ; i ++ ) { m [ arr [ i ] ] += 1 ; twice_count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { twice_count += m [ arr [ i ] ] ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -= 1 ; } } return - 1 ; }

32.8
34.76
45.27
51.67
def subArraySum ( arr , n , sum ) : for i in range ( n ) : curr_sum = arr [ i ] j = i + 1 while j <= n : if curr_sum == sum : print ( "Sumfoundbetween" ) print ( "indexes%dand%d" % ( i , j - 1 ) ) return 1 if curr_sum > sum or j == n : break curr_sum = curr_sum + arr [ j ] j += 1 print ( "Nosubarrayfound" ) return 0

int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( "Sum found between indexes " + i + " and " + p ) ; return 1 ; } if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( "No subarray found" ) ; return 0 ; }

static int subArraySum ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( curr_sum == sum ) return 1 ; for ( int j = i ; j <= n ; j ++ ) { if ( curr_sum == sum ) return 1 ; if ( curr_sum > sum ) return 0 ; for ( int i = i ; i <= n ; i ++ ) { if (

static int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { curr_sum = arr [ i ] ; while ( j <= n ) { if ( curr_sum == sum ) return 1 ; if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; j ++ ; } } return 0 ; }

32.8
37.96
47.12
41.85
def findElement ( arr , n ) : leftMax = [ None ] * n leftMax [ 0 ] = float ( '-inf' ) for i in range ( 1 , n ) : leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) rightMin = float ( 'inf' ) for i in range ( n - 1 , - 1 , - 1 ) : if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] : return i rightMin = min ( rightMin , arr [ i ] ) return - 1

static int findElement ( int [ ] arr , int n ) { int [ ] leftMax = new int [ n ] ; leftMax [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ; int rightMin = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ; rightMin = Math . min ( rightMin , arr [ i ] ) ; } return - 1 ; }

static int findElement ( float arr [ ] , int n ) { float leftMax [ ] = arr [ 0 ] ; float rightMin = float ( 'inf' ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( leftMax [ i ] > arr [ i ] ) return i ; rightMin = min ( rightMin , arr [ i ] ) ; } return - 1 ; }

static int findElement ( int arr [ ] , int n ) { int leftMax [ ] = new int [ n ] ; int rightMax [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( leftMax [ i ] < arr [ i ] && rightMax [ i ] > arr [ i ] ) return i ; rightMax [ i ] = max ( rightMax [ i ] , arr [ i ] ) ; } return - 1 ; }

32.82
47.61
58.18
73.8
def maximizecube ( l , b , h ) : side = gcd ( l , gcd ( b , h ) ) num = int ( l / side ) num = int ( num * b / side ) num = int ( num * h / side ) print ( side , num )

static void maximizecube ( int l , int b , int h ) { int side = gcd ( l , gcd ( b , h ) ) ; int num = l / side ; num = ( num * b / side ) ; num = ( num * h / side ) ; System . out . println ( side + " " + num ) ; }

static void maximizecube ( int l , int b , int h ) { int num = int ( l / side ) num = int ( num * b / side ) num = int ( num * h / side ) num = int ( num * h / side ) num = int ( num * h / side ) num = int ( num * b / side ) num = int ( num * h / side ) num = int ( num * h / side ) num = int

static void maximizecube ( int l , int b , int h ) { int side = gcd ( l , gcd ( b , h ) ) ; int num = int ( l / side ) ; num = int ( num * b / side ) ; num = int ( num * h / side ) ; num = int ( num * h / side ) ; num = int ( num * h / side ) ; num = num ; }

32.82
48.51
58.9
74.58
def computeLastDigit ( A , B ) : variable = 1 if ( A == B ) : return 1 elif ( ( B - A ) >= 5 ) : return 0 else : for i in range ( A + 1 , B + 1 ) : variable = ( variable * ( i % 10 ) ) % 10 return variable % 10

static int computeLastDigit ( long A , long B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }

static int computeLastDigit ( int A , int B ) { int variable = 1 ; for ( int i = A ; i <= B ; i ++ ) { variable = ( variable * ( i / 10 ) ) % 10 ; } return 0 ; }

; } static int computeLastDigit ( int A , int B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( int i = A ; i <= B ; i ++ ) { variable = ( variable * ( i % 10 ) ) % 10 ; variable = ( variable * ( i % 10 ) ) % 10 ; variable = ( variable * ( i % 10 ) ) % 10 ; } return variable % 10 ; } }

32.83
32.26
67.52
75.79
def decToOctal ( n ) : octalNum = [ 0 ] * 100 i = 0 while ( n != 0 ) : octalNum [ i ] = n % 8 n = int ( n / 8 ) i += 1 for j in range ( i - 1 , - 1 , - 1 ) : print ( octalNum [ j ] , end = "" )

static void decToOctal ( int n ) { int [ ] octalNum = new int [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( octalNum [ j ] ) ; }

static void decToOctal ( int n ) { int i = 0 ; int j = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( octalNum [ j ] != 0 ) { print ( octalNum [ j ] , end = "" ) ; } i ++ ; for ( int j = 0 ; j < i ; j ++ ) { print ( octalNum [ j ] , end = "" ) ; } } }

static void decToOctal ( int n ) { int octalNum [ ] = new int [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = int ( n / 8 ) ; i ++ ; for ( int j = i - 1 ; j >= 0 ; j -- ) { octalNum [ j ] = n % 8 ; } print ( octalNum [ i ] , end = "" ) ; } }

32.83
34.16
58.53
50.57
def countDivisibleSubseq ( str , n ) : l = len ( str ) dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 for i in range ( 1 , l ) : dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 for j in range ( n ) : dp [ i ] [ j ] += dp [ i - 1 ] [ j ] dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] return dp [ l - 1 ] [ 0 ]

static int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }

static int countDivisibleSubseq ( String str , int n ) { int dp [ ] [ ] = new int [ l - 1 ] [ n ] ; for ( int i = 1 ; i <= l ; i ++ ) { dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ ( j *

static int countDivisibleSubseq ( String str , int n ) { int l = str . length ( ) ; int dp [ ] = new int [ l ] ; for ( int i = 1 ; i < l ; i ++ ) { dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ l - 1 ] [ 0 ] ; }

32.9
38.26
49.63
44.41
def calculate ( a ) : a . sort ( ) count = 1 answer = 0 for i in range ( 1 , len ( a ) ) : if a [ i ] == a [ i - 1 ] : count += 1 else : answer = answer + count * ( count - 1 ) // 2 count = 1 answer = answer + count * ( count - 1 ) // 2 return answer

static int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }

static int calculate ( int [ ] a ) { int count = 1 ; for ( int i = 1 ; i <= len ( a ) ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } } return answer ; }

static int calculate ( int [ ] a ) { int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) count ++ ; else if ( a [ i ] == a [ i - 1 ] ) count ++ ; else answer = answer + count * ( count - 1 ) ; } return answer ; }

32.9
43.75
33.24
41.25
def KnapSack ( val , wt , n , W ) : mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ] i = 0 while i < n : j = 0 if i % 2 == 0 : while j < W : j += 1 if wt [ i ] <= j : mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) else : mat [ 1 ] [ j ] = mat [ 0 ] [ j ] else : while j < W : j += 1 if wt [ i ] <= j : mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) else : mat [ 0 ] [ j ] = mat [ 1 ] [ j ] i += 1 if n % 2 == 0 : return mat [ 0 ] [ W ] else : return mat [ 1 ] [ W ]

static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; } else { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }

static int KnapSack ( int val [ ] , int wt [ ] , int n ) { int mat [ ] [ ] = new int [ W + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; else : mat [ 0 ] [ j ] = mat [ 0 ] [ j ] ) ; } return mat [ 0 ] [ W ] ; } }

static int KnapSack ( double [ ] val , double [ ] wt , int n , int W ) { int mat [ ] [ ] = new int [ W ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; while ( j < W ) { j += 1 ; if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } return mat [ 0 ] [ W ] ; }

32.92
41.48
61.58
60.31
def maxCost ( mat , N ) : dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] for i in range ( 1 , N ) : for j in range ( 1 , min ( i + 1 , N ) ) : dp [ i ] [ j ] = mat [ i ] [ j ] + \ max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) result = 0 for i in range ( N ) : if ( result < dp [ N - 1 ] [ i ] ) : result = dp [ N - 1 ] [ i ] return result

public static int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }

static int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( dp [ i ] [ j ] > mat [ i ] [ j ] ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; } } return 0 ; } }

static int maxCost ( int [ ] mat , int N ) { int dp [ ] [ ] = new int [ N ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i - 1 ] [ j ] ; } } result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i - 1 ] [ j ] ; } } } return result ; }

32.92
33.14
94.6
96.73
def isEven ( n ) : return ( n % 2 == 0 )

public static boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }

static boolean isEven ( int n ) { return

static boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }

33.0
38.16
71.04
75.8
def checkMarkov ( m ) : for i in range ( 0 , len ( m ) ) : sm = 0 for j in range ( 0 , len ( m [ i ] ) ) : sm = sm + m [ i ] [ j ] if ( sm != 1 ) : return False return True

static boolean checkMarkov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }

static boolean checkMarkov ( int [ ] [ ] m ) { int sm = 0 ; for ( int i = 0 ; i < len ( m ) ; i ++ ) { if ( sm != 0 ) return false ; } return true ; }

static boolean checkMarkov ( int [ ] m ) { for ( int i = 0 ; i < m . length ; i ++ ) { int sm = 0 ; for ( int j = 0 ; j < m . length ; j ++ ) { sm = sm + m [ i ] [ j ] ; if ( sm != 1 ) return false ; } } return true ; }

33.02
38.42
56.76
61.52
def checkReverse ( arr , n ) : temp = [ 0 ] * n for i in range ( n ) : temp [ i ] = arr [ i ] temp . sort ( ) for front in range ( n ) : if temp [ front ] != arr [ front ] : break for back in range ( n - 1 , - 1 , - 1 ) : if temp [ back ] != arr [ back ] : break if front >= back : return True while front != back : front += 1 if arr [ front - 1 ] < arr [ front ] : return False return True

static boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }

static boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( temp [ i ] < arr [ i ] ) return false ; for ( int front = 0 ; front < n ; front ++ ) { if ( temp [ front ] < arr [ front ] ) return false ; for ( int back = front ; back <=

static boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; temp . sort ( ) ; for ( int front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } for ( int back = 0 ; back < n ; back ++ ) { if ( temp [ back ] != arr [ back ] ) { break ; } } } return true ; }

33.07
37.33
55.05
36.9
def CountSubString ( Str , n ) : ans = ( n * ( n + 1 ) ) // 2 a_index = 0 b_index = 0 c_index = 0 for i in range ( n ) : if ( Str [ i ] == 'a' ) : a_index = i + 1 ans -= min ( b_index , c_index ) elif ( Str [ i ] == 'b' ) : b_index = i + 1 ans -= min ( a_index , c_index ) else : c_index = i + 1 ans -= min ( a_index , b_index ) return ans

static int CountSubstring ( char str [ ] , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == 'a' ) { a_index = i + 1 ; ans -= Math . min ( b_index , c_index ) ; } else if ( str [ i ] == 'b' ) { b_index = i + 1 ; ans -= Math . min ( a_index , c_index ) ; } else { c_index = i + 1 ; ans -= Math . min ( a_index , b_index ) ; } } return ans ; }

static int CountSubString ( String Str , int n ) { int ans = 0 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Str [ i ] == 'a' ) { a_index = i + 1 ; } else {

static int CountSubString ( String Str , int n ) { int ans = ( n * ( n + 1 ) ) // 2 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Str [ i ] == 'a' ) a_index = i + 1 ; else if ( Str [ i ] == 'b' ) b_index = i + 1 ; else if ( Str [ i ] == 'c' ) c_index = i + 1 ; else c_index = i + 1 ; } return ans ; }

33.11
33.28
50.65
50.2
def decodeMedianString ( s ) : l = len ( s ) s1 = "" if ( l % 2 == 0 ) : isEven = True else : isEven = False for i in range ( 0 , l , 2 ) : if ( isEven ) : s1 = s [ i ] + s1 s1 += s [ i + 1 ] else : if ( l - i > 1 ) : s1 += s [ i ] s1 = s [ i + 1 ] + s1 else : s1 += s [ i ] return s1

static String decodeMedianString ( String s ) { int l = s . length ( ) ; String s1 = "" ; boolean isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }

static String decodeMedianString ( String s ) { int l = s . length ( ) ; boolean isEven = ( l % 2 == 0 ) ; else isEven = false ; for ( int i = 0 ; i < l ; i ++ ) { if ( isEven ) s1 = s [ i ] + s1 ; else s1 += s [ i + 1 ] ; } return s1 ; }

static String decodeMedianString ( String s ) { int l = s . length ( ) ; String s1 = "" ; if ( l % 2 == 0 ) { isEven = true ; } else { isEven = false ; } for ( int i = 0 ; i < l ; i ++ ) { if ( isEven ) { s1 = s [ i ] + s1 s1 = s [ i + 1 ] + s1 ; s1 = s [ i + 2 ] + s1 ; } else { if ( l - i > 1 ) { s1 += s [ i ] s1 = s [ i + 1 ] + s1 ; } else { if ( l - i > 1 ) { s1 += s [ i ] s1 = s [ i + 1 ] + s1 ; } else { s1 += s [ i ] ; } } } } return s1 ; }

33.16
39.86
36.21
37.79
def arrangeString ( str1 , x , y ) : count_0 = 0 count_1 = 0 n = len ( str1 ) for i in range ( n ) : if str1 [ i ] == '0' : count_0 += 1 else : count_1 += 1 while count_0 > 0 or count_1 > 0 : for i in range ( 0 , x ) : if count_0 > 0 : print ( "0" , end = "" ) count_0 -= 1 for j in range ( 0 , y ) : if count_1 > 0 : print ( "1" , end = "" ) count_1 -= 1

static void arrangeString ( String str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { System . out . print ( "0" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { System . out . print ( "1" ) ; count_1 -- ; } } } }

static void arrangeString ( String str , int x , int y ) { int n = str . length ( ) ; int count_0 = 0 ; int count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count_0 > 0 ) print ( "0" ) count_0 -= 1 ; for ( int j = 0 ; j < y ; j ++ ) { if ( count_1 > 0 ) print (

static void arrangeString ( String str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else if ( str . charAt ( i ) == '1' ) count_1 ++ ; else if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } }

33.16
36.21
56.14
50.14
def recursiveReverse ( str ) : stack = [ ] for i in range ( len ( str ) ) : stack . append ( str [ i ] ) for i in range ( len ( str ) ) : str [ i ] = stack . pop ( )

public static String recursiveReverse ( char [ ] str ) { Stack < Character > st = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ; i ++ ) { str [ i ] = st . peek ( ) ; st . pop ( ) ; } return String . valueOf ( str ) ; }

static void recursiveReverse ( String str ) { Stack < String > stack = new Stack < String > ( ) ; for ( int i = 0 ; i < len ( str ) ; i ++ ) { str [ i ] = stack . pop ( ) ; } return str ; }

static void recursiveReverse ( String str ) { List < String > stack = new ArrayList < String > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { stack . add ( str [ i ] ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { str [ i ] = stack . pop ( ) ; } }

33.17
40.66
66.98
66.43
def sumNodes ( l ) : leafNodeCount = math . pow ( 2 , l - 1 ) sumLastLevel = 0 sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) sum = sumLastLevel * l return int ( sum )

static double sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }

static int sumNodes ( int l ) { int sum = 0 ; int sumLastLevel = 0 ; int sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ; return int ( sumLastLevel ) ; }  def sumNodes ( int l ) { int sum = 0 ; int sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sumLastLevel = ( leafNodeCount *

static int sumNodes ( int l ) { int leafNodeCount = math . pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; sum = sumLastLevel * l ; return int ( sum ) ; }

33.22
38.9
50.06
46.33
def printCommonElements ( mat ) : mp = dict ( ) for j in range ( N ) : mp [ mat [ 0 ] [ j ] ] = 1 for i in range ( 1 , M ) : for j in range ( N ) : if ( mat [ i ] [ j ] in mp . keys ( ) and mp [ mat [ i ] [ j ] ] == i ) : mp [ mat [ i ] [ j ] ] = i + 1 if i == M - 1 : print ( mat [ i ] [ j ] , end = "" )

static void printCommonElements ( int mat [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( mat [ i ] [ j ] ) == i ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " " ) ; } } } }

static void printCommonElements ( int mat [ ] [ ] ) { int mp [ ] = new int ( ) ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp [ mat [ i ] [ j ] ] == 1 ) mp [ mat [ i ] [ j ] ] = i + 1 ; else mp [ mat [ i ] [ j ] ] = i +

static void printCommonElements ( int [ ] mat ) { HashMap < String , Integer > mp = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] in mp . keys ( ) && mp [ mat [ i ] [ j ] ] == i ) mp [ mat [ i ] [ j ] ] = i + 1 ; if ( i == M - 1 ) print ( mat [ i ] [ j ] , end = "" ) ; } } }

33.29
40.3
44.59
53.88
def rearrangeArr ( arr , n ) : evenPos = int ( n / 2 ) oddPos = n - evenPos tempArr = np . empty ( n , dtype = object ) for i in range ( 0 , n ) : tempArr [ i ] = arr [ i ] tempArr . sort ( ) j = oddPos - 1 for i in range ( 0 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j - 1 j = oddPos for i in range ( 1 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j + 1 for i in range ( 0 , n ) : print ( arr [ i ] , end = '' )

public static void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Arrays . sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

static void rearrangeArr ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tempArr [ i ] = arr [ j ] ; j = j + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { tempArr [ i ] = arr [ j ] ; j = j - 1 ; } for ( int i = 0 ; i < n ;

static void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int tempArr = np . empty ( n , dtype = object ) ; for ( int i = 0 ; i < n ; i ++ ) { tempArr [ i ] = arr [ i ] ; tempArr . sort ( ) ; j = oddPos - 1 for ( i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ j ] ; j = oddPos - 1 for ( i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ j ] ; j = j - 1 for ( i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ j ] ; j = j + 1 for ( i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ j ] ; j = j + 1 for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ j ] ; j = j + 1 for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ j ]

33.36
42.67
75.62
78.95
def LCSubStr ( X , Y , m , n ) : LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] result = 0 for i in range ( m + 1 ) : for j in range ( n + 1 ) : if ( i == 0 or j == 0 ) : LCSuff [ i ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 result = max ( result , LCSuff [ i ] [ j ] ) else : LCSuff [ i ] [ j ] = 0 return result

static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }

static int LCSubStr ( int X [ ] , int Y [ ] , int m , int n ) { int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) result = max ( result , LCSuff [ i ] [ j ] + 1 ) ; else result = max (

static int LCSubStr ( int X , int Y , int m , int n ) { int [ ] LCSuff = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) { LCSuff [ i ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 result = max ( result , LCSuff [ i ] [ j ] ) ; } else { LCSuff [ i ] [ j ] = 0 ; } } } return result ; }

33.43
75.24
100.0
100.0
def fib ( n ) : if ( n <= 1 ) : return n return fib ( n - 1 ) + fib ( n - 2 )

static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }

static int fib ( int n ) { if ( n <= 2 ) return fib ( n - 1 ) + fib ( n - 2 ) ; return fib ( n - 2 ) ; }  def fib ( int n ) { return fib ( n - 1 ) + fib ( n - 2 ) + fib ( n - 1 ) + fib ( n - 2 ) + fib ( n - 2 ) + fib ( n -

static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }

33.53
40.56
22.27
50.95
def lis ( arr ) : global maximum n = len ( arr ) maximum = 1 _lis ( arr , n ) return maximum

static int lis ( int arr [ ] , int n ) { max_ref = 1 ; _lis ( arr , n ) ; return max_ref ; }

static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 0 ; while ( n > maximum ) { _lis ( arr , n - maximum ) ; } }

static int lis ( int arr [ ] ) { global maximum ; int n = arr . length ; maximum = 1 ; for ( int i = 0 ; i < n ; i ++ ) { lis ( arr [ i ] ) ; } return maximum ; }

33.53
40.56
22.27
50.95
def lis ( arr ) : global maximum n = len ( arr ) maximum = 1 _lis ( arr , n ) return maximum

static int lis ( int arr [ ] , int n ) { max_ref = 1 ; _lis ( arr , n ) ; return max_ref ; }

static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 0 ; while ( n > maximum ) { _lis ( arr , n - maximum ) ; } }

static int lis ( int arr [ ] ) { global maximum ; int n = arr . length ; maximum = 1 ; for ( int i = 0 ; i < n ; i ++ ) { lis ( arr [ i ] ) ; } return maximum ; }

33.63
35.36
59.27
54.92
def longest ( a , n , k ) : freq = [ 0 ] * n start = 0 end = 0 now = 0 l = 0 for i in range ( n ) : freq [ a [ i ] ] += 1 if ( freq [ a [ i ] ] == 1 ) : now += 1 while ( now > k ) : freq [ a [ l ] ] -= 1 if ( freq [ a [ l ] ] == 0 ) : now -= 1 l += 1 if ( i - l + 1 >= end - start + 1 ) : end = i start = l for i in range ( start , end + 1 ) : print ( a [ i ] , end = "" )

static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

static int longest ( int [ ] a , int n , int k ) { int freq [ ] = new int [ n ] ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] += 1 ; if ( freq [ a [ i ] ] == 1 ) { now += 1 ; while ( now > k ) { freq [ a [ i ] ] -= 1 ; if (

static void longest ( int [ ] a , int n , int k ) { int start = 0 ; int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] += 1 ; if ( freq [ a [ i ] ] == 1 ) now += 1 ; while ( now > k ) { freq [ a [ l ] ] -= 1 ; if ( freq [ a [ l ] ] == 0 ) now -= 1 ; l ++ ; } } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } }

33.71
35.57
36.85
36.93
def longDivision ( number , divisor ) : ans = "" idx = 0 temp = ord ( number [ idx ] ) - ord ( '0' ) while ( temp < divisor ) : temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) idx += 1 idx += 1 while ( ( len ( number ) ) > idx ) : ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) idx += 1 ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) if ( len ( ans ) == 0 ) : return "0" return ans

static String longDivision ( String number , int divisor ) { String ans = "" ; int idx = 0 ; char [ ] num = number . toCharArray ( ) ; int temp = num [ idx ] - '0' ; while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ; idx += 1 ; while ( num . length > idx ) { ans += ( temp / divisor ) ; temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; }

static String longDivision ( String number , int divisor ) { int temp = 0 ; while ( ( len ( number ) ) > idx ) { ans += chr ( math . floor ( temp / divisor ) + ord ( '0' ) ) ; temp = ( temp % divisor ) * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) ; idx += 1 ; while ( ( len ( number ) ) > idx ) { ans += chr (

static String longDivision ( String number , int divisor ) { int idx = 0 ; int temp = ord ( number [ idx ] ) - ord ( '0' ) ; while ( temp < divisor ) { temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) ; idx += 1 ; while ( ( len ( number ) ) > idx ) { ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) ; temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) ; idx += 1 ; } ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) ; } return ans ; }

33.73
42.44
20.96
32.05
def search ( arr , low , high ) : if low > high : return None if low == high : return arr [ low ] mid = low + ( high - low ) / 2 if mid % 2 == 0 : if arr [ mid ] == arr [ mid + 1 ] : return search ( arr , mid + 2 , high ) else : return search ( arr , low , mid ) else : if arr [ mid ] == arr [ mid - 1 ] : return search ( arr , mid + 1 , high ) else : return search ( arr , low , mid - 1 )

public static void search ( int [ ] arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . println ( "The required element is " + arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else if ( mid % 2 == 1 ) { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }

static int search ( int arr [ ] , int low , int high ) { int mid ; while ( mid <= high ) { if ( arr [ mid ] == arr [ mid + 2 ] ) return search ( arr , low , mid - 1 ) ; else if ( arr [ mid ] == arr [ mid - 1 ] ) return search ( arr , low , mid - 2 ) ; else if ( arr [ mid ] == arr [ mid ] ) return search ( arr , low

static int search ( int arr [ ] , int low , int high ) { if ( low == high ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; if ( arr [ low ] == null ) return null ; return search ( arr , low , high ) ; }

33.8
36.04
47.18
46.54
def subarrayDivisibleByK ( arr , n , k ) : mp = [ 0 ] * 1000 s = 0 e = 0 maxs = 0 maxe = 0 mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 for i in range ( 1 , n ) : mod = arr [ i ] % k while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 s = s + 1 mp [ mod ] = mp [ mod ] + 1 e = e + 1 if ( ( e - s ) > ( maxe - maxs ) ) : maxe = e maxs = s print ( "Themaximumsizeis{}andthe" . format ( ( maxe - maxs + 1 ) ) ) for i in range ( maxs , maxe + 1 ) : print ( "{}" . format ( arr [ i ] ) , end = "" )

static void subarrayDivisibleByK ( int [ ] arr , int n , int k ) { int [ ] mp = new int [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } System . out . print ( "The maximum size is " + ( maxe - maxs + 1 ) + " and the subarray is as follows\n" ) ; for ( int i = maxs ; i <= maxe ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

static void subarrayDivisibleByK ( int arr [ ] , int k ) { int s = 0 ; int e = 0 ; int mp [ ] = new int [ arr [ 0 ] % k ] ; mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int mod = arr [ i ] % k ; if ( mp [ mod ] != 0 ) { mp [ mod ] = mp [ mod ] + 1 ; mp [ mod ] != 0 ) mp [ mod ] = mp [ mod ] + 1 ; mp [ mod ] = mp [ mod ] + 1 ; mp [ mod ] = mp [ mod ] + 1 ; mp [ mod ] + 1 ; } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int s = s ; s ++ ; if ( mp [ mod ] != 0 ) mp [ mod ] = mp [ mod ] = mp [ mod ] + 1 ; mp [ mod ] = mp [ mod ] + 1 ; mp [ mod ] = mp [ mod ] + 1 ; mp [ mod ] = mp [ mod ] + 1 ; }

static void subarrayDivisibleByK ( int arr [ ] , int n , int k ) { int mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] ; for ( int i = 0 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 and mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 ] ; mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 ] ; s = s + 1 mp [ mod ] = mp [ mod ] + 1 e = e + 1 if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e maxs = s ; } } } for ( int i = 0 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 and mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] = mp [ arr [ s ]

33.88
44.58
34.09
42.15
def maxSumWO3Consec ( n ) : if ( sum [ n ] != - 1 ) : return sum [ n ] if ( n == 0 ) : sum [ n ] = 0 return sum [ n ] if ( n == 1 ) : sum [ n ] = arr [ 0 ] return sum [ n ] if ( n == 2 ) : sum [ n ] = arr [ 1 ] + arr [ 0 ] return sum [ n ] sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) return sum [ n ]

static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }

static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) { sum [ n ] = max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) + arr [ n - 2 ] + maxSumWO3Consec ( n - 3 ) + arr [ n - 1 ] + maxSumWO3Con

static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( sum [ n ] == 0 ) return sum [ n ] ; if ( n == 1 ) return sum [ n ] ; if ( n == 2 ) return sum [ n ] ; if ( n == 3 ) return sum [ n ] ; if ( n == 4 ) return sum [ n ] ; if ( n == 5 ) return sum [ n ] ; if ( n == 6 ) return sum [ n ] ; if ( n == 7 ) return sum [ n ] ; if ( n == 8 ) return sum [ n ] ; if ( n == 9 ) return sum [ n ] ; if ( n == 10 ) return sum [ n ] ; if ( n == 11 ) return sum [ n ] ; if ( n == 12 ) return sum [ n ] ; if ( n == 13 ) return sum [ n ] ; return sum [ n ] ; }

33.92
42.45
62.49
61.1
def minRange ( arr , n , k ) : l = 0 r = n for i in range ( n ) : s = [ ] for j in range ( i , n ) : s . append ( arr [ j ] ) if ( len ( s ) == k ) : if ( ( j - i ) < ( r - l ) ) : r = j l = i break if ( j == n ) : break if ( l == 0 and r == n ) : print ( "Invalidk" ) else : print ( l , r )

static void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { Set < Integer > s = new HashSet < Integer > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) System . out . println ( "Invalid k" ) ; else System . out . println ( l + " " + r ) ; }

static void minRange ( int arr [ ] , int n , int k ) { int l = 0 ; int r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int s [ ] = arr [ i ] ; if ( len ( s ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; break if ( ( j - i ) < ( r - l ) ) { l =

static void minRange ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n ; for ( int i = 0 ; i < n ; i ++ ) { int s = new int [ k ] ; for ( int j = 0 ; j < n ; j ++ ) { s . append ( arr [ j ] ) ; if ( len ( s ) == k ) { if ( ( j - i ) < ( r - l ) ) { l = j ; r = i ; break ; } if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } if ( j == n ) break ; } } } }

33.95
40.28
32.27
44.28
def countOps ( A , B , m , n ) : for i in range ( n ) : for j in range ( m ) : A [ i ] [ j ] -= B [ i ] [ j ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : return - 1 result = 0 for i in range ( n ) : result += abs ( A [ i ] [ 0 ] ) for j in range ( m ) : result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) return ( result )

static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; }

static int countOps ( int [ ] A , int [ ] B , int m , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( A [ i ] [ j ] - A [ i ] [ 0 ] + A [ 0 ] [ 0 ] != 0 ) result += abs ( B [ i ] [ j ] - A [ 0 ] [ 0 ] != 0 ) return - 1 ; } return 0 ; } }

static int countOps ( double [ ] A , double [ ] B , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( A [ i ] [ j ] - A [ i ] [ j ] - A [ i ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; } } } return 0 ; }

34.01
37.36
42.84
46.26
def encrypt ( text , s ) : result = "" for i in range ( len ( text ) ) : char = text [ i ] if ( char . isupper ( ) ) : result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) else : result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) return result

public static StringBuffer encrypt ( String text , int s ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( Character . isUpperCase ( text . charAt ( i ) ) ) { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 65 ) % 26 + 65 ) ; result . append ( ch ) ; } else { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 97 ) % 26 + 97 ) ; result . append ( ch ) ; } } return result ; }

static String encrypt ( String text , int s ) { String result = "" ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( char . islower ( ) ) result += chr ( ( ord ( char ) + s - 'a' ) % 26 + 'a' ) ; else result += chr ( ( ord ( char ) + s - 'a' ) % 26 + 'a' ) ; } return result ; }

static String encrypt ( String text , int s ) { String result = "" ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char = text [ i ] ; if ( char . isupper ( ) ) result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) ; else result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) ; } return result ; }

34.21
40.89
73.49
60.29
def cosXSertiesSum ( x , n ) : x = x * ( PI / 180.0 ) res = 1 sign = 1 fact = 1 pow = 1 for i in range ( 1 , 5 ) : sign = sign * - 1 fact = fact * ( 2 * i - 1 ) * ( 2 * i ) pow = pow * x * x res = res + sign * pow / fact return res

static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }

static int cosXSertiesSum ( double x , int n ) { int res = 0 ; int sign = 1 ; int fact = 1 ; int pow = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { res = res + sign * pow / fact ; } return res ; }

static int cosXSertiesSum ( int x , int n ) { int res = 1 ; int sign = 1 ; int fact = 1 ; int pow = 1 ; for ( int i = 1 ; i <= 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }

34.27
47.65
47.29
49.28
def gcdOfFactorial ( m , n ) : return math . factorial ( min ( m , n ) )

static int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; }

static double gcdOfFactorial ( int m, int n) {  def gcdOfFactorial ( int m , int n ) { return math . gcd ( m , n )

static int gcdOfFactorial ( int m , int n ) { return Math . factorial ( min ( m , n ) ) ; }

34.29
35.57
38.1
36.93
def replaceOriginal ( s , n ) : r = [ '' ] * n for i in range ( n ) : r [ i ] = s [ n - 1 - i ] if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) : print ( r [ i ] , end = "" ) print ( )

static void replaceOriginal ( String s , int n ) { char r [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( "" ) ; }

static void replaceOriginal ( String s , int n ) { String r [ ] = s [ n - 1 - i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) { print ( r [ i ] , end =

static void replaceOriginal ( String s , int n ) { String r [ ] = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' && s [ i ] != 'o' && s [ i ] != 'u' ) r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' && s [ i ] != 'o' && s [ i ] != 'u' ) r [ i ] = s [ n - 1 - i ] ; } }

34.32
41.77
51.15
52.96
def findRepeatFirst ( s ) : p = - 1 hash = [ 0 for i in range ( MAX_CHAR ) ] pos = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( len ( s ) ) : k = ord ( s [ i ] ) if ( hash [ k ] == 0 ) : hash [ k ] += 1 pos [ k ] = i elif ( hash [ k ] == 1 ) : hash [ k ] += 1 for i in range ( MAX_CHAR ) : if ( hash [ i ] == 2 ) : if ( p == - 1 ) : p = pos [ i ] elif ( p > pos [ i ] ) : p = pos [ i ] return p

public static int findRepeatFirst ( String s ) { int p = - 1 , i , k ; int MAX_CHAR = 256 ; int hash [ ] = new int [ MAX_CHAR ] ; int pos [ ] = new int [ MAX_CHAR ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { k = ( int ) s . charAt ( i ) ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } else if ( hash [ k ] == 1 ) hash [ k ] ++ ; } for ( i = 0 ; i < MAX_CHAR ; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) p = pos [ i ] ; else if ( p > pos [ i ] ) p = pos [ i ] ; } } return p ; }

static int findRepeatFirst ( String s ) { int p = - 1 ; int hash [ ] = new int [ MAX_CHAR ] ; int pos [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { int k = ord ( s [ i ] ) ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } } return p ; }

static int findRepeatFirst ( String s ) { int p = - 1 ; int hash = [ 0 ] ; int pos = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { int k = ord ( s [ i ] ) ; if ( hash [ k ] == 0 ) hash [ k ] += 1 ; pos [ k ] = i ; } if ( p == - 1 ) p = pos [ i ] ; else if ( p > pos [ i ] ) p = pos [ i ] ; else if ( p > pos [ i ] ) p = pos [ i ] ; } return p ; }

34.36
45.32
39.31
42.03
def rotateMatrix ( mat ) : i = N - 1 while ( i >= 0 ) : j = N - 1 while ( j >= 0 ) : print ( mat [ i ] [ j ] , end = "" ) j = j - 1 print ( ) i = i - 1

static void rotateMatrix ( int mat [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j >= 0 ; j -- ) System . out . print ( mat [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

static void rotateMatrix ( int mat [ ] [ ] , int N ) { int i = N - 1 ; int j = N - 1 ; while ( i >= 0 ) { print ( mat [ i ] [ j ] , end = "" ) j = j - 1 print ( ) i = i - 1 ; while ( j >= 0 ) { print ( mat [ i ] [ j ] , end = "" ) j = j - 1 print ( ) i = i -

rotateMatrix ( int mat [ ] [ ] ) { int i = N - 1 ; int j = N - 1 ; while ( i >= 0 ) { print ( mat [ i ] [ j ] , end = "" ) ; j = j - 1 ; } i = i - 1 ; while ( j >= 0 ) { print ( mat [ i ] [ j ] , end = "" ) ; j = j - 1 ; } }

34.58
44.55
40.78
42.53
def maxSum ( arr , n ) : cum_sum = 0 for i in range ( 0 , n ) : cum_sum += arr [ i ] curr_val = 0 for i in range ( 0 , n ) : curr_val += i * arr [ i ] res = curr_val for i in range ( 1 , n ) : next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) curr_val = next_val res = max ( res , next_val ) return res

static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }

static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) ) * ( n - 1 ) ) + arr [ i ] ; } return cum_sum ; }

static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { cum_sum += arr [ i ] ; curr_val = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { curr_val += i * arr [ i ] ; res = curr_val ; } } return res ; }

34.62
45.42
65.1
60.28
def numOfIncSubseqOfSizeK ( arr , n , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ] for i in range ( n ) : dp [ 0 ] [ i ] = 1 for l in range ( 1 , k ) : for i in range ( l , n ) : dp [ l ] [ i ] = 0 for j in range ( l - 1 , i ) : if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ l - 1 ] [ j ] Sum = 0 for i in range ( k - 1 , n ) : Sum += dp [ k - 1 ] [ i ] return Sum

static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int l = 1 ; l < k ; l ++ ) { for ( int i = l ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } } for ( int i = k - 1 ; i < n ; i ++ ) { sum += dp [ k - 1 ] [ i ] ; } return sum ; }

static long numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { long [ ] dp = new long [ n ] [ k ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } return Sum ; }

static int numOfIncSubseqOfSizeK ( int arr [ ] , int k ) { int [ ] dp = new int [ n ] [ k ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int l = 1 ; l <= k ; l ++ ) { for ( int j = l ; j <= i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l ] [ j ] ; } } } } for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ i ] = 1 for ( int l = 1 ; l <= k ; l ++ ) { dp [ l ] [ i ] = 0 for ( j in range ( l - 1 , i ) ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } } return Sum ; }

34.63
37.75
44.03
43.18
def printStringAlternate ( string ) : occ = { } for i in range ( 0 , len ( string ) ) : temp = string [ i ] . lower ( ) occ [ temp ] = occ . get ( temp , 0 ) + 1 if occ [ temp ] & 1 : print ( string [ i ] , end = "" ) print ( )

static void printStringAlternate ( String str ) { int [ ] occ = new int [ 122 ] ; String s = str . toLowerCase ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = s . charAt ( i ) ; occ [ temp ] ++ ; if ( occ [ temp ] % 2 != 0 ) System . out . print ( str . charAt ( i ) ) ; } System . out . println ( ) ; }

static void printStringAlternate ( String string ) { int occ [ ] = 0 ; for ( int i = 0 ; i < len ( string ) ; i ++ ) { String temp = string [ i ] . lower ( ) ; occ [ temp ] = occ . get ( temp , 0 ) + 1 ; if ( occ [ temp ] & 1 ) { print ( string [ i ] , end = "" ) } else { print ( string [ i ] , end = "" ) } }

static void printStringAlternate ( String string ) { int occ = new int [ string . length ( ) ] ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { String temp = string [ i ] . toLowerCase ( ) ; occ [ temp ] = occ . get ( temp , 0 ) + 1 ; if ( occ [ temp ] & 1 ) print ( string [ i ] , end = "" ) ; } }

34.63
43.19
61.78
65.64
def canFormPalindrome ( st ) : count = [ 0 ] * ( NO_OF_CHARS ) for i in range ( 0 , len ( st ) ) : count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 odd = 0 for i in range ( 0 , NO_OF_CHARS ) : if ( count [ i ] & 1 ) : odd = odd + 1 if ( odd > 1 ) : return False return True

static boolean canFormPalindrome ( String str ) { int count [ ] = new int [ NO_OF_CHARS ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }

static boolean canFormPalindrome ( String st ) { int count [ ] = new int [ NO_OF_CHARS ] ; int odd = 0 ; for ( int i = 0 ; i < len ( st ) ; i ++ ) { if ( count [ i ] & 1 ) { odd = odd + 1 ; } } return true ; }

static boolean canFormPalindrome ( String st ) { int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < len ( st ) ; i ++ ) { count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 ; odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) { odd = odd + 1 ; if ( odd > 1 ) return false ; } } } return true ; }

34.74
38.22
59.23
55.76
def findMinDiff ( arr , n , m ) : if ( m == 0 or n == 0 ) : return 0 arr . sort ( ) if ( n < m ) : return - 1 min_diff = sys . maxsize first = 0 last = 0 i = 0 while ( i + m - 1 < n ) : diff = arr [ i + m - 1 ] - arr [ i ] if ( diff < min_diff ) : min_diff = diff first = i last = i + m - 1 i += 1 return ( arr [ last ] - arr [ first ] )

static int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = Integer . MAX_VALUE ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) { min_diff = diff ; first = i ; last = i + m - 1 ; } } return ( arr [ last ] - arr [ first ] ) ; }

static int findMinDiff ( int [ ] arr , int n , int m ) { int min_diff = 0 ; int first = 0 ; int last = 0 ; while ( i < n ) { int diff = arr [ i ] - arr [ last ] ; if ( diff < min_diff ) min_diff = diff ; first = i ; last = i + m - 1 ; i ++ ; } return min_diff ; }

static int findMinDiff ( int arr [ ] , int n , int m ) { int first = 0 ; int last = 0 ; int i = 0 ; while ( i + m - 1 < n ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) { min_diff = diff ; first = i ; last = i + m - 1 i ++ ; } return ( arr [ last ] - arr [ first ] ) ; } }

34.76
45.37
56.42
60.6
def isPowerOfFour ( n ) : count = 0 if ( n and ( not ( n & ( n - 1 ) ) ) ) : while ( n > 1 ) : n >>= 1 count += 1 if ( count % 2 == 0 ) : return True else : return False

static int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }

static boolean isPowerOfFour ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; if ( count % 2 == 0 ) return false ; } return true ; } return false ; }

static boolean isPowerOfFour ( int n ) { int count = 0 ; if ( n && ( ! ( n & ( n - 1 ) ) ) ) { while ( n > 1 ) { n >>= 1 ; count ++ ; if ( count % 2 == 0 ) return true ; else return false ; } } return false ; }

34.8
43.98
50.14
52.53
def isDivisibleBy10 ( bin ) : n = len ( bin ) if ( bin [ n - 1 ] == '1' ) : return False sum = 0 i = n - 2 while i >= 0 : if ( bin [ i ] == '1' ) : posFromRight = n - i - 1 if ( posFromRight % 4 == 1 ) : sum = sum + 2 elif ( posFromRight % 4 == 2 ) : sum = sum + 4 elif ( posFromRight % 4 == 3 ) : sum = sum + 8 elif ( posFromRight % 4 == 0 ) : sum = sum + 6 i = i - 1 if ( sum % 10 == 0 ) : return True return False

static boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; if ( bin . charAt ( n - 1 ) == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin . charAt ( i ) == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; }

static boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; int sum = 0 ; while ( i >= 0 ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 0 ) { sum = sum + 1 ; } else { if ( posFromRight % 4 == 0 ) { sum = sum + 2 ; } else { if ( posFromRight % 4 == 3 ) { sum = sum +

static boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) { sum = sum + 2 ; } else if ( posFromRight % 4 == 2 ) { sum = sum + 4 ; } else if ( posFromRight % 4 == 3 ) { sum = sum + 8 ; } else if ( posFromRight % 4 == 0 ) { sum = sum + 6 ; } else if ( posFromRight % 4 == 1 ) { sum = sum + 6 ; } else if ( posFromRight % 4 == 2 ) { sum = sum + 7 ; } else if ( posFromRight % 4 == 0 ) { sum = sum + 8 ; } else if ( posFromRight % 4 == 0 ) { sum = sum + 6 ; } } } return true ; }

34.85
41.2
43.44
46.16
def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( "InvalidInput" ) return first = arr [ 0 ] second = - sys . maxsize third = - sys . maxsize for i in range ( 1 , arr_size ) : if ( arr [ i ] > first ) : third = second second = first first = arr [ i ] elif ( arr [ i ] > second ) : third = second second = arr [ i ] elif ( arr [ i ] > third ) : third = arr [ i ] print ( "ThethirdLargest" , "elementis" , third )

static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " Invalid Input " ) ; return ; } int first = arr [ 0 ] , second = Integer . MIN_VALUE , third = Integer . MIN_VALUE ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } System . out . printf ( "The third Largest element is %d\n" , third ) ; }

static void thirdLargest ( int arr [ ] , int arr_size ) { int first = arr [ 0 ] ; int second = arr [ 0 ] ; int third = - sys . maxsize ; for ( int i = 1 ; i <= arr_size ; i ++ ) { if ( arr [ i ] > third ) third = second second = arr [ i ] ; else if ( arr [ i ] > first ) third = first first = arr [ i ] ; else

static void thirdLargest ( int arr [ ] , int arr_size ) { int first = arr [ 0 ] ; int second = - 1 ; int third = - 1 ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) first = arr [ i ] ; if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > third ) third = arr [ i ] ; else if ( arr [ i ] > third ) third = arr [ i ] ; else if ( arr [ i ] > third ) third = arr [ i ] ; else if ( arr [ i ] > third ) third = arr [ i ] ; else if ( arr [ i ] > third ) third = arr [ i ] ; else if ( arr [ i ] > third ) third = arr [ i ] ; else print ( "ThethirdLargest" , "elementis" , third ) ; } }

34.87
42.73
36.32
54.41
def gcd ( a , b ) : if ( a == 0 ) : return b if ( b == 0 ) : return a k = 0 while ( ( ( a | b ) & 1 ) == 0 ) : a = a >> 1 b = b >> 1 k = k + 1 while ( ( a & 1 ) == 0 ) : a = a >> 1 while ( b != 0 ) : while ( ( b & 1 ) == 0 ) : b = b >> 1 if ( a > b ) : temp = a a = b b = temp b = ( b - a ) return ( a << k )

static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }

static int gcd ( int a , int b ) { int k = 0 ; while ( ( a | b ) & 1 ) == 0 ) { a = a >> 1 b = b >> 1 k = k + 1 ; while ( ( a | b ) & 1 ) == 0 ) { a = a >> 1 ; b = b >> 1 ; } k = k + 1 ; while ( ( b & 1 ) == 0 ) { a = a >> 1 ; } }

static int gcd ( int a , int b ) { int k = 0 ; while ( ( a | b ) & 1 ) ; a = a >> 1 ; b = b >> 1 ; k = k + 1 ; while ( ( a & 1 ) == 0 ) a = a >> 1 ; while ( ( b & 1 ) == 0 ) a = a >> 1 ; while ( ( a & 1 ) == 0 ) a = a >> 1 ; while ( ( b & 1 ) == 0 ) a = a >> 1 ; while ( ( b & 1 ) == 0 ) a = a >> 1 ; while ( ( a & 1 ) == 0 ) a = a >> 1 ; while ( ( b & 1 ) == 0 ) b = b >> 1 ; if ( a > b ) { temp = a a = b b = temp ; a = temp ; b = temp ; } } return ( a << k ) | ( b << k ) ; }

34.93
38.93
34.98
39.9
def distance ( lat1 , lat2 , lon1 , lon2 ) : lon1 = radians ( lon1 ) lon2 = radians ( lon2 ) lat1 = radians ( lat1 ) lat2 = radians ( lat2 ) dlon = lon2 - lon1 dlat = lat2 - lat1 a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 c = 2 * asin ( sqrt ( a ) ) r = 6371 return ( c * r )

public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; double r = 6371 ; return ( c * r ) ; }

static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { double a = sin ( lat1 ) * sin ( lat2 ) * sin ( dlon / 2 ) ** 2 + cos ( dlat / 2 ) * sin ( dlon / 2 ) ** 2 ; double b = 2 * asin ( sqrt ( a ) ) ; double c = 2 * asin ( sqrt ( b ) ) ; double r = 6371 ; return ( c * r ) ; }

static int distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { double dlon = lon2 - lon1 ; double dlat = lat1 - lat2 ; a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ; c = 2 * asin ( sqrt ( a ) ) ; r = 6371 ; return ( c * r ) + ( r * r ) ; }

34.95
41.56
42.99
44.28
def printHosoya ( n ) : dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 for i in range ( 2 , n ) : for j in range ( n ) : if ( i > j ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) for i in range ( n ) : for j in range ( i + 1 ) : print ( dp [ i ] [ j ] , end = '' ) print ( )

static void printHosoya ( int n ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( dp [ i ] [ j ] + "" ) ; System . out . println ( "" ) ; } }

static void printHosoya ( int N ) { int [ ] dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 2 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } }

static void printHosoya ( int N ) { int dp [ ] [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 2 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 2 ] [ 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 2 ] [ 0 ] ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 2 ] [ 0 ] ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 2 ] [ 0 ] ; } for ( int

34.95
37.87
74.71
69.18
def minCoins ( coins , m , V ) : if ( V == 0 ) : return 0 res = sys . maxsize for i in range ( 0 , m ) : if ( coins [ i ] <= V ) : sub_res = minCoins ( coins , m , V - coins [ i ] ) if ( sub_res != sys . maxsize and sub_res + 1 < res ) : res = sub_res + 1 return res

static int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }

static int minCoins ( int [ ] coins , int m , int V ) { int res = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] > V ) res = sub_res ; } } return res ; }

static int minCoins ( int coins , int m , int V ) { int res = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != sys . maxsize && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }

35.02
39.57
48.41
53.06
def minDist ( arr , n , x , y ) : min_dist = sys . maxsize for i in range ( n ) : if arr [ i ] == x or arr [ i ] == y : prev = i break while i < n : if arr [ i ] == x or arr [ i ] == y : if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist : min_dist = i - prev prev = i else : prev = i i += 1 return min_dist

int minDist ( int arr [ ] , int n , int x , int y ) { int i = 0 ; int min_dist = Integer . MAX_VALUE ; int prev = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) { min_dist = i - prev ; prev = i ; } else prev = i ; } } return min_dist ; }

static int minDist ( int arr [ ] , int n , int x , int y ) { int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x or arr [ i ] == y ) min_dist = i - prev ; else min_dist = i - prev ; else min_dist = i - prev ; } } return min_dist ; }

static int minDist ( int arr [ ] , int n , int x , int y ) { int min_dist = sys . maxsize ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) min_dist = i - prev ; else if ( arr [ prev ] != arr [ i ] && i - prev ) < min_dist ) min_dist = i - prev ; else min_dist = i ; } return min_dist ; }

35.02
42.63
53.25
55.03
def countOfBinaryNumberLessThanN ( N ) : q = deque ( ) q . append ( 1 ) cnt = 0 while ( q ) : t = q . popleft ( ) if ( t <= N ) : cnt = cnt + 1 q . append ( t * 10 ) q . append ( t * 10 + 1 ) return cnt

static int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }

static int countOfBinaryNumberLessThanN ( int N ) { int cnt = 0 ; while ( q ) { int t = q . popleft ( ) ; if ( t <= N ) { cnt = cnt + 1 ; q . append ( t * 10 + 1 ) ; } } return cnt ; }

static int countOfBinaryNumberLessThanN ( int N ) { int cnt = 0 ; while ( q . size ( ) > 0 ) { int t = q . pop ( ) ; if ( t <= N ) { cnt = cnt + 1 ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }

35.03
50.25
42.67
50.02
def printFun ( test ) : if ( test < 1 ) : return else : print ( test , end = "" ) printFun ( test - 1 ) print ( test , end = "" ) return

static void printFun ( int test ) { if ( test < 1 ) return ; else { System . out . printf ( "%d " , test ) ; printFun ( test - 1 ) ; System . out . printf ( "%d " , test ) ; return ; } }

static void printFun ( int test ) { if ( test == 0 ) return ; else : print ( test , end = "" ) printFun ( test + 1 ) ; print ( test , end = "" ) printFun ( test ) ; } }

static void printFun ( int test ) { if ( test < 1 ) return ; else print ( test , end = "" ) ; printFun ( test - 1 ) ; }

35.04
48.49
50.61
67.07
def print_sequence ( n , k ) : b = int ( n / ( k * ( k + 1 ) / 2 ) ) if b == 0 : print ( "-1" ) else : r = 1 x = 1 while x ** 2 <= n : if n % x != 0 : continue elif x <= b and x > r : r = x elif n / x <= b and n / x > r : r = n / x x = x + 1 i = 1 while i < k : print ( r * i , end = "" ) i = i + 1 last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) print ( last_term )

static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( "-1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } }

static void print_sequence ( int n , int k ) { int b = int ( n / ( k + 1 ) / 2 ) ) ; int r = 1 ; int x = 1 ; while ( x ** 2 <= n ; x = x + 1 ) { if ( n / x <= b && n / x > r ) r = n / x ; else r = x ; } for ( int i = 1 ; i < k ; i ++ ) { if (

static void print_sequence ( int n , int k ) { int b = int ( n / ( k * ( k + 1 ) / 2 ) ) ; int r = 1 ; int x = 1 ; while ( x ** 2 <= n ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; else if ( n / x <= b && n / x > r ) r = x ; else if ( n / x <= b && n / x <= r ) r = x ; else if ( n / x <= b && n / x > r ) r = x ; else if ( n / x <= b && n / x > r ) r = x ; else r = n / x ; x = x + 1 i = 1 ; while ( i < k ) { print ( r * i , end = "" ) i = i + 1 last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) print ( last_term ) ; } } }

35.11
43.45
77.35
72.85
def printSpiral ( n ) : for i in range ( 0 , n ) : for j in range ( 0 , n ) : x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) if ( i <= j ) : print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = "\t" ) else : print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = "\t" ) print ( )

static void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + "\t" ) ; else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + "\t" ) ; } System . out . println ( ) ; } }

static void printSpiral ( int n ) { for ( int i = 0 ; i <= j ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i <= j ) { print ( ( n - 2 * x ) * ( n - 2 * x ) + ( j - x ) ) , end = "\t" ) ; } else { print ( ( n - 2 * x - 2 ) * ( n -

static void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) { print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = "\t" ) ; } else { print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = "\t" ) ; } } } }

35.13
50.22
58.38
66.62
def sortedCount ( mat , r , c ) : result = 0 for i in range ( r ) : j = 0 for j in range ( c - 1 ) : if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : break if j == c - 2 : result += 1 for i in range ( 0 , r ) : j = 0 for j in range ( c - 1 , 0 , - 1 ) : if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : break if c > 1 and j == 1 : result += 1 return result

static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }

static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < c ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : break ; } return result ; }

static int sortedCount ( int mat [ ] [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j = 0 ; for ( int i = 0 ; i < r ; i ++ ) { j = 0 ; for ( int j = 0 ; j < c ; j ++ ) { if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) { break ; } } if ( c > 1 && j == 1 ) result ++ ; } } return result ; }

35.14
41.15
58.6
53.83
def countMinOperations ( target , n ) : result = 0 while ( True ) : zero_count = 0 i = 0 while ( i < n ) : if ( ( target [ i ] & 1 ) > 0 ) : break elif ( target [ i ] == 0 ) : zero_count += 1 i += 1 if ( zero_count == n ) : return result if ( i == n ) : for j in range ( n ) : target [ j ] = target [ j ] // 2 result += 1 for j in range ( i , n ) : if ( target [ j ] & 1 ) : target [ j ] -= 1 result += 1

static int countMinOperations ( int n ) { int result = 0 ; while ( true ) { int zero_count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) break ; else if ( arr [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 1 ) { arr [ j ] -- ; result ++ ; } } } }

static int countMinOperations ( int [ ] target , int n ) { int result = 0 ; int i = 0 ; while ( i < n ) { if ( ( target [ i ] & 1 ) > 0 ) result ++ ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( target [ j ] & 1 ) > 0 ) result ++ ; for ( int j = i ; j < n ; j ++ ) { if ( target [

static int countMinOperations ( int target [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int zero_count = 0 ; i = 0 ; while ( true ) { if ( ( target [ i ] & 1 ) > 0 ) { break ; } else if ( ( target [ i ] == 0 ) ) { zero_count ++ ; i ++ ; } } if ( zero_count == n ) { for ( int j = 0 ; j < n ; j ++ ) { target [ j ] = target [ j ] // 2 ; result += 1 for ( int j = 0 ; j < n ; j ++ ) { if ( target [ j ] & 1 ) { target [ j ] -= 1 ; result ++ ; } } } } } return result ; }

35.17
35.98
37.34
49.0
def dfs ( List , node , arrival ) : print ( node ) for i in range ( len ( List [ node ] ) ) : if ( List [ node ] [ i ] != arrival ) : dfs ( List , List [ node ] [ i ] , node )

public static void dfs ( LinkedList < Integer > list [ ] , int node , int arrival ) { System . out . println ( node ) ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] . get ( i ) != arrival ) dfs ( list , list [ node ] . get ( i ) , node ) ; } }

static void dfs ( List [ ] [ ] , int node ) { for ( int i = 0 ; i < len ( List [ node ] ) ; i ++ ) { if ( List [ node ] [ i ] != arrival ) { dfs ( List , List [ node ] [ i ] , arrival ) ; } } }

static void dfs ( List List , int node , int arrival ) { for ( int i = 0 ; i < List . length ; i ++ ) { if ( List [ node ] [ i ] != arrival ) { dfs ( List , List [ node ] [ i ] , node ) ; } } }

35.18
38.72
20.18
30.71
def getMinSquares ( n ) : dp = [ 0 , 1 , 2 , 3 ] for i in range ( 4 , n + 1 ) : dp . append ( i ) for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : temp = x * x ; if temp > i : break else : dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) return dp [ n ]

static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }

static int getMinSquares ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = sqrt ( i ) ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } return dp [ n ] ; } }

static int getMinSquares ( int n ) { int dp [ ] = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } return dp [ n ] ; }

35.29
21.9
51.86
33.29
def censor ( text , word ) : word_list = text . split ( ) result = '' stars = '*' * len ( word ) count = 0 index = 0 for i in word_list : if i == word : word_list [ index ] = stars index += 1 result = '' . join ( word_list ) return result

static String censor ( String text , String word ) { String [ ] word_list = text . split ( "\\s+" ) ; String result = "" ; String stars = "" ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) stars += '*' ; int index = 0 ; for ( String i : word_list ) { if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ; index ++ ; } for ( String i : word_list ) result += i + ' ' ; return result ; }

static String censor ( String text , String word ) { String result = '' ; int count = 0 ; int index = 0 ; for ( int i = 0 ; i < word_list . length ; i ++ ) { if ( i == word ) { word_list [ index ] = stars ; index += 1 ; } } return result ; }

static String censor ( String text , String word ) { String [ ] word_list = text . split ( ) ; String result = '' ; int stars = '*' * len ( word ) ; int index = 0 ; for ( int i = 0 ; i < word_list . length ; i ++ ) { if ( i == word ) word_list [ index ] = stars ; count ++ ; result += word_list [ index ] ; } return result ; }

35.39
39.83
75.69
74.24
def getRemainder ( num , divisor ) : while ( num >= divisor ) : num -= divisor return num

static int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }

static int getRemainder ( int num , int divisor ) { return num

static int getRemainder ( int num , int divisor ) { while ( num >= divisor ) { num -- ; } return num ; }

35.43
41.95
53.62
64.03
def findLongestRepeatingSubSeq ( X , m , n ) : if ( dp [ m ] [ n ] != - 1 ) : return dp [ m ] [ n ] if ( m == 0 or n == 0 ) : dp [ m ] [ n ] = 0 return dp [ m ] [ n ] if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 return dp [ m ] [ n ] dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) return dp [ m ] [ n ]

static int findLongestRepeatingSubSeq ( char X [ ] , int m , int n ) { if ( dp [ m ] [ n ] != - 1 ) { return dp [ m ] [ n ] ; } if ( m == 0 || n == 0 ) { return dp [ m ] [ n ] = 0 ; } if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) { return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ; } return dp [ m ] [ n ] = Math . max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) ; }

static int findLongestRepeatingSubSeq ( int [ ] dp , int m , int n ) { if ( dp [ m ] [ n ] == - 1 ) dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m , n - 1 ) + 1 ; else dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m , n - 1 ) + 1 ; return dp [ m ] [ n ] ; }

int findLongestRepeatingSubSeq ( int [ ] X , int m , int n ) { if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ] ; if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) { dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ; return dp [ m ] [ n ] ; } if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) { dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ; return dp [ m ] [ n ] ; } if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) { dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ; return dp [ m ] [ n ] ; } return dp [ m ] [ n ] ; }

35.54
42.02
39.29
43.52
def printRotatedString ( str ) : lenn = len ( str ) temp = [ 0 ] * ( lenn ) for i in range ( lenn ) : j = i k = 0 while ( j < len ( str ) ) : temp [ k ] = str [ j ] k += 1 j += 1 j = 0 while ( j < i ) : temp [ k ] = str [ j ] j += 1 k += 1 print ( * temp , sep = "" )

static void printRotatedString ( String str ) { int len = str . length ( ) ; StringBuffer sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuffer ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . length ( ) ; k2 ++ ) { sb . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( sb ) ; } }

static void printRotatedString ( String str ) { int lenn = str . length ( ) ; int k = 0 ; for ( int i = 0 ; i < lenn ; i ++ ) { temp [ k ] = str . charAt ( j ) ; k += 1 j = 0 ; while ( j < i ) { temp [ k ] = str . charAt ( j ) ; j += 1 k += 1 } } return ; }

static void printRotatedString ( String str ) { int lenn = str . length ( ) ; int k = 0 ; for ( int i = 0 ; i < lenn ; i ++ ) { j = i ; k = 0 ; while ( j < len ( str ) ) { temp [ k ] = str [ j ] ; k += 1 j += 1 j = 0 ; while ( j < i ) { temp [ k ] = str [ j ] ; k += 1 j += 1 j ++ ; } } print ( * temp , sep = "" ) ; } }

35.57
32.1
46.81
52.7
def decToBinary ( n ) : binaryNum = [ 0 ] * n i = 0 while ( n > 0 ) : binaryNum [ i ] = n % 2 n = int ( n / 2 ) i += 1 for j in range ( i - 1 , - 1 , - 1 ) : print ( binaryNum [ j ] , end = "" )

static void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }

static void decToBinary ( int n ) { int i = 0 ; int j = 0 ; for ( int j = 0 ; j < i ; j ++ ) { print ( binaryNum [ j ] , end = "" ) ; } for ( int j = 0 ; j < i ; j ++ ) { print ( binaryNum [ j ] , end = "" ) ; } return ; }

static void decToBinary ( int n ) { int binaryNum [ ] = new int [ n ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = int ( n / 2 ) ; i ++ ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binaryNum [ j ] = n % 2 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { binaryNum [ j ] = n % 2 ; } } return ; }

35.57
45.82
44.23
50.68
def Identity ( size ) : for row in range ( 0 , size ) : for col in range ( 0 , size ) : if ( row == col ) : print ( "1" , end = "" ) else : print ( "0" , end = "" ) print ( )

static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " " ) ; else System . out . print ( 0 + " " ) ; } System . out . println ( ) ; } return 0 ; }

static void Identity ( int size ) { for ( int row = 0 ; row < size ; row ++ ) { for ( int col = 0 ; col < size ; col ++ ) { if ( row == col ) { print ( "1" , end = "" ) ; } else { print ( "0" , end = "" ) ; } } } }

static void Identity ( int size ) { for ( int row = 0 ; row < size ; row ++ ) { for ( int col = 0 ; col < size ; col ++ ) { if ( row == col ) { System . out . print ( "1" ) ; } else { System . out . print ( "0" ) ; } } } }

35.58
52.32
43.96
62.82
def fib ( n , lookup ) : if n == 0 or n == 1 : lookup [ n ] = n if lookup [ n ] is None : lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) return lookup [ n ]

int fib ( int n ) { if ( lookup [ n ] == NIL ) { if ( n <= 1 ) lookup [ n ] = n ; else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; } return lookup [ n ] ; }

static int fib ( int n , int lookup [ ] ) { if ( lookup [ n ] is None ) lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) + fib ( n - 2 , lookup ) ; return lookup [ n ] ; } return fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) + fib ( n - 2 , lookup ) + fib ( n - 1 , lookup ) ; }

static int fib ( int n , int lookup [ ] ) { if ( n == 0 || n == 1 ) lookup [ n ] = n ; else lookup [ n ] = fib ( n - 1 , lookup ) ; if ( lookup [ n ] == null ) lookup [ n ] = fib ( n - 2 , lookup ) ; else lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) ; return lookup [ n ] ; }

35.6
63.11
23.12
25.6
def sumDigits ( no ) : return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) )

static int sumDigits ( int no ) { return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 ) ; }

static int sumDigits ( int no ) { return 0 if no == 0 else int ( no / 10 ) + sumDigits ( int ( no / 100 ) ) ; }  def sumDigits ( int no ) { return 0 ; }

static int sumDigits ( int no ) { return 0 ; }

35.62
43.48
72.16
78.69
def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 digits = 0 for i in range ( 2 , n + 1 ) : digits += math . log10 ( i ) return math . floor ( digits ) + 1

static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; }

static int findDigits ( int n ) { int digits = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { digits += math . log10 ( i ) ; } return 1 ; }

static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; int digits = 0 ; for ( int i = 2 ; i <= n + 1 ; i ++ ) { digits += Math . log10 ( i ) ; digits += math . log10 ( i ) ; } return digits ; }

35.63
50.66
59.18
63.82
def exponentiation ( bas , exp ) : if ( exp == 0 ) : return 1 if ( exp == 1 ) : return bas % N t = exponentiation ( bas , int ( exp / 2 ) ) t = ( t * t ) % N if ( exp % 2 == 0 ) : return t else : return ( ( bas % N ) * t ) % N

static long exponentiation ( long base , long exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return base % N ; long t = exponentiation ( base , exp / 2 ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( base % N ) * t ) % N ; }

static int exponentiation ( int bas , int exp ) { int t = exponentiation ( bas , int ( exp / 2 ) ) ; if ( exp % 2 == 1 ) { return ( ( bas % N ) * t ) % N ; } return 1 ; }  static int exponentiation ( int bas , int exp ) { int t = exponentiation ( bas , int ( exp / 2 ) ) ; if ( exp % 2 == 0 ) { return ( t *

int exponentiation ( int bas , int exp ) { int t = exponentiation ( bas , exp ) ; if ( t == 0 ) return 1 ; t = exponentiation ( bas , exp ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( bas % N ) * t ) % N ; }

35.68
42.77
45.43
50.85
def findMinAvgSubarray ( arr , n , k ) : if ( n < k ) : return 0 res_index = 0 curr_sum = 0 for i in range ( k ) : curr_sum += arr [ i ] min_sum = curr_sum for i in range ( k , n ) : curr_sum += arr [ i ] - arr [ i - k ] if ( curr_sum < min_sum ) : min_sum = curr_sum res_index = ( i - k + 1 ) print ( "Subarraybetween[" , res_index , "," , ( res_index + k - 1 ) , "]hasminimumaverage" )

static void findMinAvgSubarray ( int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } System . out . println ( "Subarray between [" + res_index + ", " + ( res_index + k - 1 ) + "] has minimum average" ) ; }

static int findMinAvgSubarray ( int arr [ ] , int n , int k ) { int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curr_sum < min_sum ) res_index = ( i - k ) ; else min_sum = curr_sum ; for ( int i = 0 ; i < k ; i ++ ) { if ( curr_sum <

static int findMinAvgSubarray ( int arr [ ] , int n , int k ) { int res_index = 0 ; curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; print ( "Subarraybetween[" , res_index , "," , ( res_index + k - 1 ) , "] hasminimumaverage" ) ; } } return res_index ; }

35.69
38.4
55.46
42.91
def fib ( n ) : a = 0 b = 1 if ( n >= 0 ) : print ( a , end = '' ) if ( n >= 1 ) : print ( b , end = '' ) for i in range ( 2 , n + 1 ) : c = a + b print ( c , end = '' ) a = b b = c

static void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + " " ) ; if ( n >= 1 ) System . out . print ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + " " ) ; a = b ; b = c ; } }

static void fib ( int n ) { int a = 0 ; int b = 1 ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i >= 0 ) { print ( a + b , end = '' ) for ( int i = 0 ; i < n ; i ++ ) { if ( i >= 1 ) { print ( c , end = '' ) for ( int i = 0 ; i < n ; i ++ ) { c = a + b ; } } } }

static void fib ( int n ) { int a = 0 ; int b = 1 ; if ( n >= 0 ) { print ( a , end = '' ) ; if ( n >= 1 ) { print ( b , end = '' ) ; } for ( int i = 2 ; i < n ; i ++ ) { c = a + b ; print ( c , end = '' ) ; a = b b = c ; } } }

35.71
35.65
63.79
60.27
def countNums ( n , x , y ) : arr = [ False for i in range ( n + 2 ) ] if ( x <= n ) : arr [ x ] = True if ( y <= n ) : arr [ y ] = True result = 0 for i in range ( min ( x , y ) , n + 1 ) : if ( arr [ i ] ) : if ( i + x <= n ) : arr [ i + x ] = True if ( i + y <= n ) : arr [ i + y ] = True result = result + 1 return result

static int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }

static int countNums ( int n , int x , int y ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( arr [ i ] ) result = result + 1 ; else result = result + 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( arr [ i ] ) result = result + 1 ; if ( arr [ i ] ) result = result + 1 ; if (

static int countNums ( int n , int x , int y ) { boolean arr [ ] = new boolean [ n + 2 ] ; boolean arr [ ] = new boolean [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( arr [ i + y ] ) arr [ i + y ] = true ; result = result + 1 ; } } return result ; }

35.74
36.59
76.42
68.31
def getParity ( n ) : parity = 0 while n : parity = ~ parity n = n & ( n - 1 ) return parity

static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }

static int getParity ( int n ) { int parity = 0 ; while ( n > 0 ) parity = ~ parity & parity ; n = n - 1 ; }

static int getParity ( int n ) { int parity = 0 ; while ( n != 0 ) { parity = ~ parity ; n = n & ( n - 1 ) ; } return parity ; }

35.76
41.42
38.28
40.46
def findMaxGCD ( arr , n ) : high = 0 for i in range ( 0 , n ) : high = max ( high , arr [ i ] ) count = [ 0 ] * ( high + 1 ) for i in range ( 0 , n ) : count [ arr [ i ] ] += 1 counter = 0 for i in range ( high , 0 , - 1 ) : j = i while ( j <= high ) : if ( count [ j ] > 0 ) : counter += count [ j ] j += i if ( counter == 2 ) : return i counter = 0

public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int count [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; }

static int findMaxGCD ( int [ ] arr , int n ) { int high = 0 ; int counter = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( count [ arr [ i ] ] > 0 ) { counter ++ ; for ( int j = i ; j <= high ) { if ( count [ j ] > 0 ) { counter ++ ; for ( int i = i ; j <= high ) { if ( counter ==

static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { high = max ( high , arr [ i ] ) ; for ( int j = 0 ; j <= high ; j ++ ) { if ( count [ arr [ j ] ] > 0 ) { counter ++ ; if ( counter == 2 ) return i ; } } } return - 1 ; }

35.76
41.8
76.5
67.37
def maximumDifferenceSum ( arr , N ) : dp = [ [ 0 , 0 ] for i in range ( N ) ] for i in range ( N ) : dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 for i in range ( N - 1 ) : dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )

static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }

static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i ] [ 1 ] + abs ( arr [ i ] - 1 ) ; dp [ i ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( arr [ i ] ) ; } return 0 ; }

static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ 0 ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i ] [ 0 ] + abs ( 1 - arr [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - 1 ) ) ; dp [ i ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }

35.89
27.47
74.94
85.2
def checkJumbled ( num ) : if ( num // 10 == 0 ) : return True while ( num != 0 ) : if ( num // 10 == 0 ) : return True digit1 = num % 10 digit2 = ( num // 10 ) % 10 if ( abs ( digit2 - digit1 ) > 1 ) : return False num = num // 10 return True

static boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }

static boolean checkJumbled ( int num ) { int digit1 = 0 ; int digit2 = ( num // 10 ) % 10 ; if ( abs ( digit1 - digit2 ) > 1 ) { return false num = num % 10 ; } return true ; } return false ; }

static boolean checkJumbled ( int num ) { if ( num == 0 ) return true ; while ( num != 0 ) { if ( num % 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; if ( abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }

35.9
44.13
41.47
60.95
def checkCollision ( a , b , c , x , y , radius ) : dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) if ( radius == dist ) : print ( "Touch" ) elif ( radius > dist ) : print ( "Intersect" ) else : print ( "Outside" )

static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( "Touch" ) ; else if ( radius > dist ) System . out . println ( "Intersect" ) ; else System . out . println ( "Outside" ) ; }

static void checkCollision ( float a , float b , float c , float radius ) { float dist = ( Math . sqrt ( a * a + b * b + c ) ) / math . sqrt ( a * a + b * b + c ) ) ; if ( radius == dist ) { print ( "Touch" ) ; } else { print ( "Intersect" ) ; } }

static void checkCollision ( int a , int b , int c , float x , float y , float radius ) { int dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ; if ( radius == dist ) { checkCollision ( a , b , c , x , y , radius ) ; } else if ( radius > dist ) { checkCollision ( a , b , c , x , y , radius ) ; } else if ( radius > dist ) { checkCollision ( a , b , c , x , y , radius ) ; } else { print ( "Outside" ) ; } } }

35.96
67.54
100.0
100.0
def numberOfPaths ( m , n ) : if ( m == 1 or n == 1 ) : return 1 return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 )

static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }

static int numberOfPaths ( int m , int n ) { if ( m == 0 ) return 0 ; return numberOfPaths ( m - 1 , n - 1 ) + numberOfPaths ( m , n - 1 ) + numberOfPaths ( m , n - 2 ) + numberOfPaths ( m , n - 2 ) + numberOfPaths ( m , n - 2 ) + numberOfPaths ( m , n - 1 ) + numberOfPaths ( m , n - 2 ) + numberOfPaths ( m

static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }

36.01
72.19
93.37
96.65
def nswp ( n ) : if n == 0 or n == 1 : return 1 return 2 * nswp ( n - 1 ) + nswp ( n - 2 )

static int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }

static int nswp ( int n ) { if ( n == 0 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) + nswp ( n - 3 ) + nswp ( n - 4 ) + nswp ( n - 5 ) + nswp ( n - 3 ) + nswp ( n - 4 ) + nswp ( n - 3 ) + nswp ( n - 4 ) + nswp ( n -

static int nswp ( int n ) { if ( n == 0 || n == 1 ) return 2 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }

36.08
38.89
36.58
31.45
def convert ( s ) : n = len ( s ) s1 = "" s1 = s1 + s [ 0 ] . lower ( ) i = 1 while i < n : if ( s [ i ] == '' and i <= n ) : s1 = s1 + "" + ( s [ i + 1 ] ) . lower ( ) i = i + 1 else : s1 = s1 + ( s [ i ] ) . upper ( ) i = i + 1 return s1

static String convert ( String s ) { int n = s . length ( ) ; String s1 = "" ; s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ' && i < n ) { s1 = s1 + " " + Character . toLowerCase ( s . charAt ( i + 1 ) ) ; i ++ ; } else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ; } return s1 ; }

static String convert ( String s ) { int n = s . length ( ) ; int i = 0 ; while ( i < n ) { if ( s [ i ] == 'a' ) s1 = s1 + ( s [ i + 1 ] ) . lower ( ) i = i + 1 ; else s1 = s1 + ( s [ i ] ) . upper ( ) i = i + 1 ; else s1 = s1 + s [ i ] ; } return s1 ; }

static String convert ( String s ) { int n = s . length ( ) ; int i = 0 ; while ( i < n ) { if ( s [ i ] == '' && i <= n ) s1 = s1 + "" + s [ i + 1 ] . lower ( ) ; i ++ ; else s1 = s1 + ( s [ i ] ) . upper ( ) ; i ++ ; } return s1 ; }

36.12
42.88
63.51
59.6
def optimalStrategyOfGame ( arr , n ) : table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for gap in range ( n ) : for j in range ( gap , n ) : i = j - gap x = 0 if ( ( i + 2 ) <= j ) : x = table [ i + 2 ] [ j ] y = 0 if ( ( i + 1 ) <= ( j - 1 ) ) : y = table [ i + 1 ] [ j - 1 ] z = 0 if ( i <= ( j - 2 ) ) : z = table [ i ] [ j - 2 ] table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) return table [ 0 ] [ n - 1 ]

static int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }

static int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i <= j ; i ++ ) { for ( int j = gap ; j <= n ; j ++ ) { if ( i <= j ) { table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) return table [ 0 ] [ j ] ; } } return table [ 0 ] [ n - 1 ] [ n ] ; } }

static int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ n - 1 ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x = table [ i + 2 ] [ j ] ; if ( ( i + 1 ) <= ( j - 1 ) ) x = table [ i + 1 ] [ j - 1 ] ; if ( ( i + 2 ) <= ( j - 1 ) ) y = table [ i ] [ j - 1 ] ; if ( i <= ( j - 2 ) ) z = table [ i ] [ j - 2 ] table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }

36.13
39.58
67.09
73.1
def findFirstMissing ( array , start , end ) : if ( start > end ) : return end + 1 if ( start != array [ start ] ) : return start mid = int ( ( start + end ) / 2 ) if ( array [ mid ] == mid ) : return findFirstMissing ( array , mid + 1 , end ) return findFirstMissing ( array , start , mid )

int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }

static int findFirstMissing ( int [ ] array , int start , int end ) { int mid = int ( ( start + end ) / 2 ) ; if ( array [ mid ] == mid ) return ( mid + 1 ) ; if ( array [ mid ] == mid ) return ( mid + 1 ) ; if ( array [ mid ] == mid ) return ( mid + 1 ) ; if ( array [ mid ] == mid ) return ( mid + 1 ) ; if ( array

static int findFirstMissing ( int array [ ] , int start , int end ) { int mid = int ( ( start + end ) / 2 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , end ) ; }

36.13
71.95
79.99
84.26
def maxTripletSum ( arr , n ) : arr . sort ( ) return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )

static int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }

static int maxTripletSum ( int arr [ ] , int n ) { int arr [ ] . sort ( ) ; return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] + arr [ n - 4 ] + arr [ n - 5 ] + arr [ n - 4 ] + arr [ n - 5 ] + arr [ n - 4 ] + arr [ n - 5 ] + arr [ n - 4 ] + arr

static int maxTripletSum ( int arr [ ] , int n ) { arr . sort ( ) ; return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) ; }

36.22
42.95
77.84
66.02
def stringReduction ( str ) : n = len ( str ) count = [ 0 ] * 3 for i in range ( n ) : count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : return n if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : return 2 return 1

static int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - 'a' ] ++ ; } if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }

static int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ i ] == 'a' ) return 2 ; if ( count [ i ] == 'a' ) return 2 ; if ( count [ i ] == 'a' ) return 2 ; if ( count [ i ] == 'a' )

; } static int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 ; if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n ; if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2 ; } return - 1 ; }

36.23
36.2
47.61
46.68
def subArrayExists ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : sum += arr [ i ] if sum == 0 or sum in s : return True s . add ( sum ) return False

static Boolean subArrayExists ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 || sum == 0 || hM . get ( sum ) != null ) return true ; hM . put ( sum , i ) ; } return false ; }

static boolean subArrayExists ( int arr [ ] , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( sum == 0 ) return true ; s . add ( sum ) ; return false ; } return false ; }

static boolean subArrayExists ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 || sum in s ) return true ; s . add ( sum ) ; } return false ; }

36.28
45.4
35.45
46.27
def findMinRooms ( slots , n , m ) : counts = [ 0 ] * m for i in range ( n ) : for j in range ( m ) : if ( slots [ i ] [ j ] == '1' ) : counts [ j ] += 1 return max ( counts )

static int findMinRooms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }

static int findMinRooms ( int [ ] slots , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( slots [ i ] [ j ] == '1' ) counts [ j ] += 1 ; } } return 0 ; }

static int findMinRooms ( int slots [ ] [ ] , int m ) { int [ ] counts = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; } } return max ( counts ) ; }

36.28
42.91
60.19
65.62
def possibleStrings ( n , r , b , g ) : fact = [ 0 for i in range ( n + 1 ) ] fact [ 0 ] = 1 for i in range ( 1 , n + 1 , 1 ) : fact [ i ] = fact [ i - 1 ] * i left = n - ( r + g + b ) sum = 0 for i in range ( 0 , left + 1 , 1 ) : for j in range ( 0 , left - i + 1 , 1 ) : k = left - ( i + j ) sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) return sum

static int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }

static int possibleStrings ( int n , int r , int b , int g ) { int sum = 0 ; int fact [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < left ; j ++ ) { for ( int k = 0 ; k < left ; k ++ ) { if ( k + g > n ) sum = ( sum + fact [ n ] / (

static int possibleStrings ( int n , int r , int b , int g ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < left - i + 1 ; k ++ ) { for ( int j = 0 ; j < left - i + 1 ; j ++ ) { int k = left - ( i + j ) ; sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) ; sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) ; } } } return sum ; }

36.33
39.86
38.83
42.89
def findLongestConseqSubseq ( arr , n ) : s = Set ( ) ans = 0 for ele in arr : s . add ( ele ) for i in range ( n ) : if ( arr [ i ] - 1 ) not in s : j = arr [ i ] while ( j in s ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans

static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) S . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! S . contains ( arr [ i ] - 1 ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }

static int findLongestConseqSubseq ( int arr [ ] , int n ) { Set s = new Set ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = arr [ i ] ; j <= arr [ i ] ; j ++ ) { if ( j - 1 in s ) { ans = max ( ans , j - arr [ i ] ) ; } } } return ans ; }

static int findLongestConseqSubseq ( int arr [ ] , int n ) { Set s = new HashSet ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] - 1 ) not in s ) { j = arr [ i ] ; while ( j in s ) { j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } } return ans ; }

36.33
49.68
56.91
64.6
def search ( arr , low , high ) : if low > high : return None if low == high : return arr [ low ] mid = ( low + high ) / 2 ; if mid % 2 == 0 : if arr [ mid ] == arr [ mid + 1 ] : return search ( arr , mid + 2 , high ) else : return search ( arr , low , mid ) else : if arr [ mid ] == arr [ mid - 1 ] : return search ( arr , mid + 1 , high ) else : return search ( arr , low , mid - 1 )

static void search ( int arr [ ] , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . printf ( "The required element is %d " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }

static int search ( int [ ] arr , int low , int high ) { int mid = 0 ; while ( mid < high ) { if ( arr [ mid ] == arr [ mid + 2 ] ) return search ( arr , low , mid - 1 ) ; else if ( arr [ mid ] == arr [ mid - 1 ] ) return search ( arr , low , mid - 2 ) ; else if ( arr [ mid ] == arr [ mid ] ) return search ( arr

static int search ( int arr [ ] , int low , int high ) { int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) return search ( arr , mid + 2 , high ) ; else if ( arr [ mid ] == arr [ mid - 1 ] ) return search ( arr , mid + 1 , high ) ; else return search ( arr , low , mid - 1 ) ; } }

36.39
40.69
53.76
70.61
def findMinInsertions ( str , l , h ) : if ( l > h ) : return sys . maxsize if ( l == h ) : return 0 if ( l == h - 1 ) : return 0 if ( str [ l ] == str [ h ] ) else 1 if ( str [ l ] == str [ h ] ) : return findMinInsertions ( str , l + 1 , h - 1 ) else : return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )

static int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }

static int findMinInsertions ( String str , int l , int h ) { if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return 1 ; if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return 1 ; if ( str [ l ] == str [ h ] ) return (

static int findMinInsertions ( String str , int l , int h ) { if ( l > h ) return 0 ; if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return 0 ; if ( str [ l ] == str [ h ] ) return findMinInsertions ( str , l + 1 , h - 1 ) ; else return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }

36.44
39.22
54.65
48.5
def decToHexa ( n ) : hexaDeciNum = [ '0' ] * 100 i = 0 while ( n != 0 ) : temp = 0 temp = n % 16 if ( temp < 10 ) : hexaDeciNum [ i ] = chr ( temp + 48 ) i = i + 1 else : hexaDeciNum [ i ] = chr ( temp + 55 ) i = i + 1 n = int ( n / 16 ) j = i - 1 while ( j >= 0 ) : print ( ( hexaDeciNum [ j ] ) , end = "" ) j = j - 1

static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }

static void decToHexa ( int n ) { int i = 0 ; int j = 0 ; while ( i < 100 ) { hexaDeciNum [ i ] = '0' ; i = i + 1 ; } } while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) hexaDeciNum [ i ] = '0' ; else hexaDeciNum [ i ] = '0

static void decToHexa ( int n ) { int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) hexaDeciNum [ i ] = chr ( temp + 48 ) ; else hexaDeciNum [ i ] = chr ( temp + 55 ) ; i = i + 1 ; else hexaDeciNum [ i ] = chr ( temp + 55 ) ; i = i + 1 ; } j = i - 1 ; while ( j >= 0 ) { print ( ( hexaDeciNum [ j ] ) , end = "" ) ; j = j - 1 ; } } return ; }

36.52
41.15
43.81
47.07
def modularEquation ( a , b ) : if ( a < b ) : print ( "Nosolutionpossible" ) return if ( a == b ) : print ( "InfiniteSolutionpossible" ) return count = 0 n = a - b y = ( int ) ( math . sqrt ( a - b ) ) for i in range ( 1 , y + 1 ) : if ( n % i == 0 ) : if ( n / i > b ) : count = count + 1 if ( i > b ) : count = count + 1 if ( y * y == n and y > b ) : count = count - 1 print ( count )

static void modularEquation ( int a , int b ) { if ( a < b ) { System . out . println ( "No solution possible " ) ; return ; } if ( a == b ) { System . out . println ( "Infinite Solution possible " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; }

static void modularEquation ( int a , int b ) { int count = 0 ; int n = ( int ) ( a - b ) ; int y = ( int ) ( math . sqrt ( a - b ) ) ; for ( int i = 1 ; i <= y ; i ++ ) { if ( n / i > b ) count = count + 1 ; if ( i > b ) count = count + 1 ; if ( n / i > b ) count =

static void modularEquation ( int a , int b ) { int count = 0 ; int n = a - b ; for ( int i = 1 ; i < y + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i > b ) count = count + 1 ; if ( i > b ) count = count + 1 ; if ( ( y * y == n && y > b ) ) count = count - 1 ; if ( ( y * y == n && y > b ) ) count = count - 1 ; } } }

36.55
33.49
37.64
35.61
def divisibleBy20 ( num ) : lastTwoDigits = int ( num [ - 2 : ] ) return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) )

static Boolean divisibleBy20 ( String num ) { int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }

static boolean divisibleBy20 ( String num ) { int lastTwoDigits = int ( num [ - 2 : ] ) ; return ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) ; }

static boolean divisibleBy20 ( int num ) { int lastTwoDigits = num . intValue ( ) ; if ( ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 ) || ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 ) ) return true ; }

36.56
70.12
83.03
82.27
def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24

static int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }

static int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 1 ) * ( n + 2 ) * ( n + 1 ) * ( n + 2 ) * ( n + 1 ) * ( n + 2 ) * ( n + 1 ) * ( n + 2 ) / 24.0 ) ; }

; static int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }

36.75
40.77
64.25
58.8
def find ( a , b , k , n1 , n2 ) : s = set ( ) for i in range ( n2 ) : s . add ( b [ i ] ) missing = 0 for i in range ( n1 ) : if a [ i ] not in s : missing += 1 if missing == k : return a [ i ] return - 1

static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }

static int find ( int [ ] a , int [ ] b , int k ) { int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( a [ i ] in s ) { missing += 1 if ( missing == k ) return a [ i ] ; } } return - 1 ; }

; } static int find ( int a , int b , int k , int n1 , int n2 ) { Set s = new HashSet ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( a [ i ] != null ) s . add ( a [ i ] ) ; else if ( b [ i ] != null ) s . add ( b [ i ] ) ; else if ( a [ i ] != null ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }

36.79
34.93
31.45
58.32
def addOne ( x ) : return ( - ( ~ x ) )

static int addOne ( int x ) { return ( - ( ~ x ) ) ; }

static int addOne ( int x ) { return

static int addOne ( int x ) { static int addOne ( int x ) { System . out . println ( "addOne(" + x + ")" ) ; } }

36.79
35.88
100.0
100.0
def find_Area ( r ) : return ( 2 * r * r )

static int find_Area ( int r ) { return ( 2 * r * r ) ; }

static int find_Area ( int r ) { return

static int find_Area ( int r ) { return ( 2 * r * r ) ; }

36.83
41.87
40.33
36.18
def rearrangeArray ( arr , n ) : arr . sort ( ) tempArr = [ 0 ] * ( n + 1 ) ArrIndex = 0 i = 0 j = n - 1 while ( i <= n // 2 or j > n // 2 ) : tempArr [ ArrIndex ] = arr [ i ] ArrIndex = ArrIndex + 1 tempArr [ ArrIndex ] = arr [ j ] ArrIndex = ArrIndex + 1 i = i + 1 j = j - 1 for i in range ( 0 , n ) : arr [ i ] = tempArr [ i ]

static void rearrangeArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int [ ] tempArr = new int [ n ] ; int ArrIndex = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { if ( ArrIndex < n ) { tempArr [ ArrIndex ] = arr [ i ] ; ArrIndex ++ ; } if ( ArrIndex < n ) { tempArr [ ArrIndex ] = arr [ j ] ; ArrIndex ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ i ] ; }

static void rearrangeArray ( int arr [ ] , int n ) { int tempArr [ ] = new int [ n + 1 ] ; int ArrIndex = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { tempArr [ ArrIndex ] = arr [ i ] ; ArrIndex = ArrIndex + 1 tempArr [ ArrIndex ] = arr [ j ] ; ArrIndex = ArrIndex + 1 } return arr ; }

static void rearrangeArray ( int arr [ ] , int n ) { int ArrIndex = 0 ; int i = 0 ; int j = n - 1 ; while ( i <= n // 2 || j > n // 2 ) { tempArr [ ArrIndex ] = arr [ i ] ; ArrIndex = ArrIndex + 1 ; tempArr [ ArrIndex ] = arr [ j ] ; ArrIndex = ArrIndex + 1 ; i = i + 1 ; j = j - 1 ; for ( i = i + 1 ; i <= n ; i ++ ) { tempArr [ ArrIndex ] = arr [ i ] ; ArrIndex = ArrIndex + 1 ; i = i + 1 j = j - 1 ; for ( i in range ( 0 , n ) ; arr [ i ] = tempArr [ i ] ; arr [ j ] = tempArr [ j ] ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } }

36.85
42.58
47.31
48.54
def sort012 ( a , arr_size ) : lo = 0 hi = arr_size - 1 mid = 0 while mid <= hi : if a [ mid ] == 0 : a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] lo = lo + 1 mid = mid + 1 elif a [ mid ] == 1 : mid = mid + 1 else : a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] hi = hi - 1

static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } }

static void sort012 ( int [ ] a , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { if ( a [ mid ] == 0 ) mid = mid + 1 ; else { a [ mid ] , a [ mid ] = a [ mid ] , a [ mid ] ; lo = mid + 1 ; } } return ; }

private static void sort012 ( int [ ] a , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( lo <= hi ) { if ( a [ lo ] == 0 ) a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] ; else a [ lo ] = a [ lo ] , a [ mid ] ; lo = lo + 1 ; mid = mid + 1 ; } while ( mid <= arr_size - 1 ) { a [ lo ] , a [ mid ] = a [ lo ] , a [ mid ] ; lo = lo + 1 ; mid = mid + 1 ; } }

36.91
39.32
45.59
48.82
def lexicographicSubConcat ( s ) : n = len ( s ) sub_count = ( n * ( n + 1 ) ) // 2 arr = [ 0 ] * sub_count index = 0 for i in range ( n ) : for j in range ( 1 , n - i + 1 ) : arr [ index ] = s [ i : i + j ] index += 1 arr . sort ( ) res = "" for i in range ( sub_count ) : res += arr [ i ] return res

static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . substring ( i , i + len ) ; } Arrays . sort ( arr ) ; String res = "" ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }

static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int arr [ ] = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < sub_count ; j ++ ) { res += s [ i : i + j ] ; index ++ ; } } return res ; }

static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = ( n * ( n + 1 ) ) / 2 ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { arr [ index ] = s [ i : i + j ] ; index ++ ; arr . sort ( ) ; res += arr [ index ] ; } } return res ; }

37.0
40.38
40.25
45.02
def convertOpposite ( str ) : ln = len ( str ) for i in range ( ln ) : if str [ i ] >= 'a' and str [ i ] <= 'z' : str [ i ] = chr ( ord ( str [ i ] ) - 32 ) elif str [ i ] >= 'A' and str [ i ] <= 'Z' : str [ i ] = chr ( ord ( str [ i ] ) + 32 )

static void convertOpposite ( StringBuffer str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { Character c = str . charAt ( i ) ; if ( Character . isLowerCase ( c ) ) str . replace ( i , i + 1 , Character . toUpperCase ( c ) + "" ) ; else str . replace ( i , i + 1 , Character . toLowerCase ( c ) + "" ) ; } }

static void convertOpposite ( String str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str [ i ] >= 'a' and str [ i ] <= 'z' ) str [ i ] = chr ( str [ i ] - 32 ) + 'a' ; else str [ i ] = chr ( str [ i ] - 32 ) + 'a' ; else str [ i ] =

static void convertOpposite ( String str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) str [ i ] = chr ( ord ( str [ i ] ) - 32 ) ; else str [ i ] = chr ( ord ( str [ i ] ) + 32 ) ; } }

37.01
41.77
49.25
41.03
def printDistinct ( str ) : count = [ 0 ] * NO_OF_CHARS for i in range ( len ( str ) ) : if ( str [ i ] != '' ) : count [ ord ( str [ i ] ) ] += 1 n = i for i in range ( n ) : if ( count [ ord ( str [ i ] ) ] == 1 ) : print ( str [ i ] , end = "" )

static void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) != ' ' ) count [ ( int ) str . charAt ( i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str . charAt ( i ) ] == 1 ) System . out . print ( str . charAt ( i ) ) ; }

static void printDistinct ( String str ) { int count [ ] = 0 ; int n = 0 ; for ( int i = 0 ; i < len ( str ) ; i ++ ) { if ( count [ ord ( str [ i ] ) ] == 1 ) { print ( str [ i ] , end = "" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ ord ( str [ i ] ) ] == 0 ) {

static void printDistinct ( String str ) { int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != '' ) count [ ord ( str [ i ] ) ] += 1 ; n = i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( count [ ord ( str [ i ] ) ] == 1 ) { print ( str [ i ] , end = "" ) ; } } } }

37.08
44.38
69.01
68.97
def MaxTotalRectangleArea ( a , n ) : a . sort ( reverse = True ) sum = 0 flag = False len = 0 i = 0 while ( i < n - 1 ) : if ( i != 0 ) : i = i + 1 if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : flag = True len = a [ i + 1 ] i = i + 1 elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : sum = sum + a [ i + 1 ] * len flag = False i = i + 1 return sum

static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }

static int MaxTotalRectangleArea ( int [ ] a , int n ) { int sum = 0 ; int i = 0 ; while ( i < n ) { if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 0 ) and flag == True ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i = i + 1 ; } } return sum ; }

static int MaxTotalRectangleArea ( int a [ ] , int n ) { int sum = 0 ; int flag = false ; int len = 0 ; int i = 0 ; while ( i < n - 1 ) { if ( i != 0 ) i = i + 1 ; if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) { flag = true len = a [ i + 1 ] i = i + 1 ; if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) { sum = sum + a [ i + 1 ] * len ; flag = false i = i + 1 ; } } } return sum ; }

37.12
49.32
26.24
48.44
def to_upper ( string ) : for i in range ( len ( string ) ) : if ( 'a' <= string [ i ] <= 'z' ) : string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] ) return string

static String to_upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) { if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) { in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) ; } } return String . valueOf ( in ) ; }

static String to_upper ( String string ) { for ( int i = 0 ; i < len ( string ) ; i ++ ) { if ( 'a' <= string [ i ] <= 'z' ) string = ( string [ 0 : i ] + 'a' ) + 'A' ; else string = ( string [ 0 : i ] + 'a' ) + 'A' ; else string = ( string [ i ] + 'z' ) + string [

; } static String to_upper ( String string ) { for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( 'a' <= string [ i ] <= 'z' ) { string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] ) ; } else if ( 'a' <= string [ i ] <= 'z' ) { string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] ) ; } } return string ; }

37.12
37.51
43.82
50.99
def calculate ( N ) : length = len ( N ) l = int ( ( length ) / 2 ) count = 0 for i in range ( l + 1 ) : s = N [ 0 : 0 + i ] l1 = len ( s ) t = N [ i : l1 + i ] try : if s [ 0 ] == '0' or t [ 0 ] == '0' : continue except : continue if s == t : count += 1 return count

static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; }

static int calculate ( String N ) { int length = N . length ( ) ; int l = int ( length / 2 ) ; for ( int i = 0 ; i < l ; i ++ ) { String s = N [ 0 : 0 + i ] ; String t = N [ i : l1 + i ] ; try : if ( s [ 0 ] == '0' or t [ 0 ] == '0' ) continue ; if ( t == '0' ) continue ;

static int calculate ( String [ ] N ) { int length = len ( N ) ; int l = int ( length / 2 ) ; int count = 0 ; for ( int i = 0 ; i < l ; i ++ ) { String s = N [ 0 : 0 + i ] ; int l1 = len ( s ) ; String t = N [ i : l1 + i ] try { if ( s [ 0 ] == '0' || t [ 0 ] == '0' ) continue ; if ( s == t ) count ++ ; else if ( s == t ) count ++ ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return count ; }

37.13
38.95
39.97
41.58
def check ( degree , n ) : deg_sum = sum ( degree ) if ( 2 * ( n - 1 ) == deg_sum ) : return True else : return False

static boolean check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { deg_sum += degree [ i ] ; } return ( 2 * ( n - 1 ) == deg_sum ) ; }

static boolean check ( int degree [ ] , int n ) { int deg_sum = degree . sum ( ) ; if ( 2 * n == deg_sum ) { return true ; } else { return false ; } }

static boolean check ( int degree , int n ) { int deg_sum = sum ( degree ) ; if ( 2 * ( n - 1 ) == deg_sum ) return true ; else return false ; }

37.13
40.57
39.79
41.45
def findVolume ( l , b , h ) : return ( ( l * b * h ) / 2 )

static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }

static int findVolume ( int l , int b , int h ) { return ( l * b * h ) / 2

private static int findVolume ( int l , int b , int h ) { return ( ( l * b * h ) / 2 ) ; }

37.15
46.11
48.76
54.23
def isLucky ( n ) : next_position = n if isLucky . counter > n : return 1 if n % isLucky . counter == 0 : return 0 next_position = next_position - next_position / isLucky . counter isLucky . counter = isLucky . counter + 1 return isLucky ( next_position )

static boolean isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }

static int isLucky ( int n ) { int next_position = isLucky . counter ; isLucky . counter ++ ; return isLucky ( next_position ) ; }  def isLucky ( int n ) { int next_position = n - isLucky . counter ; isLucky . counter ++ ; if ( next_position % isLucky . counter == 0 ) return 0 ; isLucky . counter ++ ; isLucky .

static int isLucky ( int n ) { int next_position = n ; if ( isLucky . counter > n ) return 1 ; next_position = next_position - next_position / isLucky . counter ; isLucky . counter = isLucky . counter + 1 ; return isLucky ( next_position ) ; }

37.17
43.42
61.92
56.66
def printSmall ( arr , n , k ) : for i in range ( k , n ) : max_var = arr [ k - 1 ] pos = k - 1 for j in range ( k - 2 , - 1 , - 1 ) : if ( arr [ j ] > max_var ) : max_var = arr [ j ] pos = j if ( max_var > arr [ i ] ) : j = pos while ( j < k - 1 ) : arr [ j ] = arr [ j + 1 ] j += 1 arr [ k - 1 ] = arr [ i ] for i in range ( 0 , k ) : print ( arr [ i ] , end = "" )

public static void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

static void printSmall ( int arr [ ] , int n , int k ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ j ] > max_var ) max_var = arr [ j ] ; pos = j ; if ( max_var > arr [ j ] ) { arr [ j ] = arr [ j + 1 ] ; } } }

static void printSmall ( int arr [ ] , int n , int k ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; if ( max_var > arr [ i ] ) { j = pos ; while ( j < k - 1 ) arr [ j ] = arr [ j + 1 ] j += 1 ; arr [ k - 1 ] = arr [ j + 1 ] ; j += 1 ; arr [ k - 1 ] = arr [ i ] ; } } } }

37.17
41.58
38.66
43.2
def printGrouped ( string ) : n = len ( string ) count = [ 0 ] * MAX_CHAR for i in range ( n ) : count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1 for i in range ( n ) : while count [ ord ( string [ i ] ) - ord ( "a" ) ] : print ( string [ i ] , end = "" ) count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1 count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0

static void printGrouped ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str . charAt ( i ) - 'a' ] != 0 ) { System . out . print ( str . charAt ( i ) ) ; count [ str . charAt ( i ) - 'a' ] -- ; } count [ str . charAt ( i ) - 'a' ] = 0 ; } }

static void printGrouped ( String string ) { int n = string . length ( ) ; int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { while ( count [ ord ( string [ i ] ) - ord ( "a" ) ] > 0 ) print ( string [ i ] , end = "" ) ; count [ ord ( string [ i ] ) - ord ( "a" ) ] ++ ; } }

static void printGrouped ( String string ) { int n = string . length ( ) ; int count [ ] = new int [ n ] * MAX_CHAR ; for ( int i = 0 ; i < n ; i ++ ) { count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1 ; while ( count [ ord ( string [ i ] ) - ord ( "a" ) ] ) { print ( string [ i ] , end = "" ) ; count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1 count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0 ; } } }

37.21
38.24
56.37
49.08
def leafNode ( preorder , n ) : s = [ ] i = 0 for j in range ( 1 , n ) : found = False if preorder [ i ] > preorder [ j ] : s . append ( preorder [ i ] ) else : while len ( s ) != 0 : if preorder [ j ] > s [ - 1 ] : s . pop ( - 1 ) found = True else : break if found : print ( preorder [ i ] , end = "" ) i += 1 print ( preorder [ n - 1 ] )

static void leafNode ( int preorder [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { boolean found = false ; if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ) ; else { while ( ! s . isEmpty ( ) ) { if ( preorder [ j ] > s . peek ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) System . out . print ( preorder [ i ] + " " ) ; } System . out . println ( preorder [ n - 1 ] ) ; }

static void leafNode ( int preorder [ ] , int n ) { int i = 0 ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ) ; else if ( preorder [ i ] > preorder [ j ] ) s . pop ( - 1 ) ; else if ( preorder [ j ] > s [ - 1 ] ) found =

static void leafNode ( int preorder [ ] , int n ) { String s [ ] = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { boolean found = false ; for ( int j = 1 ; j < n ; j ++ ) { if ( preorder [ i ] > preorder [ j ] ) s . append ( preorder [ i ] ) ; else if ( preorder [ j ] > s [ - 1 ] ) s . pop ( - 1 ) ; else break ; } if ( found ) { print ( preorder [ i ] , end = "" ) ; i += 1 ; print ( preorder [ n - 1 ] ) ; } } }

37.25
42.42
77.45
82.1
def myCopy ( s1 , s2 , index ) : s2 [ index ] = s1 [ index ] if ( index == len ( s1 ) - 1 ) : return myCopy ( s1 , s2 , index + 1 )

static void myCopy ( char s1 [ ] , char s2 [ ] , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1 . length - 1 ) { return ; } myCopy ( s1 , s2 , index + 1 ) ; }

static int myCopy ( int [ ] s1 , int [ ] s2 , int index ) { if ( index < len ( s1 ) ) return - 1 ; return myCopy ( s1 , s2 , index + 1 ) ; } return 0 ; }

static int myCopy ( int s1 [ ] , int s2 [ ] , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1 . length - 1 ) return myCopy ( s1 , s2 , index + 1 ) ; }

37.28
36.57
55.29
52.17
def printBracketNumber ( exp , n ) : left_bnum = 1 right_bnum = list ( ) for i in range ( n ) : if exp [ i ] == '(' : print ( left_bnum , end = "" ) right_bnum . append ( left_bnum ) left_bnum += 1 elif exp [ i ] == ')' : print ( right_bnum [ - 1 ] , end = "" ) right_bnum . pop ( )

static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; Stack < Integer > right_bnum = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == '(' ) { System . out . print ( left_bnum + " " ) ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ')' ) { System . out . print ( right_bnum . peek ( ) + " " ) ; right_bnum . pop ( ) ; } } }

static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; int right_bnum = list ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == '(' ) left_bnum ++ ; else if ( exp [ i ] == ')' ) right_bnum . append ( right_bnum [ - 1 ] ) right_bnum . pop ( ) ; else left

static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; int right_bnum = list ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == '(' ) { print ( left_bnum , end = "" ) ; right_bnum . append ( left_bnum ) ; left_bnum ++ ; } else if ( exp [ i ] == ')' ) { print ( right_bnum [ - 1 ] , end = "" ) ; right_bnum . pop ( ) ; } } }

37.36
38.18
37.51
30.71
def checkCorrectOrNot ( s ) : global MAX_CHAR count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR n = len ( s ) if n == 1 : return true i = 0 j = n - 1 while ( i < j ) : count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 i += 1 j -= 1 for i in range ( MAX_CHAR ) : if count1 [ i ] != count2 [ i ] : return False return True

static boolean checkCorrectOrNot ( String s ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - 'a' ] ++ ; count2 [ s . charAt ( j ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }

static boolean checkCorrectOrNot ( String s ) { int i , j ; int count1 [ ] = new int [ MAX_CHAR ] ; int count2 [ ] = new int [ MAX_CHAR ] ; for ( i = 0 ; i < n ; i ++ ) { if ( count1 [ i ] != count2 [ i ] ) return false ; for ( i = 0 ; i < j ; i ++ ) { if ( count1 [ i ] != count2

static boolean checkCorrectOrNot ( String s ) { int i = 0 ; int j = n - 1 ; while ( i < j ) { count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] ++ ; count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] ++ ; i ++ ; j -- ; } for ( int i = 0 ; i < j ; i ++ ) { count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] ++ ; } return true ; }

37.39
34.21
45.38
50.43
def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if ( B [ i ] == 1 ) : j = i while ( B [ j ] == 1 ) : j = j + 1 A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] i = j for i in range ( 0 , n ) : if ( A [ i ] != i + 1 ) : return False return True

static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }

static boolean sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { int i = 0 ; int j = 0 ; while ( B [ i ] == 1 ) { i = i + 1 ; while ( A [ i ] == 1 ) { j = j + 1 ; while ( B [ j ] == 1 ) { i = i + 1 ; while ( A [ i ] == 1 ) { j = j + 1 ; } } } return

static boolean sortedAfterSwap ( int A , int B , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( B [ i ] == 1 ) { j = i ; while ( B [ j ] == 1 ) { j = j + 1 ; A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 ] ; i = j + 1 ; } } } return true ; }

37.41
37.77
41.55
37.35
def findPair ( arr , n ) : s = { i : 1 for i in arr } found = False for i in range ( n ) : for j in range ( i + 1 , n ) : if arr [ i ] + arr [ j ] in s . keys ( ) : print ( arr [ i ] , arr [ j ] ) found = True if found == False : print ( "Notexist" )

public static void findPair ( int [ ] arr , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( Integer i : arr ) { s . add ( i ) ; } boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( s . contains ( sum ) ) { found = true ; System . out . println ( arr [ i ] + " " + arr [ j ] ) ; } } } if ( found == false ) System . out . println ( "Not Exist " ) ; }

static void findPair ( int [ ] arr , int n ) { int found = false ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] + arr [ j ] in s . keys ( ) ) found = true ; else if ( found == false ) { print ( arr [ i ] , arr [ j ] ) ; found =

static void findPair ( int arr [ ] , int n ) { int s = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] + arr [ j ] in s . keys ( ) ) { if ( arr [ i ] + arr [ j ] == s . get ( arr [ i ] + arr [ j ] ) ) found = true ; if ( arr [ i ] + arr [ j ] in s . keys ( ) ) { print ( arr [ i ] , arr [ j ] ) ; found = true ; } } } } return ; }

37.42
41.84
46.87
43.97
def printPrevSmaller ( arr , n ) : print ( "_," , end = "" ) for i in range ( 1 , n ) : for j in range ( i - 1 , - 2 , - 1 ) : if ( arr [ j ] < arr [ i ] ) : print ( arr [ j ] , "," , end = "" ) break if ( j == - 1 ) : print ( "_," , end = "" )

static void printPrevSmaller ( int [ ] arr , int n ) { System . out . print ( "_, " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { System . out . print ( arr [ j ] + ", " ) ; break ; } } if ( j == - 1 ) System . out . print ( "_, " ) ; } }

static void printPrevSmaller ( int arr [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] < arr [ j ] ) { print ( arr [ i ] , "," , end = "" ) break if ( j == - 2 ) { print ( arr [ i ] , "," , end = "" ) break if ( j == - 1 ) { print ( arr [ i ] , "," , end

static void printPrevSmaller ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ j ] ) { if ( arr [ j ] > arr [ i ] ) { print ( arr [ j ] , "," , end = "" ) ; } } if ( j == - 1 ) { print ( "_," , end = "" ) ; } } }

37.43
44.09
70.93
66.89
def isRectangle ( m ) : rows = len ( m ) if ( rows == 0 ) : return False columns = len ( m [ 0 ] ) for y1 in range ( rows ) : for x1 in range ( columns ) : if ( m [ y1 ] [ x1 ] == 1 ) : for y2 in range ( y1 + 1 , rows ) : for x2 in range ( x1 + 1 , columns ) : if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : return True return False

static boolean isRectangle ( int m [ ] [ ] ) { int rows = m . length ; if ( rows == 0 ) return false ; int columns = m [ 0 ] . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) for ( int x1 = 0 ; x1 < columns ; x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) for ( int x2 = x1 + 1 ; x2 < columns ; x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; return false ; }

static boolean isRectangle ( int [ ] m ) { int rows = m . length ; int columns = m . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) { for ( int x1 = 0 ; x1 < columns ; x1 ++ ) { if ( m [ y1 ] [ x1 ] == 1 ) { for ( int y2 = 0 ; y2 < rows ; y2 ++ ) { if ( m [

static boolean isRectangle ( int [ ] m ) { int rows = m . length ; int columns = m . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) { for ( int x1 = 0 ; x1 < columns ; x1 ++ ) { if ( m [ y1 ] [ x1 ] == 1 ) { for ( int y2 = 0 ; y2 < rows ; y2 ++ ) { if ( m [ y2 ] [ x2 ] == 1 ) { for ( int x2 = 0 ; x2 < columns ; x2 ++ ) { if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) { return true ; } } } } } return false ; } return false ; }

37.52
37.19
70.85
64.17
def isSubSeqDivisible ( st ) : l = len ( st ) arr = [ 0 ] * l for i in range ( 0 , l ) : for j in range ( i , l ) : for k in range ( j , l ) : if ( arr [ i ] % 8 == 0 ) : return True elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : return True elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : return True return False

static boolean isSubSeqDivisible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }

static boolean isSubSeqDivisible ( int st [ ] ) { int arr [ ] = new int [ l ] ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < l ; j ++ ) { if ( arr [ i ] % 8 == 0 ) { if ( arr [ i ] * 10 + arr [ j ] * 100 + arr [ k ] ) % 8 == 0 and i != j && j !=

static boolean isSubSeqDivisible ( int st [ ] ) { int l = st . length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < l ; j ++ ) { for ( int k = 0 ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 ) return true ; if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) ) return true ; } } return false ; }

37.62
50.25
56.28
62.45
def shortestPath ( graph , u , v , k ) : V = 4 INF = 999999999999 if k == 0 and u == v : return 0 if k == 1 and graph [ u ] [ v ] != INF : return graph [ u ] [ v ] if k <= 0 : return INF res = INF for i in range ( V ) : if graph [ u ] [ i ] != INF and u != i and v != i : rec_res = shortestPath ( graph , i , v , k - 1 ) if rec_res != INF : res = min ( res , graph [ u ] [ i ] + rec_res ) return res

int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }

static int shortestPath ( int [ ] graph , int u , int v , int k ) { int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { int rec_res = shortestPath ( graph , u , v , k - 1 ) ; if ( rec_res != INF ) res = min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }

static int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { res = shortestPath ( graph , i , v , k - 1 ) ; if ( res != INF ) res = min ( res , graph [ u ] [ i ] + res ) ; } } return res ; }

37.63
50.06
54.83
62.47
def query ( s , i , j ) : n = len ( s ) i %= n j %= n print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" )

static void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }

static void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n j %= n print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" ) return ; }  static void query ( String s , int i , int j ) { String s = s . split ( " " ) ; for ( int i = 0 ; i < n ; i ++ ) { if

static void query ( String s , int i , int j ) { int n = s . length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) { print ( "Yes" ) ; } else if ( s [ i ] == s [ j ] ) { print ( "No" ) ; } }

37.69
41.06
51.18
45.47
def sumofFactors ( n ) : if ( n % 2 != 0 ) : return 0 res = 1 for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : count = 0 curr_sum = 1 curr_term = 1 while ( n % i == 0 ) : count = count + 1 n = n // i if ( i == 2 and count == 1 ) : curr_sum = 0 curr_term = curr_term * i curr_sum = curr_sum + curr_term res = res * curr_sum if ( n >= 2 ) : res = res * ( 1 + n ) return res

public static int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }

static int sumofFactors ( int n ) { int res = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count = count + 1 ; if ( count == 1 ) { curr_sum = curr_sum + curr_term ; } else { curr_sum = curr_sum + curr_term ;

static int sumofFactors ( int n ) { int res = 1 ; int count = 0 ; int curr_sum = 1 ; curr_term = 1 ; while ( n % i == 0 ) { count = count + 1 ; n = n // i ; if ( i == 2 && count == 1 ) { curr_sum = 0 ; curr_term = curr_term * i ; curr_sum = curr_sum + curr_term ; } res = res * curr_sum ; if ( n >= 2 ) res = res * ( 1 + n ) ; } return res ; }

37.7
38.52
53.3
45.28
def productArray ( arr , n ) : if n == 1 : print ( 0 ) return i , temp = 1 , 1 prod = [ 1 for i in range ( n ) ] for i in range ( n ) : prod [ i ] = temp temp *= arr [ i ] temp = 1 for i in range ( n - 1 , - 1 , - 1 ) : prod [ i ] *= temp temp *= arr [ i ] for i in range ( n ) : print ( prod [ i ] , end = "" ) return

void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( "0" ) ; return ; } int i , temp = 1 ; int prod [ ] = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) prod [ j ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " " ) ; return ; }

static int productArray ( int arr [ ] , int n ) { int i = 1 ; int temp = 1 ; for ( int i = 0 ; i < n ; i ++ ) { prod [ i ] *= arr [ i ] ; temp *= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == n - 1 ) prod [ i ] *= temp ; temp *= arr [ i ] ; } return i ;

int productArray ( int arr [ ] , int n ) { int i = 1 ; int temp = 1 ; int prod [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { prod [ i ] *= arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { prod [ i ] *= temp ; } for ( int i = 0 ; i < n ; i ++ ) { prod [ i ] *= arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { prod [ i ] *= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { prod [ i ] *= arr [ i ] ; } return i ; }

37.71
45.5
35.37
48.13
def generate_derangement ( N ) : S = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : S [ i ] = i D = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 , 2 ) : if i == N : D [ N ] = S [ N - 1 ] D [ N - 1 ] = S [ N ] else : D [ i ] = i + 1 D [ i + 1 ] = i for i in range ( 1 , N + 1 ) : print ( D [ i ] , end = "" ) print ( )

static void generate_derangement ( int N ) { int S [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " " ) ; System . out . println ( ) ; }

static void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; int [ ] D = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == N ) D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; D [ N ] = S [ N ] ; D [ N ] = i ; } }

static void generate_derangement ( int N ) { int S [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { D [ i ] = S [ i ] ; D [ i + 1 ] = S [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { D [ i ] = S [ i ] ; D [ i + 1 ] = S [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { D [ i ] = S [ i ] ; D [ i + 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { D [ i ] = S [ i ] ; D [ i + 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { D [ i ] = S [ i ] ; D [ i + 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { D [ i ] = S [ i ] ; D [ i + 1 ] = i ; } }

37.75
43.59
67.31
57.84
def count9s ( number ) : n = len ( number ) d = [ 0 for i in range ( 9 ) ] d [ 0 ] = 1 result = 0 mod_sum = 0 continuous_zero = 0 for i in range ( n ) : if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : continuous_zero += 1 else : continuous_zero = 0 mod_sum += ord ( number [ i ] ) - ord ( '0' ) mod_sum %= 9 result += d [ mod_sum ] d [ mod_sum ] += 1 result -= continuous_zero return result

static int count9s ( char number [ ] ) { int n = number . length ; int d [ ] = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( number [ i ] - '0' ) == 0 ) { continuous_zero ++ ; } else { continuous_zero = 0 ; } mod_sum += ( number [ i ] - '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; }

static int count9s ( String number ) { int n = number . length ( ) ; int d [ ] = new int [ 9 ] ; for ( int i = 0 ; i < n ; i ++ ) { int mod_sum = 0 ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] += 1 ; } return result ; }

static int count9s ( int number ) { int n = number . length ( ) ; int d [ 0 ] = 1 ; int result = 0 ; mod_sum = 0 ; continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) { continuous_zero += 1 ; } else { continuous_zero += 0 ; } mod_sum += ord ( number [ i ] ) - ord ( '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] d [ mod_sum ] += 1 ; result -= continuous_zero ; } } return result ; }

37.79
43.56
66.07
60.45
def bonacciseries ( n , m ) : a = [ 0 for i in range ( m ) ] a [ n - 1 ] = 1 a [ n ] = 1 for i in range ( n + 1 , m ) : a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] for i in range ( 0 , m ) : print ( a [ i ] , end = "" )

static void bonacciseries ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = 0 ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

static void bonacciseries ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = 2 * a [ i - 1 ] + a [ i - n - 1 ] - a [ i - n - 1 ] ; } return a ; }

static void bonacciseries ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; } } } }

37.81
42.92
34.51
34.93
def printTwoElements ( arr , size ) : for i in range ( size ) : if arr [ abs ( arr [ i ] ) - 1 ] > 0 : arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] else : print ( "Therepeatingelementis" , abs ( arr [ i ] ) ) for i in range ( size ) : if arr [ i ] > 0 : print ( "andthemissingelementis" , i + 1 )

static void printTwoElements ( int arr [ ] , int size ) { int i ; System . out . print ( "The repeating element is " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else System . out . println ( abs_val ) ; } System . out . print ( "And the missing element is " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } }

static void printTwoElements ( int arr [ ] , int size ) { System . out . print ( "Therepeatingelementis" , abs ( arr [ i ] ) - 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = - arr [ i ] ; else System . out . print ( "Therepeatingelementis" , i + 1 ) ; for ( int

static void printTwoElements ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else print ( "Therepeatingelementis" , abs ( arr [ i ] ) ) ; } } }

37.94
49.54
68.28
69.26
def solve ( A , n ) : cnt = 0 parent = [ None ] * ( n + 1 ) vis = [ None ] * ( n + 1 ) for i in range ( 0 , n + 1 ) : parent [ i ] = - 1 vis [ i ] = 0 for i in range ( 0 , n ) : j = i if ( parent [ j ] == - 1 ) : while ( parent [ j ] == - 1 ) : parent [ j ] = i j = ( j + A [ j ] + 1 ) % n if ( parent [ j ] == i ) : while ( vis [ j ] == 0 ) : vis [ j ] = 1 cnt = cnt + 1 j = ( j + A [ j ] + 1 ) % n return cnt

static int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; vis [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; }

static int solve ( int A [ ] , int n ) { int cnt = 0 ; int parent [ ] = new int [ n + 1 ] ; int vis [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { while ( parent [ j ] == - 1 ) { while ( vis [ j ] == 0 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } } return cnt ; }

static int solve ( int A , int n ) { int cnt = 0 ; int parent [ ] = new int [ n + 1 ] ; int vis [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = i ; if ( parent [ j ] == - 1 ) while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 cnt = cnt + 1 j = ( j + A [ j ] + 1 ) % n ; } parent [ j ] = i ; } } } return cnt ; }

38.01
37.82
26.63
30.86
def printNos ( n ) : if n > 0 : printNos ( n - 1 ) print ( n , end = '' )

static void printNos ( int n ) { if ( n > 0 ) { printNos ( n - 1 ) ; System . out . print ( n + " " ) ; } return ; }

static void printNos ( int n ) { if ( n > 0 ) print ( '\n' , end = '' ) ; } }

static void printNos ( int n ) { System . out . println ( n . toString ( ) ) ; }

38.06
48.09
33.52
46.85
def maxDiff ( arr , n ) : SubsetSum_1 = 0 SubsetSum_2 = 0 for i in range ( 0 , n ) : isSingleOccurance = True for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : isSingleOccurance = False arr [ i ] = arr [ j ] = 0 break if ( isSingleOccurance == True ) : if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] return abs ( SubsetSum_1 - SubsetSum_2 )

static int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }

static int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 ; int SubsetSum_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } if ( isSingleOccurance == true ) { if ( arr [ i ] > 0 ) Sub

static int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 ; int SubsetSum_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } return abs ( SubsetSum_1 - SubsetSum_2 ) ; }

38.07
41.31
52.32
63.77
def lcs ( i , j , count ) : if ( i == 0 or j == 0 ) : return count if ( X [ i - 1 ] == Y [ j - 1 ] ) : count = lcs ( i - 1 , j - 1 , count + 1 ) count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) return count

static int lcs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) { return count ; } if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }

static int lcs ( int i , int j , int count ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { return lcs ( i - 1 , j - 1 , count + 1 ) ; } return lcs ( i - 1 , j - 1 , count + 1 ) ; } return 0 ; }

static int lcs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j - 1 , 0 ) ) ) ; } else { count = lcs ( i , j - 1 , count + 1 ) ; count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i , j - 1 , 0 ) ) ) ; } return count ; }

38.12
40.77
78.41
81.2
def maxRowDiff ( mat , m , n ) : rowSum = [ 0 ] * m for i in range ( 0 , m ) : sum = 0 for j in range ( 0 , n ) : sum += mat [ i ] [ j ] rowSum [ i ] = sum max_diff = rowSum [ 1 ] - rowSum [ 0 ] min_element = rowSum [ 0 ] for i in range ( 1 , m ) : if ( rowSum [ i ] - min_element > max_diff ) : max_diff = rowSum [ i ] - min_element if ( rowSum [ i ] < min_element ) : min_element = rowSum [ i ] return max_diff

static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }

static int maxRowDiff ( int [ ] mat , int m , int n ) { int [ ] rowSum = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( row

static int maxRowDiff ( int mat [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; if ( rowSum [ i ] - min_element > max_diff ) { max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } } return max_diff ; }

38.14
61.21
80.85
87.49
def lastPosition ( n , m , k ) : if ( m <= n - k + 1 ) : return m + k - 1 m = m - ( n - k + 1 ) if ( m % n == 0 ) : return n else : return m % n

static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }

static int lastPosition ( int n , int m , int k ) { int lastPosition = lastPosition ( n , m , k ) ; if ( m <= n - k + 1 ) { return m - k - 1 ; } return lastPosition ; }  static int lastPosition ( int n , int m , int k ) { int lastPosition = lastPosition ( n , int m , int k ) ; if ( m <= n - k + 1 ) { return

; } static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; if ( m % n == 0 ) return n ; else return m % n ; }

38.17
49.4
46.01
48.15
def printMinIndexChar ( Str , patt ) : minIndex = 10 ** 9 m = len ( Str ) n = len ( patt ) for i in range ( n ) : for j in range ( m ) : if ( patt [ i ] == Str [ j ] and j < minIndex ) : minIndex = j break if ( minIndex != 10 ** 9 ) : print ( "MinimumIndexCharacter=" , Str [ minIndex ] ) else : print ( "Nocharacterpresent" )

static void printMinIndexChar ( String str , String patt ) { int minIndex = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != Integer . MAX_VALUE ) System . out . println ( "Minimum Index Character = " + str . charAt ( minIndex ) ) ; else System . out . println ( "No character present" ) ; }

static void printMinIndexChar ( String Str , String patt ) { int minIndex = 10 ** 9 ; int m = len ( Str ) ; int n = len ( patt ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( patt [ i ] == Str [ j ] and j < minIndex ) { minIndex = j ; } } if ( minIndex != 10

static void printMinIndexChar ( String Str , String patt ) { int minIndex = 10 ** 9 ; int m = len ( Str ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt [ i ] == Str [ j ] && j < minIndex ) { minIndex = j ; break ; } if ( minIndex != 10 ** 9 ) { print ( "MinimumIndexCharacter=" , Str [ minIndex ] ) ; } else { print ( "Nocharacterpresent" ) ; } } } }

38.21
39.96
37.44
49.13
def modularInverse ( n , prime ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime for i in range ( 1 , n + 1 ) : print ( dp [ i ] , end = "" )

static void modularInverse ( int n , int prime ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }

static void modularInverse ( int n , int prime ) { int dp [ ] ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime ; } return dp ; }

static void modularInverse ( int n , int prime ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime ; for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = dp [ prime % i ] * ( prime - prime // i ) % prime ; } } for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime ; } for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime ; } }

38.23
41.39
56.34
50.34
def oddEvenSort ( arr , n ) : isSorted = 0 while isSorted == 0 : isSorted = 1 temp = 0 for i in range ( 1 , n - 1 , 2 ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 for i in range ( 0 , n - 1 , 2 ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 return

public static void oddEvenSort ( int arr [ ] , int n ) { boolean isSorted = false ; while ( ! isSorted ) { isSorted = true ; int temp = 0 ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } } return ; }

static int oddEvenSort ( int arr [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] ; isSorted = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i ] ) temp = temp ; temp ++ ; } return isSorted ; }

static int oddEvenSort ( int arr [ ] , int n ) { int isSorted = 0 ; while ( isSorted == 0 ) { isSorted = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] ; isSorted = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] ; isSorted = 0 ; } } } return isSorted ; }

38.27
43.6
51.74
47.48
def maxelement ( arr ) : no_of_rows = len ( arr ) no_of_column = len ( arr [ 0 ] ) for i in range ( no_of_rows ) : max1 = 0 for j in range ( no_of_column ) : if arr [ i ] [ j ] > max1 : max1 = arr [ i ] [ j ] print ( max1 )

public static void maxelement ( int no_of_rows , int [ ] [ ] arr ) { int i = 0 ; int max = 0 ; int [ ] result = new int [ no_of_rows ] ; while ( i < no_of_rows ) { for ( int j = 0 ; j < arr [ i ] . length ; j ++ ) { if ( arr [ i ] [ j ] > max ) { max = arr [ i ] [ j ] ; } } result [ i ] = max ; max = 0 ; i ++ ; } printArray ( result ) ; }

static int maxelement ( int [ ] arr ) { int no_of_rows ; int no_of_column ; for ( int i = 0 ; i < no_of_rows ; i ++ ) { int max1 = 0 ; for ( int j = 0 ; j < no_of_column ; j ++ ) if ( arr [ i ] [ j ] > max1 ) max1 = arr [ i ] [ j ] ; } return max1 ; }

static void maxelement ( int [ ] arr ) { int no_of_rows = arr . length ; int no_of_column = arr . length ; for ( int i = 0 ; i < no_of_rows ; i ++ ) { int max1 = 0 ; for ( int j = 0 ; j < no_of_column ; j ++ ) { if ( arr [ i ] [ j ] > max1 ) max1 = arr [ i ] [ j ] ; if ( arr [ i ] [ j ] > max1 ) max1 = arr [ i ] [ j ] ; } } }

38.31
41.76
47.29
45.13
def check ( st ) : n = len ( st ) if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : return False digitSum = 0 for i in range ( 0 , n ) : digitSum = digitSum + ( int ) ( st [ i ] ) return ( digitSum % 3 == 0 )

static boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }

static boolean check ( String st ) { int n = st . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digitSum = digitSum + ( int ) ( st [ i ] ) ; } return false ; }

static boolean check ( String st [ ] ) { int n = st . length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digitSum = digitSum + ( int ) st [ i ] ; digitSum = digitSum + ( int ) st [ i ] ; if ( digitSum % 3 == 0 ) return false ; } return true ; }

38.34
47.86
45.37
53.07
def findSum ( n ) : ans = 0 temp = 0 for i in range ( 1 , n + 1 ) : if temp < n : temp = i - 1 num = 1 while temp < n : if temp + i <= n : ans += i * num else : ans += ( n - temp ) * num temp += i num += 1 return ans

static int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }

static int findSum ( int n ) { int ans = 0 ; int temp = 0 ; int num = 1 ; while ( temp < n ) { if ( temp + i <= n ) { ans += ( n - temp ) * num ; } temp ++ ; } return ans ; }

static int findSum ( int n ) { int ans = 0 ; int temp = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp < n ) ans += i * num ; else ans += ( n - temp ) * num ; temp ++ ; } return ans ; }

38.41
50.18
37.28
53.41
def findArea ( r ) : PI = 3.142 return PI * ( r * r )

static double findArea ( int r ) { return PI * Math . pow ( r , 2 ) ; }

static double findArea ( double r)  double findArea ( double r ) { return PI * r

static int findArea ( int r ) { int PI = 3.142 ; return PI * ( r * r ) ; }

38.44
43.03
52.27
58.3
def countSubsequence ( s , n ) : cntG = 0 cntF = 0 result = 0 C = 0 for i in range ( n ) : if ( s [ i ] == 'G' ) : cntG += 1 result += C continue if ( s [ i ] == 'F' ) : cntF += 1 C += cntG continue else : continue print ( result )

static void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case 'G' : cntG ++ ; result += C ; break ; case 'F' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; }

static int countSubsequence ( String s , int n ) { int cntG = 0 ; int cntF = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'G' ) cntG += 1 result += cntF continue ; if ( s [ i ] == 'F' ) cntF += 1 result += cntF continue ; if ( s [ i ] == 'F' )

static void countSubsequence ( String s , int n ) { int cntG = 0 ; int cntF = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'G' ) { cntG ++ ; result += C ; } if ( s [ i ] == 'F' ) { cntF ++ ; result += cntF ; } else { continue ; } } print ( result ) ; }

38.49
42.66
72.3
67.79
def pairsInSortedRotated ( arr , n , x ) : for i in range ( n ) : if arr [ i ] > arr [ i + 1 ] : break l = ( i + 1 ) % n r = i cnt = 0 while ( l != r ) : if arr [ l ] + arr [ r ] == x : cnt += 1 if l == ( r - 1 + n ) % n : return cnt l = ( l + 1 ) % n r = ( r - 1 + n ) % n elif arr [ l ] + arr [ r ] < x : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return cnt

static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }

static int pairsInSortedRotated ( int arr [ ] , int n ) { int l = 0 ; int r = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] > x ) l = ( l + 1 ) % n ; else r = ( r - 1 ) % n ; } return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ l ] + arr [ r ] < x ) return cnt ; }

int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int l = ( i + 1 ) % n ; int r = ( i + 1 ) % n ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) cnt += 1 ; if ( l == ( r - 1 + n ) % n ) return cnt ; l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }

38.51
46.48
42.19
48.15
def findLarger ( arr , n ) : x = sorted ( arr ) for i in range ( n / 2 , n ) : print ( x [ i ] ) ,

static void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " " ) ; }

static void findLarger ( int arr , int n ) { int i = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] > arr [ i ] ) { print ( arr [ i ] ) ; } } }

static void findLarger ( int arr [ ] , int n ) { int x [ ] = new int [ n / 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = arr [ i ] ; } }

38.52
40.94
56.07
62.58
def kth ( arr1 , arr2 , m , n , k ) : sorted1 = [ 0 ] * ( m + n ) i = 0 j = 0 d = 0 while ( i < m and j < n ) : if ( arr1 [ i ] < arr2 [ j ] ) : sorted1 [ d ] = arr1 [ i ] i += 1 else : sorted1 [ d ] = arr2 [ j ] j += 1 d += 1 while ( i < m ) : sorted1 [ d ] = arr1 [ i ] d += 1 i += 1 while ( j < n ) : sorted1 [ d ] = arr2 [ j ] d += 1 j += 1 return sorted1 [ k - 1 ]

static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }

static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int d = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ] = arr1 [ i ] ; j += 1 ; while ( j < n ) { sorted1 [ d ] = arr2 [ j ] ; j +=

static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ ] = new int [ m + n ] ; int d = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( arr1 [ i ] < arr2 [ j ] ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ] = arr1 [ i ] ; else sorted1 [ d ] = arr2 [ j ] ; } else sorted1 [ d ] = arr2 [ j ] ; } d += 1 while ( i < m ) { sorted1 [ d ] = arr1 [ i ] ; d += 1 i ++ ; } while ( j < n ) { sorted1 [ d ] = arr2 [ j ] ; d += 1 ; } } return sorted1 [ k - 1 ] ; }

38.57
39.78
62.48
58.66
def minSumPath ( A ) : memo = [ None ] * len ( A ) n = len ( A ) - 1 for i in range ( len ( A [ n ] ) ) : memo [ i ] = A [ n ] [ i ] for i in range ( len ( A ) - 2 , - 1 , - 1 ) : for j in range ( len ( A [ i ] ) ) : memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ]

static int minSumPath ( ) { int [ ] memo = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }

static int minSumPath ( int [ ] A ) { int [ ] memo = new int [ len ( A ) ] ; for ( int i = 0 ; i < len ( A ) ; i ++ ) { for ( int j = 0 ; j < len ( A [ i ] ) ; j ++ ) { if ( memo [ j ] < memo [ j + 1 ] ) return memo [ j ] ; } return memo [ 0 ] ; } return memo [ 0 ] ; }

static int minSumPath ( int [ ] A ) { int [ ] memo = new int [ len ( A ) ] ; int n = len ( A ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { memo [ i ] = A [ n ] [ i ] ; for ( int j = 0 ; j < len ( A [ i ] ) ; j ++ ) { memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; } } return memo [ 0 ] ; }

38.6
40.95
50.55
37.69
def findMaximum ( arr , low , high ) : if low == high : return arr [ low ] if high == low + 1 and arr [ low ] >= arr [ high ] : return arr [ low ] if high == low + 1 and arr [ low ] < arr [ high ] : return arr [ high ] mid = ( low + high ) // 2 if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : return arr [ mid ] if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : return findMaximum ( arr , low , mid - 1 ) else : return findMaximum ( arr , mid + 1 , high )

static int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }

static int findMaximum ( int [ ] arr , int low , int high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] ) return arr [ mid ] ; if ( arr [ mid ] < arr [ mid -

static int findMaximum ( int arr [ ] , int low , int high ) { int mid = ( low + high ) // 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid - 1 ] ; return findMaximum ( arr , mid + 1 , high ) ; }

38.66
44.57
45.12
49.96
def nextfit ( weight , c ) : res = 0 rem = c for _ in range ( len ( weight ) ) : if rem >= weight [ _ ] : rem = rem - weight [ _ ] else : res += 1 rem = c - weight [ _ ] return res

static int nextFit ( int weight [ ] , int n , int c ) { int res = 0 , bin_rem = c ; for ( int i = 0 ; i < n ; i ++ ) { if ( weight [ i ] > bin_rem ) { res ++ ; bin_rem = c - weight [ i ] ; } else bin_rem -= weight [ i ] ; } return res ; }

static int nextfit ( int weight [ ] , int c ) { int res = 0 ; int rem = c ; for ( int _ = 0 ; _ < len ( weight ) ; _ ++ ) { if ( rem >= weight [ _ ] ) res += 1 ; else res += 1 ; } return res ; }

static int nextfit ( int weight [ ] , int c ) { int res = 0 ; int rem = c ; for ( int _ = 0 ; _ < weight . length ; _ ++ ) { if ( rem >= weight [ _ ] ) rem = rem - weight [ _ ] ; else res += 1 ; rem = c - weight [ _ ] ; } return res ; }

38.67
46.19
73.24
79.89
def offeringNumber ( n , templeHeight ) : sum = 0 for i in range ( n ) : left = 0 right = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : left += 1 else : break for j in range ( i + 1 , n ) : if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : right += 1 else : break sum += max ( right , left ) + 1 return sum

static int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }

static int offeringNumber ( int n , int [ ] templeHeight ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int left = 0 ; int right = 0 ; for ( int j = i ; j <= n ; j ++ ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) { left += 1 ; } else { right += 1 ; } } return sum ; }

static int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int left = 0 ; int right = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) { left ++ ; } else { break ; } for ( int j = i + 1 ; j < n ; j ++ ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) { right ++ ; } } sum += max ( right , left ) + 1 ; } } return sum ; }

38.72
45.44
58.83
75.34
def findTrailingZeros ( n ) : count = 0 i = 5 while ( n / i >= 1 ) : count += int ( n / i ) i *= 5 return int ( count )

static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }

static int findTrailingZeros ( int n ) { int count = 0 ; while ( n / i >= 1 ) count ++ ; }

static int findTrailingZeros ( int n ) { int count = 0 ; int i = 5 ; while ( n / i >= 1 ) { count += int ( n / i ) ; i *= 5 ; } return count ; }

38.73
47.45
24.56
38.05
def digitsNum ( N ) : if ( N == 0 ) : print ( "0" , end = "" ) if ( N % 9 != 0 ) : print ( N % 9 , end = "" ) for i in range ( 1 , int ( N / 9 ) + 1 ) : print ( "9" , end = "" ) for i in range ( 1 , N + 1 ) : print ( "0" , end = "" ) print ( )

static void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( "" ) ; }

static void digitsNum ( int N ) { if ( N % 10 != 0 ) { print ( N % 10 , end = "" ) ; for ( int i = 1 ; i <= int ( N / 10 ) + 1 ) { print ( "0" , end = "" ) for ( int i = 1 ; i <= N ; i ++ ) { print ( "9" , end = "" ) for ( int i = 1 ; i <= N ; i ++ ) {

static void digitsNum ( int N ) { if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } else if ( N == 0 ) { System . out . print ( "0" ) ; } }

38.82
65.61
77.47
75.17
def numOfways ( n , k ) : p = 1 if ( k % 2 ) : p = - 1 return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n

static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }

static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = - 1 ; if ( p == 1 ) p = - 1 ; return ( n - 1 ) / ( n - 1 ) + p * ( n - 1 ) + p * ( n - 1 ) + p * ( n - 1 ) + p * ( n - 1 ) + p * ( n - 1 ) + p * ( n - 1 ) ; }

numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = - 1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }

38.89
45.47
67.97
67.48
def findLength ( str ) : n = len ( str ) maxlen = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n , 2 ) : length = j - i + 1 leftsum = 0 rightsum = 0 for k in range ( 0 , int ( length / 2 ) ) : leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) ) if ( leftsum == rightsum and maxlen < length ) : maxlen = length return maxlen

static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str . charAt ( i + k ) - '0' ) ; rightsum += ( str . charAt ( i + k + length / 2 ) - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }

static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rightsum = 0 ; for ( int k = 0 ; k < length ; k ++ ) { if ( leftsum == rightsum && maxlen < length ) { maxlen = length ; } } } return maxlen ; }

int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; int length = j - i + 1 ; int leftsum = 0 ; int rightsum = 0 ; for ( int k = 0 ; k < int ( length / 2 ) ; k ++ ) { leftsum += str [ i + k ] ; rightsum += str [ i + k + int ( length / 2 ) ] ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } return maxlen ; }

38.9
48.12
70.99
72.32
def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count

static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }

static int nextPowerOf2 ( int n ) { int count = 0 ; while ( n != 0 ) { n >>= 1 ; count ++ ; } return 0 ; }

static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count ++ ; } return n ; }

38.9
48.12
70.99
72.32
def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count

static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }

static int nextPowerOf2 ( int n ) { int count = 0 ; while ( n != 0 ) { n >>= 1 ; count ++ ; } return 0 ; }

static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count ++ ; } return n ; }

39.03
40.02
60.59
61.76
def compute ( st , n ) : reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" l = len ( st ) answer = "" for i in range ( 0 , n ) : answer = answer + st [ i ] for i in range ( n , l ) : answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( 'a' ) ] ) return answer

static String compute ( String str , int n ) { String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ; int l = str . length ( ) ; String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str . charAt ( i ) ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - 'a' ) ; return answer ; }

static String compute ( String st , int n ) { String answer = "" ; int l = st . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { answer = answer + reverseAlphabet [ st [ i ] - ord ( 'a' ) ] ; } return answer ; }

static String compute ( String st , int n ) { String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ; int l = st . length ; String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) { answer = answer + st [ i ] ; for ( int i = 0 ; i < l ; i ++ ) { answer = answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( 'a' ) ] ; } return answer ; } }

39.19
46.17
38.8
40.85
def printDivisors ( n ) : list = [ ] for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : if ( n % i == 0 ) : if ( n / i == i ) : print ( i , end = "" ) else : print ( i , end = "" ) list . append ( int ( n / i ) ) for i in list [ : : - 1 ] : print ( i , end = "" )

static void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( "%d " , i ) ; else { System . out . printf ( "%d " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( "%d " , v . get ( i ) ) ; }

static void printDivisors ( int n ) { List < int > list = new List < int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n / i == i ) list . append ( i ) ; else list . append ( i ) ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) print ( i , end = "" ) ; }

static void printDivisors ( int n ) { String [ ] list = new String [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( n / i == i ) { if ( n / i == i ) { if ( n / i == i ) { if ( n / i == i ) { print ( i , end = "" ) ; } else { print ( i , end = "" ) ; } } else { print ( i , end = "" ) ; } list . append ( int ( n / i ) ) ; } } } } }

39.21
40.41
77.82
82.05
def countRotations ( arr , low , high ) : if ( high < low ) : return 0 if ( high == low ) : return low mid = low + ( high - low ) / 2 mid = int ( mid ) if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : return ( mid + 1 ) if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : return mid if ( arr [ high ] > arr [ mid ] ) : return countRotations ( arr , low , mid - 1 ) return countRotations ( arr , mid + 1 , high )

static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }

static int countRotations ( int arr [ ] , int low , int high ) { int mid ; if ( arr [ low ] > arr [ mid ] ) return ( low + 1 ) if ( arr [ mid - 1 ] > arr [ mid ] ) return ( mid - 1 ) if ( arr [ mid ] > arr [ mid - 1 ] ) return ( mid - 1 ) if ( arr [ mid ] > arr [ mid ] ) return ( mid - 1 ) if

static int countRotations ( int arr [ ] , int low , int high ) { if ( high == low ) return 0 ; int mid = low + ( high - low ) / 2 ; if ( mid < low && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > high && arr [ mid - 1 ] < arr [ mid - 1 ] ) return ( mid - 1 ) ; if ( arr [ high ] > arr [ mid ] ) return ( mid + 1 ) ; if ( arr [ low ] > arr [ mid ] ) return ( mid - 1 ) ; return countRotations ( arr , low , high ) ; }

39.21
41.34
42.86
48.58
def isLucky ( n ) : ar = [ 0 ] * 10 while ( n > 0 ) : digit = math . floor ( n % 10 ) if ( ar [ digit ] ) : return 0 ar [ digit ] = 1 n = n / 10 return 1

static boolean isLucky ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }

static int isLucky ( int n ) { int ar [ ] = { } ; while ( n > 0 ) { int digit = 0 ; while ( ar [ digit ] ) { if ( ar [ digit ] ) return 0 ar [ digit ] = 1 ; n = n / 10 ; } return 1 ; } return 0 ; }

static int isLucky ( int n ) { int ar [ ] = new int [ 10 ] ; while ( n > 0 ) { int digit = math . floor ( n / 10 ) ; if ( ar [ digit ] ) return 0 ; ar [ digit ] = 1 ; n = n / 10 ; } return 0 ; }

39.31
41.67
31.2
37.01
def findMax ( arr ) : row = 0 j = N - 1 for i in range ( 0 , N ) : while ( arr [ i ] [ j ] == 1 and j >= 0 ) : row = i j -= 1 print ( "Rownumber=" , row + 1 , ",MaxCount=" , N - 1 - j )

static void findMax ( int arr [ ] [ ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( j >= 0 && arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } System . out . print ( "Row number = " + ( row + 1 ) ) ; System . out . print ( ", MaxCount = " + ( N - 1 - j ) ) ; }

static int findMax ( int arr [ ] [ ] , int N ) { int row = 0 ; int j = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } return row ; }

static void findMax ( int [ ] arr , int row , int N ) { int row = 0 ; int j = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ j ] == 1 ) row = i ; else if ( arr [ i ] [ j ] == 0 ) row = i ; else if ( arr [ i ] [ j ] == 0 ) row = i ; else if ( arr [ i ] [ j ] == 1 ) row = i ; else if ( arr [ i ] [ j ] == 0 ) row = i ; } }

39.35
39.7
47.93
53.6
def printPrevSmaller ( arr , n ) : S = list ( ) for i in range ( n ) : while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : S . pop ( ) if ( len ( S ) == 0 ) : print ( "_," , end = "" ) else : print ( S [ - 1 ] , end = "," ) S . append ( arr [ i ] )

static void printPrevSmaller ( int arr [ ] , int n ) { Stack < Integer > S = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . peek ( ) >= arr [ i ] ) { S . pop ( ) ; } if ( S . empty ( ) ) { System . out . print ( "_, " ) ; } else { System . out . print ( S . peek ( ) + ", " ) ; } S . push ( arr [ i ] ) ; } }

static void printPrevSmaller ( int arr [ ] , int n ) { List < int > S = list ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( S [ - 1 ] >= arr [ i ] ) S . pop ( ) ; if ( S [ - 1 ] >= arr [ i ] ) S . append ( arr [ i ] ) ; else S . append ( arr [ i ] ) ; } }

static void printPrevSmaller ( int arr [ ] , int n ) { int S = list ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( S . size ( ) > 0 && S [ - 1 ] >= arr [ i ] ) { S . pop ( ) ; if ( S . length ( ) == 0 ) { print ( "_," , end = "" ) ; } else { S . append ( S [ - 1 ] ) ; } } } }

39.37
41.74
75.33
71.73
def countFibs ( low , high ) : f1 , f2 , f3 = 0 , 1 , 1 result = 0 while ( f1 <= high ) : if ( f1 >= low ) : result += 1 f1 = f2 f2 = f3 f3 = f1 + f2 return result

static int countFibs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) result ++ ; f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }

static int countFibs ( int low , int high ) { int f1 , f2 , f3 ; f1 = low ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }

static int countFibs ( int low , int high ) { int f1 = 0 ; int f2 = 0 ; int f3 = 0 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) { result += 1 ; f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } } return result ; }

39.39
64.69
65.95
66.1
def isPower ( x , y ) : res1 = math . log ( y ) / math . log ( x ) res2 = math . log ( y ) / math . log ( x ) return 1 if ( res1 == res2 ) else 0

static boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }

static int isPower ( int x , int y ) { int res1 = math . log ( x ) / math . log ( y ) ; int res2 = math . log ( y ) / math . log ( x ) ; return 1 if ( res1 == res2 ) else 0 ; }  def isPower ( int x , int y ) { int res1 = math . log ( x ) / math . log ( y ) ; int res2 = math .

static int isPower ( int x , int y ) { int res1 = Math . log ( y ) / math . log ( x ) ; int res2 = Math . log ( y ) / math . log ( x ) ; return 1 if ( res1 == res2 ) return 1 ; }

39.4
45.52
57.19
56.97
def selectRandom ( x ) : res = 0 count = 0 count += 1 if ( count == 1 ) : res = x else : i = random . randrange ( count ) if ( i == count - 1 ) : res = x return res

static int selectRandom ( int x ) { count ++ ; if ( count == 1 ) res = x ; else { Random r = new Random ( ) ; int i = r . nextInt ( count ) ; if ( i == count - 1 ) res = x ; } return res ; }

static int selectRandom ( int x ) { int res = 0 ; int count = x . length ( ) ; if ( count == 0 ) res = x ; else res = res + i ; } return res ; }

static int selectRandom ( int x ) { int res = 0 ; int count = 0 ; count += 1 ; if ( count == 1 ) { res = x ; } else { i = random . randrange ( count ) ; if ( i == count - 1 ) res = x ; else res = x ; } return res ; }

39.43
37.36
35.57
28.62
def fib ( n ) : a = 0 b = 1 if ( n >= 0 ) : print ( a , end = '' ) if ( n >= 1 ) : print ( b , end = '' ) for i in range ( 2 , n + 1 ) : print ( a + b , end = '' ) b = a + b a = b - a

static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + " " ) ; if ( n >= 1 ) System . out . print ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { System . out . print ( a + b + " " ) ; b = a + b ; a = b - a ; } }

static void fib ( int n ) { int a = 0 ; int b = 1 ; if ( n >= 2 ) { print ( a + b , end = '' ) for ( int i = 0 ; i < n ; i ++ ) { print ( a + b , end = '' ) for ( int i = 0 ; i < n ; i ++ ) { print ( a + b , end = '' ) if ( i >= 1 ) { print ( a + b

; int n ; if ( n >= 0 ) { a = 0 ; b = 1 ; if ( n >= 1 ) { print ( a , end = '' ) ; for ( int i = 0 ; i < n ; i ++ ) { print ( a + b , end = '' ) ; } } if ( n >= 0 ) { print ( b , end = '' ) ; for ( int i = 0 ; i < n ; i ++ ) { print ( a + b , end = '' ) ; } } return ; }

39.45
45.97
62.77
68.3
def minheapify ( a , index ) : small = index l = 2 * index + 1 r = 2 * index + 2 if ( l < n and a [ l ] < a [ small ] ) : small = l if ( r < n and a [ r ] < a [ small ] ) : small = r if ( small != index ) : ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) minheapify ( a , small )

static void minheapify ( int [ ] a , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { int t = a [ small ] ; a [ small ] = a [ index ] ; a [ index ] = t ; minheapify ( a , small ) ; } }

static void minheapify ( int a [ ] , int n ) { int small = 0 ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l != index ) { ( a [ index ] , a [ index ] ) = ( a [ index ] , a [ index ] ) ; minheapify ( a , l + 1 ) ; minheapify ( a , r + 1 ) ; minheapify ( a , r ) ; } }

static void minheapify ( int [ ] a , int index ) { int small = index ; int l = index + 1 ; int r = index + 2 ; if ( l < n && a [ l ] < a [ r ] ) { small = l ; if ( r < n && a [ r ] < a [ small ] ) { small = r ; if ( small != index ) ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) ; } } if ( small != index ) ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) ; minheapify ( a , small ) ; }

39.52
40.49
55.5
50.06
def lexNext ( s , n ) : for i in range ( n - 1 , - 1 , - 1 ) : if s [ i ] != 'z' : k = ord ( s [ i ] ) s [ i ] = chr ( k + 1 ) return '' . join ( s ) s [ i ] = 'a'

static String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != 'z' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = 'a' ; } return null ; }

static String lexNext ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != 'a' ) return '' . join ( s ) ; if ( s [ i ] != 'z' ) return '' . join ( s ) ; s [ i ] = chr ( k + 1 ) ; s [ i ] = 'a' ; s [ i ] = 'z' ; s [ i

static String lexNext ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != 'z' ) { int k = ord ( s [ i ] ) ; s [ i ] = chr ( k + 1 ) ; return '' . join ( s ) ; } s [ i ] = 'a' ; } return null ; }

39.55
41.05
49.62
46.46
def calculateSum ( arr , n ) : if ( n == 0 ) : return 0 s = arr [ 0 ] value = int ( s ) sum = value for i in range ( 2 , n , 2 ) : s = arr [ i ] value = int ( s ) operation = arr [ i - 1 ] [ 0 ] if ( operation == '+' ) : sum += value else : sum -= value return sum

public static int calculateSum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = Integer . parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = Integer . parseInt ( s ) ; char operation = arr [ i - 1 ] . charAt ( 0 ) ; if ( operation == '+' ) sum += value ; else sum -= value ; } return sum ; }

static int calculateSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { s = arr [ i ] ; value = int ( s ) ; operation = arr [ i - 1 ] [ 0 ] ; if ( operation == '-' ) { sum += value ; } else { sum -= value ; } } return sum ; }

static int calculateSum ( int [ ] arr , int n ) { int sum = 0 ; int s = arr [ 0 ] ; int value = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { s = arr [ i ] ; value = int ( s ) ; int operation = arr [ i - 1 ] [ 0 ] ; if ( operation == '+' ) { sum += value ; } else { sum -= value ; } } return sum ; }

39.58
37.95
57.26
54.83
def countNumber ( n ) : result = 0 for i in range ( 1 , 10 ) : s = [ ] if ( i <= n ) : s . append ( i ) result += 1 while len ( s ) != 0 : tp = s [ - 1 ] s . pop ( ) for j in range ( tp % 10 , 10 ) : x = tp * 10 + j if ( x <= n ) : s . append ( x ) result += 1 return result

static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < > ( ) ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; }

static int countNumber ( int n ) { int result = 0 ; int s = [ ] ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i * 10 + j ; if ( x <= n ) s . append ( x ) result += 1 ; while ( len ( s ) != 0 ) { int tp = s [ - 1 ] ; for ( int j = 0 ; j <= 10 ; j ++ ) { if ( x <=

static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int s = new int [ n ] ; s . append ( i ) ; result += 1 ; while ( s . length ( ) != 0 ) { int tp = s [ - 1 ] ; s . pop ( ) ; for ( int j = 0 ; j < tp % 10 , 10 ) { x = tp * 10 + j ; if ( x <= n ) s . append ( x ) ; result ++ ; } } } return result ; }

39.65
32.53
45.4
39.3
def checkCorrectOrNot ( s ) : global MAX_CHAR count = [ 0 ] * MAX_CHAR n = len ( s ) if n == 1 : return true i = 0 j = n - 1 while i < j : count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1 i += 1 j -= 1 for i in range ( MAX_CHAR ) : if count [ i ] != 0 : return False return True

static boolean checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( j ) - 'a' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }

static boolean checkCorrectOrNot ( String s ) { int i , j ; int count [ ] = new int [ MAX_CHAR ] ; for ( i = 0 ; i < n ; i ++ ) { if ( count [ i ] != 0 ) return false ; count [ i ] += 1 ; count [ i ] -= 1 ; } for ( i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count [ i ] != 0 ) return false ;

static boolean checkCorrectOrNot ( String s ) { int i = 0 ; int j = n - 1 ; while ( i < j ) { count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 ; count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1 ; i ++ ; j -- ; } for ( int i = 0 ; i < j ; i ++ ) { if ( count [ ord ( s [ i ] ) - ord ( 'a' ) ] != 0 ) return false ; } return true ; }

39.73
50.62
47.82
53.87
def findExtraCharcter ( strA , strB ) : res = 0 for i in range ( 0 , len ( strA ) ) : res = res ^ ( ord ) ( strA [ i ] ) for i in range ( 0 , len ( strB ) ) : res = res ^ ( ord ) ( strB [ i ] ) return ( ( chr ) ( res ) ) ;

static char findExtraCharcter ( String strA , String strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA . charAt ( i ) ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB . charAt ( i ) ; } return ( ( char ) ( res ) ) ; }

static int findExtraCharcter ( String strA , String strB ) { int res = 0 ; for ( int i = 0 ; i < len ( strA ) ; i ++ ) { res = res ^ ( ord ) ( strA [ i ] ) ; for ( int i = 0 ; i < len ( strB ) ) { res = res ^ ( ord ) ( strB [ i ] ) ; for ( int i = 0 ; i < len (

static int findExtraCharcter ( String strA , String strB ) { int res = 0 ; for ( int i = 0 ; i < strA . length ( ) ; i ++ ) { res = res ^ ( ord ) ; for ( int j = 0 ; j < strA . length ( ) ; j ++ ) { res = res ^ ( ord ) ( strA [ i ] ) ; res = res ^ ( ord ) ( strB [ j ] ) ; } return ( ( chr ) ( res ) ) ; } }

39.74
73.24
90.05
87.58
def fib ( n , a = 0 , b = 1 ) : if n == 0 : return a if n == 1 : return b return fib ( n - 1 , b , a + b ) ;

static int fib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; return fib ( n - 1 , b , a + b ) ; }

static int fib ( int n , int a , int b ) { if ( n == 2 ) return fib ( n - 1 , a , a + a ) ; return fib ( n - 1 , a , b + b ) ; }  def fib ( int n , int a , int b ) { if ( n == 3 ) return fib ( n , a , b , a + b ) ; return fib ( n , a , b

static int fib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; return fib ( n - 1 , a , b ) ; }

39.75
40.94
63.75
61.68
def isPermutedMatrix ( mat , n ) : str_cat = "" for i in range ( n ) : str_cat = str_cat + "-" + str ( mat [ 0 ] [ i ] ) str_cat = str_cat + str_cat for i in range ( 1 , n ) : curr_str = "" for j in range ( n ) : curr_str = curr_str + "-" + str ( mat [ i ] [ j ] ) if ( str_cat . find ( curr_str ) ) : return True return False

static boolean isPermutedMatrix ( int mat [ ] [ ] , int n ) { String str_cat = "" ; for ( int i = 0 ; i < n ; i ++ ) { str_cat = str_cat + "-" + String . valueOf ( mat [ 0 ] [ i ] ) ; } str_cat = str_cat + str_cat ; for ( int i = 1 ; i < n ; i ++ ) { String curr_str = "" ; for ( int j = 0 ; j < n ; j ++ ) { curr_str = curr_str + "-" + String . valueOf ( mat [ i ] [ j ] ) ; } if ( str_cat . contentEquals ( curr_str ) ) { return false ; } } return true ; }

static boolean isPermutedMatrix ( int mat [ ] [ ] , int n ) { String str_cat = "" ; for ( int i = 0 ; i < n ; i ++ ) { String str_cat = str_cat + str_cat ; for ( int j = 0 ; j < n ; j ++ ) { if ( str_cat . find ( curr_str ) ) return true ; } return false ; } }

static boolean isPermutedMatrix ( int mat [ ] [ ] , int n ) { String str_cat = "" ; for ( int i = 0 ; i < n ; i ++ ) { str_cat = str_cat + "-" + str ( mat [ i ] [ 0 ] ) ; str_cat = str_cat + str_cat ; str_cat = str_cat + str_cat ; for ( int j = 0 ; j < n ; j ++ ) { str_cat = str_cat + "-" + str ( mat [ i ] [ j ] ) ; str_cat = str_cat + str_cat ; } if ( str_cat . find ( str_cat ) ) return true ; } return false ; }

39.77
44.94
85.32
87.35
def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : max = arr1 [ 0 ] min = arr2 [ 0 ] i = 1 while ( i < n1 and i < n2 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 while ( i < n1 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] i += 1 while ( i < n2 ) : if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 return max * min

public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }

static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int i = 1 ; while ( i < n1 && i < n2 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] if ( arr2 [ i ] < min ) min = arr2 [ i ] if ( arr2 [ i ] > min ) min = arr2 [ i ] if (

static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i = 1 ; while ( i < n1 && i < n2 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } return max * min ; }

39.79
45.99
88.47
91.3
def getMinSquares ( n ) : if n <= 3 : return n ; res = n for x in range ( 1 , n + 1 ) : temp = x * x ; if temp > n : break else : res = min ( res , 1 + getMinSquares ( n - temp ) ) return res ;

static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }

static int getMinSquares ( int n ) { int res ; int temp ; for ( temp = 1 ; temp <= n ; temp ++ ) { res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }

static int getMinSquares ( int n ) { int res ; if ( n <= 3 ) return n ; res = n ; for ( int x = 1 ; x <= n + 1 ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }

39.86
38.65
59.25
54.89
def isPrime ( p ) : checkNumber = 2 ** p - 1 nextval = 4 % checkNumber for i in range ( 1 , p - 1 ) : nextval = ( nextval * nextval - 2 ) % checkNumber if ( nextval == 0 ) : return True else : return False

static boolean isPrime ( int p ) { double checkNumber = Math . pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }

static boolean isPrime ( int p ) { int checkNumber = 2 ** p - 1 ; int nextval = 4 ; for ( int i = 1 ; i <= p ; i ++ ) { if ( nextval == 0 ) { return true ; } else { return false ; } } return false ; }

public static boolean isPrime ( int p ) { int checkNumber = 2 ** p - 1 ; int nextval = 4 ; for ( int i = 1 ; i < p ; i ++ ) { nextval = ( nextval * nextval - 2 ) % checkNumber ; if ( nextval == 0 ) return true ; else return false ; } }

39.99
47.49
54.63
57.62
def reverseFibonacci ( n ) : a = [ 0 ] * n a [ 0 ] = 0 a [ 1 ] = 1 for i in range ( 2 , n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] for i in range ( n - 1 , - 1 , - 1 ) : print ( a [ i ] , end = "" )

static void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + " " ) ; } }

static void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } return ; }

static void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } } }

40.0
50.09
34.6
56.15
def isSubSequence ( string1 , string2 , m , n ) : if m == 0 : return True if n == 0 : return False if string1 [ m - 1 ] == string2 [ n - 1 ] : return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) return isSubSequence ( string1 , string2 , m , n - 1 )

static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }

static boolean isSubSequence ( String string1 , String string2 , int m , int n ) { if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return true ; if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return false ; return string1 . substring ( m - 1 , n - 1 ) . equals ( string2 [ n - 1 ] ) ; } return false ; }

static boolean isSubSequence ( String string1 , String string2 , int m , int n ) { if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return true ; if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return true ; if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return true ; if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) ; return false ; }

40.05
39.75
50.62
47.28
def canMakeStr2 ( s1 , s2 ) : count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } for i in range ( len ( s1 ) ) : count [ s1 [ i ] ] += 1 for i in range ( len ( s2 ) ) : if count [ s2 [ i ] ] == 0 : return False count [ s2 [ i ] ] -= 1 return True

static boolean canMakeStr2 ( String str1 , String str2 ) { int [ ] count = new int [ MAX ] ; char [ ] str3 = str1 . toCharArray ( ) ; for ( int i = 0 ; i < str3 . length ; i ++ ) count [ str3 [ i ] ] ++ ; char [ ] str4 = str2 . toCharArray ( ) ; for ( int i = 0 ; i < str4 . length ; i ++ ) { if ( count [ str4 [ i ] ] == 0 ) return false ; count [ str4 [ i ] ] -- ; } return true ; }

static boolean canMakeStr ( String [ ] s1 , String [ ] s2 ) { int count = { } ; for ( int i = 0 ; i < len ( s1 ) ; i ++ ) { if ( count [ s1 [ i ] ] == 0 ) return false ; for ( int i = 0 ; i < len ( s2 ) ; i ++ ) { if ( count [ s2 [ i ] ] == 0 ) return false ; count [ s

static boolean canMakeStr2 ( int [ ] s1 , int [ ] s2 ) { int count [ ] = new int [ len ( s1 ) ] ; for ( int i = 0 ; i < len ( s1 ) ; i ++ ) { if ( count [ s1 [ i ] ] == 0 ) return false ; count [ s1 [ i ] ] -- ; } for ( int i = 0 ; i < len ( s2 ) ; i ++ ) { if ( count [ s2 [ i ] ] == 0 ) return false ; count [ s2 [ i ] ] -- ; } return true ; }

40.11
46.95
58.17
63.08
def LCIS ( arr1 , n , arr2 , m ) : table = [ 0 ] * m for j in range ( m ) : table [ j ] = 0 for i in range ( n ) : current = 0 for j in range ( m ) : if ( arr1 [ i ] == arr2 [ j ] ) : if ( current + 1 > table [ j ] ) : table [ j ] = current + 1 if ( arr1 [ i ] > arr2 [ j ] ) : if ( table [ j ] > current ) : current = table [ j ] result = 0 for i in range ( m ) : if ( table [ i ] > result ) : result = table [ i ] return result

static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }

static int LCIS ( int arr1 [ ] , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] == arr2 [ j ] ) { if ( current + 1 > table [ j ] ) { table [ j ] = current + 1 ; } } return 0 ; }

static int LCIS ( int arr1 , int n , int arr2 , int m ) { int table [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( current + 1 > table [ j ] ) { table [ j ] = current + 1 ; } if ( arr1 [ i ] > arr2 [ j ] ) { if ( table [ j ] > current ) { current = table [ j ] ; } } } } } return result ; }

40.13
44.85
40.93
45.69
def KSwapMaximum ( n , k ) : global arr for i in range ( 0 , n - 1 ) : if ( k > 0 ) : indexPosition = i for j in range ( i + 1 , n ) : if ( k <= j - i ) : break if ( arr [ j ] > arr [ indexPosition ] ) : indexPosition = j for j in range ( indexPosition , i , - 1 ) : t = arr [ j ] arr [ j ] = arr [ j - 1 ] arr [ j - 1 ] = t k = k - indexPosition - i

static void KSwapMaximum ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int indexPosition = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( k <= j - i ) break ; if ( arr [ j ] > arr [ indexPosition ] ) indexPosition = j ; } for ( int j = indexPosition ; j > i ; -- j ) SwapInts ( arr , j , j - 1 ) ; k -= indexPosition - i ; } }

static void KSwapMaximum ( int n , int k ) { int indexPosition = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i ; for ( int j = j ; j <= j ; j ++ ) { if ( k <= j - i ) { arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = arr [ j - 1 ] ; arr [ j ] = arr [ j -

; for ( int i = 0 ; i < n ; i ++ ) { if ( k > 0 ) { int indexPosition = i ; for ( int j = i ; j < n ; j ++ ) { if ( k <= j - i ) break ; if ( arr [ j ] > arr [ indexPosition ] ) { indexPosition = j ; for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] > arr [ indexPosition ] ) { arr [ indexPosition ] = arr [ j ] ; arr [ indexPosition ] = arr [ j - 1 ] ; arr [ j - 1 ] = arr [ j - 1 ] ; arr [ j - 1 ] = arr [ j - 1 ] ; } } } } } return ; }

40.18
42.63
62.76
57.35
def nthRoot ( A , N ) : xPre = random . randint ( 1 , 101 ) % 10 eps = 0.001 delX = 2147483647 xK = 0.0 while ( delX > eps ) : xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N delX = abs ( xK - xPre ) xPre = xK return xK

static double nthRoot ( int A , int N ) { double xPre = Math . random ( ) % 10 ; double eps = 0.001 ; double delX = 2147483647 ; double xK = 0.0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }

static double nthRoot ( double A , int N ) { double xPre = 1 ; double xK = 0.0 ; while ( delX > eps ) { xK = ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N ; } return xK ; }

static int nthRoot ( int A , int N ) { int xPre = random . randint ( 1 , 101 ) % 10 ; int eps = 0.001 ; int xK = 0.0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; }

40.19
44.67
49.3
59.0
def printString ( str , ch , count ) : occ , i = 0 , 0 if ( count == 0 ) : print ( str ) for i in range ( len ( str ) ) : if ( str [ i ] == ch ) : occ += 1 if ( occ == count ) : break if ( i < len ( str ) - 1 ) : print ( str [ i + 1 : len ( str ) - i + 2 ] ) else : print ( "Emptystring" )

static void printString ( String str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { System . out . println ( str ) ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ; else System . out . println ( "Empty string" ) ; }

static void printString ( String str , char ch , int count ) { int occ = 0 ; int i = 0 ; for ( int i = 0 ; i < len ( str ) ; i ++ ) { if ( str [ i ] == ch ) occ += 1 ; if ( occ == count ) { if ( i < len ( str ) - 1 ) { print ( str [ i + 1 : len ( str ) - i + 2 ] ) ; } else { if

static void printString ( String str , char ch , int count ) { int occ , i = 0 ; if ( count == 0 ) { print ( str ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) { occ += 1 ; if ( occ == count ) break ; if ( i < str . length ( ) - 1 ) { print ( str [ i + 1 : len ( str ) - i + 2 ] ) ; } else { print ( str [ i + 1 : len ( str ) - i + 2 ] ) ; } } else { print ( "Emptystring" ) ; } } } }

40.2
38.47
37.3
53.27
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }

static int factorial ( int n ) { return 1 if ( n == 0 ) return 1 ; }  def factorial ( int n ) { return 1 ; }

static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return n * factorial ( n - 1 ) ; } }

40.2
48.51
84.93
83.83
def lcs ( X , Y , m , n ) : if m == 0 or n == 0 : return 0 ; elif X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else : return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;

int lcs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }

static int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m , n - 1 ) ; else return 0 ; } }

static int lcs ( double [ ] X , double [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m - 1 , n - 1 ) , lcs ( X , Y , m - 1 , n - 1 ) ) ; }

40.2
38.47
37.3
53.27
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }

static int factorial ( int n ) { return 1 if ( n == 0 ) return 1 ; }  def factorial ( int n ) { return 1 ; }

static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return n * factorial ( n - 1 ) ; } }

40.2
48.51
84.93
83.83
def lcs ( X , Y , m , n ) : if m == 0 or n == 0 : return 0 ; elif X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else : return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;

int lcs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }

static int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m , n - 1 ) ; else return 0 ; } }

static int lcs ( double [ ] X , double [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m - 1 , n - 1 ) , lcs ( X , Y , m - 1 , n - 1 ) ) ; }

40.31
43.85
53.95
57.51
def merge ( ar1 , ar2 , m , n ) : for i in range ( n - 1 , - 1 , - 1 ) : last = ar1 [ m - 1 ] j = m - 2 while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : ar1 [ j + 1 ] = ar1 [ j ] j -= 1 if ( j != m - 2 or last > ar2 [ i ] ) : ar1 [ j + 1 ] = ar2 [ i ] ar2 [ i ] = last

static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 || last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }

static void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { int last = ar1 [ m - 1 ] ; int j = m - 2 ; while ( j >= 0 and ar2 [ i ] > ar1 [ j ] ) { ar1 [ j + 1 ] = ar1 [ j ] ; j -= 1 } if ( j != m - 1 or last > ar2 [ i ] ) { ar2 [ i ] = ar2 [ i ] ; } }

static void merge ( int ar1 [ ] , int ar2 [ ] , int n ) { int last = ar1 [ m - 1 ] ; int j = m - 2 ; while ( j >= 0 && ar1 [ j ] > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = ar1 [ j ] ; j -- ; if ( j != m - 2 || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }

40.34
47.24
45.53
52.81
def gcd ( a , b ) : if a == 0 : return b return gcd ( b % a , a )

public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }

static int gcd ( int a , int b ) { int a = a % b ; return a % b ; }

static int gcd ( int a , int b ) { return gcd ( b , a ) ; }

40.37
50.01
64.04
62.43
def countP ( n , k ) : dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( k + 1 ) : dp [ 0 ] [ k ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : if ( j == 1 or i == j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) return dp [ n ] [ k ]

static int countP ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }

static int countP ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { if ( i == 1 ) dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j -

static int countP ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( int k = 1 ; k <= n ; k ++ ) { dp [ i ] [ k ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] [ j ] = 0 ; } } } return dp [ n ] [ k ] ; }

40.42
47.73
52.07
51.62
def kthNonRepeating ( str , k ) : n = len ( str ) count = [ 0 ] * MAX_CHAR index = [ 0 ] * MAX_CHAR for i in range ( MAX_CHAR ) : count [ i ] = 0 index [ i ] = n for i in range ( n ) : x = str [ i ] count [ ord ( x ) ] += 1 if ( count [ ord ( x ) ] == 1 ) : index [ ord ( x ) ] = i if ( count [ ord ( x ) ] == 2 ) : index [ ord ( x ) ] = n index . sort ( ) return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1

static int kthNonRepeating ( String str , int k ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }

static int kthNonRepeating ( String str , int k ) { int n = str . length ( ) ; int count [ ] = new int [ MAX_CHAR ] ; int index [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = str [ i ] ; count [ ord ( x ) ] += 1 ; if ( count [ ord ( x ) ] == 1 ) index [ ord ( x ) ] = i ; if ( index [ ord ( x ) ] = n ; if ( count [ ord ( x ) ] = 0 ; if ( count [ ord ( x ) ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int i = i ; i ++ ) { if ( count [ ord ( x ) ] ++ ; if ( count [ ord ( x ) ] == 2 ) index [ ord ( x ) ] = i ; if ( count [ ord ( x ) ] == 2 ) ] = n ; } } return index [ ord ( x ) ] == 2 ) ] = i ; } return index [ ord ( x ) ] = i ; } return

static int kthNonRepeating ( String str , int k ) { int n = str . length ( ) ; int count = [ 0 ] * MAX_CHAR ; index = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = str [ i ] ; count [ ord ( x ) ] += 1 ; if ( count [ ord ( x ) ] == 1 ) index [ ord ( x ) ] = i ; if ( count [ ord ( x ) ] == 2 ) index [ ord ( x ) ] = n ; } index . sort ( ) ; return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 ; }

40.42
48.18
63.18
64.74
def maxLenSub ( arr , n ) : mls = [ ] max = 0 for i in range ( n ) : mls . append ( 1 ) for i in range ( n ) : for j in range ( i ) : if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : mls [ i ] = mls [ j ] + 1 for i in range ( n ) : if ( max < mls [ i ] ) : max = mls [ i ] return max

public static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }

static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] + 1 ; for ( int j = i ; j < n ; j ++ ) { if ( mls [ i ] < mls [ j ] + 1 ) { mls [ i ] = m

static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; } if ( max < mls [ i ] ) max = mls [ i ] ; } return max ; }

40.42
48.31
24.43
27.98
def reverseStr ( str ) : n = len ( str ) i , j = 0 , n - 1 while i < j : str [ i ] , str [ j ] = str [ j ] , str [ i ] i += 1 j -= 1

static void reverseStr ( String str ) { int n = str . length ( ) ; char [ ] ch = str . toCharArray ( ) ; char temp ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; } System . out . println ( ch ) ; }

static void reverseStr ( String str ) { int n = str . length ( ) ; int i = 0 ; int j = n - 1 ; while ( i < j ) str [ i ] , str [ j ] = str [ i ] , str [ j ] ; while ( i < j ) str [ i ] , str [ j ] = str [ i ] , str [ j ] ; i ++ ; j -- ; } return str ; }

static void reverseStr ( String str ) { int i = 0 ; int j = 0 , n - 1 ; while ( i < j ) str [ i ] , str [ j ] = str [ j ] , str [ i ] ; i ++ ; j -- ; }

40.47
41.16
58.6
53.85
def printClosest ( arr , n , x ) : res_l , res_r = 0 , 0 l , r , diff = 0 , n - 1 , MAX_VAL while r > l : if abs ( arr [ l ] + arr [ r ] - x ) < diff : res_l = l res_r = r diff = abs ( arr [ l ] + arr [ r ] - x ) if arr [ l ] + arr [ r ] > x : r -= 1 else : l += 1 print ( 'Theclosestpairis{}and{}' . format ( arr [ res_l ] , arr [ res_r ] ) )

static void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ; }

static void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r = 0 , 0 ; while ( r > l ) { int diff = abs ( arr [ l ] + arr [ r ] - x ) ; if ( arr [ l ] + arr [ r ] - x ) < diff : res_l = l res_r = r ; diff = abs ( arr [ l ] + arr [ r ] -

static void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 , l = 0 , r = 0 , diff = 0 , n - 1 , MAX_VAL ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) res_l = l res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; if ( arr [ l ] + arr [ r ] > x ) r -= 1 ; else l += 1 ; } }

40.51
41.24
27.18
33.72
def firstNonRepeating ( arr , n ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 for i in range ( n ) : if mp [ arr [ i ] ] == 1 : return arr [ i ] return - 1

static int firstNonRepeating ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; return - 1 ; }

static int firstNonRepeating ( int arr [ ] , int n ) { int mp = defaultdict ( lambda : 0 ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ; for ( int

static int firstNonRepeating ( int arr [ ] , int n ) { int mp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ; } return - 1 ; }

40.55
63.35
58.69
51.99
def lexSmallest ( a , n ) : a . sort ( reverse = True ) answer = "" for i in range ( n ) : answer += a [ i ] return answer

static String lexsmallest ( String a [ ] , int n ) { sort ( a , n ) ; String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }

static String lexSmallest ( List a , int n ) { String answer = "" for ( int i = 0 ; i < n ; i ++ ) { answer += a [ i ] + " " } return answer }  def lexSmallest ( List a , int n ) { String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) answer += " " ; } return answer ; }

static String lexSmallest ( String a , int n ) { String answer = "" ; for ( int i = 0 ; i < a . length ; i ++ ) { answer += a [ i ] ; } return answer ; }

40.58
48.38
61.68
59.2
def count ( n ) : dp = [ 0 for _ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if i <= 3 : dp [ i ] = 1 elif i == 4 : dp [ i ] = 2 else : dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] return dp [ n ]

static int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }

static int count ( int n ) { int dp [ ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } return dp [ n ] ; }

static int count ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= 3 ; i ++ ) { dp [ i ] = 1 ; } for ( int i = 1 ; i <= 4 ; i ++ ) { dp [ i ] = 1 ; } for ( int i = 1 ; i <= 5 ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } return dp [ n ] ; }

40.61
49.97
34.97
48.34
def maxDiff ( arr , n ) : result = 0 arr . sort ( ) for i in range ( n - 1 ) : if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : result += abs ( arr [ i ] ) else : pass if ( arr [ n - 2 ] != arr [ n - 1 ] ) : result += abs ( arr [ n - 1 ] ) return result

static int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }

static int maxDiff ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { result += abs ( arr [ i ] ) ; } } return result ; }

static int maxDiff ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; } return result ; }

40.77
53.25
78.3
81.93
def nextPowerOf2 ( n ) : p = 1 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( p < n ) : p <<= 1 return p

static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }

static int nextPowerOf2 ( int n ) { int p = 1 ; while ( p < n ) { p <<= 1 ; } return p ; }

static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return n ; }

40.77
53.25
78.3
81.93
def nextPowerOf2 ( n ) : p = 1 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( p < n ) : p <<= 1 return p

static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }

static int nextPowerOf2 ( int n ) { int p = 1 ; while ( p < n ) { p <<= 1 ; } return p ; }

static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return n ; }

40.87
38.6
13.19
22.78
def maxDP ( n ) : res = list ( ) res . append ( 0 ) res . append ( 1 ) i = 2 while i < n + 1 : res . append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ) i = i + 1 return res [ n ]

static int maxDP ( int n ) { int res [ ] = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }

static int maxDP ( int n ) { int res = new int [ n ] ; for ( int i = 2 ; i < n ; i ++ ) { res . append ( max ( i , res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] + res [ int ( i / 5 ) ] + res [ int ( i / 5 ) ] ) ) ) ; i = i + 1 ) ; } return res [ n ] ; } }

static int maxDP ( int n ) { int res . append ( 0 ) ; res . append ( 1 ) ; res . append ( 2 ) ; res . append ( res [ int ( res . length / 2 ) ] + res [ int ( res . length / 3 ) ] + res [ int ( res . length / 4 ) ] + res [ int ( res . length / 5 ) ] + res [ int ( res . length / 6 ) ] + res [ int ( res . length / 7 ) ] + res [ int ( res . length / 8 ) ] + res [ int ( res . length / 9 ) ] + res [ int ( res . length / 10 ) ] + res [ int ( res . length / 11 ) ] + res [ int ( res . length / 12 ) ] + res [ int ( res . length / 13 ) ] + res [ int ( res . length / 14 ) ] + res [ int ( res . length / 15 ) ] ) ) ; }

40.94
42.47
56.5
52.63
def remainderWith7 ( num ) : series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] series_index = 0 result = 0 for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : digit = ord ( num [ i ] ) - 48 result += digit * series [ series_index ] series_index = ( series_index + 1 ) % 6 result %= 7 if ( result < 0 ) : result = ( result + 7 ) % 7 return result

static int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 }; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }

static int remainderWith7 ( int num ) { int series_index = 0 ; int result = 0 ; for ( int i = 0 ; i < len ( num ) ; i ++ ) { int digit = num [ i ] - 48 ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } return result ; }

int remainderWith7 ( int num ) { int series = new int [ 1 ] ; int series_index = 0 ; int result = 0 ; for ( int i = 1 ; i < num . length ; i ++ ) { digit = ord ( num [ i ] ) - 48 ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; if ( result < 0 ) result = ( result + 7 ) % 7 ; } return result ; }

40.96
66.5
91.74
95.04
def rectCount ( n , m ) : return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4

public static long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }

static int rectCount ( int n , int m ) { int n = n + 1 ; int m = m + 1 ; int m = m + 1 ; return n * ( n + 1 ) * ( m + 1 ) * ( m + 1 ) ; }

static int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }

40.97
74.94
66.21
71.7
def multiplyWith3Point5 ( x ) : return ( x << 1 ) + x + ( x >> 1 )

static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }

static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + ( x >> 1 ) + ( x >> 1 ) + ( x >> 1 ) + ( x >> 1 ) + ( x >> 1 ) + ( x >> 1 ) ; }

static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x ; }

41.07
58.99
32.8
57.21
def printSubStr ( st , low , high ) : sys . stdout . write ( st [ low : high + 1 ] ) sys . stdout . flush ( ) return ''

static void printSubStr ( String str , int low , int high ) { System . out . println ( str . substring ( low , high + 1 ) ) ; }

static String printSubStr ( String st , int low , int high ) { System . stdout . write ( st [ low : high + 1 ] ) return st ; }

static String printSubStr ( String st , int low , int high ) { System . out . write ( st [ low ] ) ; System . out . write ( st [ high ] ) ; System . out . flush ( ) ; }

41.08
30.71
46.05
44.59
def dayofweek ( d , m , y ) : t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] y -= m < 3 return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 )

static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 }; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }

static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 1 , 2 , 3 , 2 , 4 , 5 , 0 , 3 , 2 , 5 , 0 , 1 , 4 , 5 , 2 , 6 , 0 , 1 , 2 , 5 , 0 , 1 , 2 , 4 , 5 , 2 , 6 , 0 , 1 , 5 , 0 , 2 , 5 , 0 , 1 , 5 , 0 ,

static int dayofweek ( int d , int m , int y ) { int t [ ] = new int [ 3 ] ; int [ ] t = new int [ 4 ] ; y -= m < 3 ; return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) ; }

41.09
51.51
55.87
64.52
def minSwap ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : if ( arr [ i ] <= k ) : count = count + 1 bad = 0 for i in range ( 0 , count ) : if ( arr [ i ] > k ) : bad = bad + 1 ans = bad j = count for i in range ( 0 , n ) : if ( j == n ) : break if ( arr [ i ] > k ) : bad = bad - 1 if ( arr [ j ] > k ) : bad = bad + 1 ans = min ( ans , bad ) j = j + 1 return ans

static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . min ( ans , bad ) ; } return ans ; }

static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; int bad = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { count = count + 1 ; if ( arr [ i ] > k ) { bad = bad - 1 if ( arr [ j ] <= k ) { bad = bad + 1 if ( arr [ j ] <= k ) {

static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { count = count + 1 ; bad = 0 for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > k ) { bad = bad - 1 if ( arr [ i ] > k ) { bad = bad + 1 ; } ans = bad ; } } else if ( arr [ i ] > k ) { bad = bad - 1 if ( arr [ j ] > k ) { bad = bad + 1 } ans = min ( ans , bad ) ; j = j + 1 } } } return ans ; }

41.15
45.99
65.77
62.58
def findElements ( arr , n ) : first = - sys . maxsize second = - sys . maxsize for i in range ( 0 , n ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] for i in range ( 0 , n ) : if ( arr [ i ] < second ) : print ( arr [ i ] , end = "" )

static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " " ) ; }

static void findElements ( int arr [ ] , int n ) { int first = - sys . maxsize ; int second = - sys . maxsize ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < first ) { first = arr [ i ] ; } else { second = arr [ i ] ; } } return ; }

static void findElements ( int arr [ ] , int n ) { int first = - sys . maxsize ; int second = - sys . maxsize ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) first = arr [ i ] ; if ( arr [ i ] < second ) second = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) first = arr [ i ] ; if ( arr [ i ] < second ) { print ( arr [ i ] , end = "" ) ; } } } }

41.19
61.25
54.0
60.83
def checkOrigin ( x1 , y1 , x2 , y2 ) : return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) )

static boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }

static boolean checkOrigin ( float x1 , float y1 , float x2 , float y2 ) { return ( x1 * ( x2 - x1 ) == y1 * ( y2 - y1 ) == x2 * ( y2 - y1 ) == y2 * ( x2 - x1 ) == y2 * ( y2 - y1 ) ) ; }

static boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return checkOrigin ( x1 , y1 , x2 , y2 ) ; }

41.23
49.57
74.44
70.69
def minRemove ( arr , n ) : LIS = [ 0 for i in range ( n ) ] len = 0 for i in range ( n ) : LIS [ i ] = 1 for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) len = max ( len , LIS [ i ] ) return ( n - len )

static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }

static int minRemove ( int arr [ ] , int n ) { int [ ] LIS = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= j ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; len = max ( len ,

static int minRemove ( int arr [ ] , int n ) { int [ ] LIS = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; len = max ( len , LIS [ i ] ) ; } } } return ( n - len ) ; }

41.26
45.29
65.19
54.04
def kthgroupsum ( k ) : cur = int ( ( k * ( k - 1 ) ) + 1 ) sum = 0 while k : sum += cur cur += 2 k = k - 1 return sum

public static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }

static int kthgroupsum ( int k ) { int sum = 0 ; while ( k > 0 ) sum += cur ; k -- ; } return sum ; }

( int k ) { int cur = int ( ( k * ( k - 1 ) + 1 ) ; int sum = 0 ; while ( k ) { sum += cur ; cur ++ ; } return sum ; }

41.26
47.37
63.61
67.84
def countSetBits ( n ) : count = 0 while ( n ) : n &= ( n - 1 ) count += 1 return count

static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }

static int countSetBits ( int n ) { int count = 0 ; while ( n ) count += 1 ; }

static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; } return count ; }

41.26
41.23
64.72
61.18
def overflow ( H , r , h , N , R ) : tank_cap = 3.14 * r * r * H water_vol = 3.14 * r * r * h balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R vol = water_vol + balls_vol if vol > tank_cap : print ( "Overflow" ) else : print ( "Notinoverflowstate" )

static void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { System . out . println ( "Overflow" ) ; } else { System . out . println ( "Not in overflow state" ) ; } }

static void overflow ( int H , int r , int h , int N , int R ) { int tank_cap = 3.14 * r * r * h ; int water_vol = 3.14 * r * r * h ; int balls_vol = 3.14 * r * r * R ; if ( water_vol > tank_cap ) { print ( "Overflow" ) } else { print ( "Notinoverflowstate" ) }

static void overflow ( int H , int r , int h , int water_vol , int balls_vol ) { int tank_cap = 3.14 * r * r * H ; int water_vol = 3.14 * r * r * h ; int balls_vol = N * ( 4 / 3 ) * 3.14 * R * R ; int vol = water_vol + balls_vol ; if ( vol > tank_cap ) { print ( "Overflow" ) ; } else { print ( "Notinoverflowstate" ) ; } } }

41.36
34.26
46.65
42.76
def printSubsequences ( arr , n ) : opsize = math . pow ( 2 , n ) for counter in range ( 1 , ( int ) ( opsize ) ) : for j in range ( 0 , n ) : if ( counter & ( 1 << j ) ) : print ( arr [ j ] , end = "" ) print ( )

static void printSubsequences ( int n ) { int opsize = ( int ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) System . out . print ( arr [ j ] + " " ) ; } System . out . println ( ) ; } }

static void printSubsequences ( int arr [ ] , int n ) { int counter = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << j ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j

static void printSubsequences ( int arr [ ] , int n ) { for ( int counter = 1 ; counter < ( int ) ( opsize * 2 ) ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) { if ( counter & ( 1 << j ) ) { if ( counter & ( 1 << j ) ) { print ( arr [ j ] , end = "" ) ; } } } } } }

41.38
42.7
61.88
57.65
def check ( st ) : n = len ( st ) if ( n == 0 ) : return False if ( n == 1 ) : return ( ( st [ 0 ] - '0' ) % 4 == 0 ) last = ( int ) ( st [ n - 1 ] ) second_last = ( int ) ( st [ n - 2 ] ) return ( ( second_last * 10 + last ) % 4 == 0 )

static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }

static boolean check ( String st ) { int n = st . length ( ) ; if ( n == 2 ) return ( st [ n - 1 ] - '0' ) % 4 == 0 ) return ( st [ n - 2 ] - '0' ) % 4 == 0 ) return ( st [ n - 1 ] - '0' ) % 4 == 0 ) ; if ( n == 3 ) return ( st [ n - 2 ] - '0' ) %

static boolean check ( String st [ ] ) { int n = st . length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( st [ 0 ] - '0' ) % 4 == 0 ) ; int last = ( int ) st [ n - 1 ] ; int second_last = ( int ) st [ n - 2 ] ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }

41.44
41.16
47.76
42.82
def findSymPairs ( arr , row ) : hM = dict ( ) for i in range ( row ) : first = arr [ i ] [ 0 ] sec = arr [ i ] [ 1 ] if ( sec in hM . keys ( ) and hM [ sec ] == first ) : print ( "(" , sec , "," , first , ")" ) else : hM [ first ] = sec

static void findSymPairs ( int arr [ ] [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; Integer val = hM . get ( sec ) ; if ( val != null && val == first ) System . out . println ( "(" + sec + ", " + first + ")" ) ; else hM . put ( first , sec ) ; } }

static void findSymPairs ( int [ ] arr , int row ) { int [ ] hM = dict ( ) ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( hM [ sec ] == first ) { print ( "(" , sec , "," , first , ")" ) } else { hM [ first ] = sec ; } }

static void findSymPairs ( int [ ] arr , int row ) { int [ ] hM = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( sec in hM . keys ( ) && hM [ sec ] == first ) { print ( "(" , sec , "," , first , ")" ) ; } else { hM [ first ] = sec ; } } }

41.45
53.47
74.72
74.73
def countUnique ( mat , n , m ) : rowsum = [ 0 ] * n colsum = [ 0 ] * m for i in range ( n ) : for j in range ( m ) : if ( mat [ i ] [ j ] != 0 ) : rowsum [ i ] += 1 colsum [ j ] += 1 uniquecount = 0 for i in range ( n ) : for j in range ( m ) : if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : uniquecount += 1 return uniquecount

static int countUnique ( int mat [ ] [ ] , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }

static int countUnique ( int mat [ ] [ ] , int n , int m ) { int rowsum [ ] = new int [ n ] ; int colsum [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] += 1 colsum [ j ] +=

static int countUnique ( int mat [ ] [ ] , int n , int m ) { int rowsum [ ] = new int [ n ] ; int colsum [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] != 0 ) rowsum [ i ] += 1 ; colsum [ j ] += 1 ; } uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] != 0 ) rowsum [ i ] += 1 colsum [ j ] += 1 ; uniquecount ++ ; } } } return uniquecount ; }

41.46
44.77
82.71
85.48
def findRepeatingElement ( arr , low , high ) : if low > high : return - 1 mid = ( low + high ) / 2 if ( arr [ mid ] != mid + 1 ) : if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : return mid return findRepeatingElement ( arr , low , mid - 1 ) return findRepeatingElement ( arr , mid + 1 , high )

static int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }

static int findRepeatingElement ( int [ ] arr , int low , int high ) { int mid ; for ( mid = low ; mid <= high ; mid ++ ) { if ( arr [ mid ] == arr [ mid + 1 ] ) return mid ; } return - 1 ; } return findRepeatingElement ( arr , low , high ) ; }

static int findRepeatingElement ( int arr [ ] , int low , int high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , low , high ) ; }

41.5
46.28
69.29
69.21
def printPascal ( n ) : for line in range ( 1 , n + 1 ) : C = 1 for i in range ( 1 , line + 1 ) : print ( C , end = "" ) C = int ( C * ( line - i ) / i ) print ( "" )

public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }

static void printPascal ( int n ) { int C = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { print ( C , end = "" ) C = int ( C * line / i ) + " " ) ; } } }

static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { print ( C , end = "" ) ; C = int ( C * ( line - i ) / i ) ; } print ( "" ) ; } }

41.54
42.23
61.85
58.14
def findPossibleMoves ( mat , p , q ) : global n , m X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] count = 0 for i in range ( 8 ) : x = p + X [ i ] y = q + Y [ i ] if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) : count += 1 return count

static int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) { int X [ ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 }; int Y [ ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 }; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }

static int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) { int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 and y >= 0 and x < n and y < m ) { count += 1 ; } } return count ; }

static int findPossibleMoves ( int mat , int p , int q ) { int n = p + 1 ; int m = q + 1 ; int [ ] X = new int [ 8 ] ; int [ ] Y = new int [ 8 ] ; int [ ] count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }

41.57
40.16
62.17
56.52
def returnMaxSum ( A , B , n ) : mp = set ( ) result = 0 curr_sum = curr_begin = 0 for i in range ( 0 , n ) : while A [ i ] in mp : mp . remove ( A [ curr_begin ] ) curr_sum -= B [ curr_begin ] curr_begin += 1 mp . add ( A [ i ] ) curr_sum += B [ i ] result = max ( result , curr_sum ) return result

static int returnMaxSum ( int A [ ] , int B [ ] , int n ) { Set < Integer > mp = new HashSet < Integer > ( ) ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . contains ( A [ i ] ) ) { mp . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . add ( A [ i ] ) ; curr_sum += B [ i ] ; result = Integer . max ( result , curr_sum ) ; } return result ; }

static int returnMaxSum ( int A , int B , int n ) { Set < int > mp = new HashSet < int > ( ) ; int curr_sum = 0 ; int curr_begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( A [ i ] in mp : mp . add ( A [ curr_begin ] ) curr_sum -= B [ curr_begin ] ; curr_begin += 1 ; mp .

static int returnMaxSum ( int A , int B , int n ) { int result = 0 ; int curr_sum = 0 ; curr_begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( A [ i ] in mp ) { mp . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin += 1 ; mp . add ( A [ i ] ) ; curr_sum += B [ curr_begin ] ; } result = max ( result , curr_sum ) ; } return result ; }

41.61
42.69
63.71
52.86
def firstLetterWord ( str ) : result = "" v = True for i in range ( len ( str ) ) : if ( str [ i ] == '' ) : v = True elif ( str [ i ] != '' and v == True ) : result += ( str [ i ] ) v = False return result

static String firstLetterWord ( String str ) { String result = "" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ' ) { v = true ; } else if ( str . charAt ( i ) != ' ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; }

static String firstLetterWord ( String str ) { boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( v == true ) result += ( str [ i ] ) ; v = false ; } return result ; }

public static String firstLetterWord ( String str ) { String result = "" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '' ) v = true ; else if ( str [ i ] != '' && v == true ) result += ( str [ i ] ) ; v = false ; } return result ; }

41.62
48.46
77.84
78.8
def superSeq ( X , Y , m , n ) : dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if ( not i ) : dp [ i ] [ j ] = j elif ( not j ) : dp [ i ] [ j ] = i elif ( X [ i - 1 ] == Y [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) return dp [ m ] [ n ]

static int superSeq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

static int superSeq ( int X [ ] , int Y [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; } }

static int superSeq ( int X , int Y , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

41.63
42.35
51.68
68.84
def interpolationSearch ( arr , n , x ) : lo = 0 hi = ( n - 1 ) while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : if lo == hi : if arr [ lo ] == x : return lo ; return - 1 ; pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ) if arr [ pos ] == x : return pos if arr [ pos ] < x : lo = pos + 1 ; else : hi = pos - 1 ; return - 1

static int interpolationSearch ( int x ) { int lo = 0 , hi = ( arr . length - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) { if ( arr [ lo ] == x ) return lo ; return - 1 ; } int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) lo = pos + 1 ; else hi = pos - 1 ; } return - 1 ; }

static int interpolationSearch ( int arr [ ] , int n , int x ) { int pos ; int lo = 0 ; int hi = ( n - 1 ) ; while ( lo <= hi ) { if ( arr [ lo ] == x ) return lo ; if ( arr [ lo ] < x ) lo = pos + 1 ; else hi = pos - 1 ; } return - 1 ; } int hi = ( n - 1 ) ; while ( lo <= hi ) { if

private static int interpolationSearch ( int arr [ ] , int n , int x ) { int lo = 0 ; int hi = ( n - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) return lo ; pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; lo = pos + 1 ; else hi = pos - 1 ; } return - 1 ; }

41.65
45.53
51.03
58.81
def findArea ( arr , n ) : arr . sort ( reverse = True ) dimension = [ 0 , 0 ] i = 0 j = 0 while ( i < n - 1 and j < 2 ) : if ( arr [ i ] == arr [ i + 1 ] ) : dimension [ j ] = arr [ i ] j += 1 i += 1 i += 1 return ( dimension [ 0 ] * dimension [ 1 ] )

static int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 }; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }

static int findArea ( int arr [ ] , int n ) { int i = 0 ; int j = 0 ; while ( i < n - 1 and j < 2 ) { if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ] = arr [ i ] ; else dimension [ j ] = arr [ i ] ; j += 1 ; } return 0 ; }

static int findArea ( int arr [ ] , int n ) { int i = 0 ; int j = 0 ; while ( i < n - 1 && j < 2 ) { if ( arr [ i ] == arr [ i + 1 ] ) { dimension [ j ] = arr [ i ] ; j ++ ; } else if ( arr [ i ] == arr [ i + 1 ] ) { dimension [ j ] = arr [ i ] ; j ++ ; } } return ( dimension [ 0 ] * dimension [ 1 ] ) ; }

41.68
66.46
97.85
99.45
def binomialCoeff ( n , k ) : if k == 0 or k == n : return 1 return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k )

static int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }

static int binomialCoeff ( int n , int k ) { int binomialCoeff = binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n , k - 1 ) ; return binomialCoeff ( n , k - 1 ) + binomialCoeff ( n , k - 1 ) + binomialCoeff ( n , k - 1 ) + bin

public static int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }

41.87
42.61
63.41
54.55
def countSubstr ( s ) : n = len ( s ) auxArr = [ 0 for i in range ( n ) ] if ( s [ 0 ] == '1' ) : auxArr [ 0 ] = 1 for i in range ( 0 , n ) : if ( s [ i ] == '1' ) : auxArr [ i ] = auxArr [ i - 1 ] + 1 else : auxArr [ i ] = auxArr [ i - 1 ] count = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( s [ i ] == '1' ) : count += auxArr [ i ] return count

static int countSubstr ( String s ) { int n = s . length ( ) ; int [ ] auxArr = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ] ; return count ; }

static int countSubstr ( String s ) { int n = s . length ( ) ; int auxArr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else : auxArr [ i ] = auxArr [ i - 1 ] + 1 ; } } return 0 ; }

static int countSubstr ( String s ) { int n = s . length ( ) ; int auxArr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } return count ; }

41.88
37.86
56.73
57.71
def findmin ( p , n ) : a , b , c , d = 0 , 0 , 0 , 0 for i in range ( n ) : if ( p [ i ] [ 0 ] <= 0 ) : a += 1 elif ( p [ i ] [ 0 ] >= 0 ) : b += 1 if ( p [ i ] [ 1 ] >= 0 ) : c += 1 elif ( p [ i ] [ 1 ] <= 0 ) : d += 1 return min ( [ a , b , c , d ] )

static int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }

static int findmin ( int [ ] p , int n ) { int a , b , c , d ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] [ 0 ] <= 0 ) a += 1 ; if ( p [ i ] [ 1 ] >= 0 ) b += 1 ; if ( p [ i ] [ 0 ] >= 0 ) c += 1 ; if ( p [ i ] [ 1 ] >= 0 ) d

static int findmin ( int [ ] p , int n ) { int a = 0 ; int b = 0 ; int c = 0 ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] [ 0 ] <= 0 ) a += 1 ; else if ( p [ i ] [ 0 ] >= 0 ) b += 1 ; else if ( p [ i ] [ 1 ] >= 0 ) c += 1 ; else if ( p [ i ] [ 1 ] <= 0 ) d ++ ; } return min ( [ a , b , c , d ] ) ; }

41.9
42.51
63.14
55.46
def minLexRotation ( str_ ) : n = len ( str_ ) arr = [ 0 ] * n concat = str_ + str_ for i in range ( n ) : arr [ i ] = concat [ i : n + i ] arr . sort ( ) return arr [ 0 ]

static String minLexRotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }

static int minLexRotation ( String str_ ) { int n = str . length ( ) ; int i = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat [ i : n + i ] ; } return - 1 ; }

public static int minLexRotation ( String str ) { int n = str . length ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = str . charAt ( i ) ; } arr . sort ( ) ; return arr [ 0 ] ; }

41.91
66.7
43.09
60.35
def center ( x1 , x2 , y1 , y2 ) : print ( int ( ( x1 + x2 ) / 2 ) , end = "" ) print ( "," , int ( ( y1 + y2 ) / 2 ) )

static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + ", " + ( float ) ( y1 + y2 ) / 2 ) ; }

static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( int ( ( x1 + x2 ) / 2 ) , end = "" ) print ( "," , int ( ( y1 + y2 ) / 2 ) , end = "" ) print ( "," , int ( ( x1 + x2 ) / 2 ) , end = "" ) print ( "," , int ( ( y1 + y2

static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( x1 ) ; System . out . print ( x2 ) ; System . out . print ( y1 ) ; System . out . print ( y2 ) ; System . out . print ( " " ) ; }

41.98
48.41
58.5
57.85
def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 if ( dp [ position ] [ previous_sum ] != - 1 ) : return dp [ position ] [ previous_sum ] dp [ position ] [ previous_sum ] = 0 res = 0 sum = 0 for i in range ( position , length ) : sum += ( ord ( num [ i ] ) - ord ( '0' ) ) if ( sum >= previous_sum ) : res += countGroups ( i + 1 , sum , length , num ) dp [ position ] [ previous_sum ] = res return res

static int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }

static int countGroups ( int position , int previous_sum , int length , int [ ] dp ) { int res = 0 ; int sum = 0 ; for ( int i = 0 ; i < position ; i ++ ) { if ( sum >= previous_sum ) res += countGroups ( i + 1 , previous_sum , length , num ) ; dp [ position ] [ previous_sum ] = res ; } return res ; }

static int countGroups ( int position , int previous_sum , int length , int num ) { int res = 0 ; int sum = 0 ; for ( int i = 0 ; i < position ; i ++ ) { sum += ord ( num [ i ] ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }

41.99
49.59
58.34
59.75
def evenFibSum ( limit ) : if ( limit < 2 ) : return 0 ef1 = 0 ef2 = 2 sm = ef1 + ef2 while ( ef2 <= limit ) : ef3 = 4 * ef2 + ef1 if ( ef3 > limit ) : break ef1 = ef2 ef2 = ef3 sm = sm + ef2 return sm

static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }

static int evenFibSum ( int limit ) { int ef1 = 0 ; int ef2 = 2 ; int ef3 = 4 * ef2 + ef1 ; int sm = 0 ; while ( ef2 <= limit ) { ef1 = ef1 + ef2 ; ef2 = ef3 ; } return 0 ; }

static int evenFibSum ( int limit ) { int ef1 = 0 ; int ef2 = 2 ; int sm = 0 ; int ef3 = 0 ; while ( ef2 <= limit ) { ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sm = sm + ef2 ; } return sm ; }

42.1
41.2
51.5
45.62
def calcMaxValue ( str ) : res = ord ( str [ 0 ] ) - 48 for i in range ( 1 , len ( str ) ) : if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : res += ord ( str [ i ] ) - 48 else : res *= ord ( str [ i ] ) - 48 return res

static int calcMaxValue ( String str ) { int res = str . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' ) ; else res *= ( str . charAt ( i ) - '0' ) ; } return res ; }

static int calcMaxValue ( String str ) { int res = 0 ; for ( int i = 1 ; i < len ( str ) ; i ++ ) { if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) res += ord ( str [ i ] ) - 48 ; else res *= 2 ; } return res ; }

static int calcMaxValue ( String str ) { int res = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) res += ord ( str [ i ] ) - 48 ; else res *= ord ( str [ i ] ) - 48 ; } return res ; }

42.13
47.68
21.66
34.78
def fib ( n ) : if ( n == 0 ) : return 0 if ( n == 1 or n == 2 ) : f [ n ] = 1 return ( f [ n ] ) if ( f [ n ] ) : return f [ n ] if ( n & 1 ) : k = ( n + 1 ) // 2 else : k = n // 2 if ( ( n & 1 ) ) : f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) else : f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) return f [ n ]

public static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }

static int fib ( int n ) { int f [ ] = new int [ n + 1 ] ; if ( n == 2 ) f [ n ] = ( fib ( k ) + fib ( k - 1 ) ) * fib ( k - 1 ) ; else f [ n ] = ( fib ( k ) + fib ( k - 1 ) ) * fib ( k - 1 ) + fib ( k ) ) ; return f [ n ] ; }

static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return ( f [ n ] ) ; if ( n == 2 ) return ( f [ n ] ) ; if ( n == 3 ) return ( f [ n ] ) ; if ( n == 4 ) return ( f [ n ] ) ; if ( n == 5 ) return ( f [ n ] ) ; if ( n == 6 ) return ( f [ n ] ) ; if ( n == 7 ) return ( f [ n ] ) ; if ( n == 8 ) return ( f [ n ] ) ; if ( n == 9 ) return ( f [ n ] ) ; if ( n == 10 ) return ( f [ n ] ) ; if ( n == 11 ) return ( f [ n ] ) ; if ( n == 12 ) return ( f [ n ] ) ; if ( n == 13 ) return ( f [ n ] ) ; if ( n == 14 ) return ( f [ n ] ) ; if ( n == 15 ) return ( f [ n ] ) ; return ( f [ n ] ) ; }

42.19
39.5
60.54
52.33
def areDisjoint ( set1 , set2 , m , n ) : set1 . sort ( ) set2 . sort ( ) i = 0 ; j = 0 while ( i < m and j < n ) : if ( set1 [ i ] < set2 [ j ] ) : i += 1 elif ( set2 [ j ] < set1 [ i ] ) : j += 1 else : return False return True

boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { int i = 0 , j = 0 ; Arrays . sort ( set1 ) ; Arrays . sort ( set2 ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }

static boolean areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; while ( i < m && j < n ) { if ( set1 [ i ] > set2 [ j ] ) { i += 1 ; } else { return false ; } } return true ; }

static boolean areDisjoint ( int set1 , int set2 , int m , int n ) { int i = 0 ; int j = 0 ; while ( i < m && j < n ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set2 [ j ] < set1 [ i ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } }

42.27
42.52
56.18
51.02
def printAllAPTriplets ( arr , n ) : s = [ ] for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : diff = arr [ j ] - arr [ i ] if ( ( arr [ i ] - diff ) in arr ) : print ( "{}{}{}" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = "\n" ) s . append ( arr [ i ] )

static void printAllAPTriplets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }

static void printAllAPTriplets ( int arr [ ] , int n ) { List < int > s = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( ( arr [ i ] - diff ) in arr ) s . append ( arr [ i ] ) ; else s . append ( arr [ j ] ) ; } }

static void printAllAPTriplets ( int arr [ ] , int n ) { int s [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( ( arr [ i ] - diff ) in arr ) { print ( "{}{}{}" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = "\n" ) s . append ( arr [ i ] ) ; } } } return ; }

42.38
48.4
30.0
31.74
def squareRoot ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( ( x * x ) % p == n ) : print ( "Squarerootis" , x ) return print ( "Squarerootdoesn'texist" )

static void squareRoot ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) { System . out . println ( "Square " + "root is " + x ) ; return ; } } System . out . println ( "Square root " + "doesn't exist" ) ; }

static void squareRoot ( int n , int p ) { int x ; for ( x = 2 ; x <= p ; x ++ ) { if ( ( x * x ) % p == n ) { print ( "Squarerootis" , x ) return print ( "Squarerootdoesn'texist" ) return print ( "Squarerootdoesn'texist" ) return print ( "Squarerootdoesn'texist" ) return print

static void squareRoot ( int n , int p ) { System . out . println ( "Squarerootis" ) ; System . out . println ( "Squarerootdoesn'texist" ) ; System . out . println ( "Squarerootdoesn'texist" ) ; System . out . println ( "Squarerootis" ) ; System . out . println ( "Squarerootdoesn'texist" ) ; System . out . println ( "Squarerootdoesn'texist" ) ; }

42.39
36.01
52.9
49.17
def minPalPartion ( str ) : n = len ( str ) C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] P = [ [ False for i in range ( n ) ] for i in range ( n ) ] j = 0 k = 0 L = 0 for i in range ( n ) : P [ i ] [ i ] = True C [ i ] [ i ] = 0 for L in range ( 2 , n + 1 ) : for i in range ( n - L + 1 ) : j = i + L - 1 if L == 2 : P [ i ] [ j ] = ( str [ i ] == str [ j ] ) else : P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] ) if P [ i ] [ j ] == True : C [ i ] [ j ] = 0 else : C [ i ] [ j ] = 100000000 for k in range ( i , j ) : C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) return C [ 0 ] [ n - 1 ]

static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }

static int minPalPartion ( String str ) { int n = str . length ( ) ; int i = 0 ; int j = 0 ; int k = 0 ; int L = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; } C [ i ] [ j ] = ( P [ i ] [ j - 1 ] == true ) ; C [ i ] [ j ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( P [ i ] [ j ] == true ) P [ i ] [ j ] = ( P [ i ] == str [ j ] ) ; P [ i ] [ j ] = ( P [ i ] == str [ j ] ) ; } } C [ i ] [ j ] = true ; } C [ j ] [ j ] = ( P [ i ] [ j ] = true ; C [ j ] = 0 ; for ( int j = i ; j ++ ) { if ( P [ i ] [ j

static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = i ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( P [ i ] [ j ] == true ) { C [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; } else if ( P [ i ] [ j ] == true ) { C [ i ] [ j ] = 0 ; } else if ( P [ i ] [ j ] == true ) { C [ i ] [ j ] = 0 ; } else { C [ i ] [ j ] = 100000000 ; } for ( int k = 0 ; k < n ; k ++ ) { C [ i ] [ k ] = min ( C [ i ] [ k ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }

42.46
44.83
54.78
48.12
def firstElement ( arr , n , k ) : count_map = { } for i in range ( 0 , n ) : if ( arr [ i ] in count_map . keys ( ) ) : count_map [ arr [ i ] ] += 1 else : count_map [ arr [ i ] ] = 1 i += 1 for i in range ( 0 , n ) : if ( count_map [ arr [ i ] ] == k ) : return arr [ i ] i += 1 return - 1

static int firstElement ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > count_map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = 0 ; if ( count_map . get ( arr [ i ] ) != null ) { a = count_map . get ( arr [ i ] ) ; } count_map . put ( arr [ i ] , a + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . get ( arr [ i ] ) == k ) { return arr [ i ] ; } } return - 1 ; }

static int firstElement ( int arr [ ] , int n , int k ) { int count_map = { } ; for ( int i = 0 ; i < n ; i ++ ) { if ( count_map [ arr [ i ] ] == k ) return arr [ i ] ; i += 1 for ( int i = 0 ; i < n ; i ++ ) { if ( count_map [ arr [ i ] ] == k ) return arr [ i ] ;

static int firstElement ( int arr [ ] , int n , int k ) { int count_map = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in count_map . keySet ( ) ) { count_map [ arr [ i ] ] ++ ; } else { count_map [ arr [ i ] ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in count_map . keySet ( ) ) { count_map [ arr [ i ] ] ++ ; } else { count_map [ arr [ i ] ] = 1 ; } } return - 1 ; }

42.46
44.5
85.68
84.37
def isTriangular ( num ) : if ( num < 0 ) : return False c = ( - 2 * num ) b , a = 1 , 1 d = ( b * b ) - ( 4 * a * c ) if ( d < 0 ) : return False root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) if ( root1 > 0 and math . floor ( root1 ) == root1 ) : return True if ( root2 > 0 and math . floor ( root2 ) == root2 ) : return True return False

static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }

static boolean isTriangular ( int num ) { int b = 0 , a = 0 ; int c = ( - 2 * num ) ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; if ( root1 > 0 and math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 and math . floor ( root2 ) == root2 ) return true ; if

static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) ; root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && math . floor ( root2 ) == root2 ) return true ; return false ; }

42.49
38.6
40.34
50.59
def findMin ( V ) : deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] n = len ( deno ) ans = [ ] i = n - 1 while ( i >= 0 ) : while ( V >= deno [ i ] ) : V -= deno [ i ] ans . append ( deno [ i ] ) i -= 1 for i in range ( len ( ans ) ) : print ( ans [ i ] , end = "" )

static void findMin ( int V ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( " " + ans . elementAt ( i ) ) ; } }

static int findMin ( int V ) { int n = deno . length - 1 ; int ans [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int i = 0 ; i < ans . length ; i ++ ) { if ( V >= deno [ i ] ) ans . append ( deno [ i ] ) ; i -- ; } } return ans [ n - 1 ] ; } }

static void findMin ( int V ) { int deno [ ] = new int [ n ] ; int i = n - 1 ; while ( V >= deno [ i ] ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . append ( deno [ i ] ) ; i -- ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . append ( deno [ i ] ) ; i -- ; } for ( int i = 0 ; i < n ; i ++ ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . append ( deno [ i ] ) ; i -- ; } } } return ; }

42.5
46.01
53.0
49.11
def nearestSmallerEqFib ( n ) : if ( n == 0 or n == 1 ) : return n f1 , f2 , f3 = 0 , 1 , 1 while ( f3 <= n ) : f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; return f2 ;

public static int nearestSmallerEqFib ( int n ) { if ( n == 0 || n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }

static int nearestSmallerEqFib ( int n ) { int f1 , f2 , f3 ; while ( f2 <= n ) { f1 = f1 ; f2 = f3 ; f3 = f1 + f2 ; } return n ; }

static int nearestSmallerEqFib ( int n ) { int f1 , f2 , f3 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }

42.5
41.56
26.89
39.44
def countWays ( s ) : count = [ 0 ] * 26 for x in s : count [ ord ( x ) - ord ( 'a' ) ] = ( count [ ord ( x ) - ord ( 'a' ) ] ) + 1 count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1 ans = 1 for i in range ( 26 ) : if ( count [ i ] != 0 ) : ans *= count [ i ] return ans

static int countWays ( String s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( 0 ) - 'a' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }

static int countWays ( String s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] != 0 ) ans *= count [ i ] ; else ans *= count [ i ] ; } return ans ; }

static int countWays ( int [ ] s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { count [ ord ( s [ i ] ) - ord ( 'a' ) ] = ( count [ ord ( s [ i ] ) - ord ( 'a' ) ] ) + 1 ; count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = ( count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] ) + 1 ; count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = ( count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] ) + 1 ; count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1 ; } return ans ; }

42.52
43.08
54.99
46.96
def minTimeForWritingChars ( N , insrt , remov , cpy ) : if N == 0 : return 0 if N == 1 : return insrt dp = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : if i % 2 == 0 : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + cpy ) else : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) // 2 ] + cpy + remov ) return dp [ N ]

static int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }

static int minTimeForWritingChars ( int N , int insrt , int remov , int cpy ) { int dp [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + remov , dp [ i // 2 ] + cpy ) ; } return insrt ; }

public static int minTimeForWritingChars ( int N , int insrt , int remov , int cpy ) { int dp [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) dp [ i - 1 ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + cpy ) ; else dp [ ( i + 1 ) // 2 ] = min ( dp [ ( i + 1 ) // 2 ] + insrt , dp [ ( i + 1 ) // 2 ] + cpy ) ; } return insrt ; }

42.52
42.24
53.81
50.32
def pythagoreanTriplets ( limits ) : c , m = 0 , 2 while c < limits : for n in range ( 1 , m ) : a = m * m - n * n b = 2 * m * n c = m * m + n * n if c > limits : break print ( a , b , c ) m = m + 1

static void pythagoreanTriplets ( int limit ) { int a , b , c = 0 ; int m = 2 ; while ( c < limit ) { for ( int n = 1 ; n < m ; ++ n ) { a = m * m - n * n ; b = 2 * m * n ; c = m * m + n * n ; if ( c > limit ) break ; System . out . println ( a + " " + b + " " + c ) ; } m ++ ; } }

static void pythagoreanTriplets ( int limits ) { int c , m = 0 , 2 ; for ( int n = 1 ; n <= m ; n ++ ) { for ( int a = m * m - n * n ; a < limits ; a ++ ) { for ( int b = m * m + n * n ; b < limits ; b ++ ) { if ( c > limits ) break ; c = m * m + n * n ;

; int c , m = 0 , 2 ; while ( c < limits ) { for ( int n = 1 ; c < m ; n ++ ) { a = m * m - n * n ; b = 2 * m * n ; c = m * m + n * n ; if ( c > limits ) break ; print ( a , b , c ) ; m = m + 1 ; } }

42.57
49.73
45.21
46.27
def countSink ( n , m , edgeFrom , edgeTo ) : mark = [ 0 ] * ( n + 1 ) for i in range ( m ) : mark [ edgeFrom [ i ] ] = 1 count = 0 for i in range ( 1 , n + 1 ) : if ( not mark [ i ] ) : count += 1 return count

static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int [ ] mark = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( mark [ i ] == 0 ) count ++ ; return count ; }

static int countSink ( int n , int m , int [ ] edgeFrom , int [ ] edgeTo ) { int count = 0 ; int mark [ ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ! mark [ edgeTo [ i ] ] ) count += 1 ; } return count ; }

static int countSink ( int n , int m , int edgeFrom , int edgeTo ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mark [ edgeFrom [ i ] ] ) { count ++ ; } } if ( ! mark [ edgeTo [ i ] ] ) { count ++ ; } return count ; }

42.58
40.09
71.65
65.26
def binarySearch ( arr , l , r , x ) : if ( r >= l ) : mid = int ( l + ( r - l ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > l and arr [ mid - 1 ] == x ) : return ( mid - 1 ) if ( mid < r and arr [ mid + 1 ] == x ) : return ( mid + 1 ) if ( arr [ mid ] > x ) : return binarySearch ( arr , l , mid - 2 , x ) return binarySearch ( arr , mid + 2 , r , x ) return - 1

int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; }

static int binarySearch ( int arr [ ] , int l , int r , int x ) { int mid = int ( l + r / 2 ) ; if ( arr [ mid ] < x ) return ( mid - 1 ) if ( arr [ mid ] < x ) return ( mid + 1 ) if ( arr [ mid ] > x ) return ( mid - 1 ) if ( arr [ mid ] < x ) return ( mid + 1 ) if ( arr [ mid ] < x ) return (

static int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = int ( l + ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return ( mid + 1 ) ; if ( arr [ mid ] < x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return ( mid + 1 ) ; } return - 1 ; }

42.59
47.17
48.55
71.04
def findMin ( arr , low , high ) : if high < low : return arr [ 0 ] if high == low : return arr [ low ] mid = int ( ( low + high ) / 2 ) if mid < high and arr [ mid + 1 ] < arr [ mid ] : return arr [ mid + 1 ] if mid > low and arr [ mid ] < arr [ mid - 1 ] : return arr [ mid ] if arr [ high ] > arr [ mid ] : return findMin ( arr , low , mid - 1 ) return findMin ( arr , mid + 1 , high )

static int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }

static int findMin ( int arr [ ] , int low , int high ) { int mid ; for ( mid = low ; mid <= high ; mid ++ ) { if ( arr [ mid ] > arr [ mid - 1 ] ) return findMin ( arr , mid - 1 , high ) ; if ( arr [ mid ] > arr [ mid ] ) return findMin ( arr , low , mid ) ; if ( arr [ mid ] > arr [ mid ] ) return find

static int findMin ( int arr [ ] , int low , int high ) { int mid = int ( ( low + high ) / 2 ) ; if ( mid < low && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > high && arr [ mid - 1 ] < arr [ mid - 1 ] ) return arr [ mid - 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( mid > low && arr [ mid - 1 ] < arr [ mid - 1 ] ) return arr [ mid - 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( mid > high && arr [ mid - 1 ] < arr [ mid - 1 ] ) return arr [ mid - 1 ] ; return findMin ( arr , low , mid - 1 ) ; }

42.59
55.7
77.91
68.27
def power ( x , y ) : if ( y == 0 ) : return 1 temp = power ( x , int ( y / 2 ) ) if ( y % 2 == 0 ) : return temp * temp else : if ( y > 0 ) : return x * temp * temp else : return ( temp * temp ) / x

static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }

static int power ( int x , int y ) { int temp = power ( x , int ( y / 2 ) ) ; if ( y % 2 == 0 ) return ( x * temp ) / x ; else return ( x * temp ) / x ; } return 1 ; }  def power ( int x , int y ) { int temp = power ( x , int ( y ) ) ; if ( y > 0 ) return ( x * temp ) / x ;

; } static int power ( int x , int y ) { if ( y == 0 ) return 1 ; int temp = power ( x , y ) ; if ( y % 2 == 0 ) return temp * temp ; else if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; }

42.6
49.01
39.25
49.28
def relativeComplement ( arr1 , arr2 , n , m ) : i = 0 j = 0 while ( i < n and j < m ) : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ] , "" , end = "" ) i += 1 elif ( arr1 [ i ] > arr2 [ j ] ) : j += 1 elif ( arr1 [ i ] == arr2 [ j ] ) : i += 1 j += 1 while ( i < n ) : print ( arr1 [ i ] , "" , end = "" )

static void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ] + " " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) System . out . print ( arr1 [ i ] + " " ) ; }

static void relativeComplement ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { int i = 0 ; int j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { print ( arr1 [ i ] , "" , end = "" ) i += 1 ; } else { if ( arr1 [ i ] > arr2 [ j ] ) { i

static void relativeComplement ( int arr1 [ ] , int arr2 [ ] ) { int i = 0 ; int j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { if ( arr1 [ i ] > arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; }

42.6
44.3
65.09
74.12
def binarySearch ( arr , low , high , key ) : if ( high < low ) : return - 1 mid = ( low + high ) / 2 if ( key == arr [ int ( mid ) ] ) : return mid if ( key > arr [ int ( mid ) ] ) : return binarySearch ( arr , ( mid + 1 ) , high , key ) return ( binarySearch ( arr , low , ( mid - 1 ) , key ) )

static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }

static int binarySearch ( int [ ] arr , int low , int high , int key ) { int mid = ( low + high ) / 2 ; if ( key < arr [ int ( mid ) ] ) return mid ; if ( key > arr [ int ( mid ) ] ) return mid ; if ( key < arr [ int ( mid ) ] ) return mid ; if ( key > arr [ int ( mid ) ] ) return mid ; if ( key > arr [ int ( mid ) ] ) return (

static int binarySearch ( int [ ] arr , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ int ( mid ) ] ) return mid ; if ( key > arr [ int ( mid + 1 ) ] ) return mid ; if ( key < arr [ int ( mid + 1 ) ] ) return mid ; return ( binarySearch ( arr , low , ( mid + 1 ) , key ) ) ; }

42.65
57.99
14.65
24.37
def findCombinations ( string , index , out ) : if index == len ( string ) : print ( out ) for i in range ( index , len ( string ) , 1 ) : findCombinations ( string , i + 1 , out + "(" + string [ index : i + 1 ] + ")" )

static void findCombinations ( String str , int index , String out ) { if ( index == str . length ( ) ) System . out . println ( out ) ; for ( int i = index ; i < str . length ( ) ; i ++ ) findCombinations ( str , i + 1 , out + "(" + str . substring ( index , i + 1 ) + ")" ) ; }

static void findCombinations ( String string , int index , String out ) { if ( index == 0 ) return ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) findCombinations ( string , i , out + "(" + string [ index : i + 1 ] + ")" ) ; if ( i == index ) return ; for ( int i = 0 ; i < index ; i ++ ) findCombinations ( string , i , out +

static void findCombinations ( String string , int index , StringBuilder out ) { if ( index == 0 ) { out . append ( string ) ; } else { out . append ( string ) ; } }

42.67
61.13
98.52
99.05
def countP ( n , k ) : if ( n == 0 or k == 0 or k > n ) : return 0 if ( k == 1 or k == n ) : return 1 return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) )

public static int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }

static int countP ( int n , int k ) { if ( n == 0 ) return 0 if ( k == 1 ) return ( n - 1 ) + countP ( n - 1 , k - 1 ) + countP ( n - 1 , k - 1 ) + countP ( n - 1 , k - 1 ) + countP ( n - 1 , k - 1 ) + countP ( n , k - 1 ) + countP ( n , k -

static int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }

42.76
44.03
46.0
44.45
def findTriplets ( arr , n ) : found = False for i in range ( n - 1 ) : s = set ( ) for j in range ( i + 1 , n ) : x = - ( arr [ i ] + arr [ j ] ) if x in s : print ( x , arr [ i ] , arr [ j ] ) found = True else : s . add ( arr [ j ] ) if found == False : print ( "NoTripletFound" )

static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( s . contains ( x ) ) { System . out . printf ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) ; found = true ; } else { s . add ( arr [ j ] ) ; } } } if ( found == false ) { System . out . printf ( " No Triplet Found\n" ) ; } }

static boolean findTriplets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { Set < int > s = new HashSet < int > ( ) ; for ( int j = i ; j < n ; j ++ ) { if ( s . contains ( arr [ j ] ) ) found = true ; else s . add ( arr [ j ] ) ; } } if ( found == false

static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < arr . length ; i ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( x in s ) found = true ; else s . add ( arr [ j ] ) ; if ( found == true ) { print ( x , arr [ i ] , arr [ j ] ) ; found = true ; } } }

42.8
44.55
69.02
65.23
def segregateElements ( arr , n ) : temp = [ 0 for k in range ( n ) ] j = 0 for i in range ( n ) : if ( arr [ i ] >= 0 ) : temp [ j ] = arr [ i ] j += 1 if ( j == n or j == 0 ) : return for i in range ( n ) : if ( arr [ i ] < 0 ) : temp [ j ] = arr [ i ] j += 1 for k in range ( n ) : arr [ k ] = temp [ k ]

static void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }

static void segregateElements ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < 0 ) temp [ j ] = arr [ i ] ; j += 1 for ( int k = 0 ; k < n ; k ++ ) { temp [ j ] = arr [ k ] ; j += 1 for ( int i = 0 ; i < arr

; int segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) temp [ j ] = arr [ i ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) temp [ j ] = arr [ i ] ; j ++ ; } for ( int k = 0 ; k < n ; k ++ ) arr [ k ] = temp [ k ] ; } return ; }

42.81
52.77
38.86
35.09
def printDistinct ( arr , n ) : s = dict ( ) for i in range ( n ) : if ( arr [ i ] not in s . keys ( ) ) : s [ arr [ i ] ] = arr [ i ] print ( arr [ i ] , end = "" )

static void printDistinct ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ! set . contains ( arr [ i ] ) ) { set . add ( arr [ i ] ) ; System . out . print ( arr [ i ] + " " ) ; } } }

static void printDistinct ( int arr [ ] , int n ) { dict s = new dict ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( s [ arr [ i ] ] != arr [ i ] ) s [ arr [ i ] ] = arr [ i ] ; if ( s [ arr [ i ] ] != arr [ i ] ) { s [ arr [ i ] ] = arr [ i ] ; } } }

static void printDistinct ( String [ ] arr , int n ) { HashMap < String , String > s = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != null ) s [ arr [ i ] ] = arr [ i ] ; else s [ arr [ i ] ] = arr [ i ] ; } }

42.92
44.83
75.38
74.14
def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : if ( curr_sum <= 0 and x > 0 ) : start = end curr_sum = 0 curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len

static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end ; curr_sum = 0 ; } curr_sum += arr [ end ++ ] ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }

static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int min_len = arr . length - 1 ; int start = 0 ; int end = 0 ; while ( curr_sum > x ) { if ( end - start < min_len ) { min_len = end - start ; curr_sum -= arr [ start ] start += 1 while ( curr_sum > 0 and x > 0 ) { start = end curr_sum =

static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 ; int min_len = n + 1 ; int start = 0 ; int end = 0 ; while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) start = end curr_sum = 0 ; curr_sum += arr [ end ] ; end += 1 ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start curr_sum -= arr [ start ] ; start += 1 ; } } return min_len ; }

42.97
46.36
30.22
45.34
def exponential ( n , x ) : sum = 1.0 for i in range ( n , 0 , - 1 ) : sum = 1 + x * sum / i print ( "e^x=" , sum )

static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }

static void exponential ( int n , int x ) { double sum = 1.0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = 1 + x * sum / i ; } print ( "e^n=" , n ) ; }

static void exponential ( int n , int x ) { double sum = 1.0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = 1 + x * sum / i ; sum = 1 + x * sum / i ; } sum = 1 + x * sum / n ; System . out . println ( "e^x=" , sum ) ; }

43.0
46.28
40.71
57.06
def exactPrimeFactorCount ( n ) : count = 0 if ( n % 2 == 0 ) : count = count + 1 while ( n % 2 == 0 ) : n = int ( n / 2 ) i = 3 while ( i <= int ( math . sqrt ( n ) ) ) : if ( n % i == 0 ) : count = count + 1 while ( n % i == 0 ) : n = int ( n / i ) i = i + 2 if ( n > 2 ) : count = count + 1 return count

static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }

static int exactPrimeFactorCount ( int n ) { int count = 0 ; int i = 3 ; while ( i <= int ( math . sqrt ( n ) ) ) { if ( n % i == 0 ) { count = count + 1 ; while ( i <= int ( math . sqrt ( n ) ) ) { if ( n % i == 0 ) { count = count + 1 ; while ( i <= int ( math . sqrt ( n ) ) ) { if (

public static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count = count + 1 ; while ( i <= int ( math . sqrt ( n ) ) ) { if ( n % i == 0 ) { count = count + 1 ; while ( n % i == 0 ) { count = count + 1 ; while ( n % i == 0 ) { count = count + 1 ; } n = int ( n / i ) ; i = i + 2 ; } } if ( n % i == 0 ) { count = count + 1 ; while ( n % i == 0 ) { count = count + 1 ; } n = int ( n / i ) ; i = i + 2 ; } if ( n > 2 ) { count = count + 1 ; } } } return count ; }

43.09
50.25
78.96
71.0
def find ( p ) : return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) )

static double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }

static int find ( int p ) { return math . ceil ( math . log ( 1 / ( 1 - p ) ) ) ; }  static int find ( int p ) { return find ( p ) ; }

static int find ( int p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ; }

43.1
43.36
75.28
79.81
def maxTripletSum ( arr , n ) : maxA = - 100000000 maxB = - 100000000 maxC = - 100000000 for i in range ( 0 , n ) : if ( arr [ i ] > maxA ) : maxC = maxB maxB = maxA maxA = arr [ i ] elif ( arr [ i ] > maxB ) : maxC = maxB maxB = arr [ i ] elif ( arr [ i ] > maxC ) : maxC = arr [ i ] return ( maxA + maxB + maxC )

static int maxTripletSum ( int arr [ ] , int n ) { int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }

static long maxTripletSum ( long [ ] arr , int n ) { long maxA = - 100000000 ; long maxB = - 100000000 ; long maxC = - 100000000 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxA maxA = arr [ i ] ; } } return ( maxA + maxB + maxC ) ; } return (

static int maxTripletSum ( int arr [ ] , int n ) { int maxA = - 100000000 ; int maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) maxC = maxB maxB = maxA maxA = arr [ i ] ; else if ( arr [ i ] > maxB ) maxC = maxB maxB = arr [ i ] ; else if ( arr [ i ] > maxC ) maxC = maxB maxB = arr [ i ] ; else if ( arr [ i ] > maxC ) maxC = maxC ; } return ( maxA + maxB + maxC ) ; }

43.11
42.81
38.85
39.37
def maxDistance ( arr , n ) : mp = { } maxDict = 0 for i in range ( n ) : if arr [ i ] not in mp . keys ( ) : mp [ arr [ i ] ] = i else : maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) return maxDict

static int maxDistance ( int [ ] arr , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }

static int maxDistance ( int arr [ ] , int n ) { int maxDict = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( mp . get ( arr [ i ] ) == - 1 ) maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) ; else maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) ; } return maxDict ; }

static int maxDistance ( int arr [ ] , int n ) { int maxDict = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] not in mp . keys ( ) ) mp [ arr [ i ] ] = i ; else maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) ; } return maxDict ; }

43.31
54.63
100.0
100.0
def maxSquare ( b , m ) : return ( b / m - 1 ) * ( b / m ) / 2

static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }

static int maxSquare ( int b , int m ) { int maxSquare = maxSquare ( b , m ) ; return maxSquare ; }

static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }

43.32
54.04
49.66
56.0
def countWays ( N ) : if ( N == 1 ) : return 4 countB = 1 countS = 1 for i in range ( 2 , N + 1 ) : prev_countB = countB prev_countS = countS countS = prev_countB + prev_countS countB = prev_countS result = countS + countB return ( result * result )

static int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }

static int countWays ( int N ) { int countB = 1 ; int countS = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int prev_countB = countB ; countB = prev_countB + prev_countS ; countS = prev_countS ; countS = prev_countB + prev_countS ; countB = prev_countB ; countS = prev_countS ; } return

static int countWays ( int N ) { int countB = 1 ; int countS = 1 ; for ( int i = 2 ; i < N ; i ++ ) { int prev_countB = countB ; int prev_countS = countS ; int countB = countB ; int countS = countS ; int result = countB + countS ; return ( result * result ) / ( countB + countS ) ; } }

43.4
48.23
49.91
51.81
def rangeGCD ( n , m ) : return n if ( n == m ) else 1

static int rangeGCD ( int n , int m ) { return ( n == m ) ? n : 1 ; }

static int rangeGCD ( int n , int m ) { return n

static int rangeGCD ( int n , int m ) { return n ; }

43.4
62.93
43.42
64.99
def countSolutions ( n ) : res = 0 x = 0 while ( x * x < n ) : y = 0 while ( x * x + y * y < n ) : res = res + 1 y = y + 1 x = x + 1 return res

static int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }

static int countSolutions ( int n ) { int res = 0 ; int x = 0 ; int y = 0 ; while ( x * x + y * y < n ) { res = res + 1 x = x + 1 ; while ( y * y < n ) { res = res + 1 y = y + 1 ; } } return res ; }

static int countSolutions ( int n ) { int res = 0 ; int x = 0 ; int y = 0 ; while ( x * x + y * y < n ) { res = res + 1 ; while ( x * x + y * y < n ) res = res + 1 ; y = y + 1 ; x = x + 1 ; } return res ; }

43.48
51.91
61.38
61.36
def findRepeatFirstN2 ( s ) : p = - 1 for i in range ( len ( s ) ) : for j in range ( i + 1 , len ( s ) ) : if ( s [ i ] == s [ j ] ) : p = i break if ( p != - 1 ) : break return p

static int findRepeatFirstN2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }

static int findRepeatFirstN2 ( String s ) { int p = - 1 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break if ( p != - 1 ) { break if ( s [ i ] == s [ j ] ) { p = i ; break if ( p != - 1 ) { break if ( p != - 1 ) {

static int findRepeatFirstN2 ( String s ) { int p = - 1 ; for ( int i = 0 ; i < s . length ; i ++ ) { for ( int j = 0 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } if ( p != - 1 ) { break ; } } } return p ; }

43.5
44.56
66.64
69.01
def findMinimumAngle ( arr , n ) : l = 0 _sum = 0 ans = 360 for i in range ( n ) : _sum += arr [ i ] while _sum >= 180 : ans = min ( ans , 2 * abs ( 180 - _sum ) ) _sum -= arr [ l ] l += 1 ans = min ( ans , 2 * abs ( 180 - _sum ) ) return ans

public static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 , sum = 0 , ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; while ( sum >= 180 ) { ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; sum -= arr [ l ] ; l ++ ; } ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; } return ans ; }

static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 ; int _sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( _sum >= 180 ) { ans = min ( ans , 2 * abs ( 180 - _sum ) ) ; _sum -= arr [ l ] ; l += 1 ; } } return ans ; }

static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 ; int _sum = 0 ; int ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { _sum += arr [ i ] ; while ( _sum >= 180 ) { ans = min ( ans , 2 * abs ( 180 - _sum ) ) ; _sum -= arr [ l ] ; l += 1 ; } ans = min ( ans , 2 * abs ( 180 - _sum ) ) ; } return ans ; }

43.54
66.82
65.03
56.72
def isInorder ( arr , n ) : if ( n == 0 or n == 1 ) : return True for i in range ( 1 , n , 1 ) : if ( arr [ i - 1 ] > arr [ i ] ) : return False return True

static boolean isInorder ( int [ ] arr , int n ) { if ( n == 0 || n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }

static boolean isInorder ( int arr [ ] , int n ) { if ( arr [ 0 ] > arr [ n - 1 ] ) return false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] ) return false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] > arr [ i ] ) return false ; } return true ; }

public static boolean isInorder ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i <= n ; i ++ ) { if ( isInorder ( arr [ i - 1 ] , n ) ) return true ; } return false ; }

43.55
60.95
61.56
69.4
def kthSmallest ( arr , n , k ) : arr . sort ( ) return arr [ k - 1 ]

public static int kthSmallest ( Integer [ ] arr , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }

static int kthSmallest ( int arr[], int n, int k) {  def kthSmallest ( int arr [ ] , int n , int k ) { return arr [ k - 1 ] ; }

public static int kthSmallest ( int arr [ ] , int n , int k ) { arr . sort ( ) ; return arr [ k - 1 ] ; }

43.77
41.97
39.56
56.0
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

static int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }

static int factorial ( int n ) { return 1 if ( n == 0 ) return 1 ; }  def factorial ( int n ) { return 1 ; }

static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return n * factorial ( n - 1 ) ; } }

43.8
42.78
40.78
43.02
def printNGE ( arr ) : for i in range ( 0 , len ( arr ) , 1 ) : next = - 1 for j in range ( i + 1 , len ( arr ) , 1 ) : if arr [ i ] < arr [ j ] : next = arr [ j ] break print ( str ( arr [ i ] ) + "--" + str ( next ) )

static void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " -- " + next ) ; } }

static void printNGE ( int arr [ ] ) { int next = - 1 ; for ( int i = 0 ; i < len ( arr ) ; i ++ ) { if ( arr [ i ] > arr [ j ] ) next = arr [ j ] ; } print ( str ( arr [ i ] ) + "--" + str ( next ) ) ; } }

static void printNGE ( int arr [ ] ) { int i = 0 ; int next = - 1 ; for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] < arr [ j ] ) next = arr [ j ] ; else if ( arr [ i ] > arr [ j ] ) next = arr [ j ] ; else if ( arr [ i ] > arr [ j ] ) next = arr [ j ] ; else break ; } print ( str ( arr [ i ] ) + "--" + str ( next ) ) ; } }

43.81
43.71
67.15
74.05
def minCost ( coin , n , k ) : coin . sort ( ) coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) ans = 0 for i in range ( coins_needed - 1 + 1 ) : ans += coin [ i ] return ans

static int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }

static int minCost ( int coin [ ] , int n , int k ) { int ans = 0 ; for ( int i = 0 ; i < coins_needed ; i ++ ) { ans += coin [ i ] ; } return ans ; }

public static int minCost ( Coin coin , int n , int k ) { coin . sort ( ) ; int coins_needed = math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i < coins_needed ; i ++ ) { ans += coin [ i ] ; } return ans ; }

43.84
44.07
50.67
46.91
def maximumSum ( a , n ) : global M for i in range ( 0 , n ) : a [ i ] . sort ( ) sum = a [ n - 1 ] [ M - 1 ] prev = a [ n - 1 ] [ M - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : for j in range ( M - 1 , - 1 , - 1 ) : if ( a [ i ] [ j ] < prev ) : prev = a [ i ] [ j ] sum += prev break if ( j == - 1 ) : return 0 return sum

static int maximumSum ( int a [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a , i , n ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }

static int maximumSum ( int [ ] [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] [ M - 1 ] > sum ) sum = a [ i ] [ M - 1 ] ; for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; } } return sum ; }

static int maximumSum ( int a [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] . sort ( ) ; sum = a [ i ] [ M - 1 ] ; prev = a [ i ] [ M - 1 ] ; for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += a [ i ] [ j ] ; } } } }

43.98
44.02
44.72
46.34
def permutatedRows ( mat , m , n , r ) : s = set ( ) for j in range ( n ) : s . add ( mat [ r ] [ j ] ) for i in range ( m ) : if i == r : continue for j in range ( n ) : if mat [ i ] [ j ] not in s : j = j - 2 break if j + 1 != n : continue print ( i )

static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) s . add ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ; if ( j != n ) continue ; System . out . print ( i + ", " ) ; } }

static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] not in s ) j = j - 2 break if ( j + 1 != n ) { if (

static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { Set s = new HashSet ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] != null ) { s . add ( mat [ i ] [ j ] ) ; } } } }

44.11
45.12
74.95
71.92
def isProduct ( arr , n , x ) : if n < 2 : return False s = set ( ) for i in range ( 0 , n ) : if arr [ i ] == 0 : if x == 0 : return True else : continue if x % arr [ i ] == 0 : if x // arr [ i ] in s : return True s . add ( arr [ i ] ) return False

static boolean isProduct ( int arr [ ] , int n , int x ) { HashSet < Integer > hset = new HashSet < > ( ) ; if ( n < 2 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( hset . contains ( x / arr [ i ] ) ) return true ; hset . add ( arr [ i ] ) ; } } return false ; }

static boolean isProduct ( int arr [ ] , int n , int x ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( x % arr [ i ] == 0 ) return true ; s . add ( arr [ i ] ) ; } return false ; }

static boolean isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; Set s = new HashSet ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) if ( x == 0 ) return true ; else if ( x % arr [ i ] == 0 ) if ( x % arr [ i ] == 0 ) { if ( x // arr [ i ] in s ) return true ; s . add ( arr [ i ] ) ; } } return false ; }

44.13
59.99
49.62
59.73
def numberOfSquares ( base ) : base = ( base - 2 ) base = base / 2 return base * ( base + 1 ) / 2

public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }

static int numberOfSquares ( int base ) { int numberOfSquares ( int base ) { int numberOfSquares = base * ( base + 1 ) / 2 ; int numberOfSquares ( int base ) ; return numberOfSquares * ( base + 1 ) / 2 ; }

; public static int numberOfSquares ( int base ) { return base * ( base + 1 ) / 2 ; } public static int numberOfSquares ( int base ) { return base * ( base + 1 ) / 2 ; } }

44.16
40.94
48.23
43.94
def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : swapped = False for j in range ( 0 , n - i - 1 ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] swapped = True if swapped == False : break

static void bubbleSort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; } }

static void bubbleSort ( int arr [ ] ) { int n = arr . length ; int i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) arr [ j ] , arr [ j + 1 ] = arr [ j ] , arr [ j ] ; swapped = true ; } } return ; }

static void bubbleSort ( int arr [ ] ) { int n = arr . length ; int i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] ; swapped = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] ; swapped = true ; } } }

44.23
62.35
63.14
73.32
def power ( x , y ) : if ( y == 0 ) : return 1 elif ( int ( y % 2 ) == 0 ) : return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) else : return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) )

static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }

static int power ( int x , int y ) { if ( int ( y / 2 ) % 2 ) == 0 ) return ( x * power ( x , int ( y / 2 ) ) + power ( x , int ( y / 2 ) ) ) ; else return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) + power ( x , int ( y / 2 ) ) ) ; } return

static int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( y % 2 == 0 ) return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ; else return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) ; }

44.24
43.35
55.93
50.41
def lps ( s ) : n = len ( s ) a = [ 0 ] * n for i in range ( n - 1 , - 1 , - 1 ) : back_up = 0 for j in range ( i , n ) : if j == i : a [ j ] = 1 elif s [ i ] == s [ j ] : temp = a [ j ] a [ j ] = back_up + 2 back_up = temp else : back_up = a [ j ] a [ j ] = max ( a [ j - 1 ] , a [ j ] ) return a [ n - 1 ]

static int lps ( String s ) { int n = s . length ( ) ; int a [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int back_up = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) a [ j ] = 1 ; else if ( s . charAt ( i ) == s . charAt ( j ) ) { int temp = a [ j ] ; a [ j ] = back_up + 2 ; back_up = temp ; } else { back_up = a [ j ] ; a [ j ] = Math . max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }

static int lps ( int s [ ] ) { int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( s [ i ] == s [ j ] ) a [ j ] = back_up + 2 ; else a [ j ] = max ( a [ j - 1 ] , a [ j ] ) ; } } return a [ n ] ; }

static int lps ( int [ ] s , int i , int n ) { int [ ] a = new int [ n ] ; int [ ] back_up = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == i ) a [ j ] = 1 ; else if ( s [ i ] == s [ j ] ) { temp = a [ j ] ; a [ j ] = back_up + 2 ; back_up = temp ; } else { temp = a [ j ] ; a [ j ] = back_up + 2 ; back_up = temp ; } } return a [ n - 1 ] ; }

44.24
42.42
56.66
46.04
def printPowerSet ( set , set_size ) : pow_set_size = ( int ) ( math . pow ( 2 , set_size ) ) counter = 0 j = 0 for counter in range ( 0 , pow_set_size ) : for j in range ( 0 , set_size ) : if ( ( counter & ( 1 << j ) ) > 0 ) : print ( set [ j ] , end = "" ) print ( "" )

static void printPowerSet ( char [ ] set , int set_size ) { long pow_set_size = ( long ) Math . pow ( 2 , set_size ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { for ( j = 0 ; j < set_size ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( set [ j ] ) ; } System . out . println ( ) ; } }

static void printPowerSet ( int set [ ] , int set_size ) { int counter = 0 ; int j = 0 ; for ( int j = 0 ; j < set_size ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) { print ( set [ j ] , end = "" ) } else { print ( set [ j ] , end = "" ) } } return ; }

static void printPowerSet ( int set , int set_size ) { int counter = 0 ; for ( int j = 0 ; j < set_size ; j ++ ) { for ( int counter = 0 ; counter < pow_set_size ; counter ++ ) { for ( int j = 0 ; j < set_size ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) { print ( set [ j ] , end = "" ) ; } } } } }

44.25
48.32
53.63
49.68
def maxSum ( grid , n ) : incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) excl = 0 for i in range ( 1 , n ) : excl_new = max ( excl , incl ) incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) excl = excl_new return max ( excl , incl )

public static int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }

static int maxSum ( int [ ] grid , int n ) { int excl = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int excl_new = max ( excl , incl ) excl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; } return max ( excl , incl ) ; }

static int maxSum ( int [ ] grid , int n ) { int incl = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ) { int excl_new = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ) { excl_new = max ( excl ) ; incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return max ( excl , incl ) ; } }

44.25
42.2
52.83
57.01
def reorder ( arr , index , n ) : temp = [ 0 ] * n for i in range ( 0 , n ) : temp [ index [ i ] ] = arr [ i ] for i in range ( 0 , n ) : arr [ i ] = temp [ i ] index [ i ] = i

static void reorder ( ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }

static void reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ index [ i ] ] = arr [ i ] ; } return arr ; }

; int reorder ( int arr [ ] , int index [ ] ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ index [ i ] ] = arr [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ index [ j ] ] = temp [ index [ j ] ] ; index [ j ] = i ; } } return ; }

44.27
55.48
30.18
53.7
def sortInWave ( arr , n ) : arr . sort ( ) for i in range ( 0 , n - 1 , 2 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]

void sortInWave ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; }

static void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] , arr [ i + 1 ] = arr [ i ] , arr [ i + 1 ] ; } }

static void sortInWave ( int arr [ ] , int n ) { arr . sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] , arr [ i + 1 ] = arr [ i ] , arr [ i + 1 ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; } }

44.29
41.07
43.22
46.02
def countNum ( arr , n ) : s = dict ( ) count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 for i in range ( n ) : s [ arr [ i ] ] = 1 if ( arr [ i ] < minm ) : minm = arr [ i ] if ( arr [ i ] > maxm ) : maxm = arr [ i ] for i in range ( minm , maxm + 1 ) : if i not in s . keys ( ) : count += 1 return count

static int countNum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }

static int countNum ( int arr [ ] , int n ) { int count = 0 , maxm = 0 , - 10 ** 9 , 10 ** 9 ; for ( int i = 0 ; i < arr . length ; i ++ ) { s [ arr [ i ] ] = 0 ; if ( arr [ i ] < maxm ) maxm = arr [ i ] ; if ( arr [ i ] > minm ) minm = arr [ i ] ; if (

static int countNum ( int arr [ ] , int n ) { int count = 0 ; int maxm = 0 ; int minm = 0 ; int maxm = - 10 ** 9 ; int minm = 10 ** 9 ; int maxm = 10 ** 9 ; for ( int i = 0 ; i < n ; i ++ ) { s [ arr [ i ] ] = 1 ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ arr [ i ] ] = 1 ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } } return count ; }

44.3
61.78
70.03
64.46
def productSubSeqCount ( arr , k ) : n = len ( arr ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] for i in range ( 1 , k + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 return dp [ k ] [ n ]

public static int productSubSeqCount ( ArrayList < Integer > arr , int k ) { int n = arr . size ( ) ; int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }

static int productSubSeqCount ( int arr [ ] , int k ) { int n = arr . length ; int dp [ ] [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( arr [ j - 1 ] <= i ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] + 1 ; if ( arr [ j - 1 ] > 0 ) return dp [ k ] [ n ] ; } return dp [ k ] [ n ] [ k - 1 ] ; } return dp [ k ] [ n ] ; } for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= j ; j ++ ) { if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) { if ( arr [ j - 1 ] > 0 ) { if ( arr [ j - 1 ] > 0 ) dp [ i ] [ j ] ; } return dp [ k ] [ n ] ; } return dp [ k ] [ n ] ; } return dp [ k ] [

static int productSubSeqCount ( int arr [ ] , int k ) { int n = arr . length ; int dp [ ] [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < k ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }

44.43
45.92
60.01
75.99
def binomialCoeffSum ( n ) : C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] sum = 0 for i in range ( 0 , n + 1 ) : sum += C [ n ] [ i ] return sum

static int binomialCoeffSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }

static int binomialCoeffSum ( int n ) { int [ ] [ ] C = new int [ n + 2 ] [ n + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 ) C [ i ] [ j ] = 0 ; else C [ i ] [ j ] = C [ i - 1 ] [ j -

static int binomialCoeffSum ( int n ) { int [ ] C = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } return sum ; }

44.48
48.38
82.58
83.47
def round ( n ) : a = ( n // 10 ) * 10 b = a + 10 return ( b if n - a > b - n else a )

static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }

static int round ( int n ) { int a = 0 ; int b = n ; if ( a > b ) a = b - n ; else a = n ; return ( a ; }

static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( b if n - a > b - n else a ) ; }

44.54
50.83
61.39
61.58
def maxSubArraySum ( a , size ) : max_so_far = - maxsize - 1 max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( 0 , size ) : max_ending_here += a [ i ] if max_so_far < max_ending_here : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 return ( end - start + 1 )

static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }

static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = - maxsize - 1 ; int start = 0 ; int end = 0 ; int s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; start = s

static int maxSubArraySum ( int a , int size ) { int max_so_far = - maxsize - 1 ; int max_ending_here = 0 ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; start = s ; end = i ; } return ( end - start + 1 ) ; }

44.59
45.15
65.19
58.74
def findMaxSum ( arr , n ) : res = - sys . maxsize - 1 for i in range ( n ) : prefix_sum = arr [ i ] for j in range ( i ) : prefix_sum += arr [ j ] suffix_sum = arr [ i ] j = n - 1 while ( j > i ) : suffix_sum += arr [ j ] j -= 1 if ( prefix_sum == suffix_sum ) : res = max ( res , prefix_sum ) return res

static int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }

static int findMaxSum ( int arr [ ] , int n ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int suffix_sum = arr [ i ] ; for ( int j = i ; j <= n ; j -- ) { if ( prefix_sum == suffix_sum ) res = max ( res , suffix_sum ) ; } } return res ; }

static int findMaxSum ( int arr [ ] , int n ) { int res = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < arr . length ; j ++ ) { int suffix_sum = arr [ j ] ; while ( j > i ) { suffix_sum += arr [ j ] ; j -- ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } } } return res ; }

44.61
72.14
90.79
92.15
def unitnumber ( x , y ) : x = x % 10 if y != 0 : y = y % 4 + 4 return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 )

static int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ; }

static int unitnumber ( int x , int y ) { int x = x % 10 ; int y = y % 4 + 4 ; if ( x != 0 ) x = x % 10 + 4 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( int ) ( math . pow ( x , y ) ) % 10 + 4 ) % 10 + 4 ) % 10 + 4 ; return ( ( int ) ( math . pow ( x ,

public static int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ; }

44.63
46.37
55.18
53.46
def areEqual ( arr1 , arr2 , n , m ) : if ( n != m ) : return False ; arr1 . sort ( ) ; arr2 . sort ( ) ; for i in range ( 0 , n - 1 ) : if ( arr1 [ i ] != arr2 [ i ] ) : return False ; return True ;

public static boolean areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . length ; int m = arr2 . length ; if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }

static boolean areEqual ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { if ( arr1 . length != arr2 . length ) return False ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) return False ; return True ; } return False ; }

static boolean areEqual ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( arr1 . length != arr2 . length ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) return false ; } return true ; }

44.65
38.6
43.41
31.66
def getMaxOccuringChar ( str ) : count = [ 0 ] * ASCII_SIZE max = - 1 c = '' for i in str : count [ ord ( i ) ] += 1 ; for i in str : if max < count [ ord ( i ) ] : max = count [ ord ( i ) ] c = i return c

static char getMaxOccuringChar ( String str ) { int count [ ] = new int [ ASCII_SIZE ] ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) count [ str . charAt ( i ) ] ++ ; int max = - 1 ; char result = ' ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str . charAt ( i ) ] ) { max = count [ str . charAt ( i ) ] ; result = str . charAt ( i ) ; } } return result ; }

static int getMaxOccuringChar ( String str ) { int max = - 1 ; for ( int i = 0 ; i < ASCII_SIZE ; i ++ ) { if ( max < count [ ord ( i ) ] ) max = count [ ord ( i ) ] ; for ( int i = 0 ; i < ASCII_SIZE ; i ++ ) { if ( max < count [ ord ( i ) ] ) max = count [ ord ( i ) ] ; } } return

static int getMaxOccuringChar ( String str ) { int count [ ] = new int [ ASCII_SIZE ] ; int max = - 1 ; int c = '' ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( max < count [ ord ( i ) ] ) max = count [ ord ( i ) ] ; c = str [ i ] ; } return c ; }

44.65
47.06
65.77
57.28
def pairs ( arr , n , k ) : smallest = 999999999999 count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if abs ( arr [ i ] + arr [ j ] - k ) < smallest : smallest = abs ( arr [ i ] + arr [ j ] - k ) count = 1 elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : count += 1 print ( "MinimalValue=" , smallest ) print ( "TotalPairs=" , count )

static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( "Minimal Value = " + smallest ) ; System . out . println ( "Total Pairs = " + count ) ; }

static void pairs ( int arr [ ] , int n , int k ) { int smallest = 999999999999 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] + arr [ j ] - k ) { count = 1 ; } else { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) smallest = abs ( arr [ i ] + arr [ j ] -

static void pairs ( int arr [ ] , int n , int k ) { int smallest = 999999999999 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] - k ) { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) smallest = abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } } } }

44.75
70.45
96.29
96.44
def pythagorean_quadruple ( a , b , c , d ) : sum = a * a + b * b + c * c if ( d * d == sum ) : return True else : return False

static Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }

static boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c + d * d ; if ( sum == sum ) return false ; }  def pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c + d * d ; return

static boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }

44.79
40.7
58.5
54.63
def find_prob ( N , P ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 1 dp [ 1 ] = 0 dp [ 2 ] = P dp [ 3 ] = 1 - P for i in range ( 4 , N + 1 ) : dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] return dp [ N ]

static float find_prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }

static int find_prob ( int n , int P ) { int dp [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = ( 1 - P ) * dp [ i - 1 ] + ( 1 - P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; } return dp [ N ] ; }

static int find_prob ( int N , int P ) { int dp [ ] = new int [ 4 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; dp [ 3 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; } return dp [ N ] ; } }

44.8
55.53
60.55
72.39
def findS ( s ) : _sum = 0 n = 1 while ( _sum < s ) : _sum += n * n * n n += 1 n -= 1 if _sum == s : return n return - 1

static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }

static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) _sum += n * n ; n += 1 ; } return - 1 ; }

static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n ; n ++ ; if ( _sum == s ) return n ; } return - 1 ; }

44.86
45.51
54.54
57.35
def countFreq ( a , n ) : hm = dict ( ) for i in range ( n ) : hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 cumul = 0 for i in range ( n ) : cumul += hm [ a [ i ] ] if ( hm [ a [ i ] ] > 0 ) : print ( a [ i ] , "->" , cumul ) hm [ a [ i ] ] = 0

static void countFreq ( int a [ ] , int n ) { int hm [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { System . out . println ( a [ i ] + "->" + cumul ) ; } hm [ a [ i ] ] = 0 ; } }

static int countFreq ( int [ ] a , int n ) { int hm = dict ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 ; if ( hm [ a [ i ] ] > 0 ) { print ( a [ i ] , "->" , cumul ) hm [ a [ i ] ] = hm . get ( a

static void countFreq ( int [ ] a , int n ) { HashMap < String , Integer > hm = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 ; cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 ; cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] > 0 ) { print ( a [ i ] , "->" , cumul ) ; hm [ a [ i ] ] = 0 ; } } } }

44.9
49.88
54.4
74.6
def evenSum ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n + 1 ) ) : if j == 0 or j == i : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] sum = 0 ; for i in range ( 0 , n + 1 ) : if n % 2 == 0 : sum = sum + C [ n ] [ i ] return sum

static int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }

static int evenSum ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] [ n + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 ) sum = sum + C [ i - 1 ] [ j - 1 ] ; else sum = sum + C [ i - 1 ] [ j ] ; } } return sum ; }

static int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } sum = sum + C [ i ] [ j ] ; } } return sum ; }

44.91
42.73
51.88
74.81
def stoogesort ( arr , l , h ) : if l >= h : return if arr [ l ] > arr [ h ] : t = arr [ l ] arr [ l ] = arr [ h ] arr [ h ] = t if h - l + 1 > 2 : t = ( int ) ( ( h - l + 1 ) / 3 ) stoogesort ( arr , l , ( h - t ) ) stoogesort ( arr , l + t , ( h ) ) stoogesort ( arr , l , ( h - t ) )

static void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }

static void stoogesort ( int arr [ ] , int l , int h ) { int t ; if ( arr [ l ] < arr [ h ] ) t = arr [ l ] ; arr [ l ] = arr [ h ] ; if ( arr [ l ] > arr [ h ] : t = arr [ l ] ; arr [ h ] = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; }

static void stoogesort ( int arr [ ] , int l , int h ) { if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) t = ( int ) ( ( h - l + 1 ) / 3 ) ; stoogesort ( arr , l + t , ( h ) ) ; if ( h - l + 1 > 2 ) t = ( int ) ( ( h - l + 1 ) / 3 ) ; stoogesort ( arr , l + t , ( h ) ) ; if ( h - l + 1 > 2 ) t = ( int ) ( ( h - l + 1 ) / 3 ) ; stoogesort ( arr , l + t , ( h ) ) ; stoogesort ( arr , l + t , ( h ) ) ; }

44.93
54.26
100.0
100.0
def fun ( n ) : return n & ( n - 1 )

static int fun ( int n ) { return n & ( n - 1 ) ; }

static int fun ( int n ) { return n

static int fun ( int n ) { return n & ( n - 1 ) ; }

44.99
44.91
61.77
50.87
def getSecondMostFreq ( str ) : NO_OF_CHARS = 256 count = [ 0 ] * NO_OF_CHARS for i in range ( len ( str ) ) : count [ ord ( str [ i ] ) ] += 1 first , second = 0 , 0 for i in range ( NO_OF_CHARS ) : if count [ i ] > count [ first ] : second = first first = i elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : second = i return chr ( second )

static char getSecondMostFreq ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) ( count [ str . charAt ( i ) ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; }

static int getSecondMostFreq ( String str ) { int count = [ 0 ] * NO_OF_CHARS ; int first = 0 ; int second = 0 ; for ( int i = 0 ; i < len ( str ) ; i ++ ) { if ( count [ i ] > count [ second ] ) first = i ; else if ( count [ i ] != count [ first ] ) second = i ; else if ( count [ i ] > count [ second ] ) first =

static int getSecondMostFreq ( String str ) { int NO_OF_CHARS = 256 ; int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ ord ( str [ i ] ) ] ++ ; if ( count [ i ] > count [ first ] ) second = first ; first = i ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( count [ i ] > count [ second ] ) second = i ; else if ( count [ i ] > count [ second ] ) second = i ; } return chr ( second ) ; }

45.11
42.76
60.4
59.5
def printMaxOfMin ( arr , n ) : for k in range ( 1 , n + 1 ) : maxOfMin = INT_MIN for i in range ( n - k + 1 ) : min = arr [ i ] for j in range ( k ) : if ( arr [ i + j ] < min ) : min = arr [ i + j ] if ( min > maxOfMin ) : maxOfMin = min print ( maxOfMin , end = "" )

static void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } System . out . print ( maxOfMin + " " ) ; } }

static void printMaxOfMin ( int arr [ ] , int n ) { int maxOfMin = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxOfMin ) maxOfMin = arr [ i ] ; for ( int j = 0 ; j < k ; j ++ ) if ( arr [ i + j ] > maxOfMin ) maxOfMin = arr [ i + j ] ;

static void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k < n ; k ++ ) { int min = arr [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; if ( min > maxOfMin ) maxOfMin = min ; if ( maxOfMin > arr [ i + j ] ) maxOfMin = arr [ i + j ] ; if ( maxOfMin > arr [ i + j ] ) maxOfMin = arr [ i + j ] ; } } }

45.16
39.48
65.97
69.45
def areConsecutive ( arr , n ) : if ( n < 1 ) : return False Min = min ( arr ) Max = max ( arr ) if ( Max - Min + 1 == n ) : visited = [ False for i in range ( n ) ] for i in range ( n ) : if ( visited [ arr [ i ] - Min ] != False ) : return False visited [ arr [ i ] - Min ] = True return True return False

boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }

static boolean areConsecutive ( int arr [ ] , int n ) { boolean visited = false ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( visited [ arr [ i ] - Min ] != False ) return false ; visited [ arr [ i ] - Min ] = true ; visited [ arr [ i ] - Min ] = true ; visited [ arr [ i ] - Min ] = true ; return true ; } return false ; }

static boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int Min = min ( arr ) ; int Max = max ( arr ) ; if ( Max - Min + 1 == n ) { visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - Min ] != false ) return false ; visited [ arr [ i ] - Min ] = true ; } } return true ; }

45.17
41.05
49.53
48.41
def sequence ( n ) : f = array . array ( 'i' , [ 0 , 1 , 1 ] ) for i in range ( 3 , n + 1 ) : r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] f . append ( r ) ; return r

static int sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; int i ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }

static int sequence ( int n ) { int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; f . append ( r ) ; } return r ; } return 0 ; }

static int sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; int [ ] r = new int [ n + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { r [ i - 1 ] = f [ i - 1 ] ; r [ i - 1 ] = f [ i - 1 ] ; r [ i - 1 ] = f [ i - 1 ] ; } return r ; }

45.22
42.96
50.5
45.8
def subsequence ( s , t , n , k ) : last = 0 cnt = 0 new_last = 0 size = 0 string = 'zyxwvutsrqponmlkjihgfedcba' for ch in string : cnt = 0 for i in range ( last , n ) : if s [ i ] == ch : cnt += 1 if cnt >= k : for i in range ( last , n ) : if s [ i ] == ch : t [ size ] = ch new_last = i size += 1 last = new_last

static void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_last = 0 , size = 0 ; for ( char ch = 'z' ; ch >= 'a' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_last = i ; } } last = new_last ; } } t [ size ] = '\0' ; }

static void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int cnt = 0 ; int new_last = 0 ; int size = 0 ; for ( char i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ] = ch new_last = i size += 1 ; } else { for ( int i = last ; i < n ; i ++ ) { if

int subsequence ( char [ ] s , char [ ] t , int n ) { int last = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; if ( cnt >= k ) for ( int i = 0 ; i < last ; i ++ ) { if ( s [ i ] == ch ) t [ size ] = ch ; new_last = i ; size ++ ; last = new_last ; } } } return ; }

45.25
52.4
53.06
62.06
def isPerfectSquare ( n ) : i = 1 the_sum = 0 while the_sum < n : the_sum += i if the_sum == n : return True i += 2 return False

static boolean isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }

static boolean isPerfectSquare ( int n ) { int the_sum = 0 ; while ( the_sum < n ) { the_sum += i ; if ( the_sum == n ) return true i ++ ; } return false ; }

static boolean isPerfectSquare ( int n ) { int i = 1 ; int the_sum = 0 ; while ( the_sum < n ) { the_sum += i ; if ( the_sum == n ) return true ; i ++ ; } return false ; }

45.31
50.76
43.45
50.58
def alternateSort ( arr , n ) : arr . sort ( ) i = 0 j = n - 1 while ( i < j ) : print ( arr [ j ] , end = "" ) j -= 1 print ( arr [ i ] , end = "" ) i += 1 if ( n % 2 != 0 ) : print ( arr [ i ] )

static void alternateSort ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { System . out . print ( arr [ j -- ] + " " ) ; System . out . print ( arr [ i ++ ] + " " ) ; } if ( n % 2 != 0 ) System . out . print ( arr [ i ] ) ; }

static void alternateSort ( int arr [ ] , int n ) { int i = 0 ; int j = arr . length - 1 ; while ( i < j ) { print ( arr [ i ] , end = "" ) i -= 1 if ( n % 2 != 0 ) print ( arr [ j ] , end = "" ) j += 1 if ( n % 2 != 0 ) print ( arr [ i ] , end = "" ) i += 1 if ( n % 2

static void alternateSort ( int arr [ ] , int n ) { int i = 0 ; int j = n - 1 ; while ( i < j ) { arr . sort ( ) ; i ++ ; if ( n % 2 != 0 ) { print ( arr [ i ] ) ; } } }

45.42
54.43
48.87
58.86
def isSubSequence ( str1 , str2 , m , n ) : j = 0 i = 0 while j < m and i < n : if str1 [ j ] == str2 [ i ] : j = j + 1 i = i + 1 return j == m

static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) j ++ ; return ( j == m ) ; }

static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { int j = 0 ; int i = 0 ; while ( j < m and i < n ) { if ( str1 [ j ] == str2 [ i ] ) j = j + 1 ; else i = i + 1 ; } return false ; } return false ; }

&& i < n ; public static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { int j = 0 ; int i = 0 ; while ( j < m && i < n ; j ++ ) { if ( str1 [ j ] == str2 [ i ] ) return true ; i ++ ; } return false ; }

45.46
52.19
63.29
68.71
def countRect ( n ) : ans = 0 for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : height = length while ( height * length <= n ) : ans += 1 height += 1 return ans

static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }

static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= n ; length ++ ) { ans += 1 ; } } return ans ; }

static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= n ; length ++ ) { int height = length ; while ( height * length <= n ) { ans += 1 ; height ++ ; } } return ans ; }

45.46
54.95
51.56
50.08
def printRoots ( n ) : theta = math . pi * 2 / n for k in range ( 0 , n ) : real = math . cos ( k * theta ) img = math . sin ( k * theta ) print ( real , end = "" ) if ( img >= 0 ) : print ( "+i" , end = "" ) else : print ( "-i" , end = "" ) print ( abs ( img ) )

static void printRoots ( int n ) { double theta = 3.14 * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . println ( real ) ; if ( img >= 0 ) System . out . println ( " + i " ) ; else System . out . println ( " - i " ) ; System . out . println ( Math . abs ( img ) ) ; } }

static void printRoots ( int n ) { float theta = Math . PI / n ; for ( int k = 0 ; k < n ; k ++ ) { float real = math . cos ( k * theta ) ; float img = math . sin ( k * theta ) ; if ( img >= 0 ) { print ( "+i" , end = "" ) } else { print ( "-i" , end = "" ) } print ( abs ( real ) ) ; } }

static void printRoots ( int n ) { int theta = math . pi * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { int real = math . cos ( k * theta ) ; int img = math . sin ( k * theta ) ; print ( real ) ; if ( img >= 0 ) { print ( "+i" , end = "" ) ; } else { print ( "-i" , end = "" ) ; } } print ( abs ( img ) ) ; }

45.46
38.52
55.24
45.2
def findMinNumber ( n ) : count = 0 ans = 1 while n % 2 == 0 : count += 1 n //= 2 if count % 2 is not 0 : ans *= 2 for i in range ( 3 , ( int ) ( math . sqrt ( n ) ) + 1 , 2 ) : count = 0 while n % i == 0 : count += 1 n //= i if count % 2 is not 0 : ans *= i if n > 2 : ans *= n return ans

static int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }

static int findMinNumber ( int n ) { int count = 0 ; while ( n % 2 == 0 ) count += 1 n //= 2 if count % 2 is not 0 : ans *= 2 ; for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; while ( n % i == 0 ) count += 1 n //= i ; if ( count % 2 is not 0 ) ans *= i ; if ( count % 2 is not 0

static int findMinNumber ( int n ) { int count = 0 ; int ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n //= 2 ; if ( count % 2 is not 0 ) ans *= 2 ; for ( int i = 0 ; i < 3 ; i ++ ) { count ++ ; if ( n % i == 0 ) count ++ ; n //= i if ( count % 2 is not 0 ) ans *= i ; } } return ans ; }

45.49
43.99
72.03
73.19
def isConvertible ( str1 , str2 , k ) : if ( ( len ( str1 ) + len ( str2 ) ) < k ) : return True commonLength = 0 for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : if ( str1 [ i ] == str2 [ i ] ) : commonLength += 1 else : break if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : return True return False

static boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }

static boolean isConvertible ( String str1 , String str2 , int k ) { int commonLength = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) { commonLength += 1 ; } } if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) return true ; } return false ; }

static boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) { commonLength += 1 ; } else { break ; } } if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) return true ; } return false ; }

45.61
47.91
63.01
67.61
def sumofFactors ( n ) : res = 1 for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : curr_sum = 1 curr_term = 1 while n % i == 0 : n = n / i curr_term = curr_term * i curr_sum += curr_term res = res * curr_sum if n > 2 : res = res * ( 1 + n ) return res

static int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n > 2 ) res *= ( 1 + n ) ; return res ; }

static int sumofFactors ( int n ) { int res = 1 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n > 0 ) { n = n / i ; curr_sum = curr_sum * i ; curr_term = curr_term * i ; } res = res * ( 1 + n ) ; } return res ; }

static int sumofFactors ( int n ) { int res = 1 ; int i = 2 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { n = n / i ; curr_term = 1 ; while ( n % i == 0 ) n = n / i ; curr_sum += curr_term ; res = res * ( 1 + n ) ; if ( n > 2 ) res = res * ( 1 + n ) ; } return res ; }

45.63
50.75
92.58
96.24
def countSetBits ( n ) : count = 0 while ( n ) : count += n & 1 n >>= 1 return count

static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }

static int countSetBits ( int n ) { int count = 0 ; while ( n ) count += 1 ; }

static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }

45.64
54.74
69.25
72.36
def fib ( n ) : if n < 6 : return f [ n ] t = 5 fn = 5 while t < n : fn = round ( fn * PHI ) t += 1 return fn

static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; }

static int fib ( int n ) { int t = 0 ; int fn = 0 ; while ( t < n ) { fn = round ( fn * PHI ) t += 1 ; } return fn ; }

static int fib ( int n ) { int t = 5 ; int fn = 5 ; while ( t < n ) { fn = f [ t ] ; while ( fn < n ) { fn = round ( fn * PHI ) ; t ++ ; } return fn ; } }

45.65
48.34
78.11
70.54
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : arr . sort ( ) dp = [ 0 ] * N dp [ 0 ] = 0 for i in range ( 1 , N ) : dp [ i ] = dp [ i - 1 ] if ( arr [ i ] - arr [ i - 1 ] < K ) : if ( i >= 2 ) : dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) else : dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) return dp [ N - 1 ]

static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }

static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int K ) { int dp [ ] = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] < K ) { dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ 0 ] ; }

static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { int dp [ ] = new int [ N ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) { dp [ i ] = dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ; } else { dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; } else { dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } } return dp [ N - 1 ] ; }

45.69
72.79
90.46
90.72
def firstFactorialDivisibleNumber ( x ) : i = 1 fact = 1 for i in range ( 1 , x ) : fact = fact * i if ( fact % x == 0 ) : break return i

static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }

static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( int i = 1 ; i <= x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) fact = fact * i ; if ( fact % x == 0 ) fact = fact * i ; if ( fact % x == 0 ) fact = fact * i ; if ( fact % x == 0 ) fact = fact *

static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( int i = 1 ; i <= x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }

45.75
41.22
56.37
49.95
def getMaxGold ( gold , m , n ) : goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] for col in range ( n - 1 , - 1 , - 1 ) : for row in range ( m ) : if ( col == n - 1 ) : right = 0 else : right = goldTable [ row ] [ col + 1 ] if ( row == 0 or col == n - 1 ) : right_up = 0 else : right_up = goldTable [ row - 1 ] [ col + 1 ] if ( row == m - 1 or col == n - 1 ) : right_down = 0 else : right_down = goldTable [ row + 1 ] [ col + 1 ] goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) res = goldTable [ 0 ] [ 0 ] for i in range ( 1 , m ) : res = max ( res , goldTable [ i ] [ 0 ] ) return res

static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }

static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int res = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int col = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int right = 0 ; int right_up = 0 ; int right_down = goldTable [ row ] [ col + 1 ] ; if ( row == m - 1 ) right_up = goldTable [ row ] [ col ] = goldTable [ row ] [ col ] + gold [ row ] [ col ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( col == n - 1 ) { for ( int j = 0 ; j < m ; j ++ ) { if ( right_up == 0 ) right_down = goldTable [ row ] [ col + 1 ] ; if ( col == n - 1 ) right_up = goldTable [ row ] [ col ] ; if ( col == n - 1 ) right_up = goldTable [ col ] ; } } } } return res ; } } return res ; } } return res ; } return res ; } } return res ; }

static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int [ ] goldTable = new int [ m ] [ n ] ; for ( int row = 0 ; row < m ; row ++ ) { for ( int col = 0 ; col < n ; col ++ ) { if ( row == 0 || col == n - 1 ) { right = 0 ; } else { right = goldTable [ row ] [ col + 1 ] ; if ( row == 0 || col == n - 1 ) { right_up = 0 ; else : right_up = goldTable [ row - 1 ] [ col + 1 ] ; if ( row == m - 1 || col == n - 1 ) { right_down = 0 ; } else : right_down = goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) ; } goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) ; } } } } return res ; }

45.77
40.99
53.58
42.94
def sortUsingHash ( a , n ) : Max = max ( a ) Hash = [ 0 ] * ( Max + 1 ) for i in range ( 0 , n ) : Hash [ a [ i ] ] += 1 for i in range ( 0 , Max + 1 ) : if Hash [ i ] != 0 : for j in range ( 0 , Hash [ i ] ) : print ( i , end = "" )

static void sortUsingHash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int hash [ ] = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] != 0 ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { System . out . print ( i + " " ) ; } } } }

static void sortUsingHash ( int [ ] a , int n ) { int Hash [ ] = new int [ Max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( Hash [ i ] != 0 ) { for ( int j = 0 ; j < Hash [ i ] ; j ++ ) { if ( Hash [ i ] != 0 ) { for ( int j = 0 ; j < Hash [ i ] ; j ++ ) {

static void sortUsingHash ( int [ ] a , int n ) { int Hash [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { Hash [ a [ i ] ] += 1 ; for ( int j = 0 ; j < Hash [ i ] ; j ++ ) { if ( Hash [ a [ i ] ] != 0 ) { for ( int j = 0 ; j < Hash [ i ] ; j ++ ) { Hash [ a [ i ] ] ++ ; } } } } }

45.85
46.54
68.11
67.61
def maxvolume ( s ) : length = int ( s / 3 ) s -= length breadth = s / 2 height = s - breadth return int ( length * breadth * height )

static int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }

static int maxvolume ( int s ) { int length = int ( s / 2 ) ; int breadth = int ( s / 2 ) ; int height = int ( s / 2 ) ; return length ; }

static int maxvolume ( int s ) { int length = Math . max ( s / 3 ) ; int breadth = s / 2 ; int height = s - breadth ; return int ( length * breadth * height ) ; }

45.92
55.21
27.17
29.05
def search ( pat , txt ) : M = len ( pat ) N = len ( txt ) for i in range ( N - M + 1 ) : j = 0 while ( j < M ) : if ( txt [ i + j ] != pat [ j ] ) : break j += 1 if ( j == M ) : print ( "Patternfoundatindex" , i )

public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( "Pattern found at index " + i ) ; } }

static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( j < M ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } j += 1 } if ( j == M ) { if ( j == M ) { print ( "Patternfoundatindex" , i )

static int search ( char [ ] pat , char [ ] txt ) { int i = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { print ( "Patternfoundatindex" , i ) ; return i ; } } return - 1 ; }

45.98
51.99
49.02
69.3
def sumofsquare ( n ) : C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) sum = 0 for i in range ( 0 , n + 1 ) : sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) return sum

static int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }

static int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] [ n + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i ) C [ i ] [ j ] = ( C [ i ] [ j - 1 ] + C [ i ] [ j ] ) ; } } return sum ; }

static int sumofsquare ( int n ) { int [ ] C = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 or j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } } return sum ; }

46.03
49.46
56.89
55.5
def maxGameByWinner ( N ) : dp = [ 0 for i in range ( N ) ] dp [ 0 ] = 1 dp [ 1 ] = 2 i = 1 while dp [ i ] <= N : i = i + 1 dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return ( i - 1 )

static int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }

static int maxGameByWinner ( int N ) { int dp [ ] = new int [ N ] ; while ( dp [ i ] <= N ) { i = i + 1 ; while ( dp [ i ] <= N ) { i = i + 1 ; while ( dp [ i ] <= N ) { i = i - 1 ; } dp [ i ] = dp [ i - 2 ] + dp [ i - 1 ] + dp [ i - 2 ] ; } return ( i - 1 ) ; }

static int maxGameByWinner ( int N ) { int dp [ ] = new int [ N ] ; int i = 1 ; while ( dp [ i ] <= N ) { i = i + 1 ; while ( dp [ i ] <= N ) { i = i + 1 ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } i ++ ; } return ( i - 1 ) ; }

46.1
60.71
73.76
84.14
def minPerimeter ( n ) : l = math . sqrt ( n ) sq = l * l if ( sq == n ) : return l * 4 else : row = n / l perimeter = 2 * ( l + row ) if ( n % l != 0 ) : perimeter += 2 return perimeter

public static long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }

static int minPerimeter ( int n ) { int l = math . sqrt ( n ) ; int row = n / l ; int perimeter = 2 * ( l + row ) ; if ( n % l == 0 ) perimeter += 2 ; if ( n % l != 0 ) perimeter += 2 ; if ( n % l != 0 ) perimeter += 2 ; if ( n % l != 0 ) perimeter += 2 ; if ( n % l != 0 ) perimeter ++ ; return perimeter ; }

static int minPerimeter ( int n ) { int l = Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { int row = n / l ; int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; if ( n % l != 0 ) perimeter += 2 ; } return perimeter ; }

46.11
49.48
63.54
73.31
def mulmod ( a , b , mod ) : res = 0 a = a % mod while ( b > 0 ) : if ( b % 2 == 1 ) : res = ( res + a ) % mod a = ( a * 2 ) % mod b //= 2 return res % mod

static long mulmod ( long a , long b , long mod ) { long res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) { res = ( res + a ) % mod ; } a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }

static int mulmod ( int a , int b ) { int res = 0 ; while ( b > 0 ) { res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b //= 2 ; } return res ; }

; } static int mulmod ( int a , int b , int mod ) { int res = 0 ; int a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; else res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; } return res % mod ; }

46.19
51.32
57.09
46.41
def remAnagram ( str1 , str2 ) : count1 = [ 0 ] * CHARS count2 = [ 0 ] * CHARS i = 0 while i < len ( str1 ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 i += 1 i = 0 while i < len ( str2 ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 i += 1 result = 0 for i in range ( 26 ) : result += abs ( count1 [ i ] - count2 [ i ] ) return result

static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }

static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < len ( str1 ) ; i ++ ) { int result = 0 ; for ( int i = 0 ; i < len ( str2 ) ; i ++ ) { count1 [ i ] += 1 ; i ++ ; } return result ; }

static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] ++ ; } result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { result += abs ( count1 [ i ] - count2 [ i ] ) ; } return result ; }

46.21
46.74
91.2
83.63
def isPowerOfK ( n , k ) : oneSeen = False while ( n > 0 ) : digit = n % k if ( digit > 1 ) : return False if ( digit == 1 ) : if ( oneSeen ) : return False oneSeen = True n //= k return True

static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }

static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { if ( oneSeen ) return false oneSeen = true n //= k ; } return true ; }

static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true n //= k ; } } return true ; }

46.21
42.56
40.19
39.78
def countManipulations ( s1 , s2 ) : count = 0 char_count = [ 0 ] * 26 for i in range ( 26 ) : char_count [ i ] = 0 for i in range ( len ( s1 ) ) : char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( s2 ) ) : char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1 if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] < 0 ) : count += 1 return count

static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int char_count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) if ( char_count [ s2 . charAt ( i ) - 'a' ] -- <= 0 ) count ++ ; return count ; }

static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int char_count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] ++ ; if ( char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] > 0 ) { count +=

static int countManipulations ( String s1 , String s2 ) { int count = 0 ; char_count = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ i ] = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 ; char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1 ; if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] < 0 ) count ++ ; } } return count ; }

46.24
37.61
58.7
61.14
def check ( st ) : n = len ( st ) oddDigSum = 0 evenDigSum = 0 for i in range ( 0 , n ) : if ( i % 2 == 0 ) : oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) else : evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) return ( ( oddDigSum - evenDigSum ) % 11 == 0 )

static boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }

static boolean check ( int st [ ] ) { int oddDigSum = 0 ; int evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) ; else : evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) ; } return ( oddDigSum - evenDig

static boolean check ( int st [ ] ) { int n = st . length ; int oddDigSum = 0 ; int evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) ; else evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }

46.24
72.12
86.34
91.84
def arraySortedOrNot ( arr , n ) : if ( n == 0 or n == 1 ) : return True for i in range ( 1 , n ) : if ( arr [ i - 1 ] > arr [ i ] ) : return False return True

static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }

static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( arr [ 0 ] > arr [ 0 ] ) return false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] ) return false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] > arr [ i ] ) return false ; } return true ; }

public static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) return false ; } return true ; }

46.29
41.58
74.52
76.04
def countOccurrences ( s , K ) : n = len ( s ) c1 = 0 c2 = 0 C = 0 for i in range ( n ) : if s [ i ] == 'a' : c1 += 1 if s [ i ] == 'b' : c2 += 1 C += c1 return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2

static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == 'a' ) c1 ++ ; if ( s . charAt ( i ) == 'b' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }

static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'a' ) c1 += 1 if ( s [ i ] == 'b' ) c2 += 1 if ( s [ i ] == 'c' ) c2 += 1 if ( s [

static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; int C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'a' ) c1 ++ ; if ( s [ i ] == 'b' ) c2 ++ ; else C ++ ; } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }

46.31
38.15
54.61
43.24
def wordReverse ( str ) : i = len ( str ) - 1 start = end = i + 1 result = '' while i >= 0 : if str [ i ] == '' : start = i + 1 while start != end : result += str [ start ] start += 1 result += '' end = i i -= 1 start = 0 while start != end : result += str [ start ] start += 1 return result

static String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; String result = "" ; while ( i >= 0 ) { if ( str . charAt ( i ) == ' ' ) { start = i + 1 ; while ( start != end ) result += str . charAt ( start ++ ) ; result += ' ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str . charAt ( start ++ ) ; return result ; }

static String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start = 0 ; int end = i + 1 ; while ( start != end ) result += str [ start ] start += 1 result += '' end = i - 1 ; start = 0 ; while ( start != end ) result += str [ start ] start += 1 result += '' end = i - 1 ; start = 0 ; while ( start != end ) result += str [

static String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start = 0 ; int end = i + 1 ; String result = str . substring ( start , end ) ; while ( i >= 0 ) { if ( str [ i ] == '' ) start = i + 1 ; while ( start != end ) result += str [ start ] ; start += 1 ; result += str [ end ] ; } return result ; }

46.36
54.37
56.19
62.91
def maxProd ( n ) : if ( n == 0 or n == 1 ) : return 0 max_val = 0 for i in range ( 1 , n - 1 ) : max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) return max_val

static int maxProd ( int n ) { if ( n == 0 || n == 1 ) return 0 ; int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ; return max_val ; }

static int maxProd ( int n ) { int max_val = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { max_val = max ( max_val , maxProd ( n - i ) * i ) ) ; } return max_val ; }

static int maxProd ( int n ) { int max_val = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { max_val = max ( max_val , i * ( n - i ) , maxProd ( n - i ) * i ) ; } return max_val ; }

46.39
56.36
70.93
79.05
def findPosition ( k , n ) : f1 = 0 f2 = 1 i = 2 while i != 0 : f3 = f1 + f2 f1 = f2 f2 = f3 if f2 % k == 0 : return n * i i += 1 return

public static int findPosition ( int k , int n ) { long f1 = 0 , f2 = 1 , f3 ; int i = 2 ; while ( i != 0 ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; }

static int findPosition ( int k , int n ) { int f1 = 0 ; int f2 = 1 ; int f3 = 0 ; while ( f2 % k == 0 ) f2 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f3 % k == 0 ) f2 = f3 ; if ( f2 % k == 0 ) f2 = f3 ; if ( f3 % k == 0 ) return n

static int findPosition ( int k , int n ) { int f1 = 0 ; int f2 = 1 ; int i = 2 ; while ( i != 0 ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; i ++ ; if ( f3 % k == 0 ) return n * i ; } return n * i ; }

46.41
44.14
59.44
58.2
def LCSubStr ( X , Y ) : m = len ( X ) n = len ( Y ) result = 0 len_mat = np . zeros ( ( 2 , n ) ) currRow = 0 for i in range ( m ) : for j in range ( n ) : if ( i == 0 | j == 0 ) : len_mat [ currRow ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 result = max ( result , len_mat [ currRow ] [ j ] ) else : len_mat [ currRow ] [ j ] = 0 currRow = 1 - currRow return result

static int LCSubStr ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int [ ] [ ] len = new int [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }

static int LCSubStr ( int X [ ] , int Y [ ] ) { int result = 0 ; int m = X . length ( ) ; int n = Y . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] == 0 ) len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( j == 0 ) { for ( int j = i ; j ++ ) { if ( i == Y [ j - 1 ] == 0 ) len_mat [ currRow ] [ j ] = len_mat [ currRow ] [ j - 1 ] = len_mat [ j ] = len_mat [ j ] = len_mat [ j ] [ j - 1 ] + 1 ] = len_mat [ j ] =

static int LCSubStr ( int X , int Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int len_mat = np . zeros ( ( 2 , n ) ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 | j == 0 ) { len_mat [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 result = max ( result , len_mat [ currRow ] [ j ] ) ; } currRow = 1 - currRow ; } } return result ; }

46.44
52.64
50.38
51.75
def lis ( arr , n ) : mpis = [ 0 ] * ( n ) for i in range ( n ) : mpis [ i ] = arr [ i ] for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] return max ( mpis )

static int lis ( int [ ] arr , int n ) { int [ ] mpis = new int [ n ] ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; for ( int k = 0 ; k < mpis . length ; k ++ ) { if ( mpis [ k ] > max ) { max = mpis [ k ] ; } } return max ; }

static int lis ( int arr [ ] , int n ) { int mpis [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] > arr [ j ] ) mpis [ i ] = mpis [ j ] * arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( mpis [ i ] > ( mpis [ j ] * arr [ i ] ) ) mpis [ j ] = mpis [ j ] * arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( mpis [ i ] > mpis [ j ] ) mpis [ i ] = mpis [ j ] * arr [ i ] ; } } return mpis [ i ] ; for ( int j = i ; j ++ ) { if ( mpis [ i ] * mpis [ j ] * arr [ j ] ) mpis [ i ] = mpis [ j ] * arr [ i ] ; } } return mpis [ i ] ; } return max ( mpis [ i ] ; } } return mpis [ i ] ; }

static int lis ( int arr [ ] , int n ) { int [ ] mpis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) { mpis [ i ] = mpis [ j ] * arr [ i ] ; } } } return max ( mpis ) ; }

46.48
47.56
62.92
68.22
def floorSearch ( arr , low , high , x ) : if ( low > high ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )

static int floorSearch ( int arr [ ] , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid - 1 , x ) ; return floorSearch ( arr , mid + 1 , high , x ) ; }

static int floorSearch ( int [ ] arr , int low , int high , int x ) { int mid = int ( low + high ) / 2 ; if ( x < arr [ mid ] ) return mid + 1 ; if ( x > arr [ mid - 1 ] ) return mid + 1 ; if ( x > arr [ mid ] ) return mid ; if ( x < arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return mid ;

static int floorSearch ( int arr , int low , int high , int x ) { int mid = int ( ( low + high ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return mid + 1 ; return floorSearch ( arr , low , high , x ) ; }

46.54
39.87
46.24
44.25
def rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x

static void rotate ( ) { int x = arr [ arr . length - 1 ] , i ; for ( i = arr . length - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }

static void rotate ( int arr [ ] , int n ) { int x = arr [ 0 ] ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = arr [ i - 1 ] ; } return ; }

; int rotate ( int arr [ ] , int n ) { int x = arr [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; arr [ i - 1 ] = arr [ i - 1 ] ; arr [ 0 ] = x ; } }

46.55
72.78
94.59
94.48
def multiply ( x , y ) : if ( y == 0 ) : return 0 if ( y > 0 ) : return ( x + multiply ( x , y - 1 ) ) if ( y < 0 ) : return - multiply ( x , - y )

static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; }

static int multiply ( int x , int y ) { if ( y == 1 ) return ( x + multiply ( x , y ) ) ; if ( y > 0 ) return ( x - multiply ( x , y ) ) ; if ( y < 0 ) return ( x + multiply ( x , y + 1 ) ) ; if ( y < 0 ) return - x ; if ( y > 0 ) return x + multiply ( x , y ) ; if ( y < 0 ) return

static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return x ; }

46.58
46.16
61.15
59.47
def largestSubset ( a , n ) : a . sort ( ) dp = [ 0 for i in range ( n ) ] dp [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : mxm = 0 for j in range ( i + 1 , n ) : if a [ j ] % a [ i ] == 0 : mxm = max ( mxm , dp [ j ] ) dp [ i ] = 1 + mxm return max ( dp )

static int largestSubset ( int [ ] a , int n ) { Arrays . sort ( a ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; }

static int largestSubset ( int [ ] a , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int mxm = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 ) { mxm = max ( mxm , dp [ j ] ) ; } } return 0 ; }

static int largestSubset ( int a , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mxm = max ( mxm , dp [ j ] ) ; dp [ j ] = 1 + mxm ; } } } } return max ( dp ) ; }

46.61
45.98
48.9
45.24
def printSumSimple ( mat , k ) : if ( k > n ) : return for i in range ( n - k + 1 ) : for j in range ( n - k + 1 ) : sum = 0 for p in range ( i , k + i ) : for q in range ( j , k + j ) : sum += mat [ p ] [ q ] print ( sum , end = "" ) print ( )

static void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + " " ) ; } System . out . println ( ) ; } }

static void printSumSimple ( int n , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { for ( int p = 0 ; p < n ; p ++ ) { for ( int q = 0 ; q < n ; q ++ ) { if ( q < k ) sum += mat [ p ] [ q ] ; } } } }

static void printSumSimple ( int mat , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { sum = 0 ; for ( int p = 0 ; p < i ; p ++ ) { for ( int q = 0 ; q < j ; q ++ ) { sum += mat [ p ] [ q ] ; } } print ( sum , end = "" ) ; } } }

46.76
50.52
72.29
67.58
def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 2 ) : for j in range ( i + 1 , arr_size - 1 ) : for k in range ( j + 1 , arr_size ) : if A [ i ] + A [ j ] + A [ k ] == sum : print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , A [ k ] ) return True return False

boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( "Triplet is " + A [ i ] + ", " + A [ j ] + ", " + A [ k ] ) ; return true ; } } } } return false ; }

static boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = 0 ; j < arr_size - 1 ; j ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { print ( "Tripletis" , A [ i ] , "," , A [ j ] ,

static boolean find3Numbers ( int A , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = 0 ; j < arr_size - 1 ; j ++ ) { for ( int k = 0 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , A [ k ] ) ; return true ; } } } } return false ; }

46.89
54.75
73.61
69.17
def countSubStr ( st , n ) : res = 0 for i in range ( 0 , n ) : if ( st [ i ] == '1' ) : for j in range ( i + 1 , n ) : if ( st [ j ] == '1' ) : res = res + 1 return res

int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }

static int countSubStr ( String st , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( st [ i ] == '1' ) res = res + 1 ; } } return res ; }

static int countSubStr ( String st , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( st [ i ] == '1' ) { for ( int j = 0 ; j < n ; j ++ ) { if ( st [ j ] == '1' ) { res = res + 1 ; break ; } } } } return res ; }

46.92
45.74
66.81
61.36
def countarray ( n , k , x ) : dp = list ( ) dp . append ( 0 ) dp . append ( 1 ) i = 2 while i < n : dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) i = i + 1 return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] )

public static int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }

static int countarray ( int n , int k , int x ) { int dp [ ] = new int [ n ] ; while ( i < n ) { dp . append ( ( k - 1 ) * dp [ i - 2 ] + ( k - 1 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) ; i = i + 1 ; } return 0 ; }

static int countarray ( int n , int k , int x ) { int dp [ ] = new int [ n ] ; int i = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) ; i = i + 1 ; } return ( ( k - 1 ) * dp [ n - 2 ] + ( k - 1 ) * dp [ n - 1 ] ) ; }

46.95
73.09
100.0
100.0
def leonardo ( n ) : if ( n == 0 or n == 1 ) : return 1 return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )

static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ; }

static int leonardo ( int n ) { if ( n == 0 ) return 0 ; return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ; }  def leonardo ( int n ) { return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ; } return 1 ; }

static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ; }

46.97
48.68
46.72
46.52
def randomize ( arr , n ) : for i in range ( n - 1 , 0 , - 1 ) : j = random . randint ( 0 , i + 1 ) arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] return arr

static void randomize ( int arr [ ] , int n ) { Random r = new Random ( ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int j = r . nextInt ( i + 1 ) ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } System . out . println ( Arrays . toString ( arr ) ) ; }

static int randomize ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j = random . randint ( 0 , i + 1 ) ; arr [ j ] = arr [ j ] , arr [ i ] ; arr [ i ] = arr [ i ] , arr [ j ] ; } return arr ; }

public static int randomize ( int arr [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { int j = random . nextInt ( 0 , i + 1 ) ; arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] ; arr [ j ] = arr [ j ] ; } return arr ; }

47.04
54.29
44.61
45.68
def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( y2 - y1 ) slope_error_new = m_new - ( x2 - x1 ) y = y1 for x in range ( x1 , x2 + 1 ) : print ( "(" , x , "," , y , ")\n" ) slope_error_new = slope_error_new + m_new if ( slope_error_new >= 0 ) : y = y + 1 slope_error_new = slope_error_new - 2 * ( x2 - x1 )

static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; for ( int x = x1 , y = y1 ; x <= x2 ; x ++ ) { System . out . print ( "(" + x + "," + y + ")\n" ) ; slope_error_new += m_new ; if ( slope_error_new >= 0 ) { y ++ ; slope_error_new -= 2 * ( x2 - x1 ) ; } } }

static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; for ( int y = y1 ; y <= y2 ; y ++ ) { if ( slope_error_new >= 0 ) y = y + 1 ; else slope_error_new =

int bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; slope_error_new = m_new - ( x2 - x1 ) ; if ( slope_error_new >= 0 ) y = y + 1 ; slope_error_new = slope_error_new + m_new ; if ( slope_error_new >= 0 ) y = y + 1 ; if ( slope_error_new >= 0 ) y = y + 1 ; } return y ; }

47.09
60.01
63.07
77.63
def findS ( s ) : _sum = 0 n = 1 while ( _sum < s ) : _sum += n * n n += 1 n -= 1 if _sum == s : return n return - 1

static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n ; if ( sum == s ) return n ; } return - 1 ; }

static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) _sum += n * n ; n += 1 ; } return - 1 ; }

static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n ; n ++ ; if ( _sum == s ) return n ; } return - 1 ; }

47.1
53.18
68.78
66.03
def rearrange ( arr , n ) : i = - 1 for j in range ( n ) : if ( arr [ j ] < 0 ) : i += 1 arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] pos , neg = i + 1 , 0 while ( pos < n and neg < pos and arr [ neg ] < 0 ) : arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] pos += 1 neg += 2

static void rearrange ( int arr [ ] , int n ) { int i = - 1 , temp = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) { i ++ ; temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { temp = arr [ neg ] ; arr [ neg ] = arr [ pos ] ; arr [ pos ] = temp ; pos ++ ; neg += 2 ; } }

static void rearrange ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < 0 ) arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] ; pos ++ ; neg ++ ; } while ( pos < n && neg < i ) arr [ i ] , arr [ j ] = arr [ pos ] , arr

static void rearrange ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) i ++ ; arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] ; } int pos , neg = i + 1 , 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) arr [ neg ] , arr [ pos ] = arr [ neg ] , arr [ neg ] ; pos += 1 neg += 2 ; } }

47.1
49.93
46.08
57.07
def countSeq ( n , diff ) : if ( abs ( diff ) > n ) : return 0 if ( n == 1 and diff == 0 ) : return 2 if ( n == 1 and abs ( diff ) == 1 ) : return 1 res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) return res

static int countSeq ( int n , int diff ) { if ( Math . abs ( diff ) > n ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ; int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ; return res ; }

static int countSeq ( int n , int diff ) { int res = countSeq ( n - 1 , diff + 1 ) + countSeq ( n - 1 , diff - 1 ) + countSeq ( n - 1 , diff + 1 ) + countSeq ( n - 1 , diff - 1 ) + countSeq ( n - 1 , diff - 1 ) + countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff ) + countSeq (

static int countSeq ( int n , int diff ) { if ( n == 1 && diff == 0 ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && diff == 1 ) return 1 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && diff == 1 ) return 1 ; if ( n == 1 && diff == 1 ) return 1 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && diff == 1 ) return 1 ; return countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff - 1 ) ; }

47.11
43.58
70.41
73.22
def countFact ( low , high ) : fact = 1 x = 1 while ( fact < low ) : fact = fact * x x += 1 res = 0 while ( fact <= high ) : res += 1 fact = fact * x x += 1 return res

static int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }

static int countFact ( int low , int high ) { int res = 0 ; int x = 1 ; while ( fact <= high ) { res += 1 fact = fact * x x += 1 ; } return res ; }

static int countFact ( int low , int high ) { int fact = 1 ; int x = 1 ; while ( fact < high ) { fact = fact * x ; x += 1 ; res = 0 ; while ( fact <= low ) { res += 1 ; fact = fact * x ; x += 1 ; } } return res ; }

47.12
57.24
78.27
77.11
def maxArea ( a , b , c , d ) : semiperimeter = ( a + b + c + d ) / 2 return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )

static double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }

static float maxArea ( int a , int b , int c , int d ) { int semiperimeter = a + b + c + d ; return semiperimeter ; }  def maxArea ( int a , int b , int c , int d ) { return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) * ( semiperimeter -

static int maxArea ( int a , int b , int c , int d ) { int semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }

47.14
55.51
46.59
50.86
def solution ( a , b , n ) : i = 0 while i * a <= n : if ( n - ( i * a ) ) % b == 0 : print ( "x=" , i , ",y=" , int ( ( n - ( i * a ) ) / b ) ) return 0 i = i + 1 print ( "Nosolution" )

static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( "x = " + i + ", y = " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( "No solution" ) ; }

static int solution ( int a , int b , int n ) { int i = 0 ; while ( i * a <= n ) { if ( ( n - ( i * a ) ) / b == 0 ) return 0 ; i = i + 1 ; while ( i * a <= n ) { if ( ( n - ( i * a ) ) / b == 0 ) return 0 ; i = i + 1 ; while ( i * a <= n ) { if (

static int solution ( int a , int b , int n ) { int i = 0 ; while ( i * a <= n ) { if ( n - ( i * a ) % b == 0 ) return 0 ; i = i + 1 ; while ( i * a <= n ) { if ( n - ( i * a ) % b == 0 ) return 0 ; i = i + 1 ; } } return - 1 ; }

47.18
44.4
50.26
46.21
def minValue ( A , B , n ) : sorted ( A ) sorted ( B ) result = 0 for i in range ( n ) : result += ( A [ i ] * B [ n - i - 1 ] ) return result

static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }

static double minValue ( double [ ] A , double [ ] B , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += A [ i ] * B [ i - 1 ] ; } return result ; }

static int minValue ( int A , int B , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += A [ i ] * B [ i - 1 ] ; } return result ; }

47.21
55.59
90.58
85.35
def getTotalNumberOfSequences ( m , n ) : T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if i == 0 or j == 0 : T [ i ] [ j ] = 0 elif i < j : T [ i ] [ j ] = 0 elif j == 1 : T [ i ] [ j ] = i else : T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] return T [ m ] [ n ]

static int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }

static int getTotalNumberOfSequences ( int m , int n ) { int [ ] T = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { T [ i ] [ j ] = T [ i ] [ j ] + T [ i - 1 ] [ j - 1 ] ; } return T [ m ] [ n ] ; }

public static int getTotalNumberOfSequences ( int m , int n ) { int [ ] T = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }

47.21
49.9
51.0
54.57
def minimizeWithKSwaps ( arr , n , k ) : for i in range ( n - 1 ) : pos = i for j in range ( i + 1 , n ) : if ( j - i > k ) : break if ( arr [ j ] < arr [ pos ] ) : pos = j for j in range ( pos , i , - 1 ) : arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] k -= pos - i

static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }

static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { int i = 0 ; for ( int j = i ; j <= n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) { arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] ; k -= pos - i ; } } for ( int i = 0 ; i < n ; i ++ ) { for (

static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { int pos = i ; for ( int j = i ; j < k ; j ++ ) { if ( arr [ j ] < arr [ pos ] ) { arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] ; k -= pos - i ; } } } }

47.23
53.18
71.14
66.36
def kthdigit ( a , b , k ) : p = a ** b count = 0 while ( p > 0 and count < k ) : rem = p % 10 count = count + 1 if ( count == k ) : return rem p = p / 10

public static int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }

static int kthdigit ( int a , int b , int k ) { int rem = 0 ; while ( p > 0 and count < k ) { rem = rem + 1 if ( rem == 0 ) return rem ; } return 0 ; }  def kthdigit ( int a , int b , int k ) { int p = a ** b ; int count = 0 ; while ( p > 0 and count < k ) { while ( p > 0 and count

; int kthdigit ( int a , int b , int k ) { int p = a ** b ; int count = 0 ; while ( p > 0 && count < k ) { rem = p % 10 ; count = count + 1 ; if ( count == k ) return rem ; p = p / 10 ; } return p ; }

47.24
44.18
56.53
54.47
def countTriangle ( g , isDirected ) : nodes = len ( g ) count_Triangle = 0 for i in range ( nodes ) : for j in range ( nodes ) : for k in range ( nodes ) : if ( i != j and i != k and j != k and g [ i ] [ j ] and g [ j ] [ k ] and g [ k ] [ i ] ) : count_Triangle += 1 return count_Triangle / 3 if isDirected else count_Triangle / 6

int countTriangle ( int graph [ ] [ ] , boolean isDirected ) { int count_Triangle = 0 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 && graph [ k ] [ i ] == 1 ) count_Triangle ++ ; } } } if ( isDirected == true ) { count_Triangle /= 3 ; } else { count_Triangle /= 6 ; } return count_Triangle ; }

static int countTriangle ( int [ ] g , bool isDirected ) { int count_Triangle = 0 ; for ( int i = 0 ; i < nodes ; i ++ ) { for ( int j = 0 ; j < nodes ; j ++ ) { for ( int k = 0 ; k < nodes ; k ++ ) if ( g [ i ] [ j ] and g [ j ] [ k ] and g [ k ] [ i ] ) { count_Triangle +=

static int countTriangle ( int [ ] g , boolean isDirected ) { int nodes = g . length ; int count_Triangle = 0 ; for ( int i = 0 ; i < nodes ; i ++ ) { for ( int j = 0 ; j < nodes ; j ++ ) { for ( int k = 0 ; k < nodes ; k ++ ) { if ( i != j && i != k && j != k && j != i && j != k && g [ i ] [ j ] && g [ j ] [ k ] && g [ k ] [ i ] ) { count_Triangle ++ ; } } } return count_Triangle / 3 ; }

47.3
46.44
49.98
61.92
def translate ( st ) : for i in range ( 1 , len ( st ) ) : if ( st [ i - 1 ] == 'A' and st [ i ] == 'B' ) : st [ i - 1 ] = 'C' for j in range ( i , len ( st ) - 1 ) : st [ j ] = st [ j + 1 ] st [ len ( st ) - 1 ] = '' return

static void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }

static String translate ( String st ) { for ( int i = 1 ; i <= len ( st ) ; i ++ ) { if ( st [ i - 1 ] == 'A' and st [ i ] == 'B' ) st [ i - 1 ] = 'B' ; for ( int j = 0 ; j < i ; j ++ ) { if ( st [ j ] == 'C' ) st [ j ] = st [ j + 1 ] ; } } return st ; }

static void translate ( String [ ] st ) { for ( int i = 1 ; i < len ( st ) ; i ++ ) { if ( st [ i - 1 ] == 'A' && st [ i ] == 'B' ) st [ i - 1 ] = 'C' ; for ( int j = i + 1 ; j < len ( st ) ; j ++ ) st [ j ] = st [ j + 1 ] ; st [ len ( st ) - 1 ] = st [ j + 1 ] ; } }

47.3
52.56
94.98
95.21
def middleOfThree ( a , b , c ) : if ( ( a < b and b < c ) or ( c < b and b < a ) ) : return b if ( ( b < a and a < c ) or ( c < a and a < b ) ) : return a else : return c

public static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }

static int middleOfThree ( int a , int b , int c ) { int middleOfThree = middleOfThree ( a , b , c ) ; if ( ( a < b and b < c ) or ( c < a and a < a ) ) : return a ; if ( ( b < a and a < c ) ) return b ; if ( ( c < a and a < b ) ) return a ; if ( ( a < b and b < c

static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }

47.46
47.67
59.09
65.47
def printRotatedString ( string ) : n = len ( string ) temp = string + string for i in range ( n ) : for j in range ( n ) : print ( temp [ i + j ] , end = "" ) print ( )

static void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }

static void printRotatedString ( String string ) { int n = string . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { print ( temp [ i + j ] , end = "" ) } print ( ) ; } }

static void printRotatedString ( String string ) { int n = string . length ( ) ; StringBuilder sb = new StringBuilder ( string . length ( ) + string . length ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { sb . append ( string . charAt ( i + j ) ) ; } sb . append ( ' ' ) ; } }

47.58
53.2
53.84
62.22
def checkValidity ( a , b , c ) : if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : return False else : return True

public static int checkValidity ( int a , int b , int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ; else return 1 ; }

static boolean checkValidity ( int a , int b , int c ) { if ( a + b <= c ) return false ; else return true ; } }

public static boolean checkValidity ( int a , int b , int c ) { if ( a + b <= c ) { return false ; } if ( a + c <= b ) { return false ; } return true ; }

47.62
56.86
100.0
100.0
def countSetBitsRec ( num ) : nibble = 0 if ( 0 == num ) : return num_to_bits [ 0 ] nibble = num & 0xf return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 )

static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }

static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ nibble ] ; return num_to_bits [ nibble ] ; }  def countSetBitsRec ( int num ) { int nibble = num & 0xf ; int nibble = num >> 4 ; int nibble = num & 0xf ; int nibble = num & 0xf ; int nibble = num

static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }

47.63
45.14
59.23
59.25
def minJumps ( arr , l , h ) : if ( h == l ) : return 0 if ( arr [ l ] == 0 ) : return float ( 'inf' ) min = float ( 'inf' ) for i in range ( l + 1 , h + 1 ) : if ( i < l + arr [ l ] + 1 ) : jumps = minJumps ( arr , i , h ) if ( jumps != float ( 'inf' ) and jumps + 1 < min ) : min = jumps + 1 return min

static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; }

static float minJumps ( int [ ] arr , int l , int h ) { int minJumps = float ( 'inf' ) ; for ( int i = l ; i < h ; i ++ ) { if ( arr [ i ] == 0 ) minJumps = minJumps ( arr , i , h ) ; if ( jumps != float ( 'inf' ) && jumps + 1 < min ) min = jumps + 1 ; } return min

static int minJumps ( int arr [ ] , int l , int h ) { int min = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i < l + arr [ l ] + 1 ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != float ( 'inf' ) && jumps + 1 < min ) min = jumps + 1 ; } } return min ; }

47.64
54.67
58.74
62.41
def getNumStrictMonotone ( ln ) : DP = [ [ 0 ] * DP_s for _ in range ( ln ) ] for i in range ( DP_s ) : DP [ 0 ] [ i ] = i + 1 for i in range ( 1 , ln ) : for j in range ( 1 , DP_s ) : DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] return DP [ ln - 1 ] [ DP_s - 1 ]

static int getNumStrictMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; }

static int getNumStrictMonotone ( int ln ) { int [ ] DP = new int [ ln ] [ DP_s ] ; for ( int i = 1 ; i <= ln ; i ++ ) { for ( int j = 1 ; j <= DP_s ; j ++ ) { DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; } return

static int getNumStrictMonotone ( int ln ) { int DP [ ] [ ] = new int [ ln ] [ DP_s ] ; for ( int i = 0 ; i < ln ; i ++ ) { for ( int j = 0 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; } return DP [ ln - 1 ] [ DP_s - 1 ] ; }

47.64
46.5
44.67
52.18
def bonacciseries ( n , m ) : a = [ 0 ] * m a [ n - 1 ] = 1 for i in range ( n , m ) : for j in range ( i - n , i ) : a [ i ] = a [ i ] + a [ j ] for i in range ( 0 , m ) : print ( a [ i ] , end = "" )

static void bonacciseries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) for ( int j = i - n ; j < i ; j ++ ) a [ i ] += a [ j ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " " ) ; }

static void bonacciseries ( int n , int m ) { int a [ ] = new int [ n ] ; for ( int i = n ; i < m ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { a [ i ] = a [ i ] + a [ j ] ; } } return a ; }

static void bonacciseries ( int n , int m ) { int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { a [ i ] = a [ i ] + a [ j ] ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] + a [ j ] ; } for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = a [ i ] + a [ j ] ; } } }

47.7
48.78
52.37
56.67
def maximumSumSubarray ( arr , n ) : min_prefix_sum = 0 res = - math . inf prefix_sum = [ ] prefix_sum . append ( arr [ 0 ] ) for i in range ( 1 , n ) : prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) for i in range ( n ) : res = max ( res , prefix_sum [ i ] - min_prefix_sum ) min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) return res

static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }

static int maximumSumSubarray ( int arr [ ] , int n ) { int res = math . inf ; int prefix_sum [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { res = max ( res , prefix_sum [ i - 1 ] + arr [ i ] ) ; min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ;

static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = - math . inf ; int prefix_sum = [ ] ; prefix_sum . append ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { res = max ( res , prefix_sum [ i - 1 ] - min_prefix_sum ) ; min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }

47.77
44.66
69.62
73.39
def countOnes ( arr , low , high ) : if high >= low : mid = low + ( high - low ) / 2 if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : return mid + 1 if arr [ mid ] == 1 : return countOnes ( arr , ( mid + 1 ) , high ) return countOnes ( arr , low , mid - 1 ) return 0

int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }

static int countOnes ( int arr [ ] , int low , int high ) { int mid = 0 ; while ( mid <= high ) { if ( arr [ mid ] == 0 ) return ( mid + 1 ) ; if ( arr [ mid ] == 1 ) return ( mid + 1 ) ; if ( arr [ mid ] == 0 ) return ( mid + 1 ) ; if ( arr [ mid ] == 1 ) return ( mid - 1 ) ; if ( arr [

static int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + high / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return mid + 1 ; if ( arr [ mid ] == 0 ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , low , mid - 1 ) ; } return - 1 ; }

47.8
51.71
48.04
51.94
def numberOfPermWithKInversion ( N , K ) : if ( N == 0 ) : return 0 if ( K == 0 ) : return 1 if ( memo [ N ] [ K ] != 0 ) : return memo [ N ] [ K ] sum = 0 for i in range ( K + 1 ) : if ( i <= N - 1 ) : sum += numberOfPermWithKInversion ( N - 1 , K - i ) memo [ N ] [ K ] = sum return sum

static int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }

static int numberOfPermWithKInversion ( int N , int K ) { int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; memo [ N ] [ K ] = sum ; } return 1 ; } }

static int numberOfPermWithKInversion ( int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i <= N - 1 ) { sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; memo [ N ] [ K ] = sum ; } } return sum ; }

47.81
54.78
59.25
62.19
def minInsertion ( tr1 ) : n = len ( str1 ) res = 0 count = [ 0 for i in range ( 26 ) ] for i in range ( n ) : count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( 26 ) : if ( count [ i ] % 2 == 1 ) : res += 1 if ( res == 0 ) : return 0 else : return res - 1

static int minInsertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }

static int minInsertion ( String str1 ) { int n = str1 . length ( ) ; int res = 0 ; int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ i ] % 2 == 0 ) res += 1 ; else res += 1 ; } } return res ; }

; } static int minInsertion ( String str1 ) { int n = str1 . length ( ) ; int res = 0 ; int count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] ++ ; if ( count [ i ] % 2 == 1 ) res += 1 ; if ( res == 0 ) return 0 ; else return res - 1 ; } }

47.81
47.46
60.99
57.25
def printbinomial ( max ) : for m in range ( max + 1 ) : print ( '%2d' % m , end = '' ) binom = 1 for x in range ( m + 1 ) : if m != 0 and x != 0 : binom = binom * ( m - x + 1 ) / x print ( '%4d' % binom , end = '' ) print ( "\n" , end = '' )

static void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + " " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; System . out . print ( binom + " " ) ; } System . out . println ( ) ; } }

static void printbinomial ( int max ) { int binom = 1 ; for ( int m = 0 ; m < max ; m ++ ) { if ( m != 0 ) binom = binom * ( m - x + 1 ) / x ; if ( x != 0 ) binom = binom * ( m - x + 1 ) / x ; if ( m != 0 ) binom = binom * ( m - x + 1 ) / x ; if (

static void printbinomial ( int max ) { for ( int m = 0 ; m < max ; m ++ ) { int binom = 1 ; for ( int x = 0 ; x < max ; x ++ ) { if ( m != 0 && x != 0 ) { binom = binom * ( m - x + 1 ) / x ; binom = binom * ( m - x + 1 ) / x ; print ( '%4d' % binom , end = '' ) ; } } } }

47.82
53.44
74.07
82.46
def summingSeries ( n ) : S = 0 for i in range ( 1 , n + 1 ) : S += i * i - ( i - 1 ) * ( i - 1 ) return S

static int summingSeries ( long n ) { int S = 0 ; for ( i = 1 ; i <= n ; i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ) ; return S ; }

static long summingSeries ( int n ) { long S = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { S += i * i ; } return S ; }

static int summingSeries ( int n ) { int S = 0 ; for ( int i = 1 ; i < n ; i ++ ) { S += i * i - ( i - 1 ) * ( i - 1 ) ; } return S ; }

47.83
52.45
62.63
59.68
def minCoins ( coins , m , V ) : table = [ 0 for i in range ( V + 1 ) ] table [ 0 ] = 0 for i in range ( 1 , V + 1 ) : table [ i ] = sys . maxsize for i in range ( 1 , V + 1 ) : for j in range ( m ) : if ( coins [ j ] <= i ) : sub_res = table [ i - coins [ j ] ] if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : table [ i ] = sub_res + 1 return table [ V ]

static int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; }

static int minCoins ( int [ ] coins , int m , int V ) { int table [ ] = new int [ V + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) { table [ i ] = sub_res + 1 ; } } return table [ V ] ; }

static int minCoins ( int coins , int m , int V ) { int table [ 0 ] = 0 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }

47.86
60.12
46.96
55.98
def generate ( ones , zeroes , str , len1 ) : if ( len1 == len ( str ) ) : print ( str , end = "" ) return generate ( ones + 1 , zeroes , str + "1" , len1 ) if ( ones > zeroes ) : generate ( ones , zeroes + 1 , str + "0" , len1 )

static void generate ( int ones , int zeroes , String str , int len ) { if ( len == str . length ( ) ) { System . out . print ( str + " " ) ; return ; } generate ( ones + 1 , zeroes , str + "1" , len ) ; if ( ones > zeroes ) { generate ( ones , zeroes + 1 , str + "0" , len ) ; } }

static int generate ( int ones , int zeroes , String str ) { if ( ones == zeroes ) return generate ( ones + 1 , zeroes , str + "0" , len1 ) ; if ( len1 == len ( str ) ) return generate ( ones , zeroes , str + "1" , len1 ) ; if ( ones > zeroes ) return generate ( ones , zeroes , str + "0" , len1 ) ; if ( ones >

static void generate ( int ones , int zeroes , String str , int len1 ) { if ( ones > zeroes ) { generate ( ones , zeroes , str + "1" , len1 ) ; } if ( ones > zeroes ) { generate ( ones , zeroes , str + "0" , len1 ) ; } }

47.91
58.95
50.66
65.1
def isDivisible ( n ) : while ( int ( n / 100 ) ) : last_digit = int ( n % 10 ) n = int ( n / 10 ) n += last_digit * 3 return ( n % 29 == 0 )

static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }

static boolean isDivisible ( int n ) { int last_digit = 0 ; while ( int ( n / 10 ) == 0 ) { last_digit = int ( n / 10 ) ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; } return ( n % 29 == 0 ) ; }

static boolean isDivisible ( int n ) { while ( n > 0 ) { int last_digit = int ( n / 10 ) ; n = int ( n / 10 ) ; n += last_digit * 3 ; if ( n % 29 == 0 ) return true ; } return false ; }

47.93
55.66
70.96
77.47
def spiralDiaSum ( n ) : if n == 1 : return 1 return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )

static int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }

static int spiralDiaSum ( int n ) { if ( n == 2 ) return spiralDiaSum ( n - 1 ) ; else return spiralDiaSum ( n - 2 ) ; } }

static int spiralDiaSum ( int n ) { return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }

48.05
46.15
67.45
67.65
def printFirstNegativeInteger ( arr , n , k ) : for i in range ( 0 , ( n - k + 1 ) ) : flag = False for j in range ( 0 , k ) : if ( arr [ i + j ] < 0 ) : print ( arr [ i + j ] , end = "" ) flag = True break if ( not ( flag ) ) : print ( "0" , end = "" )

static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + " " ) ; flag = true ; break ; } } if ( ! flag ) System . out . print ( "0" + " " ) ; } }

static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i + j ] < 0 ) { print ( arr [ i + j ] , end = "" ) flag = true break if ( ! ( flag ) ) { print ( "0" , end = "" ) flag = true break if ( ! ( flag ) ) {

static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { flag = true ; break ; } if ( ! ( flag ) ) { print ( arr [ i + j ] , end = "" ) ; flag = true ; } } } }

48.14
65.02
100.0
100.0
def getModulo ( n , d ) : return ( n & ( d - 1 ) )

static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }

static int getModulo ( int n , int d ) { return n % d

static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }

48.17
49.66
51.09
57.32
def countZeroes ( mat ) : N = 5 ; row = N - 1 ; col = 0 ; count = 0 ; while ( col < N ) : while ( mat [ row ] [ col ] ) : if ( row < 0 ) : return count ; row = row - 1 ; count = count + ( row + 1 ) ; col = col + 1 ; return count ;

static int countZeroes ( int mat [ ] [ ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }

static int countZeroes ( int mat [ ] [ ] ) { int row , col ; int count ; while ( col < N ) { if ( row < 0 ) return count ; row = row - 1 ; count = count + ( row + 1 ) ; col = col + 1 ; } return count ; } int N = mat . length ; int row = 0 ; int col = 0 ; while ( row < N ) { if ( col < 0 ) return count ;

static int countZeroes ( int [ ] mat , int row , int col , int count ) { int N = mat . length ; int row = 0 ; int col = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) { if ( row < 0 ) return count ; row = row - 1 ; count = count + ( row + 1 ) ; col = col + 1 ; } } return count ; }

48.21
53.73
51.23
58.72
def midPoint ( X1 , Y1 , X2 , Y2 ) : dx = X2 - X1 dy = Y2 - Y1 d = dy - ( dx / 2 ) x = X1 y = Y1 print ( x , "," , y , "\n" ) while ( x < X2 ) : x = x + 1 if ( d < 0 ) : d = d + dy else : d = d + ( dy - dx ) y = y + 1 print ( x , "," , y , "\n" )

static void midPoint ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dy - ( dx / 2 ) ; int x = X1 , y = Y1 ; System . out . print ( x + "," + y + "\n" ) ; while ( x < X2 ) { x ++ ; if ( d < 0 ) d = d + dy ; else { d += ( dy - dx ) ; y ++ ; } System . out . print ( x + "," + y + "\n" ) ; } }

static void midPoint ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dx - ( dy / 2 ) ; y = y + 1 print ( x , "," , y , "\n" ) while ( x < X2 ) { x = x + 1 if ( d < 0 ) d = d + dx ; else d = dy -

static void midPoint ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dy - dx / 2 ; while ( x < X2 ) { x = x + 1 if ( d < 0 ) d = d + dy ; else : d = d + ( dy - dx ) ; y = y + 1 print ( x , "," , y , "\n" ) ; } while ( x < X2 ) { x = x + 1 if ( d < 0 ) d = d + dy ; else : d = d + ( dy - dx ) ; y = y + 1 print ( x , "," , y , "\n" ) ; } }

48.29
49.88
63.7
59.56
def maximumChars ( str1 ) : n = len ( str1 ) res = - 1 firstInd = [ - 1 for i in range ( MAX_CHAR ) ] for i in range ( n ) : first_ind = firstInd [ ord ( str1 [ i ] ) ] if ( first_ind == - 1 ) : firstInd [ ord ( str1 [ i ] ) ] = i else : res = max ( res , abs ( i - first_ind - 1 ) ) return res

static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }

static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ ord ( str . charAt ( i ) ) ] ; if ( first_ind == - 1 ) res = max ( res , abs ( i - first_ind ) ) ; else res = max ( res , abs ( i - first_ind -

static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ ord ( str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ ord ( str . charAt ( i ) ] = i ; else res = max ( res , abs ( i - first_ind - 1 ) ) ) ; } return res ; }

48.34
65.96
95.33
96.31
def count ( S , m , n ) : if ( n == 0 ) : return 1 if ( n < 0 ) : return 0 if ( m <= 0 and n >= 1 ) : return 0 return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] )

static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }

static int count ( int S [ ] , int m , int n ) { if ( m == 0 ) return 1 return count ( S , m - 1 , n - S [ m ] ) + count ( S , m - 1 , n - S [ m ] ) ; } return 0 ; }  def count ( int [ ] S , int m , int n ) { int count ( int [ ] S , int m , int n ) { int count ( int

static int count ( int S [ ] , int m , int n ) { if ( m == 0 ) return 1 ; if ( n == 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }

48.37
51.22
77.36
66.33
def countDecodingDP ( digits , n ) : count = [ 0 ] * ( n + 1 ) count [ 0 ] = 1 count [ 1 ] = 1 for i in range ( 2 , n + 1 ) : count [ i ] = 0 if ( digits [ i - 1 ] > '0' ) : count [ i ] = count [ i - 1 ] if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : count [ i ] += count [ i - 2 ] return count [ n ]

static int countDecodingDP ( char digits [ ] , int n ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; if ( digits [ 0 ] == '0' ) return 0 ; for ( int i = 2 ; i <= n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }

static int countDecodingDP ( char digits [ ] , int n ) { int count [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] ; if ( digits [ i - 2 ] == '1' ) count [ i ] += count [ i -

static int countDecodingDP ( char [ ] digits , int n ) { int count [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] > '1' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '2' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }

48.38
48.02
47.86
48.62
def findLargestSumPair ( arr , n ) : if arr [ 0 ] > arr [ 1 ] : first = arr [ 0 ] second = arr [ 1 ] else : first = arr [ 1 ] second = arr [ 0 ] for i in range ( 2 , n ) : if arr [ i ] > first : second = first first = arr [ i ] elif arr [ i ] > second and arr [ i ] != first : second = arr [ i ] return ( first + second )

static int findLargestSumPair ( ) { int first , second ; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ] ; second = arr [ 1 ] ; } else { first = arr [ 1 ] ; second = arr [ 0 ] ; } for ( int i = 2 ; i < arr . length ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } return ( first + second ) ; }

static int findLargestSumPair ( int arr [ ] , int n ) { int first = arr [ 0 ] ; int second = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > second ) second = arr [ i ] ; if ( arr [ i ] != second ) first = arr [ i ] ; else second = arr [ i ] ; } return ( first + second ) / 2 ; }

static int findLargestSumPair ( int arr [ ] , int n ) { int first = arr [ 0 ] ; int second = arr [ 1 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > first ) first = arr [ i ] ; if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] != first ) second = arr [ i ] ; } return ( first + second ) / 2 ; }

48.44
63.75
69.45
67.27
def MaxDotProduct ( A , B , m , n ) : dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 , 1 ) : for j in range ( i , m + 1 , 1 ) : dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) return dp [ n ] [ m ]

static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }

static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= m ; j ++ ) { if ( dp [ i ] [ j ] > 0 ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] [ j - 1 ] + ( A [ i - 1 ] * B [ i - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ; } return dp [ n ] [ m ] ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] [ j - 1 ] + ( B [ i - 1 ] * B [ i - 1 ] * B [ i - 1 ] * B [ i - 1 ] ) ; } return dp [ n ] [ m ] ; }

static int MaxDotProduct ( int A , int B , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }

48.46
51.27
64.21
63.13
def countPairs ( arr , n ) : result = 0 Hash = set ( ) for i in range ( n ) : Hash . add ( arr [ i ] ) for i in range ( n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] if product in ( Hash ) : result += 1 return result

static int countPairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Hash . add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . contains ( product ) ) { result ++ ; } } } return result ; }

static int countPairs ( int arr [ ] , int n ) { Set < int > Hash = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( Hash . contains ( arr [ i ] ) ) result += 1 ; else result += 1 ; } } return result ; }

static int countPairs ( int arr [ ] , int n ) { int result = 0 ; Set < int > Hash = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( product in ( Hash ) ) { result ++ ; } } } return result ; }

48.47
53.82
43.03
58.16
def superSeq ( X , Y , m , n ) : if ( not m ) : return n if ( not n ) : return m if ( X [ m - 1 ] == Y [ n - 1 ] ) : return 1 + superSeq ( X , Y , m - 1 , n - 1 ) return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) )

static int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }

static int superSeq ( int X [ ] , int Y [ ] , int m , int n ) { if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n ) ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n ) ; return 1 + superSeq ( X , Y ,

static int superSeq ( int X , int Y , int m , int n ) { if ( ! X . equals ( Y ) ) return 1 + superSeq ( X , Y , m - 1 , n ) ; if ( ! Y . equals ( m ) ) return 1 + superSeq ( X , Y , m - 1 , n ) ; if ( ! X . equals ( Y ) ) return 1 + superSeq ( X , Y , m - 1 , n ) ; if ( ! Y . equals ( m ) ) return 1 + superSeq ( X , Y , m - 1 , n ) ; return 1 + superSeq ( X , Y , m - 1 , n ) ; }

48.52
46.64
42.36
44.99
def isComposite ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return False if ( n % 2 == 0 or n % 3 == 0 ) : return True i = 5 while ( i * i <= n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return True i = i + 6 return False

static boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( "False" ) ; if ( n <= 3 ) System . out . println ( "False" ) ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }

static boolean isComposite ( int n ) { if ( n <= 2 ) return true ; if ( n <= 3 ) return true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) return true ; if ( n % i == 0 ) return true ; if ( n % i == 0 ) return true ; if ( n % i == 0 ) return true ; if ( n % i == 0 ) return true ; if

static boolean isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 2 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; return false ; }

48.53
57.31
47.42
61.67
def getSum ( n ) : sum = 0 while ( n > 0 ) : sum += int ( n % 10 ) n = int ( n / 10 ) return sum

static int getSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; }

static int getSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += int ( n / 10 ) ; } return sum ; }

static int getSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += int ( n % 10 ) ; n = n / 10 ; } return sum ; }

48.54
47.49
43.7
49.45
def maxProduct ( arr , n ) : if ( n < 2 ) : print ( "Nopairsexists" ) return a = arr [ 0 ] b = arr [ 1 ] for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] * arr [ j ] > a * b ) : a = arr [ i ] b = arr [ j ] print ( "Maxproductpairis{" , a , "," , b , "}" , sep = "" )

static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( "No pairs exists" ) ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } System . out . println ( "Max product pair is { " + a + ", " + b + "}" ) ; }

static void maxProduct ( int arr [ ] , int n ) { if ( arr [ 0 ] * arr [ 1 ] > a * b ) return ; a = arr [ 0 ] ; b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) return ; a = arr [ i ] ; b = arr [ j ] ; } } print ( "

static void maxProduct ( int arr [ ] , int n ) { int a = arr [ 0 ] ; int b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) a = arr [ i ] ; b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] > a * b ) a = arr [ i ] ; if ( arr [ j ] * arr [ i ] > a * b ) a = arr [ j ] ; if ( arr [ i ] * arr [ j ] > a * b ) a = arr [ i ] ; if ( arr [ j ] * arr [ j ] > a * b ) b = arr [ j ] ; } } }

48.56
49.77
49.25
47.54
def minimumBox ( arr , n ) : q = collections . deque ( [ ] ) arr . sort ( ) q . append ( arr [ 0 ] ) for i in range ( 1 , n ) : now = q [ 0 ] if ( arr [ i ] >= 2 * now ) : q . popleft ( ) q . append ( arr [ i ] ) return len ( q )

static int minimumBox ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }

static int minimumBox ( long [ ] arr , int n ) { long [ ] q = collections . deque ( [ ] ) ; for ( int i = 0 ; i < n ; i ++ ) { long now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) { q . popleft ( ) q . append ( arr [ i ] ) ; } else { q . append ( arr [ i ] ) ; } } return - 1 ; }

static int minimumBox ( int arr [ ] , int n ) { int q [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . popleft ( ) ; q . append ( arr [ i ] ) ; } return len ( q ) ; }

48.61
55.71
56.05
66.04
def printSquares ( n ) : square = 0 odd = 1 for x in range ( 0 , n ) : print ( square , end = "" ) square = square + odd odd = odd + 2

static void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " " ) ; square = square + odd ; odd = odd + 2 ; } }

static void printSquares ( int n ) { int square = 0 ; int odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { print ( square , end = "" ) ; } for ( int x = 0 ; x < n ; x ++ ) { print ( odd , end = "" ) ; } }

; for ( int n ; n > 0 ; n -- ) { int square = 0 ; int odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { print ( square , end = "" ) ; square = square + odd ; odd = odd + 2 ; } print ( square , end = "" ) ; }

48.74
51.56
62.19
53.77
def maximumNumberDistinctPrimeRange ( m , n ) : factorCount = [ 0 ] * ( n + 1 ) prime = [ False ] * ( n + 1 ) for i in range ( n + 1 ) : factorCount [ i ] = 0 prime [ i ] = True for i in range ( 2 , n + 1 ) : if ( prime [ i ] == True ) : factorCount [ i ] = 1 for j in range ( i * 2 , n + 1 , i ) : factorCount [ j ] += 1 prime [ j ] = False max = factorCount [ m ] num = m for i in range ( m , n + 1 ) : if ( factorCount [ i ] > max ) : max = factorCount [ i ] num = i return num

static int maximumNumberDistinctPrimeRange ( int m , int n ) { long factorCount [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; }

static int maximumNumberDistinctPrimeRange ( int m , int n ) { int [ ] factorCount = new int [ n + 1 ] ; int [ ] prime = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( factorCount [ i ] > max ) max = factorCount [ j ] ; prime [ j ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ i ] == false ) prime [ i ] = false ; for ( int i = 0 ; i < m ; i ++ ) { if ( prime [ i ] = false ; } } } } } } } return max ; } } return max ; } return max ; } } return max ; } } ; } return max ; } return max ; } ; } ; } ; } return max ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ i ] = true ; } } ; } return false ; } return false ; }

static int maximumNumberDistinctPrimeRange ( int m , int n ) { int factorCount [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; for ( int j = i * 2 ; j < n ; j ++ ) { if ( prime [ j ] == true ) factorCount [ i ] = 1 ; for ( int j = i * 2 ; j < i ; j ++ ) factorCount [ j ] += 1 ; prime [ j ] = false ; } max = factorCount [ m ] ; num = m ; for ( int i = m ; i < n ; i ++ ) { if ( factorCount [ i ] > max ) max = factorCount [ i ] ; num = i ; } } return num ; }

48.82
52.58
54.42
65.32
def checkplusperfect ( x ) : temp = x n = 0 while ( x != 0 ) : x = x // 10 n = n + 1 x = temp sm = 0 while ( x != 0 ) : sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) x = x // 10 return ( sm == temp )

static boolean checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }

static boolean checkplusperfect ( int x ) { int n = 0 ; int temp = x ; while ( x != 0 ) { int sm = 0 ; while ( x != 0 ) { sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) ; x = temp ; n = n + 1 x = temp ; } return ( temp == x ) ; } return ( x == 0 ) ; } return ( x == 0 ) ; }

static boolean checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { temp = temp + ( int ) ( math . pow ( x % 10 , n ) ) ; x = temp ; sm = 0 ; while ( x != 0 ) { sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) ; x = x ; } return ( sm == temp ) ; } }

48.83
55.47
51.08
36.16
def findConsecutive ( N ) : start = 1 end = ( N + 1 ) // 2 while ( start < end ) : Sum = 0 for i in range ( start , end + 1 ) : Sum = Sum + i if ( Sum == N ) : for j in range ( start , i + 1 ) : print ( j , end = "" ) print ( ) break if ( Sum > N ) : break Sum = 0 start += 1

static void findConsecutive ( int N ) { int start = 1 ; int end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= i ; j ++ ) System . out . print ( j + " " ) ; System . out . println ( ) ; break ; } if ( sum > N ) break ; } sum = 0 ; start ++ ; } }

static int findConsecutive ( int N ) { int start = 1 ; int end = ( N + 1 ) / 2 ; while ( start < end ) { int Sum = 0 ; for ( int i = 0 ; i < end ; i ++ ) { if ( Sum == N ) { for ( int j = start ; j < end ; j ++ ) { if ( Sum == N ) { for ( int j = start ; j < end ; j ++ ) { if

static int findConsecutive ( int N ) { int start = 1 ; int end = ( N + 1 ) // 2 ; while ( start < end ) { int Sum = 0 ; for ( int i = start ; i < end ; i ++ ) { Sum = Sum + i ; if ( Sum == N ) { for ( int j = start ; j < end ; j ++ ) { Sum = Sum + j ; if ( Sum == N ) { for ( int j = start ; j < end ; j ++ ) { print ( j , end = "" ) ; } } } } } } return start ; }

48.83
47.85
64.03
58.65
def findPlatform ( arr , dep , n ) : arr . sort ( ) dep . sort ( ) plat_needed = 1 result = 1 i = 1 j = 0 while ( i < n and j < n ) : if ( arr [ i ] < dep [ j ] ) : plat_needed += 1 i += 1 if ( plat_needed > result ) : result = plat_needed else : plat_needed -= 1 j += 1 return result

static int findPlatform ( int arr [ ] , int dep [ ] , int n ) { Arrays . sort ( arr ) ; Arrays . sort ( dep ) ; int plat_needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat_needed ++ ; i ++ ; if ( plat_needed > result ) result = plat_needed ; } else { plat_needed -- ; j ++ ; } } return result ; }

static int findPlatform ( int [ ] arr , int [ ] dep , int n ) { int result = 1 ; int i = 0 ; int j = 0 ; while ( i < n and j < n ) { if ( arr [ i ] < dep [ j ] ) { plat_needed += 1 i += 1 if ( plat_needed > result ) result = plat_needed ; } else { plat_needed -= 1 j += 1 if ( plat_needed > result

static int findPlatform ( int arr , int dep , int n ) { int plat_needed = 1 ; int result = 1 ; int i = 1 ; int j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] < dep [ j ] ) { plat_needed += 1 ; i ++ ; if ( plat_needed > result ) { result = plat_needed ; } else { plat_needed -= 1 ; j ++ ; } } } return result ; }

48.84
60.4
97.02
98.19
def countSetBits ( n ) : if ( n == 0 ) : return 0 else : return 1 + countSetBits ( n & ( n - 1 ) )

public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }

static int countSetBits ( int n ) { if ( n == 1 ) return 1 ; else return countSetBits ( n >> 1 ) ; } }

static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }

48.87
50.21
55.34
54.9
def maxRepeating ( str ) : n = len ( str ) count = 0 res = str [ 0 ] cur_count = 1 for i in range ( n ) : if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : cur_count += 1 else : if cur_count > count : count = cur_count res = str [ i ] cur_count = 1 return res

static char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }

static int maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; String res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cur_count > count ) count = cur_count ; res = str [ i ] ; cur_count = 1 ; } return res ; }

static int maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) count ++ ; else if ( cur_count > count ) count = cur_count ; res = str [ i ] ; cur_count = 1 ; } return res ; }

48.91
46.26
58.17
57.35
def maxArea ( mat ) : hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] for i in range ( 0 , C , 1 ) : hist [ 0 ] [ i ] = mat [ 0 ] [ i ] for j in range ( 1 , R , 1 ) : if ( ( mat [ j ] [ i ] == 0 ) ) : hist [ j ] [ i ] = 0 else : hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 for i in range ( 0 , R , 1 ) : count = [ 0 for i in range ( R + 1 ) ] for j in range ( 0 , C , 1 ) : count [ hist [ i ] [ j ] ] += 1 col_no = 0 j = R while ( j >= 0 ) : if ( count [ j ] > 0 ) : for k in range ( 0 , count [ j ] , 1 ) : hist [ i ] [ col_no ] = j col_no += 1 j -= 1 max_area = 0 for i in range ( 0 , R , 1 ) : for j in range ( 0 , C , 1 ) : curr_area = ( j + 1 ) * hist [ i ] [ j ] if ( curr_area > max_area ) : max_area = curr_area return max_area

static int maxArea ( int mat [ ] [ ] ) { int hist [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ; for ( int i = 0 ; i < C ; i ++ ) { hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < R ; j ++ ) { hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 ; } } for ( int i = 0 ; i < R ; i ++ ) { int count [ ] = new int [ R + 1 ] ; for ( int j = 0 ; j < C ; j ++ ) { count [ hist [ i ] [ j ] ] ++ ; } int col_no = 0 ; for ( int j = R ; j >= 0 ; j -- ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { hist [ i ] [ col_no ] = j ; col_no ++ ; } } } } int curr_area , max_area = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { curr_area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_area > max_area ) { max_area = curr_area ; } } } return max_area ; }

static int maxArea ( int mat [ ] [ ] ) { int [ ] hist = new int [ R + 1 ] [ ] ; for ( int i = 0 ; i < R ; i ++ ) { int [ ] count = new int [ mat [ i ] [ ] ] ; for ( int j = 0 ; j < R ; j ++ ) { if ( ( count [ j ] > 0 ) ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { if ( ( hist [ i ] [ j ] > 0 ) { for ( int j = 0 ; j < C ; j ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( hist [ i ] [ j ] > 0 ) { for ( int j = 0 ; j < C ; j ++ ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { if ( count [ j ] > 0 ) { if ( hist [ i ] > 0 ) { for ( int j < C ; j ++ ) { if ( j > 0 ) { for ( j < C ; j ++ ) { if (

static int maxArea ( int mat [ ] [ ] ) { int [ ] hist = new int [ R + 1 ] [ C + 1 ] ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { hist [ i ] [ j ] = mat [ i ] [ j ] ; if ( ( mat [ j ] [ i ] == 0 ) ) hist [ j ] [ i ] = 0 ; else hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { hist [ i ] [ j ] = mat [ i ] [ j ] ; if ( ( hist [ i ] [ j ] == 0 ) ) hist [ i ] [ j ] = 0 ; else hist [ i ] [ j ] = hist [ j - 1 ] [ j ] + 1 ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { hist [ i ] [ j ]

48.92
58.03
48.2
59.49
def isPalindrome ( string ) : l = 0 h = len ( string ) - 1 while h > l : l += 1 h -= 1 if string [ l - 1 ] != string [ h + 1 ] : return False return True

static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }

static boolean isPalindrome ( String string ) { int l = 0 ; int h = string . length ( ) - 1 ; while ( l <= h ) { if ( string [ l ] != string [ h ] ) return false ; } return true ; }

static boolean isPalindrome ( String string ) { int l = 0 ; int h = string . length ( ) - 1 ; while ( h > l ) { l += 1 ; h -= 1 ; if ( string [ l - 1 ] != string [ h + 1 ] ) return false ; } return true ; }

48.98
65.36
100.0
100.0
def recSearch ( arr , l , r , x ) : if r < l : return - 1 if arr [ l ] == x : return l if arr [ r ] == x : return r return recSearch ( arr , l + 1 , r - 1 , x )

static int recSearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return recSearch ( arr , l + 1 , r - 1 , x ) ; }

static int recSearch ( int [ ] arr , int l , int r , int x ) { if ( arr [ l ] == x ) return l + 1 ; if ( arr [ r ] == x ) return r - 1 ; if ( arr [ l ] == x ) return l + 1 ; if ( arr [ r ] == x ) return r - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return

static int recSearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return recSearch ( arr , l + 1 , r - 1 , x ) ; }

49.0
49.75
72.07
72.7
def maxOnesIndex ( arr , n ) : max_count = 0 max_index = 0 prev_zero = - 1 prev_prev_zero = - 1 for curr in range ( n ) : if ( arr [ curr ] == 0 ) : if ( curr - prev_prev_zero > max_count ) : max_count = curr - prev_prev_zero max_index = prev_zero prev_prev_zero = prev_zero prev_zero = curr if ( n - prev_prev_zero > max_count ) : max_index = prev_zero return max_index

static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }

static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; for ( int curr = 0 ; curr < arr . length ; curr ++ ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero prev_prev_zero = prev_zero

static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; curr ++ ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) max_count = curr - prev_prev_zero ; max_index = prev_zero ; prev_prev_zero = prev_zero ; prev_zero = curr ; } } return max_index ; }

49.01
50.97
70.97
60.19
def lcs ( X , Y ) : m = len ( X ) n = len ( Y ) L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] bi = bool for i in range ( m ) : bi = i & 1 for j in range ( n + 1 ) : if ( i == 0 or j == 0 ) : L [ bi ] [ j ] = 0 elif ( X [ i ] == Y [ j - 1 ] ) : L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 else : L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) return L [ bi ] [ n ]

public static int lcs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }

static int lcs ( int X [ ] , int Y [ ] ) { int m = X . length ( ) ; int n = Y . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int bi = i & 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( X [ i ] == Y [ j - 1 ] ) { L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ] ; } } return L [ 1 - bi ] [ j - 1 ] ; } } L [ ] [ n ] = L [ 1 ] ; } for ( int i = 0 ; i < m ; i ++ ) { if ( bi == 1 ) { L [ bi ] [ j ] = L [ bi ] [ j - 1 ] == Y [ j - 1 ] ) { L [ bi ] [ j ] = L [ bi ] [ j - 1 ] + 1 ] + 1 ] = L [ bi ] [ j ] = L [ bi ] [ j ] = L [ bi ] [ j ] = L [ bi ] [ j ] = L [ bi ] [ j - 1 ] ; }

static int lcs ( int [ ] X , int [ ] Y ) { int m = len ( X ) ; int n = len ( Y ) ; int bi = false ; for ( int i = 0 ; i < m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i ] == Y [ j - 1 ] ) L [ bi ] [ j ] = 0 ; else L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }

49.01
49.94
45.86
56.59
def binaryToDecimal ( n ) : num = n dec_value = 0 base1 = 1 len1 = len ( num ) for i in range ( len1 - 1 , - 1 , - 1 ) : if ( num [ i ] == '1' ) : dec_value += base1 base1 = base1 * 2 return dec_value

static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }

static int binaryToDecimal ( String n ) { int dec_value = 0 ; int base1 = 1 ; int len1 = num . length ( ) ; for ( int i = 0 ; i < len1 ; i ++ ) { if ( num [ i ] == '0' ) { dec_value += base1 ; base1 = base1 * 2 ; } } return dec_value ; }

static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base1 = 1 ; int len1 = len ( num ) ; for ( int i = 0 ; i < len1 ; i ++ ) { if ( num [ i ] == '1' ) { dec_value += base1 ; base1 = base1 * 2 ; } } return dec_value ; }

49.04
31.81
38.68
33.3
def recaman ( n ) : if ( n <= 0 ) : return print ( 0 , "," , end = '' ) s = set ( [ ] ) s . add ( 0 ) prev = 0 for i in range ( 1 , n ) : curr = prev - i if ( curr < 0 or curr in s ) : curr = prev + i s . add ( curr ) print ( curr , "," , end = '' ) prev = curr

static void recaman ( int n ) { if ( n <= 0 ) return ; System . out . printf ( "%d, " , 0 ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . contains ( curr ) ) curr = prev + i ; s . add ( curr ) ; System . out . printf ( "%d, " , curr ) ; prev = curr ; } }

static void recaman ( int n ) { if ( n <= 0 ) return print ( 0 , "," , end = '' ) ; s . add ( 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s . contains ( curr ) ) return print ( curr , "," , end = '' ) ; s . add ( curr ) ; if ( curr < 0 ) curr = prev + i ; s . add ( curr ) ; }

; for ( int i = 1 ; i <= n ; i ++ ) { int curr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { curr = prev - i ; if ( curr < 0 || curr in s ) { curr = prev + i ; s . add ( curr ) ; print ( curr , "," , end = '' ) ; prev = curr ; } } }

49.04
46.33
63.93
54.99
def ifPossible ( arr , n ) : cp = [ 0 ] * n cp = arr cp . sort ( ) for i in range ( 0 , n ) : if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : return False return True

static boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }

static boolean ifPossible ( int arr [ ] , int n ) { int cp [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) ) return false ; } return true ; }

static boolean possible ( int arr [ ] , int n ) { int cp [ ] = new int [ n ] ; cp . sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! arr [ i ] . equals ( cp [ i ] ) && ! arr [ n - 1 - i ] . equals ( cp [ i ] ) ) return false ; } return true ; }

49.08
68.61
70.55
72.06
def findLongestRepeatingSubSeq ( str ) : n = len ( str ) dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ n ] [ n ]

static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }

static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] ) { dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i ] [ j - 1 ] = dp [ i ] [ j - 1 ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= j ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] == str [ j - 1 ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j - 1 ] = dp [ i ] [ j - 1 ] ; } } } return dp [ i ] [ j - 1 ] ; } } return dp [ n ] [ j

static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n ] [ n ] ; } }

49.09
45.0
41.21
44.31
def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if B [ i ] : if A [ i ] != i + 1 : A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] for i in range ( n ) : if A [ i ] != i + 1 : return False return True

static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }

static boolean sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( A [ i ] != i + 1 ) A [ i ] , A [ i + 1 ] = A [ i ] , A [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( B [ i ] : if ( A [ i ] != i +

static boolean sortedAfterSwap ( int A , int B , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] ; } } return true ; }

49.11
58.32
77.23
78.36
def mostFrequent ( arr , n ) : arr . sort ( ) max_count = 1 res = arr [ 0 ] curr_count = 1 for i in range ( 1 , n ) : if ( arr [ i ] == arr [ i - 1 ] ) : curr_count += 1 else : if ( curr_count > max_count ) : max_count = curr_count res = arr [ i - 1 ] curr_count = 1 if ( curr_count > max_count ) : max_count = curr_count res = arr [ n - 1 ] return res

static int mostFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }

static int mostFrequent ( int arr [ ] , int n ) { int max_count = 1 ; int res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { curr_count += 1 ; } else { if ( curr_count > max_count ) { max_count = curr_count res = arr

static int mostFrequent ( int arr [ ] , int n ) { int max_count = 1 ; res = arr [ 0 ] ; curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { curr_count += 1 ; } else { if ( curr_count > max_count ) max_count = curr_count ; res = arr [ i - 1 ] ; curr_count = 1 ; } } if ( curr_count > max_count ) max_count = curr_count ; res = arr [ i - 1 ] ; curr_count = 1 ; } return res ; }

49.12
52.18
58.64
59.51
def groupElements ( arr , n ) : visited = [ False ] * n for i in range ( 0 , n ) : visited [ i ] = False for i in range ( 0 , n ) : if ( visited [ i ] == False ) : print ( arr [ i ] , end = "" ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] , end = "" ) visited [ j ] = True

static void groupElements ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { System . out . print ( arr [ i ] + " " ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { System . out . print ( arr [ i ] + " " ) ; visited [ j ] = true ; } } } } }

static void groupElements ( int arr [ ] , int n ) { bool visited [ ] = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == false ) visited [ i ] = true ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) visited [ j ] = true ; else visited [ j ] =

static void groupElements ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == false ) { print ( arr [ i ] , end = "" ) ; visited [ i ] = true ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == false ) { print ( arr [ i ] , end = "" ) ; visited [ i ] = true ; } } }

49.16
43.65
47.37
44.98
def KMaxCombinations ( A , B , N , K ) : pq = PriorityQueue ( ) for i in range ( 0 , N ) : for j in range ( 0 , N ) : a = A [ i ] + B [ j ] pq . put ( ( - a , a ) ) count = 0 while ( count < K ) : print ( pq . get ( ) [ 1 ] ) count = count + 1

static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) pq . add ( A [ i ] + B [ j ] ) ; int count = 0 ; while ( count < K ) { System . out . println ( pq . peek ( ) ) ; pq . remove ( ) ; count ++ ; } }

static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue pq = PriorityQueue ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( pq . get ( ) [ 1 ] < - a ) { pq . put ( ( - a , a ) ) ; } } } int count = 0 ;

static int KMaxCombinations ( int A , int B , int N , int K ) { PriorityQueue pq = new PriorityQueue ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int a = A [ i ] + B [ j ] ; pq . put ( ( - a , a ) ) ; count ++ ; } } return count ; }

49.18
52.8
65.47
65.96
def getInvCount ( arr , n ) : invcount = 0 for i in range ( 1 , n - 1 ) : small = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : small += 1 great = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( arr [ i ] < arr [ j ] ) : great += 1 invcount += great * small return invcount

int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }

static int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int great = 0 ; for ( int j = i ; j <= n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { great += 1 ; invcount += great * small ; } } return invcount ; }

int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { small ++ ; } if ( arr [ i ] < arr [ j ] ) { great ++ ; invcount ++ ; } } } return invcount ; }

49.22
59.58
57.98
55.39
def isSubsetSum ( set , n , sum ) : subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) for i in range ( n + 1 ) : subset [ i ] [ 0 ] = True for i in range ( 1 , sum + 1 ) : subset [ 0 ] [ i ] = False for i in range ( 1 , n + 1 ) : for j in range ( 1 , sum + 1 ) : if j < set [ i - 1 ] : subset [ i ] [ j ] = subset [ i - 1 ] [ j ] if j >= set [ i - 1 ] : subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) return subset [ n ] [ sum ]

static boolean isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } } return subset [ sum ] [ n ] ; }

static boolean isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] = subset [ i - 1 ] [ j ] = subset [ i - 1 ] [ j ] ; } return subset [ n ] [ sum ] ; for ( int i = 1 ; i <= n ; i ++ ) subset [ i ] [ j ] = subset [ i ] [ j ] = subset [ i ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] [ j ] = subset [ i - 1 ] [ j ] [ j ] [ j ] [ j ] [ j ] = subset [ i ] [ j ] ; } return subset [ n ] [ sum ] [ sum ] ; }

static boolean isSubsetSum ( int [ ] set , int n , int sum ) { int subset [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < set [ i - 1 ] ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) ; } } return subset [ n ] [ sum ] ; }

49.3
56.38
65.06
70.35
def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 if m < n : return 0 arr1 . sort ( ) arr2 . sort ( ) while i < n and j < m : if arr1 [ j ] < arr2 [ i ] : j += 1 elif arr1 [ j ] == arr2 [ i ] : j += 1 i += 1 elif arr1 [ j ] > arr2 [ i ] : return 0 return False if i < n else True

static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) { j ++ ; i ++ ; } else if ( arr1 [ j ] > arr2 [ i ] ) return false ; } if ( i < n ) return false ; else return true ; }

static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; while ( i < n && j < m ) { if ( arr1 [ j ] == arr2 [ i ] ) i += 1 ; else if ( arr1 [ j ] == arr2 [ i ] ) j += 1 ; else if ( arr1 [ j ] == arr2 [ i ] ) j

static boolean isSubset ( int arr1 , int arr2 , int m , int n ) { int i = 0 ; int j = 0 ; if ( m < n ) return 0 ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) i ++ ; else if ( arr1 [ j ] > arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) j ++ ; else i ++ ; } return false ; }

49.31
49.45
61.2
60.72
def findoptimal ( N ) : if ( N <= 6 ) : return N screen = [ 0 ] * N for n in range ( 1 , 7 ) : screen [ n - 1 ] = n for n in range ( 7 , N + 1 ) : screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) return screen [ N - 1 ]

static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }

static int findoptimal ( int N ) { int screen [ ] = new int [ N + 1 ] ; for ( int n = 1 ; n <= 7 ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ; } return screen [ N - 1 ] ; }

static int findoptimal ( int N ) { int screen [ ] = new int [ N ] ; for ( int n = 1 ; n < N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , 2 * screen [ n - 5 ] ) ; screen [ n - 6 ] = Math . max ( 3 * screen [ n - 6 ] , 4 * screen [ n - 7 ] ) ; } return screen [ N - 1 ] ; }

49.38
45.71
30.02
29.8
def sequence ( n ) : f = [ 0 , 1 , 1 ] print ( f [ 1 ] , end = "" ) , print ( f [ 2 ] , end = "" ) , for i in range ( 3 , n + 1 ) : f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) print ( f [ i ] , end = "" ) ,

public static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " " ) ; } }

static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) f . append ( f [ i - f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) ; print ( f [ i - f [ i ] ] + f [ i - f [ i - 1 ] ] ) ; for ( int i = 1 ; i <=

static void sequence ( int n ) { String [ ] f = new String [ n + 1 ] ; System . out . print ( f [ 0 ] ) ; System . out . print ( f [ 1 ] ) ; System . out . print ( f [ 2 ] ) ; System . out . print ( f [ 3 ] ) ; System . out . print ( f [ 4 ] ) ; System . out . print ( f [ 5 ] ) ; System . out . print ( f [ 6 ] ) ; System . out . print ( f [ 7 ] ) ; System . out . print ( f [ 8 ] ) ; System . out . print ( f [ 9 ] ) ; }

49.48
44.47
58.51
42.54
def printSequence ( arr , input ) : n = len ( input ) output = "" for i in range ( n ) : if ( input [ i ] == '' ) : output = output + "0" else : position = ord ( input [ i ] ) - ord ( 'A' ) output = output + arr [ position ] return output

static String printSequence ( String arr [ ] , String input ) { String output = "" ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ' ) output = output + "0" ; else { int position = input . charAt ( i ) - 'A' ; output = output + arr [ position ] ; } } return output ; }

static String printSequence ( int arr [ ] , int input [ ] ) { int n = arr . length ; int i = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == 'a' ) output = output + arr [ position ] ; else output = output + "A" ; else output = output + arr [ position ] ; } return output ; }

static String printSequence ( String arr , String input ) { int n = input . length ( ) ; String output = "" ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == '' ) output = output + "0" ; else output = output + arr [ i ] ; } return output ; }

49.52
44.36
49.95
46.24
def getPairsCount ( arr , n , sum ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if arr [ i ] + arr [ j ] == sum : count += 1 return count

public static void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( "Count of pairs is %d" , count ) ; }

static int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] == sum ) count += 1 ; } } return count ; }

static int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] == sum ) count ++ ; } } return count ; }

49.58
51.29
70.86
68.11
def insertSorted ( arr , n , key , capacity ) : if ( n >= capacity ) : return n i = n - 1 while i >= 0 and arr [ i ] > key : arr [ i + 1 ] = arr [ i ] i -= 1 arr [ i + 1 ] = key return ( n + 1 )

static int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }

static int insertSorted ( int arr [ ] , int key , int capacity ) { int i = n - 1 ; while ( i >= 0 and arr [ i ] > key ) { arr [ i + 1 ] = arr [ i ] i -= 1 } return ( n + 1 ) ; }

private static int insertSorted ( int arr [ ] , int n , int key , int capacity ) { int i = n - 1 ; while ( i >= 0 && arr [ i ] > key ) { arr [ i + 1 ] = arr [ i ] ; i -= 1 ; arr [ i + 1 ] = key ; } return ( n + 1 ) ; }

49.65
54.66
54.87
60.24
def rearrange ( arr , n ) : max_idx = n - 1 min_idx = 0 max_elem = arr [ n - 1 ] + 1 for i in range ( 0 , n ) : if i % 2 == 0 : arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem max_idx -= 1 else : arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem min_idx += 1 for i in range ( 0 , n ) : arr [ i ] = arr [ i ] / max_elem

public static void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }

static void rearrange ( int arr [ ] , int n ) { int min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem max_idx += 1 ; else arr [ i ] += ( arr [ min_idx

private static void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 ; int min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] += arr [ max_idx ] * max_elem ; max_idx -= 1 ; else arr [ i ] += arr [ min_idx ] * max_elem ; min_idx += 1 ; } }

49.71
65.37
26.72
40.1
def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : if ( 0 == n ) : return tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) print ( "Movethedisk" , sourcePole , "from" , sourcePole , "to" , destinationPole ) tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole )

static void tower ( int n , char sourcePole , char destinationPole , char auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; System . out . printf ( "Move the disk %d from %c to %c\n" , n , sourcePole , destinationPole ) ; tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ; }

static int tower ( int n , int sourcePole , int destinationPole , int auxiliaryPole ) { if ( 0 == n ) return tower ( n - 1 , sourcePole , destinationPole , auxiliaryPole ) ; return tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; } return tower ( n - 1 , sourcePole , destinationPole , auxiliaryPole ) ;

static void tower ( int n , int sourcePole , int auxiliaryPole , int destinationPole ) { System . out . print ( "Movethedisk" , sourcePole , "from" , sourcePole , "to" , destinationPole ) ; System . out . print ( "Movethedisk" , auxiliaryPole , "from" , auxiliaryPole , "to" ) ; }

49.73
46.29
51.88
48.12
def seriesSum ( n ) : i = 1 res = 0.0 sign = True while ( n > 0 ) : n = n - 1 if ( sign ) : sign = False res = res + ( i + 1 ) / ( i + 2 ) i = i + 2 else : sign = True res = res - ( i + 1 ) / ( i + 2 ) i = i + 2 return res

static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }

static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; while ( n > 0 ) { n = n - 1 ; if ( sign ) res = res + ( i + 1 ) / ( i + 2 ) i = i + 2 ; else res = res - ( i + 1 ) / ( i + 2 ) i = i + 2 ; } return res ; }

static int seriesSum ( int n ) { int i = 1 ; int res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n = n - 1 ; if ( sign ) { sign = false ; res = res + ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } else { sign = true ; res = res - ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } } return res ; }

49.75
63.95
58.84
73.57
def printDistinct ( arr , n ) : arr . sort ( ) for i in range ( n ) : if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : i += 1 else : print ( arr [ i ] , end = "" )

static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; System . out . print ( arr [ i ] + " " ) ; } }

static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) { while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) { while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) {

static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { while ( i < n - 1 && ( arr [ i ] == arr [ i + 1 ] ) ) { i ++ ; } else { print ( arr [ i ] , end = "" ) ; } } } }

49.82
58.26
64.18
60.77
def find_difference ( arr , n , m ) : max = 0 min = 0 arr . sort ( ) j = n - 1 for i in range ( m ) : min += arr [ i ] max += arr [ j ] j = j - 1 return ( max - min )

static int find_difference ( int arr [ ] , int n , int m ) { int max = 0 , min = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 , j = n - 1 ; i < m ; i ++ , j -- ) { min += arr [ i ] ; max += arr [ j ] ; } return ( max - min ) ; }

static int find_difference ( int arr [ ] , int n , int m ) { int max = 0 ; int min = arr [ n ] ; int max = arr [ m ] ; int j = j - 1 ; for ( int i = 0 ; i < n ; i ++ ) { min += arr [ i ] max += arr [ j ] ; j = j - 1 ; for ( int i = 0 ; i < m ; i ++ ) { max += arr

static int find_difference ( int arr [ ] , int n , int m ) { int max = 0 ; int min = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { max += arr [ i ] ; min += arr [ j ] ; max += arr [ j ] ; j ++ ; } return ( max - min ) / 2 ; }

49.82
50.97
75.87
70.56
def countPairs ( arr1 , arr2 , m , n , x ) : count , l , r = 0 , 0 , n - 1 while ( l < m and r >= 0 ) : if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : l += 1 r -= 1 count += 1 elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : l += 1 else : r -= 1 return count

static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }

static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int count , l , r = 0 , m - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) > x ) { l += 1 r -= 1 ; count += 1 } } return count ; }

static int countPairs ( int arr1 , int arr2 , int m , int n , int x ) { int count = 0 ; int l = 0 ; int r = 0 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) { l ++ ; } else { r ++ ; } } return count ; }

49.85
53.61
66.39
66.36
def printSorted ( a , b , c ) : get_max = max ( a , max ( b , c ) ) get_min = - max ( - a , max ( - b , - c ) ) get_mid = ( a + b + c ) - ( get_max + get_min ) print ( get_min , "" , get_mid , "" , get_max )

static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + " " + get_mid + " " + get_max ) ; }

static void printSorted ( int a , int b , int c ) { int get_max = int ( a , int ( b , c ) ) ; int get_min = int ( a , int ( b , c ) ) - ( get_min + get_max ) ; int get_mid = ( a + b + c ) - ( get_min + get_max ) ; print ( get_min , "" , get_mid , "" , get_

static void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; print ( get_min , "" , get_mid , "" , get_max ) ; }

49.86
47.01
61.48
53.12
def recaman ( n ) : arr = [ 0 ] * n arr [ 0 ] = 0 print ( arr [ 0 ] , end = "," ) for i in range ( 1 , n ) : curr = arr [ i - 1 ] - i for j in range ( 0 , i ) : if ( ( arr [ j ] == curr ) or curr < 0 ) : curr = arr [ i - 1 ] + i break arr [ i ] = curr print ( arr [ i ] , end = "," )

static void recaman ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " ," ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + ", " ) ; } }

static void recaman ( int n ) { int arr [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { int curr = arr [ i - 1 ] + i ; for ( int j = 0 ; j < i ; j ++ ) if ( ( arr [ j ] == 0 ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; } } return arr ; }

static void recaman ( int n ) { int arr [ ] [ ] = new int [ n ] ; int [ ] curr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { curr = arr [ i - 1 ] - i for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i break ; } arr [ i ] = curr ; } } }

49.86
53.09
58.03
66.31
def check_duck ( num ) : l = len ( num ) count_zero = 0 i = 1 while i < l : ch = num [ i ] if ( ch == "0" ) : count_zero = count_zero + 1 i = i + 1 return count_zero

static int check_duck ( String num ) { int len = num . length ( ) ; int count_zero = 0 ; char ch ; for ( int i = 1 ; i < len ; i ++ ) { ch = num . charAt ( i ) ; if ( ch == '0' ) count_zero ++ ; } return count_zero ; }

static int check_duck ( String num ) { int l = num . length ( ) ; int count_zero = 0 ; while ( i < l ) { String ch = num [ i ] if ( ch == "1" ) count_zero = count_zero + 1 ; i = i + 1 ; } return count_zero ; } return 0 ; }

static int check_duck ( String num ) { int l = num . length ( ) ; int count_zero = 0 ; int i = 1 ; while ( i < l ) { ch = num [ i ] ; if ( ch == "0" ) { count_zero = count_zero + 1 ; i ++ ; } } return count_zero ; }

49.89
44.68
49.64
50.03
def findArea ( arr , n ) : s = [ ] first = 0 second = 0 for i in range ( n ) : if arr [ i ] not in s : s . append ( arr [ i ] ) continue if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] return ( first * second )

static int findArea ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }

static int findArea ( int arr [ ] , int n ) { int s [ ] = [ ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < first ) first = arr [ i ] else if ( arr [ i ] > second ) second = first ; else if ( arr [ i ] > second ) second = arr [ i ] ; if ( arr [ i ] > second ) first = second ;

static int findArea ( int arr [ ] , int n ) { int first = 0 ; int second = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != null ) { if ( arr [ i ] > first ) first = arr [ i ] ; if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; else if ( arr [ i ] > first ) first = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; } } return ( first * second ) ; }

50.13
49.63
69.68
72.03
def solve ( i , par , a , n , k , current_ans ) : if ( par > k ) : return 0 global ans if ( par == k and i == n - 1 ) : ans = min ( ans , current_ans ) return 0 for j in range ( i + 1 , n ) : solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) )

static void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }

static int solve ( int i , int par , int a [ ] , int n , int k ) { int ans = current_ans ; for ( int j = i ; j < n ; j ++ ) { if ( a [ j ] > a [ i + 1 ] ) { ans = min ( ans , current_ans + ( a [ j ] - a [ i ] ) * ( a [ j ] - a [ i ] ) * ( a [ j ] -

static int solve ( int i , int par , int a , int n , int k , int current_ans ) { if ( par == k ) { if ( i == n - 1 ) { ans = min ( ans , current_ans ) ; return 0 ; } if ( i == n - 1 ) { ans = min ( ans , current_ans ) ; return 0 ; } for ( int j = i + 1 ; j < n ; j ++ ) { solve ( j , par , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; } } return 0 ; }

50.15
47.26
69.35
76.08
def isDivisibleBy7 ( num ) : if num < 0 : return isDivisibleBy7 ( - num ) if ( num == 0 or num == 7 ) : return True if ( num < 10 ) : return False return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) )

static boolean isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ) ; if ( num == 0 || num == 7 ) return true ; if ( num < 10 ) return false ; return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ; }

static boolean isDivisibleBy7 ( int num ) { if ( num == 0 ) return false ; return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) ) ; } return isDivisibleBy7 ( num ) ; }

static boolean isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ) ; if ( num == 0 || num == 7 ) return true ; if ( num < 10 ) return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) ) ; return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) ) ; }

50.2
63.96
63.06
46.39
def check ( n ) : return 1162261467 % n == 0

static boolean check ( int n ) { return 1162261467 % n == 0 ; }

static boolean check ( int n ) { return n

static boolean check ( int n ) { return 1162261467 ; }

50.25
46.83
55.59
60.0
def rearrange ( a , size ) : positive = 0 negative = 1 while ( True ) : while ( positive < size and a [ positive ] >= 0 ) : positive = positive + 2 while ( negative < size and a [ negative ] <= 0 ) : negative = negative + 2 if ( positive < size and negative < size ) : temp = a [ positive ] a [ positive ] = a [ negative ] a [ negative ] = temp else : break

static void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }

static void rearrange ( int [ ] a , int size ) { int positive = 0 ; int negative = 0 ; int temp = 0 ; while ( positive < size ) { positive = positive + 2 while ( negative < size ) { negative = negative + 2 } if ( positive < size ) { temp = a [ positive ] a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } } return ; }

static void rearrange ( int a [ ] , int size ) { int positive = 0 ; int negative = 0 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) { positive = positive + 2 ; while ( negative < size && a [ negative ] <= 0 ) { negative = negative + 2 ; if ( positive < size && a [ positive ] == a [ negative ] ) a [ positive ] = a [ negative ] ; } else if ( positive < size && a [ negative ] == a [ positive ] ) a [ positive ] = a [ negative ] ; else a [ negative ] = a [ positive ] ; } } }

50.5
49.91
55.71
59.25
def findDiff ( arr , n ) : arr . sort ( ) count = 0 max_count = 0 min_count = n for i in range ( 0 , ( n - 1 ) ) : if arr [ i ] == arr [ i + 1 ] : count += 1 continue else : max_count = max ( max_count , count ) min_count = min ( min_count , count ) count = 0 return max_count - min_count

static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }

static int findDiff ( int arr [ ] , int n ) { int count = 0 ; int max_count = arr . length ; int min_count = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { max_count = max ( max_count , count ) min_count = min ( min_count , count ) ;

static int findDiff ( int arr [ ] , int n ) { int count = 0 ; int max_count = 0 ; int min_count = n ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else if ( arr [ i ] == arr [ i + 1 ] ) max_count = max ( max_count , count ) min_count = min ( min_count , count ) ; } return max_count - min_count ; }

50.51
43.38
87.78
85.07
def findHeight ( parent , n ) : res = 0 for i in range ( n ) : p = i current = 1 while ( parent [ p ] != - 1 ) : current += 1 p = parent [ p ] res = max ( res , current ) return res

static int findHeight ( int [ ] parent , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i , current = 1 ; while ( parent [ p ] != - 1 ) { current ++ ; p = parent [ p ] ; } res = Math . max ( res , current ) ; } return res ; }

static int findHeight ( int parent [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 1 ; while ( p != - 1 ) { current += 1 ; } } return res ; }

static int findHeight ( int parent [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i ; int current = 1 ; while ( parent [ p ] != - 1 ) { current ++ ; p = parent [ p ] ; } res = max ( res , current ) ; } return res ; }

50.51
52.5
60.81
67.77
def getMissingNo ( a , n ) : x1 = a [ 0 ] x2 = 1 for i in range ( 1 , n ) : x1 = x1 ^ a [ i ] for i in range ( 2 , n + 2 ) : x2 = x2 ^ i return x1 ^ x2

static int getMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }

static int getMissingNo ( int [ ] a , int n ) { int x1 = 0 ; int x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x1 = x1 ^ a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { x2 = x2 ^ a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { x1 = x

static int getMissingNo ( int [ ] a , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x1 = x1 ^ a [ i ] ; x2 = x2 ^ a [ i ] ; } return x1 ^ x2 ; }

50.52
59.68
88.02
77.82
def printKDistinct ( arr , n , k ) : dist_count = 0 for i in range ( n ) : j = 0 while j < n : if ( i != j and arr [ j ] == arr [ i ] ) : break j += 1 if ( j == n ) : dist_count += 1 if ( dist_count == k ) : return arr [ i ] return - 1

static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }

static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == j ) dist_count += 1 if ( dist_count == k ) return arr [ i ] ; } } return - 1 ; }

static int printKDistinct ( int arr [ ] , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; while ( j < n ; j ++ ) { if ( i != j && arr [ j ] == arr [ i ] ) break ; j ++ ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } } return - 1 ; }

50.57
55.72
63.8
70.76
def survival ( S , N , M ) : if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : print ( "No" ) else : days = ( M * S ) / N if ( ( ( M * S ) % N ) != 0 ) : days += 1 print ( "Yes" ) , print ( days )

static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( "No" ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( "Yes " + days ) ; } }

static void survival ( int S , int N , int M ) { int days ; if ( S > 6 ) { print ( "Yes" ) , print ( S ) ; } else { days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) { days += 1 ; print ( "Yes" ) , print ( days ) ; } } }

static void survival ( int S , int M ) { int days = ( M * S ) / N ; if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || ( M > N ) ) { print ( "No" ) ; } else { days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) { days += 1 ; print ( "Yes" ) , print ( days ) ; } } }

50.57
75.12
70.85
83.61
def swap ( xp , yp ) : xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]

static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }

static void swap ( int xp [ ] , int yp [ ] ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = yp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = yp [ 0 ] ^ xp [ 0 ] ; }

static void swap ( int xp [ ] , int yp [ ] ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }

50.58
48.11
51.31
49.2
def longestSubseqWithK ( str , k ) : n = len ( str ) freq = [ 0 ] * MAX_CHARS for i in range ( n ) : freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) : print ( str [ i ] , end = "" )

static void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int freq [ ] = new int [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - 'a' ] >= k ) { System . out . print ( str . charAt ( i ) ) ; } } }

static void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int freq [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) { print ( str [ i ] , end = "" ) ; } else { print ( str [ i ] , end = "" ) ; } }

static void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int freq [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) { print ( str [ i ] , end = "" ) ; } } }

50.6
55.2
64.91
62.11
def zigzag ( n , k ) : dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , n + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) return dp [ n ] [ k ]

static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }

static int zigzag ( int n , int k ) { int [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) / 2 ; } return

static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j - 1 ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) ; } } return dp [ n ] [ k ] ; }

50.63
53.39
73.37
73.49
def maxLevel ( boxes , n ) : boxes . sort ( ) ans = 1 prev_width = boxes [ 0 ] prev_count = 1 curr_count = 0 curr_width = 0 for i in range ( 1 , n ) : curr_width += boxes [ i ] curr_count += 1 if ( curr_width > prev_width and curr_count > prev_count ) : prev_width = curr_width prev_count = curr_count curr_count = 0 curr_width = 0 ans += 1 return ans

static int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int ans = 1 ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }

static int maxLevel ( int [ ] boxes , int n ) { int ans = 0 ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( curr_width > prev_width and curr_count > prev_count ) { prev_width = curr_width prev_count = curr_count

static int maxLevel ( int boxes [ ] , int n ) { int ans = 1 ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width prev_count = curr_count ; curr_count = 0 ; } } return ans ; }

50.67
45.14
74.92
67.97
def computeLPSArray ( pat , M , lps ) : len = 0 lps [ 0 ] i = 1 while i < M : if pat [ i ] == pat [ len ] : len += 1 lps [ i ] = len i += 1 else : if len != 0 : len = lps [ len - 1 ] else : lps [ i ] = 0 i += 1

void computeLPSArray ( String pat , int M , int lps [ ] ) { int len = 0 ; int i = 1 ; lps [ 0 ] = 0 ; while ( i < M ) { if ( pat . charAt ( i ) == pat . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = len ; i ++ ; } } } }

static void computeLPSArray ( int pat [ ] , int M , int [ ] lps ) { int len = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) len = lps [ len - 1 ] ; else lps [ i ] = 0 ; i ++ ; } } while ( i < M ) { if ( len != 0 ) len = lps [ len - 1 ] ;

static void computeLPSArray ( String pat [ ] , int M , int lps [ ] ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else lps [ i ] = 0 ; i ++ ; } } }

50.75
47.83
76.11
67.5
def minDist ( arr , n , x , y ) : min_dist = 99999999 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) : min_dist = abs ( i - j ) return min_dist

int minDist ( int arr [ ] , int n , int x , int y ) { int i , j ; int min_dist = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) min_dist = Math . abs ( i - j ) ; } } return min_dist ; }

static int minDist ( int arr [ ] , int n , int x , int y ) { int min_dist = 99999999 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) if ( x == arr [ i ] and y == arr [ j ] ) min_dist = abs ( i - j ) ; } return min_dist ; } return min_dist ; }

static int minDist ( int arr [ ] , int n , int x , int y ) { int min_dist = 99999999 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) { min_dist = abs ( i - j ) ; if ( min_dist > abs ( i - j ) ) min_dist = abs ( i - j ) ; } } } return min_dist ; }

50.78
54.53
65.29
56.16
def maxProfit ( price , n , k ) : profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] for i in range ( 1 , k + 1 ) : prevDiff = float ( '-inf' ) for j in range ( 1 , n ) : prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) return profit [ k ] [ n - 1 ]

static int maxProfit ( int price [ ] , int n , int k ) { int profit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }

static int maxProfit ( int price [ ] , int n , int k ) { int [ ] profit = new int [ n + 1 ] [ k + 1 ] [ n ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( profit [ i ] [ j ] > price [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j ] + prevDiff ) return profit [ i ] [ j - 1 ] ; } } return profit [ k ] [ n - 1 ] [ k ] ; } }

static int maxProfit ( float [ ] price , int n , int k ) { int profit [ ] [ ] = new int [ n ] [ k ] ; for ( int i = 1 ; i < n ; i ++ ) { int prevDiff = float ( '-inf' ) ; for ( int j = 1 ; j < k ; j ++ ) { prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j - 1 ] , price [ j - 1 ] + prevDiff ) ; profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }

50.9
71.68
90.92
88.93
def evenFib ( n ) : if ( n < 1 ) : return n if ( n == 1 ) : return 2 return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )

static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }

static int evenFib ( int n ) { if ( n < 2 ) return ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; return ( 2 * evenFib ( n - 2 ) ) + evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }

static int evenFib ( int n ) { if ( n < 1 ) return 1 ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }

50.9
54.22
52.16
52.74
def nonDecNums ( n ) : a = np . zeros ( ( n + 1 , 10 ) ) for i in range ( 10 ) : a [ 0 ] [ i ] = 1 for i in range ( 1 , n + 1 ) : a [ i ] [ 9 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( 8 , - 1 , - 1 ) : a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] return int ( a [ n ] [ 0 ] )

static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }

static int nonDecNums ( int n ) { int a [ ] = new int [ n + 1 ] [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; } return int ( a [ n ] [ 0 ] + a [ n

static int nonDecNums ( int n ) { int a [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; } return int ( a [ n ] [ 0 ] ) ; } }

50.95
57.73
86.86
86.83
def countPairsWithDiffK ( arr , n , k ) : count = 0 arr . sort ( ) l = 0 r = 0 while r < n : if arr [ r ] - arr [ l ] == k : count += 1 l += 1 r += 1 elif arr [ r ] - arr [ l ] > k : l += 1 else : r += 1 return count

static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }

static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; int l = 0 ; int r = 0 ; while ( l < n ) { if ( arr [ r ] - arr [ l ] == k ) count += 1 l += 1 else : r += 1 } return count ; }

static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l += 1 ; r += 1 ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }

51.06
44.39
38.77
51.08
def rearrange ( arr , n ) : temp = n * [ None ] small , large = 0 , n - 1 flag = True for i in range ( n ) : if flag is True : temp [ i ] = arr [ large ] large -= 1 else : temp [ i ] = arr [ small ] small += 1 flag = bool ( 1 - flag ) for i in range ( n ) : arr [ i ] = temp [ i ] return arr

static void rearrange ( int [ ] arr , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } arr = temp . clone ( ) ; }

static void rearrange ( int arr [ ] , int n ) { int small , large ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag is True ) temp [ i ] = arr [ small ] ; small -= 1 ; else temp [ i ] = arr [ large ] ; large += 1 ; } flag = false ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ small ] ; } }

public static int rearrange ( int arr [ ] , int n ) { int [ ] temp = new int [ n ] ; int small = 0 , n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag is true ) { temp [ i ] = arr [ small ] ; small -- ; } else { temp [ i ] = arr [ small ] ; small ++ ; } flag = bool ( 1 - flag ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; } flag = bool ( 1 - flag ) ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } return arr ; }

51.1
59.02
49.81
63.31
def count ( a , b , m , n ) : if ( ( m == 0 and n == 0 ) or n == 0 ) : return 1 if ( m == 0 ) : return 0 if ( a [ m - 1 ] == b [ n - 1 ] ) : return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) else : return count ( a , b , m - 1 , n )

static int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }

static int count ( int [ ] a , int [ ] b , int m , int n ) { if ( a [ m - 1 ] == b [ n - 1 ] ) { return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) + count ( a , b , m - 1 , n ) + count ( a , b

static int count ( int a , int b , int m , int n ) { if ( a [ m - 1 ] == b [ n - 1 ] ) return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n - 1 ) ) ; else if ( a [ m - 1 ] == b [ n - 1 ] ) return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n - 1 ) ) ; else return count ( a , b , m - 1 , n ) ; }

51.12
53.93
51.12
53.93
def search ( arr , x ) : n = len ( arr ) for j in range ( 0 , n ) : if ( x == arr [ j ] ) : return j return - 1

static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int j = 0 ; j < n ; j ++ ) { if ( x == arr [ j ] ) return j ; } return - 1 ; }

static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int j = 0 ; j < n ; j ++ ) { if ( x == arr [ j ] ) return j ; } return - 1 ; }

51.13
52.49
62.59
59.0
def maxRepeating ( str ) : l = len ( str ) count = 0 res = str [ 0 ] for i in range ( l ) : cur_count = 1 for j in range ( i + 1 , l ) : if ( str [ i ] != str [ j ] ) : break cur_count += 1 if cur_count > count : count = cur_count res = str [ i ] return res

static char maxRepeating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } } return res ; }

static int maxRepeating ( String str ) { int l = str . length ( ) ; int count = 0 ; String res = str [ 0 ] ; for ( int i = 1 ; i < l ; i ++ ) { int cur_count = 1 ; for ( int j = i ; j < l ; j ++ ) { if ( str [ i ] != str [ j ] ) { count = cur_count ; res = str [ i ] ; } } return res ; }

static int maxRepeating ( String str ) { int l = str . length ( ) ; int count = 0 ; res = str . length ; for ( int i = 0 ; i < l ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < l ; j ++ ) { if ( str [ i ] != str [ j ] ) { break ; } cur_count ++ ; if ( cur_count > count ) count = cur_count ; res = str [ i ] ; } } return res ; }

51.15
47.53
80.11
84.64
def findnumberofTriangles ( arr ) : n = len ( arr ) arr . sort ( ) count = 0 for i in range ( 0 , n - 2 ) : k = i + 2 for j in range ( i + 1 , n ) : while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : k += 1 if ( k > j ) : count += k - j - 1 return count

static int findNumberOfTriangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; }

static int findnumberofTriangles ( int arr [ ] ) { int count = 0 ; int i = 0 ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] > arr [ k ] ) { count += k - j - 1 ; if ( k > j ) { count += k - j -

static int findnumberofTriangles ( int arr [ ] ) { int n = arr . length ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) { k ++ ; if ( k > j ) count += k - j - 1 ; } } } return count ; }

51.17
51.26
47.55
50.28
def isPossible ( a , b , n , k ) : a . sort ( reverse = True ) b . sort ( ) for i in range ( n ) : if ( a [ i ] + b [ i ] < k ) : return False return True

static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }

static boolean isPossible ( int a [ ] , int b [ ] , int k ) { int i = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] + b [ i ] > k ) { return false } } return true }

public static boolean isPossible ( int a [ ] , int b [ ] , int k ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( ! isPossible ( a [ i ] , b [ i ] , k ) ) return false ; } return true ; }

51.21
48.43
66.86
57.53
def findMaxValue ( mat ) : maxValue = 0 for a in range ( N - 1 ) : for b in range ( N - 1 ) : for d in range ( a + 1 , N ) : for e in range ( b + 1 , N ) : if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; return maxValue ;

static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }

static int findMaxValue ( int [ ] [ ] mat , int N ) { int maxValue = 0 ; for ( int a = 0 ; a < N ; a ++ ) { for ( int b = 0 ; b < N ; b ++ ) { if ( maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) { maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; maxValue =

static int findMaxValue ( int [ ] mat ) { int maxValue = 0 ; for ( int a = 0 ; a < N ; a ++ ) { for ( int b = 0 ; b < N ; b ++ ) { for ( int d = 0 ; d < N ; d ++ ) { for ( int e = 0 ; e < N ; e ++ ) { if ( maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) { maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; } } } } return maxValue ; }

51.21
57.68
52.06
60.51
def freq ( ar , m , n ) : even = 0 odd = 0 for i in range ( m ) : for j in range ( n ) : if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : even += 1 else : odd += 1 print ( "Frequencyofoddnumber=" , odd ) print ( "Frequencyofevennumber=" , even )

static void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( " Frequency of odd number =" + odd + " \n" ) ; System . out . print ( " Frequency of even number = " + even + " \n" ) ; }

static void freq ( int [ ] ar [ ] [ ] , int m , int n ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) even += 1 ; else odd += 1 ; } } return ; }

static void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) { even ++ ; } else { even ++ ; } } } }

51.25
70.92
73.84
77.43
def isPossibleTriangle ( arr , N ) : if N < 3 : return False arr . sort ( ) for i in range ( N - 2 ) : if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] : return True

static boolean isPossibleTriangle ( int [ ] arr , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }

static boolean isPossibleTriangle ( int arr [ ] , int N ) { if ( arr [ 0 ] + arr [ 1 ] > arr [ 2 ] ) return false ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] + arr [

static boolean isPossibleTriangle ( int arr [ ] , int N ) { if ( N < 3 ) return false ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; } return false ; }

51.32
62.94
81.02
83.56
def countStr ( n ) : return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) )

static int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }

static int countStr ( int n ) { int n = int . valueOf ( n ) ; return ( 1 + ( n * n ) + ( n * n ) ) / 2 ; }

static int countStr ( int n ) { return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) ; }

51.34
51.17
83.35
83.65
def countSeq ( n ) : nCr = 1 res = 1 for r in range ( 1 , n + 1 ) : nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; return res ;

static int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }

static int countSeq ( int n ) { int res = 0 ; for ( int r = 1 ; r <= n ; r ++ ) { res += nCr * nCr ; } return res ; }

static int countSeq ( int n ) { int nCr = 1 ; int res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = nCr * ( n + 1 - r ) ; res += nCr * nCr ; } return res ; }

51.38
51.77
59.76
65.04
def swapUpperToLower ( arr ) : n = 4 ; for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; for i in range ( 0 , n ) : for j in range ( 0 , n ) : print ( arr [ i ] [ j ] , end = "" ) ; print ( "" ) ;

static void swapUpperToLower ( int arr [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }

static void swapUpperToLower ( int [ ] arr ) { int i = 0 ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = arr [ j ] [ i ] ; } for ( int j = 0 ; j < n ; j ++ ) { if

static void swapUpperToLower ( int arr [ ] [ ] ) { int n = 4 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = arr [ j ] [ i ] ; } } }

51.45
46.08
62.02
56.37
def countPaths ( maze ) : if ( maze [ 0 ] [ 0 ] == - 1 ) : return 0 for i in range ( R ) : if ( maze [ i ] [ 0 ] == 0 ) : maze [ i ] [ 0 ] = 1 else : break for i in range ( 1 , C , 1 ) : if ( maze [ 0 ] [ i ] == 0 ) : maze [ 0 ] [ i ] = 1 else : break for i in range ( 1 , R , 1 ) : for j in range ( 1 , C , 1 ) : if ( maze [ i ] [ j ] == - 1 ) : continue if ( maze [ i - 1 ] [ j ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) if ( maze [ i ] [ j - 1 ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : return maze [ R - 1 ] [ C - 1 ] else : return 0

static int countPaths ( int maze [ ] [ ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; }

static int countPaths ( int [ ] maze [ ] [ ] ) { for ( int i = 1 ; i <= R ; i ++ ) { if ( maze [ i ] [ 0 ] > 0 ) { maze [ i ] [ 0 ] = ( maze [ i ] [ 0 ] + maze [ i ] [ 0 ] ) ; if ( maze [ i ] [ 0 ] > 0 ) { maze [ i ] [ 0 ] = ( maze [ i ] [ 0 ] + maze [ i ] [ 0 ] ) { for ( int i = 1 ; i <= C ; i ++ ) { if ( maze [ i ] [ j ] > 0 ) { if ( maze [ i ] [ j ] + maze [ i ] [ j ] ) ; if ( maze [ i ] [ j ] > 0 ) { maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j ] + maze [ i ] [ j ] + maze [ i ] [ j ] + maze [ i ] [ j ]

static int countPaths ( int [ ] maze ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue if ( maze [ i ] [ j ] == - 1 ) continue if ( maze [ i ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; if ( maze [ i ] [ j - 1 ]

51.46
58.65
36.31
34.63
def myCopy ( s1 , s2 ) : for i in range ( len ( s1 ) ) : s2 [ i ] = s1 [ i ]

static void myCopy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }

static void myCopy ( int [ ] s1 , int [ ] s2 ) { for ( int i = 0 ; i < len ( s1 ) ; i ++ ) { s2 [ i ] = s1 [ i ] ; } }

; for ( int i ; i < s1 . length ; i ++ ) { s2 [ i ] = new int [ s1 . length ] ; System . arraycopy ( s1 , 0 , s2 , 0 , s1 . length ) ; } }

51.58
55.12
69.3
51.25
def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x start = 1 end = x while ( start <= end ) : mid = ( start + end ) // 2 if ( mid * mid == x ) : return mid if ( mid * mid < x ) : start = mid + 1 ans = mid else : end = mid - 1 return ans

public static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; }

static int floorSqrt ( int x ) { int start = 0 ; int end = x - 1 ; int ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid > x ) { start = mid + 1 ; ans = mid ; } } return - 1 ; }

static int floorSqrt ( int x ) { int start = 1 ; int end = x ; while ( start <= end ) { int mid = ( start + end ) // 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) start = mid + 1 ; ans = mid ; } else end = mid - 1 ; return ans ; }

51.59
54.45
100.0
100.0
def PowerOFPINnfactorial ( n , p ) : ans = 0 temp = p while ( temp <= n ) : ans += n / temp temp = temp * p return int ( ans )

static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }

static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; while ( temp <= n ) ans += n / temp ; }

static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }

51.61
59.82
70.91
72.55
def search ( arr , l , h , key ) : if l > h : return - 1 mid = ( l + h ) // 2 if arr [ mid ] == key : return mid if arr [ l ] <= arr [ mid ] : if key >= arr [ l ] and key <= arr [ mid ] : return search ( arr , l , mid - 1 , key ) return search ( arr , mid + 1 , h , key ) if key >= arr [ mid ] and key <= arr [ h ] : return search ( a , mid + 1 , h , key ) return search ( arr , l , mid - 1 , key )

static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }

static int search ( int arr [ ] , int l , int h , int key ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= key ) return search ( arr , mid + 1 , h , key ) ; if ( key >= arr [ l ] and key <= arr [ h ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; }

static int search ( int arr [ ] , int l , int h , int key ) { if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; } return - 1 ; }

51.62
58.42
38.81
44.11
def solve ( dp , a , low , high , turn ) : if ( low == high ) : return a [ low ] * turn if ( dp [ low ] [ high ] != 0 ) : return dp [ low ] [ high ] dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ]

static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) { return a [ low ] * turn ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }

static double solve ( double [ ] dp , double [ ] a , int low , int high , double turn ) { if ( dp [ low ] [ high ] == 0 ) return dp [ low ] [ high ] ; dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high - 1 , turn ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn

public static int solve ( int dp [ ] [ ] , int low , int high , int turn ) { if ( low == high ) return dp [ low ] [ high ] ; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ; if ( dp [ low ] [ high ] == 0 ) return dp [ low ] [ high ] ; if ( dp [ low ] [ high ] == 0 ) return dp [ low ] [ high ] ; if ( dp [ low ] [ high ] == 0 ) return dp [ low ] [ high ] ; if ( dp [ low ] [ high ] == 0 ) return dp [ low ] [ high ] ; if ( dp [ low ] [ high ] == 0 ) return dp [ low ] [ high ] ; return dp [ low ] [ high ] ; }

51.64
55.09
56.4
58.28
def alternateSubarray ( arr , n ) : count = 1 prev = arr [ 0 ] for i in range ( 1 , n ) : if ( ( arr [ i ] ^ prev ) == 0 ) : while ( count ) : print ( count , end = "" ) count -= 1 count += 1 prev = arr [ i ] while ( count ) : print ( count , end = "" ) count -= 1

static void alternateSubarray ( boolean arr [ ] , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { System . out . print ( count -- + " " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + " " ) ; } }

static void alternateSubarray ( int arr [ ] , int n ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( arr [ i ] ^ prev ) == 0 ) { while ( count ) { print ( count , end = "" ) count -= 1 ; prev = arr [ i ] ; while ( count ) { print ( count , end = "" ) count += 1 prev =

static void alternateSubarray ( int arr [ ] , int n ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] ^ prev ) == 0 ) { while ( count ) { print ( count , end = "" ) count -= 1 ; count += 1 prev = arr [ i ] ; while ( count ) { print ( count , end = "" ) count -= 1 ; prev = arr [ i ] ; } } } } }

51.64
48.81
0.0
3.2
def getMinSteps ( n ) : table = [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) : table [ i ] = n - i for i in range ( n , 0 , - 1 ) : if ( not ( i % 2 ) ) : table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) if ( not ( i % 3 ) ) : table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) return table [ 1 ]

static int getMinSteps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ;

static int getMinSteps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) table [ i ] = min ( table [ i ] + 1 , table [ i // 2 ] ) ; if ( ! ( i % 3 ) ) table [ i ] = min ( table [ i ] + 1 , table [ i // 3 ] ) ; if (

* ( n + 1 ) ; }

51.79
51.17
41.43
44.81
def binarySearch ( arr , low , high ) : if high >= low : mid = ( low + high ) // 2 if mid is arr [ mid ] : return mid if mid > arr [ mid ] : return binarySearch ( arr , ( mid + 1 ) , high ) else : return binarySearch ( arr , low , ( mid - 1 ) ) return - 1

static int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }

static int binarySearch ( int arr [ ] , int low , int high ) { int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( mid > arr [ mid ] ) return mid ; if ( mid < arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return mid ; if (

; } static int binarySearch ( int arr , int low , int high ) { if ( high >= low ) return binarySearch ( arr , low , high ) ; if ( high >= low ) return binarySearch ( arr , low , high ) ; if ( high >= low ) return binarySearch ( arr , low , high ) ; return - 1 ; }

51.83
52.83
53.5
55.34
def arrayEvenAndOdd ( arr , n ) : i = - 1 j = 0 while ( j != n ) : if ( arr [ j ] % 2 == 0 ) : i = i + 1 arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] j = j + 1 for i in arr : print ( str ( i ) + "" , end = '' )

static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) System . out . print ( arr [ k ] + " " ) ; }

static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 ; int j = 0 ; while ( i != n ) { if ( arr [ i ] % 2 == 0 ) { i = i + 1 ; arr [ j ] = arr [ j ] , arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] , arr [ j ] ; } } return ; }

static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j != n ; j ++ ) { if ( arr [ j ] % 2 == 0 ) { i = i + 1 ; arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] ; arr [ j ] = arr [ j ] , arr [ i ] ; } } }

51.95
64.97
59.31
66.03
def minDaysToEmpty ( C , l ) : if ( l >= C ) : return C eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 return math . ceil ( eq_root ) + l

static int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_root ) + l ) ; }

static int minDaysToEmpty ( int C , int l ) { int eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ) ; return eq_root ; }  static int minDaysToEmpty ( int C , int l ) { int eq_root = ( math . ceil ( eq_root ) - 1 ) / 2 ) ; }

static int minDaysToEmpty ( int C , int l ) { int eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return math . ceil ( eq_root ) + l ; }

51.98
64.11
51.15
63.79
def evenbinomialCoeffSum ( n ) : return ( 1 << ( n - 1 ) )

static int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }

static int evenbinomialCoeffSum ( int n ) { return 1 << n - 1 }

static int evenbinomialCoeffSum ( int n ) { return evenbinomialCoeffSum ( n ) ; }

51.99
52.94
70.51
76.68
def minimumflip ( mat , n ) : transpose = [ [ 0 ] * n ] * n for i in range ( n ) : for j in range ( n ) : transpose [ i ] [ j ] = mat [ j ] [ i ] flip = 0 for i in range ( n ) : for j in range ( n ) : if transpose [ i ] [ j ] != mat [ i ] [ j ] : flip += 1 return int ( flip / 2 )

static int minimumflip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }

static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ j ] != 0 ) flip += 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( transpose [ i ] [ j ] != 0 ) flip += 1 ; for ( int i = 0 ; i < n ; i ++ ) {

static int minimumflip ( int [ ] mat , int n ) { int [ ] transpose = new int [ n ] * n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) { transpose [ i ] [ j ] = mat [ i ] [ j ] ; } } } } return - 1 ; }

52.1
60.23
77.84
56.27
def compute_average ( a , b ) : return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 )

static int compute_average ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }

static int compute_average ( int a , int b ) { int average = ( a % 2 + b % 2 ) / 2 ; return average ; }

static int compute_average ( int a , int b ) { return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) ; }

52.13
56.49
49.09
59.9
def maxPrefix ( s , t ) : count = 0 for i in range ( 0 , len ( t ) ) : if ( count == len ( s ) ) : break if ( t [ i ] == s [ count ] ) : count = count + 1 return count

static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == t . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }

static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( t [ i ] == s [ count ] ) { count = count + 1 ; } } return count ; }

static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( count == 0 ) break ; if ( t [ i ] == s [ count ] ) { count = count + 1 ; break ; } if ( t [ i ] == s [ count ] ) { count = count + 1 ; } } return count ; }

52.19
53.6
61.96
64.97
def largestKSubmatrix ( a ) : dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] result = 0 for i in range ( Row ) : for j in range ( Col ) : if ( i == 0 or j == 0 ) : dp [ i ] [ j ] = 1 else : if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 else : dp [ i ] [ j ] = 1 result = max ( result , dp [ i ] [ j ] ) return result

static int largestKSubmatrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }

static int largestKSubmatrix ( int [ ] a , int Row , int Col ) { int [ ] dp = new int [ Row ] [ Col ] ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] , dp [ i ] [ j - 1 ] , dp [ i ] [ j - 1 ] [ j - 1 ] [ j ] ; } } return result ; } } for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( a [ i ] [ j ] == a [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - 1 ] [ j - 1 ] , dp [ i ] [ j ] , dp [ i ] [ j ] ) ; } } return result ; } return result ; } } return result ; } } } } for ( int i =

static int largestKSubmatrix ( int [ ] a , int Row , int Col ) { int dp [ ] [ ] = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ] [ j ] = 1 ; } else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i ] [ j - 1 ] ) + 1 ; } else { dp [ i ] [ j ] = 1 ; } } result = max ( result , dp [ i ] [ j ] ) ; } } return

52.2
58.15
55.31
54.73
def maxcoefficientvalue ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n + 1 ) : for j in range ( min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) maxvalue = 0 for i in range ( n + 1 ) : maxvalue = max ( maxvalue , C [ n ] [ i ] ) return maxvalue

static int maxcoefficientvalue ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }

static int maxcoefficientvalue ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] [ n + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == i ) C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i ] [ j ] ) ; } } return maxvalue ; }

static int maxcoefficientvalue ( int n ) { int C [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 or j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } maxvalue = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 or j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } return maxvalue ; }

52.22
52.43
70.52
77.13
def countDer ( n ) : der = [ 0 for i in range ( n + 1 ) ] der [ 0 ] = 1 der [ 1 ] = 0 der [ 2 ] = 1 for i in range ( 3 , n + 1 ) : der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) return der [ n ]

static int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }

static int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { der [ i ] = der [ i - 1 ] + der [ i - 2 ] ; } return der [ n ] ; }

static int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { der [ i ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; } return der [ n ] ; } }

52.31
63.68
69.23
77.7
def diagonalsquare ( mat , row , column ) : print ( "Diagonalone:" , end = "" ) for i in range ( 0 , row ) : print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = "" ) print ( "\n\nDiagonaltwo:" , end = "" ) for i in range ( 0 , row ) : print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = "" )

static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( " Diagonal one : " ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " ) ; } System . out . println ( ) ; System . out . print ( " Diagonal two : " ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " ) ; } }

static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( "Diagonal one : " ) ; for ( int i = 0 ; i < row ; i ++ ) System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " ) ; System . out . print ( mat [ i ] [ row - i -

static void diagonalsquare ( int [ ] mat , int row , int column ) { System . out . print ( "Diagonal one" ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] ) ; System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] ) ; } System . out . print ( "Diagonal two" ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] ) ; } }

52.31
60.24
68.84
73.13
def isChangeable ( notes , n ) : fiveCount = 0 tenCount = 0 for i in range ( n ) : if ( notes [ i ] == 5 ) : fiveCount += 1 elif ( notes [ i ] == 10 ) : if ( fiveCount > 0 ) : fiveCount -= 1 tenCount += 1 else : return 0 else : if ( fiveCount > 0 and tenCount > 0 ) : fiveCount -= 1 tenCount -= 1 elif ( fiveCount >= 3 ) : fiveCount -= 3 else : return 0 return 1

static int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }

static int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) tenCount += 1 ; else if ( notes [ i ] == 10 ) { if ( tenCount > 0 ) tenCount -= 1 ; else : if ( tenCount >= 3 ) tenCount -= 3 ; else : return 0 ;

static int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) { fiveCount ++ ; } else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -= 1 ; tenCount -= 1 ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } } } return 0 ; }

52.38
55.47
59.72
60.63
def findSum ( n ) : multiTerms = n * ( n + 1 ) // 2 sm = multiTerms for i in range ( 2 , n + 1 ) : multiTerms = multiTerms - ( i - 1 ) sm = sm + multiTerms * i return sm

static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }

static long findSum ( int n ) { long sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sm = sm + multiTerms * i ; } return sm ; }

static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) ; int sm = multiTerms ; for ( int i = 2 ; i < n ; i ++ ) { sm = sm + multiTerms * i ; } return sm ; }

52.38
49.17
56.54
51.32
def maxSum ( arr ) : arrSum = 0 currVal = 0 n = len ( arr ) for i in range ( 0 , n ) : arrSum = arrSum + arr [ i ] currVal = currVal + ( i * arr [ i ] ) maxVal = currVal for j in range ( 1 , n ) : currVal = currVal + arrSum - n * arr [ n - j ] if currVal > maxVal : maxVal = currVal return maxVal

static int maxSum ( ) { int arrSum = 0 ; int currVal = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } int maxVal = currVal ; for ( int j = 1 ; j < arr . length ; j ++ ) { currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; }

static int maxSum ( int [ ] arr ) { int arrSum = 0 ; int currVal = 0 ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { arrSum = arrSum + arr [ i ] ; if ( currVal > maxVal ) maxVal = currVal ; for ( int j = 0 ; j < n ; j ++ ) { if ( currVal > maxVal ) maxVal = currVal ;

static int maxSum ( int arr [ ] , int maxVal ) { int arrSum = 0 ; int currVal = 0 ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; }

52.4
51.55
89.01
87.97
def minimum_cost ( a , n ) : mn = sys . maxsize sum = 0 for i in range ( n ) : mn = min ( a [ i ] , mn ) sum += a [ i ] return mn * ( sum - mn )

static int minimum_cost ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }

static int minimum_cost ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int mn = sys . maxsize ; sum += a [ i ] ; } return sum ; }

static int minimum_cost ( int a [ ] , int n ) { int mn = sys . maxsize ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }

52.76
47.61
43.06
44.04
def equilibrium ( arr ) : leftsum = 0 rightsum = 0 n = len ( arr ) for i in range ( n ) : leftsum = 0 rightsum = 0 for j in range ( i ) : leftsum += arr [ j ] for j in range ( i + 1 , n ) : rightsum += arr [ j ] if leftsum == rightsum : return i return - 1

int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; rightsum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }

static int equilibrium ( int arr [ ] ) { int leftsum = 0 ; int rightsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftsum += arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { rightsum += arr [ j ] ; for ( int j = i ; j < n ; j ++ ) { if ( leftsum == rightsum ) return i ;

static int equilibrium ( int arr [ ] ) { int leftsum = 0 ; int rightsum = 0 ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { leftsum += arr [ i ] ; rightsum += arr [ i + 1 ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }

52.76
50.69
65.48
66.04
def countPairs ( str1 ) : result = 0 ; n = len ( str1 ) for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : result += 1 ; return result ;

static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }

static int countPairs ( String str ) { int result = 0 ; int n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str . charAt ( i ) == 'a' ) result += 1 ; else result += 1 ; } } return result ; } }

static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( ord ( str [ i ] ) - ord ( str [ j ] ) ) == abs ( i - j ) ) { result ++ ; } } } return result ; }

52.8
56.24
67.52
63.93
def findWays ( m , n , x ) : table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] for j in range ( 1 , min ( m + 1 , x + 1 ) ) : table [ 1 ] [ j ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 1 , x + 1 ) : for k in range ( 1 , min ( m + 1 , j ) ) : table [ i ] [ j ] += table [ i - 1 ] [ j - k ] return table [ - 1 ] [ - 1 ]

public static long findWays ( int m , int n , int x ) { long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }

static int findWays ( int m , int n , int x ) { int table [ ] [ ] = new int [ n + 1 ] [ x + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k <= m ; k ++ ) { table [ i ] [ j ] += table [ i - 1 ] [ j -

private static int findWays ( int m , int n , int x ) { int table [ ] [ ] = new int [ m + 1 ] [ x + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { table [ i ] [ j ] = 1 ; for ( int k = 1 ; k <= m ; k ++ ) { table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ - 1 ] [ - 1 ] ; } }

52.84
50.27
50.36
48.66
def middlesum ( mat , n ) : row_sum = 0 col_sum = 0 for i in range ( n ) : row_sum += mat [ n // 2 ] [ i ] print ( "Sumofmiddlerow=" , row_sum ) for i in range ( n ) : col_sum += mat [ i ] [ n // 2 ] print ( "Sumofmiddlecolumn=" , col_sum )

static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( "Sum of middle row = " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( "Sum of middle column = " + col_sum ) ; }

static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 ; int col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { col_sum += mat [ i ] [ n // 2 ] ; print ( "Sumofmiddlerow=" , row_sum ) for ( int i = 0 ; i < n ; i ++ ) { col_sum += mat [ i ] [ n

static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 ; int col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { row_sum += mat [ i ] [ n // 2 ] [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { col_sum += mat [ i ] [ n // 2 ] [ j ] ; } } }

52.84
80.32
91.41
94.08
def printCountRec ( dist ) : if dist < 0 : return 0 if dist == 0 : return 1 return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) )

static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }

static int printCountRec ( int dist ) { if ( dist == 0 ) return 0 ; return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) + printCountRec ( dist - 4 ) + printCountRec ( dist - 5 ) + printCountRec ( dist - 6 ) + printCountRec ( dist - 7 ) ) ; } return 1 ; }

static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) ; }

52.86
56.77
60.17
62.77
def moduloMultiplication ( a , b , mod ) : res = 0 ; a = a % mod ; while ( b ) : if ( b & 1 ) : res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; return res ;

static long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }

static int moduloMultiplication ( int a , int b , int mod ) { int res ; while ( b ) { if ( b & 2 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; } return 0 ; }

static int moduloMultiplication ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }

52.87
48.44
43.11
40.14
def distributingBalls ( k , n , string ) : a = [ 0 ] * MAX_CHAR for i in range ( n ) : a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR ) : if ( a [ i ] > k ) : return False return True

static boolean distributingBalls ( long k , long n , String str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }

static boolean distributingBalls ( int k , int n , char [ ] string ) { int a [ ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < k ) return false ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( a [ i ] > k ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if

static boolean distributingBalls ( int k , int n , String string ) { int a [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ ord ( string [ i ] ) - ord ( 'a' ) ] ++ ; } return true ; }

52.91
58.58
52.5
62.7
def smallest ( x , y , z ) : c = 0 while ( x and y and z ) : x = x - 1 y = y - 1 z = z - 1 c = c + 1 return c

static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }

static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x and y and z ) { x = x - 1 y = y - 1 z = z - 1 c = c + 1 ; } return c ; }

static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x > 0 && y > 0 && z > 0 ) { x = x - 1 ; y = y - 1 ; z = z - 1 ; c = c + 1 ; } return c ; }

52.92
42.5
71.4
67.69
def chordCnt ( A ) : n = 2 * A dpArray = [ 0 ] * ( n + 1 ) dpArray [ 0 ] = 1 dpArray [ 2 ] = 1 for i in range ( 4 , n + 1 , 2 ) : for j in range ( 0 , i - 1 , 2 ) : dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) return int ( dpArray [ n ] )

static int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }

static int chordCnt ( int A ) { int dpArray [ ] = new int [ 4 ] * ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { dpArray [ i ] += ( dpArray [ i - 2 - j ] * dpArray [ i - 2 - j ] ) ; } return int ( dpArray [ n ] ) ; } return

static int chordCnt ( int A ) { int n = 2 * A ; int dpArray [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dpArray [ i ] = 1 ; dpArray [ 2 ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { dpArray [ i ] += dpArray [ j ] * dpArray [ i - 2 - j ] ; } return int ( dpArray [ n ] ) ; } }

53.03
57.6
40.52
56.14
def isSubsetSum ( set , n , sum ) : if ( sum == 0 ) : return True if ( n == 0 and sum != 0 ) : return False if ( set [ n - 1 ] > sum ) : return isSubsetSum ( set , n - 1 , sum ) return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] )

static boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }

static boolean isSubsetSum ( int set [ ] , int n ) { int sum = set [ n - 1 ] ; if ( set [ n - 1 ] < sum ) { return isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] + set [ n - 1 ] , sum - set [ n - 1 ] ) ; } return false ; }  def isSubsetSum ( int set [ ] , int n , int sum ) {

static boolean isSubsetSum ( int set [ ] , int sum ) { if ( sum == 0 ) return true ; if ( set [ n - 1 ] > sum ) return true ; if ( set [ n - 1 ] > sum ) return true ; if ( set [ n - 1 ] == sum ) return true ; if ( set [ n - 1 ] == sum ) return true ; if ( set [ n - 1 ] == sum ) return true ; if ( set [ n - 1 ] == sum ) return true ; if ( set [ n - 1 ] == sum ) return true ; return false ; }

53.1
48.0
75.26
70.66
def Print ( n , k ) : rem = 1 for i in range ( 0 , k ) : print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = "" ) rem = ( 10 * rem ) % n

static void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } }

static void Print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { print ( rem / n , end = "" ) ; } }

static void Print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = "" ) ; rem = ( 10 * rem ) % n ; } }

53.12
56.14
68.73
65.48
def countSubsequences ( s ) : aCount = 0 bCount = 0 cCount = 0 for i in range ( len ( s ) ) : if ( s [ i ] == 'a' ) : aCount = ( 1 + 2 * aCount ) elif ( s [ i ] == 'b' ) : bCount = ( aCount + 2 * bCount ) elif ( s [ i ] == 'c' ) : cCount = ( bCount + 2 * cCount ) return cCount

static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s . charAt ( i ) == 'b' ) bCount = ( aCount + 2 * bCount ) ; else if ( s . charAt ( i ) == 'c' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }

static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( s [ i ] == 'a' ) { aCount = ( aCount + 2 * bCount ) ; } else if ( s [ i ] == 'b' ) { bCount = ( bCount + 2 * cCount ) ;

static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == 'b' ) bCount = ( 1 + 2 * bCount ) ; else if ( s [ i ] == 'c' ) cCount = ( 1 + 2 * cCount ) ; else if ( s [ i ] == 'c' ) cCount = ( 1 + 2 * cCount ) ; } return cCount ; }

53.15
51.22
54.97
50.88
def findLongestConseqSubseq ( arr , n ) : S = set ( ) for i in range ( n ) : S . add ( arr [ i ] ) ans = 0 for i in range ( n ) : if S . __contains__ ( arr [ i ] ) : j = arr [ i ] while ( S . __contains__ ( j ) ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans

static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) S . add ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; ans = Math . max ( ans , j - arr [ i ] ) ; } } return ans ; }

static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < int > S = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = arr [ i ] ; ( S . __contains__ ( j ) ) ; j += 1 ) { if ( S . __contains__ ( j ) ) { ans = max ( ans , j - arr [ i ] ) ; } } return ans ; }

static int findLongestConseqSubseq ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { j = arr [ i ] ; while ( S . __contains__ ( j ) ) { j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } } return ans ; }

53.16
47.4
53.08
47.11
def maxProduct ( arr , n ) : if n < 3 : return - 1 max_product = - ( sys . maxsize - 1 ) for i in range ( 0 , n - 2 ) : for j in range ( i + 1 , n - 1 ) : for k in range ( j + 1 , n ) : max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) return max_product

static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }

static int maxProduct ( int arr [ ] , int n ) { int max_product = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] * arr [ j ] * arr [ k ] > max_product ) max_product = max ( max_product ,

static int maxProduct ( int arr [ ] , int n ) { int max_product = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { for ( int k = 0 ; k < arr . length ; k ++ ) { max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; } } return max_product ; } }

53.17
57.47
62.25
56.83
def findPair ( arr , n ) : found = False for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : for k in range ( 0 , n ) : if ( arr [ i ] + arr [ j ] == arr [ k ] ) : print ( arr [ i ] , arr [ j ] ) found = True if ( found == False ) : print ( "Notexist" )

static void findPair ( int [ ] arr , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + " " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) System . out . println ( "Not exist" ) ; }

static void findPair ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 , n ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) found = true ; if ( found == false ) { print ( arr [ i ] + arr [ j ] == arr [ k ] ) found = true ; if ( found

static void findPair ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { for ( int k = 0 ; k < arr . length ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) found = true ; if ( arr [ i ] + arr [ j ] == arr [ k ] ) found = true ; if ( found == true ) { print ( arr [ i ] , arr [ j ] ) ; found = true ; } } } } return ; }

53.23
60.69
54.96
60.5
def search ( mat , n , x ) : i = 0 j = n - 1 while ( i < n and j >= 0 ) : if ( mat [ i ] [ j ] == x ) : print ( "nFoundat" , i , "," , j ) return 1 if ( mat [ i ] [ j ] > x ) : j -= 1 else : i += 1 print ( "Elementnotfound" ) return 0

private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( "n Found at " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( "n Element not found" ) ; return ; }

static int search ( int [ ] mat , int n , int x ) { int i = 0 ; int j = n - 1 ; while ( i < n ) { if ( mat [ i ] [ j ] < x ) i ++ ; if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; if ( j >= 0 ) j -- ; else

static int search ( int mat [ ] , int n , int x ) { int i = 0 ; int j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { if ( nFoundat ( i , "," , j ) ) return 1 ; if ( mat [ i ] [ j ] > x ) j -= 1 ; else i ++ ; } } return 0 ; }

53.25
73.3
90.44
92.47
def numberOfWays ( x ) : if x == 0 or x == 1 : return 1 else : return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )

static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }

static int numberOfWays ( int x ) { if ( x == 1 ) return ( numberOfWays ( x - 2 ) + numberOfWays ( x - 1 ) * numberOfWays ( x - 2 ) ) / 2 ; else return ( numberOfWays ( x - 1 ) + numberOfWays ( x - 2 ) ) / 2 ; }

static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; }

53.3
63.43
82.32
81.01
def minJumps ( a , b , d ) : temp = a a = min ( a , b ) b = max ( temp , b ) if ( d >= b ) : return ( d + b - 1 ) / b if ( d == 0 ) : return 0 if ( d == a ) : return 1 return 2

static int minJumps ( int a , int b , int d ) { int temp = a ; a = Math . min ( a , b ) ; b = Math . max ( temp , b ) ; if ( d >= b ) return ( d + b - 1 ) / b ; if ( d == 0 ) return 0 ; if ( d == a ) return 1 ; return 2 ; }

static int minJumps ( int a , int b , int d ) { int temp = a ; a = max ( temp , a ) ; b = max ( temp , b ) ; if ( d <= a ) return 1 ; if ( d == b ) return 2 ; if ( d == 0 ) return 3 ; if ( d == a ) return 4 ; if ( d == b ) return 5 ; if ( d == 0 ) return 6 ; if ( d == a

static int minJumps ( int a , int b , int d ) { int temp = a ; a = b ; b = max ( temp , b ) ; if ( d >= b ) return ( d + b - 1 ) / b ; if ( d == 0 ) return 0 ; if ( d == a ) return 1 ; if ( d == a ) return 2 ; return 3 ; }

53.3
58.04
73.68
76.19
def minElements ( arr , n ) : halfSum = 0 for i in range ( n ) : halfSum = halfSum + arr [ i ] halfSum = int ( halfSum / 2 ) arr . sort ( reverse = True ) res = 0 curr_sum = 0 for i in range ( n ) : curr_sum += arr [ i ] res += 1 if curr_sum > halfSum : return res return res

static int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }

static int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; res += 1 if ( curr_sum > halfSum ) res = res + 1 ; if ( curr_sum > halfSum ) res

static int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { halfSum = halfSum + arr [ i ] ; halfSum = int ( halfSum / 2 ) ; arr . sort ( reverse = true ) ; res = 0 ; curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } } }

53.36
52.4
42.01
56.23
def sumOfLargePrimeFactor ( n ) : prime = [ 0 ] * ( n + 1 ) sum = 0 max = int ( n / 2 ) for p in range ( 2 , max + 1 ) : if prime [ p ] == 0 : for i in range ( p * 2 , n + 1 , p ) : prime [ i ] = p for p in range ( 2 , n + 1 ) : if prime [ p ] : sum += prime [ p ] else : sum += p return sum

static int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; }

static int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n + 1 ] ; for ( int p = 0 ; p < n ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ p ] == 1 ) { for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( prime [ p ] == 0 ) sum += prime [ p ] ; } } } return sum ; } return 0 ; } }

static int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n / 2 ] ; int sum = 0 ; int max = int ( n / 2 ) ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = i * 2 ; i <= p ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= p ; j ++ ) { if ( prime [ j ] == 0 ) { for ( int j = i * 2 ; j <= p ; j ++ ) { if ( prime [ j ] == 0 ) { for ( int j = i * 2 ; j <= p ; j ++ ) { if ( prime [ j ] == 0 ) { prime [ j ] = p ; } } } } } } } } } return sum ; }

53.48
54.95
77.91
81.61
def minRadius ( k , x , y , n ) : dis = [ 0 ] * n for i in range ( 0 , n ) : dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] dis . sort ( ) return dis [ k - 1 ]

static int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }

static double minRadius ( int k , double x [ ] , double y [ ] , int n ) { double dis [ ] = x [ k - 1 ] * x [ k - 1 ] + y [ k - 1 ] * y [ k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dis [ i ] = x [ i ] * y [ i ] + y [ i ] * y [ i ] ; } return dis [ k - 1 ] ; }

public static int minRadius ( int k , int x , int y , int n ) { int dis [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis [ i ] . sort ( ) ; } return dis [ k - 1 ] ; }

53.52
47.21
71.79
62.28
def sumOfSubstrings ( num ) : n = len ( num ) sumofdigit = [ ] sumofdigit . append ( int ( num [ 0 ] ) ) res = sumofdigit [ 0 ] for i in range ( 1 , n ) : numi = int ( num [ i ] ) sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) res += sumofdigit [ i ] return res

public static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) - '0' ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }

static int sumOfSubstrings ( String num ) { int res = 0 ; int n = num . length ( ) ; int sumofdigit [ ] = new int ( num [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int numi = int ( num [ i ] ) ; sumofdigit . append ( numi + 10 * sumofdigit [ i - 1 ] ) res += sumofdigit [ i ] ; }

static int sumOfSubstrings ( int num [ ] ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; sumofdigit . append ( int ( num [ 0 ] ) ) ; res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = int ( num [ i ] ) ; sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) ; res += sumofdigit [ i ] ; } return res ; }

53.55
55.1
58.68
60.78
def decToBin ( n ) : if ( n == 0 ) : return "0" bin = "" while ( n > 0 ) : if ( n & 1 == 0 ) : bin = '0' + bin else : bin = '1' + bin n = n >> 1 return bin

static String decToBin ( int n ) { if ( n == 0 ) return "0" ; String bin = "" ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; }

static String decToBin ( int n ) { String bin = "" ; while ( n > 0 ) { if ( n & 1 == 0 ) bin = '1' + bin ; else bin = '0' + bin ; } return bin ; }

static String decToBin ( int n ) { String bin = "" ; while ( n > 0 ) { if ( n & 1 == 0 ) bin = "0" ; else bin = "1" + bin ; n = n >> 1 ; } return bin ; }

53.61
54.08
53.23
57.86
def kLargest ( arr , k ) : arr . sort ( reverse = True ) for i in range ( k ) : print ( arr [ i ] , end = "" )

public static void kLargest ( Integer [ ] arr , int k ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

static void kLargest ( int arr [ ] , int k ) { System . out . print ( "kLargest: " ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] ) ; } }

static void kLargest ( int arr [ ] , int k ) { arr . sort ( reverse = true ) ; for ( int i = 0 ; i < k ; i ++ ) { arr [ i ] . print ( arr [ i ] ) ; } }

53.67
50.62
59.78
61.74
def sumEqualProduct ( a , n ) : zero = 0 two = 0 for i in range ( n ) : if a [ i ] == 0 : zero += 1 if a [ i ] == 2 : two += 1 cnt = ( zero * ( zero - 1 ) ) // 2 + \ ( two * ( two - 1 ) ) // 2 return cnt

static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }

static int sumEqualProduct ( int [ ] a , int n ) { int zero = 0 ; int two = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) two += 1 ; if ( a [ i ] == 2 ) zero += 1 ; if ( a [ i ] == 0 ) zero += 1 ; if ( a [ i ] == 2 ) two += 1 ; }

static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 ; int two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) zero ++ ; if ( a [ i ] == 2 ) two ++ ; if ( a [ i ] == 0 ) zero ++ ; if ( a [ i ] == 1 ) two ++ ; } return zero + two ; }

53.71
66.46
62.67
53.25
def LeibnizHarmonicTriangle ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , i + 1 ) : print ( "1/" , end = "" ) print ( i * C [ i - 1 ] [ j - 1 ] , end = "" ) print ( )

static void LeibnizHarmonicTriangle ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( "1/" + i * C [ i - 1 ] [ j - 1 ] + " " ) ; System . out . println ( ) ; } }

static void LeibnizHarmonicTriangle ( int n ) { int [ ] [ ] C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] [ n + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j ] = ( C [ i - 1 ] [ j - 1 ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( j == i ) C [ i ] [ j ] = ( C [ i ] [ j ] = ( C [ i ] [ j - 1 ] [ j - 1 ] [ j - 1 ] + C [ j - 1 ] [ j ] + C [ j - 1 ] + C [ i - 1 ] ; } } for ( int j = i ;

static void LeibnizHarmonicTriangle ( int n ) { int C [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i ] [ j - 1 ] + C [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 or j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i ] [ j - 1 ] + C [ i ] [ j ] ) ; } } } return ; }

53.72
50.21
47.88
45.91
def findMinSum ( a , b , n ) : a . sort ( ) b . sort ( ) sum = 0 for i in range ( n ) : sum = sum + abs ( a [ i ] - b [ i ] ) return sum

static long findMinSum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }

static int findMinSum ( int a , int b , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > b [ i ] ) sum = sum + abs ( a [ i ] - b [ i ] ) ; } return sum ; }

static int findMinSum ( int a , int b , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + abs ( a [ i ] - b [ i ] ) ; } return sum ; }

53.74
49.1
30.93
35.22
def maxSumSubarrayRemovingOneEle ( arr , n ) : fw = [ 0 for k in range ( n ) ] bw = [ 0 for k in range ( n ) ] cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] for i in range ( n ) : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) fw [ i ] = cur_max cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] i = n - 2 while i >= 0 : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) bw [ i ] = cur_max i -= 1 fans = max_so_far for i in range ( 1 , n - 1 ) : fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) return fans

static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ ] = new int [ n ] ; int bw [ ] = new int [ n ] ; int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; fw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; }

static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int cur_max , max_so_far = arr [ 0 ] ; bw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i <= n ; i ++ ) { cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) bw [ i ] = max ( bw [ i ] , cur_max + arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { cur_max = max_so_far = cur_max ; for ( int i = n - 1 ; i >= 0 ; i -- ) { cur_max = max ( cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) bw [ i ] = max ( bw [ i ] ; bw [ i ] + arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cur_max = max_so_far ; bw [ i ] = cur

static int maxSumSubarrayRemovingOneEle ( int [ ] arr , int n ) { int [ ] fw = new int [ n ] ; int [ ] bw = new int [ n ] ; int cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = max ( max_so_far , cur_max ) ; max_so_far = max ( max_so_far , cur_max ) ; bw [ i ] = cur_max i -- ; } fans = maxSumSubarrayRemovingOneEle ( arr , n ) ; return fans ; }

53.82
60.38
63.58
57.02
def subArray ( arr , n ) : for i in range ( 0 , n ) : for j in range ( i , n ) : for k in range ( i , j + 1 ) : print ( arr [ k ] , end = "" ) print ( "\n" , end = "" )

static void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " " ) ; } } }

static void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < arr . length ; k ++ ) { if ( arr [ k ] != 0 ) print ( arr [ k ] + " " ) print ( "\n" , end = "" ) print ( arr [ k ] + "

static void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { arr [ i ] [ j ] = arr [ k ] ; } } } }

53.83
61.07
61.5
67.85
def countToMake0lternate ( s ) : result = 0 for i in range ( len ( s ) - 1 ) : if ( s [ i ] == s [ i + 1 ] ) : result += 1 return result

static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ; return result ; }

static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { result += 1 ; } } return result ; }

static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { result ++ ; } } return result ; }

53.98
75.27
90.53
92.32
def findStep ( n ) : if ( n == 1 or n == 0 ) : return 1 elif ( n == 2 ) : return 2 else : return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 )

public static int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }

static int findStep ( int n ) { if ( n == 3 ) return findStep ( n - 1 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) + findStep ( n - 2 ) ; } return 0 ; }

static int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 || n == 1 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }

54.04
55.94
51.74
55.67
def Dragon_Curve_Sequence ( n ) : s = "1" for i in range ( 2 , n + 1 ) : temp = "1" prev = '1' zero = '0' one = '1' for j in range ( len ( s ) ) : temp += s [ j ] if ( prev == '0' ) : temp += one prev = one else : temp += zero prev = zero s = temp return s

static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; }

static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 0 ; i < n ; i ++ ) { String temp = "1" ; for ( int j = 0 ; j < len ( s ) ; j ++ ) { temp += s [ j ] ; if ( prev == '1' ) { temp += zero ; prev = zero ; } } return s ; } return s ; }

static String DragonCurve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i < n ; i ++ ) { String temp = "1" ; for ( int j = 0 ; j < n ; j ++ ) { temp += s [ j ] ; if ( prev == '0' ) temp += one ; else temp += one ; } s = temp ; } return s ; }

54.06
47.3
24.34
40.75
def count ( n ) : if ( n < 4 ) : return - 1 rem = n % 4 if ( rem == 0 ) : return n // 4 if ( rem == 1 ) : if ( n < 9 ) : return - 1 return ( n - 9 ) // 4 + 1 if ( rem == 2 ) : return ( n - 6 ) // 4 + 1 if ( rem == 3 ) : if ( n < 15 ) : return - 1 return ( n - 15 ) // 4 + 2

static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; }

static int count ( int n ) { int count = 0 ; int rem = n % 4 ; if ( rem == 0 ) return n // 4 + 1 ; if ( rem == 1 ) { if ( n < 6 ) return - 1 return ( n - 7 ) // 4 + 1 ; if ( rem == 2 ) return ( n - 8 ) // 4 + 1 ; if ( rem == 3 ) return ( n - 10 ) // 4 + 1 ; if ( rem ==

; if ( n < 10 ) return - 1 ; if ( n < 11 ) return - 1 ; if ( n < 12 ) return - 1 ; if ( n < 13 ) return - 1 ; if ( n < 14 ) return - 1 ; if ( n < 15 ) return - 1 ; if ( n < 16 ) return - 1 ; if ( n < 17 ) return - 1 ; if ( n < 18 ) return - 1 ; if ( n < 19 ) return - 1 ; if ( n < 20 ) return - 1 ; if ( n < 21 ) return - 1 ; if ( n < 22 ) return - 1 ; return n ; }

54.07
48.78
81.0
71.59
def findSDSFunc ( n ) : DP = [ 0 ] * ( n + 1 ) DP [ 0 ] = 0 DP [ 1 ] = 1 for i in range ( 2 , n + 1 ) : if ( int ( i % 2 ) == 0 ) : DP [ i ] = DP [ int ( i / 2 ) ] else : DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) return DP [ n ]

static int findSDSFunc ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }

static int findSDSFunc ( int n ) { int DP [ ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( int ( i % 2 ) == 0 ) DP [ i ] = DP [ int ( i / 2 ) ] + DP [ int ( i / 2 ) ] ; else DP [ i ] = DP [ int ( i / 2 ) ] ; } return DP [ n ] ; }

static int findSDSFunc ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = ( DP [ i / 2 ] + DP [ i / 2 ] ) ; } return DP [ n ] ; }

54.1
50.88
32.5
41.7
def lps ( str ) : n = len ( str ) L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] for i in range ( n ) : L [ i ] [ i ] = 1 for cl in range ( 2 , n + 1 ) : for i in range ( n - cl + 1 ) : j = i + cl - 1 if str [ i ] == str [ j ] and cl == 2 : L [ i ] [ j ] = 2 elif str [ i ] == str [ j ] : L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 else : L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; return L [ 0 ] [ n - 1 ]

static int lps ( String seq ) { int n = seq . length ( ) ; int i , j , cl ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }

static int lps ( String str ) { int n = str . length ( ) ; int L [ ] [ ] = new int [ n ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + cl - 1 ; if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j ] = L [ i ] [ j - 1 ] [ j ] = L [ i ] [ j - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j ++ ) { if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i ] [ j - 1 ] + 2 ; } } return L [ i ] [ j ] + 2 ] [ j ] ; } return L [ i ] [ j ] ; } } return L [ n ] [ j ] ; } return L [ n ] [ j ] ; } return L [ 0 ] [ n ] [ j ]

static int lps ( String str ) { int n = str . length ( ) ; int [ ] L = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; } return L [ 0 ] [ n - 1 ] ; }

54.14
49.66
64.34
68.77
def printCountDP ( dist ) : count = [ 0 ] * ( dist + 1 ) count [ 0 ] = 1 count [ 1 ] = 1 count [ 2 ] = 2 for i in range ( 3 , dist + 1 ) : count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) return count [ dist ]

static int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }

static int printCountDP ( int dist ) { int count [ ] ; for ( int i = 1 ; i <= dist ; i ++ ) { count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; } return count [ dist ] ; }

static int printCountDP ( int dist ) { int count [ ] = new int [ ] { 0 , 1 , 2 , 3 } ; int count [ ] = new int [ 3 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 0 ; i < 3 ; i ++ ) { count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) ; } return count [ dist ] ; }

54.15
56.39
60.27
71.39
def printIntersection ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and j < n : if arr1 [ i ] < arr2 [ j ] : i += 1 elif arr2 [ j ] < arr1 [ i ] : j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1

static void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { System . out . print ( arr2 [ j ++ ] + " " ) ; i ++ ; } } }

static void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i , j ; for ( i = 0 ; i < m ; i ++ ) { if ( arr2 [ j ] < arr1 [ i ] ) j += 1 else : print ( arr1 [ i ] ) j += 1 else : print ( arr2 [ j ] ) j += 1 else : print ( arr1 [ i ] ) j +=

static void printIntersection ( int arr1 , int arr2 , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) i ++ ; else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else if ( arr2 [ j ] > arr1 [ i ] ) i ++ ; else if ( arr2 [ j ] > arr1 [ i ] ) i ++ ; else i ++ ; } }

54.35
68.05
61.1
71.09
def largestPower ( n , p ) : x = 0 while n : n /= p x += n return x

static int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }

static int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) n /= p ; return x ; }

static int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) { x ++ ; n /= p ; } return x ; }

54.36
58.1
78.54
78.27
def printFactorialNums ( n ) : fact = 1 x = 2 while fact <= n : print ( fact , end = "" ) fact = fact * x x += 1

static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + " " ) ; fact = fact * x ; x ++ ; } }

static void printFactorialNums ( int n ) { int fact = 1 ; while ( fact <= n ) { print ( fact ) fact = fact * x ; x += 1 ; } }

static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { print ( fact , end = "" ) ; fact = fact * x ; x ++ ; } }

54.37
64.46
54.37
64.46
def ispalindrome ( s ) : l = len ( s ) i = 0 j = l - 1 while i <= j : if ( s [ i ] != s [ j ] ) : return False i += 1 j -= 1 return True

static boolean ispalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }

static boolean ispalindrome ( String s ) { int l = s . length ( ) ; int i = 0 ; int j = l - 1 ; while ( i <= j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }

static boolean ispalindrome ( String s ) { int l = s . length ( ) ; int i = 0 ; int j = l - 1 ; while ( i <= j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }

54.38
59.54
67.7
70.09
def printDistinct ( arr , n ) : for i in range ( 0 , n ) : d = 0 for j in range ( 0 , i ) : if ( arr [ i ] == arr [ j ] ) : d = 1 break if ( d == 0 ) : print ( arr [ i ] )

static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) System . out . print ( arr [ i ] + " " ) ; } }

static void printDistinct ( int arr [ ] , int n ) { int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ j ] ) { d = 1 ; break } } if ( d == 0 ) print ( arr [ i ] ) ; } }

static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int d = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { d = 1 ; break ; } if ( d == 0 ) { print ( arr [ i ] ) ; } } } }

54.41
60.39
39.54
65.29
def gcd ( a , b ) : if ( a == b ) : return a if ( a == 0 ) : return b if ( b == 0 ) : return a if ( ( ~ a & 1 ) == 1 ) : if ( ( b & 1 ) == 1 ) : return gcd ( a >> 1 , b ) else : return ( gcd ( a >> 1 , b >> 1 ) << 1 ) if ( ( ~ b & 1 ) == 1 ) : return gcd ( a , b >> 1 ) if ( a > b ) : return gcd ( ( a - b ) >> 1 , b ) return gcd ( ( b - a ) >> 1 , a )

static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) { if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ; else return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }

static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) return ( gcd ( a >> 1 , b ) << 1 ) ; if ( ( ~ a & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; if ( a > b ) return ( gcd ( a - b ) >> 1 ,

static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( ( ~ a & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; if ( ( ~ b & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; if ( ( ~ a & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; if ( ( ~ b & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; if ( ( ~ b & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; if ( ( ~ a & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; if ( ( ~ b & 1 ) == 1 ) return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ; }

54.5
52.92
64.74
69.8
def concatenate ( a , b , c , n1 , n2 ) : i = - 1 for i in range ( n1 ) : c [ i ] = a [ i ] for j in range ( n2 ) : c [ i ] = b [ j ] i += 1

static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }

static int concatenate ( int a [ ] , int b [ ] , int n1 , int n2 ) { int i = - 1 ; int j = - 1 ; for ( int i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] + b [ j ] ; j ++ ; } return i ; }

static void concatenate ( int a , int b , int c , int n1 , int n2 ) { int i = - 1 ; for ( int i = - 1 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; for ( int j = - 1 ; j < n2 ; j ++ ) { c [ i ] = b [ j ] ; } i ++ ; } }

54.53
53.8
52.4
47.96
def generate ( st , s ) : if len ( s ) == 0 : return if s not in st : st . add ( s ) for i in range ( len ( s ) ) : t = list ( s ) . copy ( ) t . remove ( s [ i ] ) t = '' . join ( t ) generate ( st , t ) return

static void generate ( Set < String > st , String s ) { if ( s . length ( ) == 0 ) { return ; } if ( ! st . contains ( s ) ) { st . add ( s ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String t = s ; t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; generate ( st , t ) ; } } return ; }

static void generate ( Set < String > st , String s ) { if ( st . contains ( s ) ) return ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { String t = list ( s ) . copy ( ) ; t . remove ( s [ i ] ) ; generate ( st , t ) ; } return ; } generate ( st , s ) ; return ; } generate ( st , s ) ; generate ( st , s

static void generate ( Set < String > st , String s ) { Set < String > set = new HashSet < String > ( ) ; set . add ( s ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { String t = list ( s ) . copy ( ) ; t . remove ( s [ i ] ) ; t = '' . join ( t ) ; generate ( st , t ) ; } }

54.58
50.13
56.16
34.85
def carveCross ( str ) : n = len ( str ) if ( n % 2 == 0 ) : print ( "Notpossible.Pleaseenter" , "oddlengthstring.\n" ) else : arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] m = n // 2 for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = 'X' for i in range ( n ) : arr [ i ] [ m ] = str [ i ] for i in range ( n ) : arr [ m ] [ i ] = str [ i ] for i in range ( n ) : for j in range ( n ) : print ( arr [ i ] [ j ] , end = "" ) print ( )

static void carveCross ( String str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { System . out . print ( "Not possible. Please enter " + "odd length string.\n" ) ; } else { char arr [ ] [ ] = new char [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = 'X' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " " ) ; } System . out . print ( "\n" ) ; } } }

static void carveCross ( String str , int max ) { int n = str . length ( ) ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] [ m ] = str [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] [ m ] == 'X' ) arr [ i ] [ m ] = 'X' ; else arr [ m ] [ i ] = 'X' ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i % 2 == 0 ) arr [ i ] [ m ] = str [ i ] ; for ( int j < n ; j ++ ) { if ( arr [ i ] [ m ] == 'X' ) arr [ i ] [ m ] = str [ i ] [ m ] = 'X' ; } } } else arr [ m ] = 'X' ; i ++ ) { for ( i ++ ; j ++ ) { for ( i ++ ) { for ( j < m ; j

static void carveCross ( String str ) { int n = str . length ( ) ; int m = n // 2 for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ m ] = str [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ m ] = str [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ m ] [ i ] = str [ i ] ; arr [ i ] [ m ] [ j ] = str [ i ] ; } } } } } }

54.59
46.45
59.93
48.54
def sortString ( str ) : charCount = [ 0 ] * MAX_CHAR for i in range ( len ( str ) ) : charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : for j in range ( charCount [ i ] ) : print ( chr ( 97 + i ) , end = "" )

static void sortString ( String str ) { int charCount [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { charCount [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { System . out . print ( ( char ) ( 'a' + i ) ) ; } } }

static void sortString ( String str ) { int charCount [ ] = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { for ( int i = 0 ; i < charCount [ i ] ; i ++ ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { if ( charCount [

static void sortString ( String str ) { int charCount = new int [ MAX_CHAR + 1 ] * MAX_CHAR ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 ; for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { print ( str [ i ] ) ; } } } }

54.68
48.09
81.91
77.01
def maxXOR ( mat , N ) : max_xor = 0 for i in range ( N ) : r_xor = 0 c_xor = 0 for j in range ( N ) : r_xor = r_xor ^ mat [ i ] [ j ] c_xor = c_xor ^ mat [ j ] [ i ] if ( max_xor < max ( r_xor , c_xor ) ) : max_xor = max ( r_xor , c_xor ) return max_xor

static int maxXOR ( int mat [ ] [ ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }

static int maxXOR ( int mat [ ] [ ] , int N ) { int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int r_xor = 0 ; int c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( max_xor < r_xor ) max_xor = max ( r_xor , c_xor ) ; } } return max_xor ; }

static int maxXOR ( int mat [ ] [ ] , int N ) { int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int r_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; } } return max_xor ; }

54.75
60.41
52.06
64.82
def findIndex ( n ) : if ( n <= 1 ) : return n a = 0 b = 1 c = 1 res = 1 while ( c < n ) : c = a + b res = res + 1 a = b b = c return res

static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }

static int findIndex ( int n ) { int a = 0 ; int b = 1 ; int c = 1 ; int res = 1 ; while ( b < n ) { c = a + b ; res = res + 1 ; } return res ; }

static int findIndex ( int n ) { int a = 0 ; int b = 1 ; int c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res = res + 1 ; while ( c < n ) { c = c + b ; res = res + 1 ; a = a + b ; } } return res ; }

54.76
59.02
43.67
45.0
def findMissing ( a , b , n , m ) : s = dict ( ) for i in range ( m ) : s [ b [ i ] ] = 1 for i in range ( n ) : if a [ i ] not in s . keys ( ) : print ( a [ i ] , end = "" )

static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " " ) ; }

static void findMissing ( int [ ] a , int [ ] b , int n , int m ) { dict s = new dict ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] not in s . keys ( ) ) s [ b [ i ] ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] not in s . keys ( ) ) print (

static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { int s [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] != null ) { if ( b [ i ] != null ) { s [ b [ i ] ] = 1 ; } } } }

54.8
65.44
50.82
62.77
def countwalks ( graph , u , v , k ) : if ( k == 0 and u == v ) : return 1 if ( k == 1 and graph [ u ] [ v ] ) : return 1 if ( k <= 0 ) : return 0 count = 0 for i in range ( 0 , V ) : if ( graph [ u ] [ i ] == 1 ) : count += countwalks ( graph , i , v , k - 1 ) return count

int countwalks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; return count ; }

static int countwalks ( int [ ] graph , int u , int v , int k ) { int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; else count += countwalks ( graph , u , i , v , k - 1 ) ; } return count ; }

static int countwalks ( int graph [ ] , int u , int v , int k ) { int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] == 1 ) { count += countwalks ( graph , i , v , k - 1 ) ; } } return count ; }

54.82
61.91
87.77
76.78
def eulerian ( n , m ) : dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 0 , m + 1 ) : if ( i > j ) : if ( j == 0 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) return dp [ n ] [ m ]

public static int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }

static int eulerian ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i

static int eulerian ( int n , int m ) { int dp [ ] [ ] = new int [ n ] [ m ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) ; } } } return dp [ n ] [ m ] ; }

54.83
59.88
58.4
72.78
def minimumSquare ( a , b ) : result = 0 rem = 0 if ( a < b ) : a , b = b , a while ( b > 0 ) : result += int ( a / b ) rem = int ( a % b ) a = b b = rem return result

static int minimumSquare ( int a , int b ) { int result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; rem = a % b ; a = b ; b = rem ; } return result ; }

static int minimumSquare ( int a , int b ) { int result = 0 ; int rem = 0 ; int a = a ; int b = b ; while ( a > 0 ) { result += int ( a / b ) ; rem = int ( a % b ) ; } return result ; }

static int minimumSquare ( int a , int b ) { int result = 0 ; int rem = 0 ; while ( b > 0 ) { result += int ( a / b ) ; rem = int ( a / b ) ; result += int ( a / b ) ; rem = int ( a % b ) ; a = b ; b = rem ; } return result ; }

54.84
55.15
28.68
33.35
def bin ( n ) : if n > 1 : bin ( n // 2 ) print ( n % 2 , end = "" )

static void bin ( int n ) { if ( n > 1 ) bin ( n / 2 ) ; System . out . print ( n % 2 ) ; }

static void bin ( int n ) { if ( n > 1 ) print ( n / 2 , end = "" ) ; else print ( n % 2 , end = "" ) ; } }

static void bin ( int n ) { System . out . println ( n ) ; }

54.88
62.55
67.57
69.39
def countStr ( n , bCount , cCount ) : if ( bCount < 0 or cCount < 0 ) : return 0 if ( n == 0 ) : return 1 if ( bCount == 0 and cCount == 0 ) : return 1 res = countStr ( n - 1 , bCount , cCount ) res += countStr ( n - 1 , bCount - 1 , cCount ) res += countStr ( n - 1 , bCount , cCount - 1 ) return res

static int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 || cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }

static int countStr ( int n , int bCount , int cCount ) { int res = countStr ( n - 1 , bCount , cCount - 1 ) ; res += countStr ( n - 1 , bCount - 1 , cCount - 1 ) ; res += countStr ( n - 1 , bCount - 1 , cCount - 1 ) ; res += countStr ( n - 1 , bCount - 1 , cCount - 1 ) ; res +=

static int countStr ( int n , int bCount , int cCount ) { int res = countStr ( n , bCount , cCount ) ; if ( res == 0 ) return 1 ; res += countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount - 1 ) ; res += countStr ( n - 1 , bCount - 1 , cCount - 1 ) ; return res ; }

54.92
58.63
54.61
58.56
def LexicographicalMaxString ( str ) : mx = "" for i in range ( len ( str ) ) : mx = max ( mx , str [ i : ] ) return mx

static String LexicographicalMaxString ( String str ) { String mx = "" ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ; }

static String LexicographicalMaxString ( String str ) { String mx = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mx = max ( mx , str [ i : ] ) ; } return mx ; }

static String LexicographicalMaxString ( String str ) { String mx = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mx = max ( mx , str [ i ] ) ; } return mx ; }

54.94
53.78
41.23
62.98
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }

static int factorial ( int n ) { return 1 if ( n == 0 ) return 1 ; }  def factorial ( int n ) { return 1 ; }

static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return n * factorial ( n - 1 ) ; } }

54.94
53.78
41.23
62.98
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )

static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }

static int factorial ( int n ) { return 1 if ( n == 0 ) return 1 ; }  def factorial ( int n ) { return 1 ; }

static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return 1 ; } public static int factorial ( int n ) { return n * factorial ( n - 1 ) ; } }

54.97
54.58
54.97
52.73
def findLastIndex ( str , x ) : for i in range ( len ( str ) - 1 , - 1 , - 1 ) : if ( str [ i ] == x ) : return i return - 1

static int findLastIndex ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }

static int findLastIndex ( String str , String x ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == x ) return i ; } return - 1 ; }

static int findLastIndex ( String str , int x ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == x ) return i ; } return - 1 ; }

55.06
57.15
77.99
70.49
def nobleInteger ( arr , size ) : for i in range ( 0 , size ) : count = 0 for j in range ( 0 , size ) : if ( arr [ i ] < arr [ j ] ) : count += 1 if ( count == arr [ i ] ) : return arr [ i ] return - 1

public static int nobleInteger ( int arr [ ] ) { int size = arr . length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }

static int nobleInteger ( int arr [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < arr [ size ] ; i ++ ) { if ( count == arr [ i ] ) return arr [ i ] ; if ( count == arr [ j ] ) return - 1 ; if ( count == arr [ i ] ) return arr [ i ] ; if ( count == arr [ j ] ) return arr [ j ] ; }

static int nobleInteger ( int arr [ ] , int size ) { for ( int i = 0 ; i < arr . length ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } } } return - 1 ; }

55.09
58.0
68.49
73.51
def numberOfPaths ( m , n ) : count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] for i in range ( m ) : count [ i ] [ 0 ] = 1 ; for j in range ( n ) : count [ 0 ] [ j ] = 1 ; for i in range ( 1 , m ) : for j in range ( n ) : count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] return count [ m - 1 ] [ n - 1 ]

static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }

static int numberOfPaths ( int m , int n ) { int [ ] [ ] count = new int [ m ] [ n ] [ ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ 0 ] [ n ] ; }

static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) { count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } } return count [ m - 1 ] [ n - 1 ] ; }

55.09
64.98
53.7
50.76
def sortString ( str , n ) : new_str = "" for i in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : for j in range ( n ) : if ( str [ j ] == chr ( i ) ) : new_str += str [ j ] return new_str

static String sortString ( String str , int n ) { String new_str = "" ; for ( int i = 'a' ; i <= 'z' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str . charAt ( j ) == i ) new_str += str . charAt ( j ) ; return new_str ; }

static String sortString ( String str , int n ) { String new_str = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str [ j ] == chr ( i ) ) { new_str += str [ j ] ; } } return new_str ; } return str ; }

static String sortString ( String str , int n ) { String new_str = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] == chr ( i ) ) new_str += str [ j ] ; } } return new_str ; }

55.11
66.96
73.86
80.82
def addOne ( x ) : m = 1 while ( x & m ) : x = x ^ m m <<= 1 x = x ^ m return x

static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }

static int addOne ( int x ) { int m = 1 ; while ( x & m ) { m <<= 1 ; x = x ^ m ; } return x ; }

static int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; x = x ^ m ; x = x ^ m ; } return x ; }

55.13
54.51
60.34
72.13
def countPairs ( str1 ) : result = 0 ; n = len ( str1 ) for i in range ( 0 , n ) : for j in range ( 1 , MAX_CHAR + 1 ) : if ( ( i + j ) < n ) : if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : result += 1 ; return result

static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; ( i + j ) < n && j <= MAX_CHAR ; j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ; return result ; }

static int countPairs ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( str . charAt ( i ) - 'a' ) == j ) ) { result += 1 ; } } } return result ; }

static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j < MAX_CHAR + 1 ; j ++ ) { if ( ( i + j ) < n ) { if ( ( abs ( ord ( str [ i + j ] ) - ord ( str [ i ] ) ) == j ) ) { result ++ ; } } } } return result ; }

55.17
55.52
41.14
59.28
def printPascal ( n : int ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for line in range ( 0 , n ) : for i in range ( 0 , line + 1 ) : if ( i is 0 or i is line ) : arr [ line ] [ i ] = 1 print ( arr [ line ] [ i ] , end = "" ) else : arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) print ( arr [ line ] [ i ] , end = "" ) print ( "\n" , end = "" )

public static void printPascal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( "" ) ; } }

static void printPascal ( int n : int ) -> void { int [ ] [ ] arr = new int [ n ] [ n ] [ ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ line ] [ i ] == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = ( arr [ line

static void printPascal ( int n ) { int arr [ ] = new int [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i is 0 or i is line ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) ; else arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) ; } } for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i is 0 or i is line ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) ; } } print ( arr [ line ] [ i ] , end = "" ) ; } }

55.21
52.17
79.44
79.52
def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len

static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }

static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int min_len = arr . length - 1 ; int start = 0 ; int end = 0 ; while ( start < n ) { int curr_sum = arr [ start ] ; start += 1 while ( curr_sum > x and start < n ) { if ( end - start < min_len ) { min_len = end - start ; curr_sum -= arr [

static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 ; int min_len = n + 1 ; int start = 0 ; int end = 0 ; while ( curr_sum <= x && end < n ) { curr_sum += arr [ end ] ; end ++ ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start curr_sum -= arr [ start ] ; start ++ ; } } return min_len ; }

55.26
52.09
62.32
62.15
def kPrimeFactor ( n , k ) : while ( n % 2 == 0 ) : k = k - 1 n = n / 2 if ( k == 0 ) : return 2 i = 3 while i <= math . sqrt ( n ) : while ( n % i == 0 ) : if ( k == 1 ) : return i k = k - 1 n = n / i i = i + 2 if ( n > 2 and k == 1 ) : return n return - 1

static int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }

static int kPrimeFactor ( int n , int k ) { int i = 2 ; while ( i <= math . sqrt ( n ) ) { while ( n % i == 0 ) { if ( k == 1 ) return i k = k - 1 n = n / i i = i + 2 ; if ( n > 2 and k == 0 ) return i k = k - 1 n = n / i ; i = i + 2 ; if ( k == 1 ) return

static int kPrimeFactor ( int n , int k ) { int i = 3 ; while ( i <= math . sqrt ( n ) ) { while ( n % i == 0 ) { while ( i <= math . sqrt ( n ) ) { if ( k == 1 ) return i ; k = k - 1 ; n = n / i ; i = i + 2 ; if ( n > 2 && k == 1 ) return n ; } } return - 1 ; } }

55.27
51.13
51.22
66.06
def countSolutions ( n ) : x = 0 res = 0 yCount = 0 while ( yCount * yCount < n ) : yCount = yCount + 1 while ( yCount != 0 ) : res = res + yCount x = x + 1 while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : yCount = yCount - 1 return res

static int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }

static int countSolutions ( int n ) { int res = 0 ; int yCount = 0 ; while ( yCount * yCount < n ) { yCount = yCount + 1 ; while ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) { yCount = yCount - 1 ; x = x + 1 ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( y

static int countSolutions ( int n ) { int x = 0 ; int res = 0 ; int yCount = 0 ; while ( yCount * yCount < n ) { yCount = yCount + 1 ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount = yCount - 1 ; x = x + 1 ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount = yCount - 1 ; } return res ; }

55.28
52.03
58.16
52.48
def findPairs ( arr1 , arr2 , n , m , x ) : s = set ( ) for i in range ( 0 , n ) : s . add ( arr1 [ i ] ) for j in range ( 0 , m ) : if ( ( x - arr2 [ j ] ) in s ) : print ( ( x - arr2 [ j ] ) , '' , arr2 [ j ] )

public static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( arr1 [ i ] , 0 ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . containsKey ( x - arr2 [ j ] ) ) System . out . println ( x - arr2 [ j ] + " " + arr2 [ j ] ) ; }

static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( ( x - arr2 [ j ] ) in s ) { if ( ( arr2 [ j ] ) in s ) {

static void findPairs ( int arr1 , int arr2 , int n , int m , int x ) { Set s = new HashSet ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( x - arr2 [ j ] ) in s ) { print ( ( x - arr2 [ j ] ) , '' , arr2 [ j ] ) ; } } } }

55.29
71.22
73.8
80.11
def firstNonRepeating ( arr , n ) : for i in range ( n ) : j = 0 while ( j < n ) : if ( i != j and arr [ i ] == arr [ j ] ) : break j += 1 if ( j == n ) : return arr [ i ] return - 1

static int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }

static int firstNonRepeating ( int arr [ ] , int n ) { int i = 0 ; for ( int j = 0 ; j < n ; i ++ ) { if ( i == j ) return arr [ i ] ; j += 1 if ( j == n ) return arr [ i ] ; j += 1 if ( j == n ) return arr [ i ] ; j += 1 if ( j == n ) return arr [ i ] ; } return - 1 ; }

static int firstNonRepeating ( int arr [ ] , int n ) { int i = 0 ; for ( int j = 0 ; j < n ; i ++ ) { if ( i != j && arr [ i ] == arr [ j ] ) return arr [ i ] ; if ( j == n ) return arr [ i ] ; if ( j == n ) return arr [ i ] ; } return - 1 ; }

55.35
64.07
61.33
63.13
def findElements ( arr , n ) : for i in range ( n ) : count = 0 for j in range ( 0 , n ) : if arr [ j ] > arr [ i ] : count = count + 1 if count >= 2 : print ( arr [ i ] , end = "" )

static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " " ) ; } }

static void findElements ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ j ] ) count = count + 1 ; if ( count >= 2 ) print ( arr [ i ] , end = "" ) ; if ( count >= 2 ) print ( arr [ j ] , end = "" ) ; if ( count >= 2 ) print ( arr [

static void findElements ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ n - 1 ] ) { count = count + 1 ; if ( count >= 2 ) print ( arr [ i ] , end = "" ) ; } } }

55.4
49.12
73.31
78.87
def pow ( a , b ) : if ( b == 0 ) : return 1 answer = a increment = a for i in range ( 1 , b ) : for j in range ( 1 , a ) : answer += increment increment = answer return answer

static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }

static int pow ( int a , int b ) { int answer = 0 ; int increment = 0 ; for ( int i = 1 ; i <= b ; i ++ ) { for ( int j = 1 ; j <= a ; j ++ ) { answer += increment increment = answer ; } } return answer ; }

static int pow ( int a , int b ) { int answer = a ; int increment = a ; for ( int i = 1 ; i <= b ; i ++ ) { if ( b == 0 ) return 1 ; for ( int j = 1 ; j <= a ; j ++ ) { answer += increment ; increment = answer ; } } return answer ; }

55.54
58.34
53.42
58.46
def findLength ( string , n ) : current_sum = 0 max_sum = 0 for i in range ( n ) : current_sum += ( 1 if string [ i ] == '0' else - 1 ) if current_sum < 0 : current_sum = 0 max_sum = max ( current_sum , max_sum ) return max_sum if max_sum else 0

public static int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }

static int findLength ( String string , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( string [ i ] == '0' ) current_sum = 0 ; if ( current_sum < 0 ) current_sum = 0 ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = max ( current_sum , max_

static int findLength ( String string , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += 1 ; if ( string [ i ] == '0' ) current_sum = 0 ; else if ( string [ i ] == '0' ) current_sum = 0 ; else if ( string [ i ] == '0' ) current_sum = 0 ; else max_sum = max ( current_sum , max_sum ) ; } return current_sum ; }

55.58
62.86
79.62
78.59
def gcd ( a , b ) : if ( a < b ) : return gcd ( b , a ) if ( abs ( b ) < 0.001 ) : return a else : return ( gcd ( b , a - math . floor ( a / b ) * b ) )

static double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }

static int gcd ( int a , int b ) { if ( a < b ) return ( gcd ( b , a - math . floor ( a / b ) * b ) ) ; return ( gcd ( b , a - math . floor ( a / b ) * b ) ) ; } return a ; }

static int gcd ( int a , int b ) { if ( a < b ) return gcd ( b , a ) ; if ( abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - math . floor ( a / b ) * b ) ) ; }

55.6
67.37
31.04
43.97
def isPrime ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return True if ( n % 2 == 0 or n % 3 == 0 ) : return False i = 5 while ( i * i <= n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return False i = i + 6 return True

static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }

static boolean isPrime ( int n ) { if ( n <= 2 ) return true ; if ( n <= 3 ) return false ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) return false ; if ( n % i == 0 ) return false ; if ( n % i == 0 ) return false ; if ( n % i == 0 ) return false ; if ( n % i == 0 ) return false ; if

public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 2 ) return true ; if ( n <= 3 ) return true ; if ( n <= 4 ) return true ; if ( n <= 5 ) return true ; if ( n <= 6 ) return true ; if ( n <= 7 ) return true ; if ( n <= 8 ) return true ; if ( n <= 9 ) return true ; if ( n <= 10 ) return true ; if ( n <= 11 ) return true ; if ( n <= 12 ) return true ; return false ; }

55.63
51.32
57.23
52.78
def areAnagram ( str1 , str2 ) : n1 = len ( str1 ) n2 = len ( str2 ) if n1 != n2 : return 0 str1 = sorted ( str1 ) str2 = sorted ( str2 ) for i in range ( 0 , n1 ) : if str1 [ i ] != str2 [ i ] : return 0 return 1

static boolean areAnagram ( char [ ] str1 , char [ ] str2 ) { int n1 = str1 . length ; int n2 = str2 . length ; if ( n1 != n2 ) return false ; Arrays . sort ( str1 ) ; Arrays . sort ( str2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; }

static int areAnagram ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] != str2 [ i ] : return 0 ; } return 1 ; } return 0 ; }

static int areAnagram ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) return 0 ; } return 1 ; }

55.76
59.39
63.39
63.96
def CountTriangles ( A ) : n = len ( A ) A . sort ( ) count = 0 for i in range ( n - 1 , 0 , - 1 ) : l = 0 r = i - 1 while ( l < r ) : if ( A [ l ] + A [ r ] > A [ i ] ) : count += r - l r -= 1 else : l += 1 print ( "Noofpossiblesolutions:" , count )

static void CountTriangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } System . out . print ( "No of possible solutions: " + count ) ; }

static int CountTriangles ( int [ ] A ) { int n = A . length ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int l = 0 ; int r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) count += l - r ; else count += r - l ; } } return count ; }

static void CountTriangles ( int A [ ] ) { int n = A . length ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int l = 0 ; int r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -= 1 ; } else { l ++ ; } } } return count ; }

55.88
57.22
74.05
82.9
def pad ( n ) : pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 for i in range ( 3 , n + 1 ) : pNext = pPrevPrev + pPrev pPrevPrev = pPrev pPrev = pCurr pCurr = pNext return pNext ;

static int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }

static int pad ( int n ) { int pPrevPrev , pPrev , pCurr , pNext ; for ( int i = 0 ; i < n ; i ++ ) { pPrevPrev = pPrevPrev + pPrev ; pPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pPrev ; pPrev = pPrev ; pPrev =

static int pad ( int n ) { int pPrevPrev = 1 ; int pPrev = 1 ; int pPrev = 1 ; int pCurr = 1 ; int pNext = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }

55.9
69.4
95.67
97.84
def countDer ( n ) : if ( n == 1 ) : return 0 if ( n == 0 ) : return 1 if ( n == 2 ) : return 1 return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )

static int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 0 ) return 1 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }

static int countDer ( int n ) { if ( n == 2 ) return countDer ( n - 1 ) + countDer ( n - 2 ) ; return countDer ( n - 1 ) + countDer ( n - 2 ) ; } return 0 ; }

static int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }

55.99
65.11
62.86
69.59
def section ( x1 , x2 , y1 , y2 , m , n ) : x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) print ( x , y )

static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; System . out . println ( "(" + x + ", " + y + ")" ) ; }

static void section ( int x1 , int x2 , int y1 , int y2 , int m , int n ) { float x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; float y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; print ( x , y ) ; }

static void section ( float x1 , float x2 , float y1 , float y2 , int m , int n ) { x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; System . out . println ( x , y ) ; }

56.05
62.65
71.47
87.83
def isPower ( x , y ) : if ( x == 1 ) : return ( y == 1 ) pow = 1 while ( pow < y ) : pow = pow * x return ( pow == y )

public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }

static boolean isPower ( int x , int y ) { int pow = 1 ; while ( pow < x ) { pow = pow * x + 1 ; } return ( pow == y ) ; }

static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) { pow = pow * x ; if ( pow == 1 ) return ( pow == y ) ; } return ( pow == y ) ; }

56.17
73.39
69.25
74.13
def dealnnoy ( n , m ) : if ( m == 0 or n == 0 ) : return 1 return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 )

public static int dealnnoy ( int n , int m ) { if ( m == 0 || n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }

static int dealnnoy ( int n , int m ) { int dealnnoy ( int m , int n ) { if ( m == 0 ) return 0 ; return dealnnoy ( n - 1 , m - 1 ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy (

static int dealnnoy ( int m , int n ) { if ( m == 0 || n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m , n - 1 ) ; }

56.23
68.21
66.81
67.04
def area_of_segment ( radius , angle ) : area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) area_of_triangle = 1 / 2 * ( radius * radius ) * math . sin ( ( angle * pi ) / 180 ) return area_of_sector - area_of_triangle ;

static float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }

static double area_of_segment ( double radius , double angle ) { double area_of_sector = pi * ( radius * radius ) * ( angle / 180 ) ; double area_of_triangle = 1 / 2 * ( radius * radius ) * math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector + area_of_triangle ; }  def area_of_segment ( double radius , double angle ) {

static int area_of_segment ( int radius , int angle ) { int area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; int area_of_triangle = 1 / 2 * ( radius * radius ) * math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }

56.28
59.8
38.73
42.41
def shiftMatrixByK ( mat , k ) : if ( k > N ) : print ( "shiftingis""notpossible" ) return j = 0 while ( j < N ) : for i in range ( k , N ) : print ( "{}" . format ( mat [ j ] [ i ] ) , end = "" ) for i in range ( 0 , k ) : print ( "{}" . format ( mat [ j ] [ i ] ) , end = "" ) print ( "" ) j = j + 1

static void shiftMatrixByK ( int [ ] [ ] mat , int k ) { if ( k > N ) { System . out . print ( "Shifting is" + " not possible" ) ; return ; } int j = 0 ; while ( j < N ) { for ( int i = k ; i < N ; i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ; System . out . println ( ) ; j ++ ; } }

static void shiftMatrixByK ( int mat [ ] [ ] , int k ) { System . out . print ( mat [ j ] [ i ] + " " ) ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( mat [ j ] [ i ] + " " ) ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( mat [ j ] [ i ] +

static void shiftMatrixByK ( int mat [ ] [ ] , int k ) { int j = 0 ; while ( j < N ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < k ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = 0 ; i < k ; i ++ ) { mat [ j ] [ i ] = mat [ j ] [ i ] ; } } } } } } } }

56.37
53.64
42.17
51.76
def count ( n ) : table = [ 0 for i in range ( n + 1 ) ] table [ 0 ] = 1 for i in range ( 3 , n + 1 ) : table [ i ] += table [ i - 3 ] for i in range ( 5 , n + 1 ) : table [ i ] += table [ i - 5 ] for i in range ( 10 , n + 1 ) : table [ i ] += table [ i - 10 ] return table [ n ]

static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }

static int count ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { table [ i ] += table [ i - 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { table [ i ] += table [ i -

static int count ( int n ) { int table [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] += table [ i - 10 ] ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( int i = 0 ; i < n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }

56.45
61.93
78.02
74.63
def findNth ( n ) : nthElement = 19 + ( n - 1 ) * 9 outliersCount = int ( math . log10 ( nthElement ) ) - 1 nthElement += 9 * outliersCount return nthElement

public static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; }

static int findNth ( int n ) { int nthElement = 19 + n * 9 ; int outliersCount = int ( math . log10 ( nthElement ) ) - 1 ; nthElement += 9 * outliersCount ; }  def findNth ( int n ) { int nthElement = 19 + n * 9 ; return nthElement ; }

static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = int . log10 ( nthElement ) ; nthElement += 9 * outliersCount ; return nthElement ; }

56.46
54.81
63.05
68.47
def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : principal += mat [ i ] [ i ] secondary += mat [ i ] [ n - i - 1 ] print ( "PrincipalDiagonal:" , principal ) print ( "SecondaryDiagonal:" , secondary )

static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } System . out . println ( "Principal Diagonal:" + principal ) ; System . out . println ( "Secondary Diagonal:" + secondary ) ; }

static void printDiagonalSums ( int mat [ ] [ ] , int n ) { int principal = 0 ; int secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i - 1 ] ; secondary += mat [ i ] [ i - 1 ] ; } }

static void printDiagonalSums ( int [ ] mat , int n ) { int principal = 0 ; int secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } }

56.47
52.74
71.21
60.51
def fix ( A , len ) : for i in range ( 0 , len ) : if ( A [ i ] != - 1 and A [ i ] != i ) : x = A [ i ] while ( A [ x ] != - 1 and A [ x ] != x ) : y = A [ x ] A [ x ] = x x = y A [ x ] = x if ( A [ i ] != i ) : A [ i ] = - 1

public static int [ ] fix ( int [ ] A ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ] ; while ( A [ x ] != - 1 && A [ x ] != x ) { int y = A [ x ] ; A [ x ] = x ; x = y ; } A [ x ] = x ; if ( A [ i ] != i ) { A [ i ] = - 1 ; } } } return A ; }

static void fix ( int A [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; while ( A [ x ] != - 1 and A [ x ] != x ) { int y = A [ x ] ; A [ x ] = y ; A [ x ] = x ; if ( A [ x ] != - 1 and A [ x ] != x ) { x = A [ x ] ; } } } }

; for ( int i = 0 ; i < len ; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ] ; while ( A [ x ] != - 1 && A [ x ] != x ) { y = A [ x ] ; A [ x ] = x ; x = y ; A [ x ] = x ; } if ( A [ i ] != - 1 && A [ i ] != x ) { y = A [ i ] ; A [ i ] = x ; x = y ; A [ i ] = x ; } } } return A ; }

56.56
56.49
53.44
55.8
def removeDuplicates ( S ) : n = len ( S ) if ( n < 2 ) : return j = 0 for i in range ( n ) : if ( S [ j ] != S [ i ] ) : j += 1 S [ j ] = S [ i ] j += 1 S = S [ : j ] return S

static void removeDuplicates ( char [ ] S ) { int n = S . length ; if ( n < 2 ) { return ; } int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } System . out . println ( Arrays . copyOfRange ( S , 0 , j + 1 ) ) ; }

static void removeDuplicates ( int [ ] S ) { int n = S . length ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j += 1 S [ j ] = S [ i ] ; j += 1 } return ; } return ; } }

static int removeDuplicates ( int S [ ] ) { int n = S . length ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) j ++ ; S [ j ] = S [ i ] ; j ++ ; S = S [ : j ] ; } return S ; }

56.57
60.09
62.18
62.32
def countTrees ( n ) : BT = [ 0 ] * ( n + 1 ) BT [ 0 ] = BT [ 1 ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( i ) : BT [ i ] += BT [ j ] * BT [ i - j - 1 ] return BT [ n ]

static int countTrees ( int n ) { int BT [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BT [ i ] = 0 ; BT [ 0 ] = BT [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ; return BT [ n ] ; }

static int countTrees ( int n ) { int BT [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ; } return BT [ n ] ; } }

static int countTrees ( int n ) { int BT [ ] = new int [ n + 1 ] ; int BT [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ; } return BT [ n ] ; } }

56.65
48.83
59.59
54.73
def maxSum ( arr , N , k ) : MS = [ 0 for i in range ( N ) ] MS [ N - 1 ] = arr [ N - 1 ] for i in range ( N - 2 , - 1 , - 1 ) : if ( i + k + 1 >= N ) : MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) else : MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) return MS [ 0 ]

static int maxSum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }

static int maxSum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ arr . length - 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i + k + 1 >= arr . length ) MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + k + 1 ] ) ; } return MS [ 0 ] ; }

static int maxSum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { MS [ i ] = arr [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( i + k + 1 >= N ) { MS [ i ] = arr [ i ] ; } else { MS [ i ] = arr [ i ] + MS [ i + k + 1 ] ; } } } return MS [ 0 ] ; }

56.77
63.79
43.66
57.35
def check ( st ) : n = len ( st ) digitSum = 0 for i in range ( 0 , n ) : digitSum = digitSum + ( int ) ( st [ i ] ) return ( digitSum % 9 == 0 )

static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; }

static boolean check ( String st ) { int n = st . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digitSum = digitSum + ( int ) ( st [ i ] ) ; } return false ; }

static boolean check ( int st [ ] ) { int n = st . length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digitSum = digitSum + ( int ) st [ i ] ; digitSum = digitSum + ( int ) st [ i ] ; if ( digitSum % 9 == 0 ) return true ; } return false ; }

56.89
50.43
84.9
75.07
def maxPathSum ( tri , m , n ) : for i in range ( m - 1 , - 1 , - 1 ) : for j in range ( i + 1 ) : if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : tri [ i ] [ j ] += tri [ i + 1 ] [ j ] else : tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] return tri [ 0 ] [ 0 ]

static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }

static int maxPathSum ( int [ ] tri [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( tri [ i ] [ j ] > tri [ i ] [ j + 1 ] ) { tri [ i ] [ j ] += tri [ i ] [ j + 1 ] ; } } return - 1 ; }

static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < tri [ i + 1 ] . length ; j ++ ) { if ( tri [ i ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }

56.91
75.11
63.28
76.25
def findSum ( N ) : ans = 0 for i in range ( 1 , N + 1 ) : for j in range ( 1 , N + 1 ) : ans += i // j return ans

static int findSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) ans += ( i / j ) ; return ans ; }

static int findSum ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i % j == 0 ) ans += i % j ; } } return ans ; }

static int findSum ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { ans += i * j ; } return ans ; } }

56.91
63.41
60.47
72.99
def divSum ( num ) : result = 0 i = 2 while i <= ( math . sqrt ( num ) ) : if ( num % i == 0 ) : if ( i == ( num / i ) ) : result = result + i ; else : result = result + ( i + num / i ) ; i = i + 1 return ( result + 1 ) ;

static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; }

static int divSum ( int num ) { int result = 0 ; int i = 2 ; while ( i <= ( math . sqrt ( num ) ) ) { if ( i == ( num / i ) ) { result = result + i ; } else { result = result + ( i + num / i ) ; i = i + 1 ; } } return result ; }

static int divSum ( int num ) { int result = 0 ; int i = 2 ; while ( i <= ( math . sqrt ( num ) ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result = result + i ; else result = result + ( i + num / i ) ; } else result = result + ( i + num / i ) ; i = i + 1 ; } return ( result + 1 ) ; }

56.93
62.05
38.09
56.54
def replace ( s , c1 , c2 ) : l = len ( s ) for i in range ( l ) : if ( s [ i ] == c1 ) : s = s [ 0 : i ] + c2 + s [ i + 1 : ] elif ( s [ i ] == c2 ) : s = s [ 0 : i ] + c1 + s [ i + 1 : ] return s

static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return String . valueOf ( arr ) ; }

static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s = s [ 0 : i ] + c2 + s [ i + 1 : ] ; else if ( s [ i ] == c2 ) s = s [ 0 : i ] + c1 + s [ i + 1 : ] ; } return s ; }

; } static int replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s = s [ 0 : i ] + c2 + s [ i + 1 ] ; else if ( s [ i ] == c2 ) s = s [ 0 : i ] + c1 + s [ i + 1 ] ; else if ( s [ i ] == c1 ) s = s [ 0 : i ] + c1 + s [ i + 1 ] ; else s = s [ 0 : i ] + c2 + s [ i + 1 ] ; } return s ; }

56.96
59.49
73.01
70.6
def countWays ( n ) : dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] dp [ 0 ] [ 1 ] = 1 dp [ 1 ] [ 1 ] = 2 for i in range ( 2 , n + 1 ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]

static long countWays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }

static int countWays ( int n ) { int dp [ ] [ ] = new int [ 2 ] * ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] * 2 + dp [ 0 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }

; } static int countWays ( int n ) { int dp [ ] [ ] = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; dp [ 1 ] [ i ] = 2 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }

56.99
53.23
60.21
52.54
def countWays ( n ) : DP = [ 0 for i in range ( 0 , n + 1 ) ] DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 DP [ 3 ] = 2 for i in range ( 4 , n + 1 ) : DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] return DP [ n ]

static int countWays ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ; return DP [ n ] ; }

static int countWays ( int n ) { int DP [ ] = new int [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ; } return DP [ n ] ; }

static int countWays ( int n ) { int DP [ ] = new int [ n ] ; int DP [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i - 2 ] + DP [ i - 3 ] + DP [ i - 4 ] ; DP [ i ] = DP [ i - 5 ] + DP [ i - 6 ] ; } return DP [ n ] ; }

57.02
56.17
46.98
48.73
def findMaxAverage ( arr , n , k ) : if ( k > n ) : return - 1 sum = arr [ 0 ] for i in range ( 1 , k ) : sum += arr [ i ] max_sum = sum max_end = k - 1 for i in range ( k , n ) : sum = sum + arr [ i ] - arr [ i - k ] if ( sum > max_sum ) : max_sum = sum max_end = i return max_end - k + 1

static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }

static int findMaxAverage ( int arr [ ] , int n , int k ) { int sum = 0 ; int max_sum = 0 ; int max_end = k - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return - 1 ; }

static int findMaxAverage ( int arr [ ] , int n , int k ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) { sum += arr [ i ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }

57.02
51.11
71.5
75.35
def winner ( a , n , k ) : if k >= n - 1 : return n best = 0 times = 0 for i in range ( n ) : if a [ i ] > best : best = a [ i ] if i == True : times = 1 else : times += 1 if times >= k : return best return best

static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }

static int winner ( int [ ] a , int n , int k ) { int best = 0 ; int times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] if ( i == true ) times = 1 ; else times ++ ; } } return n ; }

static int winner ( int a [ ] , int n , int k ) { int best = 0 ; int times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) best = a [ i ] ; if ( i == true ) times = 1 ; else times ++ ; if ( times >= k ) return best ; } return n ; }

57.03
50.64
58.79
58.32
def gnomeSort ( arr , n ) : index = 0 while index < n : if index == 0 : index = index + 1 if arr [ index ] >= arr [ index - 1 ] : index = index + 1 else : arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] index = index - 1 return arr

static void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; }

static int gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < arr . length ) { if ( index == 0 ) index = index + 1 if ( arr [ index ] >= arr [ index - 1 ] ) index = index - 1 ; else arr [ index ] , arr [ index ] = arr [ index - 1 ] , arr [ index ] ; else arr [ index ] , arr [ index ] = arr [ index ] , arr [ index ] ; } return arr ; }

private static int gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( arr [ index ] >= arr [ index - 1 ] ) index = index + 1 ; else arr [ index ] , arr [ index - 1 ] = arr [ index ] , arr [ index ] ; index = index + 1 ; } return arr ; }

57.1
51.86
64.31
55.86
def findSmallestDifference ( A , B , m , n ) : A . sort ( ) B . sort ( ) a = 0 b = 0 result = sys . maxsize while ( a < m and b < n ) : if ( abs ( A [ a ] - B [ b ] ) < result ) : result = abs ( A [ a ] - B [ b ] ) if ( A [ a ] < B [ b ] ) : a += 1 else : b += 1 return result

static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }

static int findSmallestDifference ( int [ ] A , int [ ] B , int m , int n ) { int a = 0 ; int b = 0 ; int result = sys . maxsize ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) { result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) {

static int findSmallestDifference ( int A , int B , int m , int n ) { int a = 0 ; int b = 0 ; int result = sys . maxsize ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) { result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) { a ++ ; } else { b ++ ; } } } return result ; }

57.12
71.4
81.64
85.25
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int K [ ] [ ] = new int [ W + 1 ] [ n ] ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = wt [ i - 1 ] ; w <= w ; w ++ ) { if ( i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] [ w ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] [ W ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int w = wt [ i - 1 ] ; w ++ ) { K [ i ] [ w ] = K [ i ] [ w ] + K [ w - wt [ i - 1 ] [ w ] + K [ w - wt [ i - 1 ] ; w ] ; } } return K [ n ] [ w ] ; } return K [ n ] [ W ] [ W ] [

static int knapSack ( int W , int wt , int val [ ] , int n ) { int [ ] K = new int [ W + 1 ] ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = 0 ; w < W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = 0 ; else if ( val [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

57.12
71.4
81.64
85.25
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int K [ ] [ ] = new int [ W + 1 ] [ n ] ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = wt [ i - 1 ] ; w <= w ; w ++ ) { if ( i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] [ w ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] [ W ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int w = wt [ i - 1 ] ; w ++ ) { K [ i ] [ w ] = K [ i ] [ w ] + K [ w - wt [ i - 1 ] [ w ] + K [ w - wt [ i - 1 ] ; w ] ; } } return K [ n ] [ w ] ; } return K [ n ] [ W ] [ W ] [

static int knapSack ( int W , int wt , int val [ ] , int n ) { int [ ] K = new int [ W + 1 ] ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = 0 ; w < W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = 0 ; else if ( val [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

57.12
71.4
81.64
85.25
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int K [ ] [ ] = new int [ W + 1 ] [ n ] ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = wt [ i - 1 ] ; w <= w ; w ++ ) { if ( i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] [ w ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] [ W ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int w = wt [ i - 1 ] ; w ++ ) { K [ i ] [ w ] = K [ i ] [ w ] + K [ w - wt [ i - 1 ] [ w ] + K [ w - wt [ i - 1 ] ; w ] ; } } return K [ n ] [ w ] ; } return K [ n ] [ W ] [ W ] [

static int knapSack ( int W , int wt , int val [ ] , int n ) { int [ ] K = new int [ W + 1 ] ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = 0 ; w < W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = 0 ; else if ( val [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }

57.15
62.66
15.15
31.18
def zigzag ( n , k ) : if ( n == 0 and k == 0 ) : return 1 if ( k == 0 ) : return 0 return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k )

static int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }

static int zigzag ( int n , int k ) { if ( n == 0 ) return 1 return zigzag ( n - 1 , k ) + zigzag ( n - 1 , k ) ; } return 0 ; }

static int zigzag ( int n , int k ) { return zigzag ( n , k ) ; }

57.15
50.81
40.92
59.76
def assign ( a , n ) : a . sort ( ) ans = [ 0 ] * n p = 0 q = n - 1 for i in range ( n ) : if ( i + 1 ) % 2 == 0 : ans [ i ] = a [ q ] q = q - 1 else : ans [ i ] = a [ p ] p = p + 1 for i in range ( n ) : print ( ans [ i ] , end = "" )

static void assign ( int a [ ] , int n ) { Arrays . sort ( a ) ; int ans [ ] = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ; else ans [ i ] = a [ p ++ ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }

static void assign ( int [ ] a , int n ) { int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ p ] ; p = p - 1 ; else ans [ i ] = a [ p ] ; else ans [ i ] = a [ p ] ; } for ( int i = 0 ; i <

static void assign ( int [ ] a , int n ) { int ans [ ] = new int [ n ] ; int p = 0 ; int q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + 1 ) { ans [ i ] = a [ p ] ; p = p - 1 ; } else { ans [ i ] = a [ p ] ; p = p - 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = a [ p ] ; p = p + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = a [ p ] ; p = p + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = a [ p ] ; p = p + 1 ; } } return ; }

57.16
77.91
81.52
87.36
def middleOfThree ( a , b , c ) : if a > b : if ( b > c ) : return b elif ( a > c ) : return c else : return a else : if ( a > c ) : return a elif ( b > c ) : return c else : return b

public static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }

static int middleOfThree ( int a , int b , int c ) { if ( a > c ) return a ; if ( b > c ) return b ; if ( a > c ) return a ; if ( b > c ) return b ; if ( a > c ) return c ; if ( b > c ) return a ; if ( a > b ) return b ; if ( b > c ) return c ; else return a ; if ( a > b )

; public static int middleOfThree ( int a , int b , int c ) { if ( a > b ) return b ; if ( b > c ) return c ; else if ( a > c ) return a ; else if ( b > c ) return b ; else if ( c > a ) return c ; else return a ; }

57.25
55.1
64.52
57.62
def noAdjacentDup ( s ) : n = len ( s ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = "a" while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 return s

public static String noAdjacentDup ( String s1 ) { int n = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = 'a' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }

static String noAdjacentDup ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = "a" ; while ( s [ i ] == s [ i + 1 ] ) { s [ i ] = "a" ; while ( s [ i ] == s [ i + 1 ] ) {

static int noAdjacentDup ( String s [ ] ) { int n = s . length ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) s [ i ] = "a" ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] += 1 ; } return s ; }

57.32
73.26
94.82
95.5
def eulerian ( n , m ) : if ( m >= n or n == 0 ) : return 0 if ( m == 0 ) : return 1 return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) )

public static int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }

static int eulerian ( int n , int m ) { if ( m >= n ) return 0 if ( n == 0 ) return 1 return ( n - m ) * eulerian ( n - 1 , m ) + ( m + 1 ) * eulerian ( n - 1 , m ) + ( n + 1 ) * eulerian ( n - 1 , m ) + ( m + 1 ) * eulerian ( n - 1 , m ) +

static int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) ; }

57.34
59.69
58.35
56.52
def count ( a , b ) : m = len ( a ) n = len ( b ) lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( n + 1 ) : lookup [ 0 ] [ i ] = 0 for i in range ( m + 1 ) : lookup [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if a [ i - 1 ] == b [ j - 1 ] : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] else : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] return lookup [ m ] [ n ]

static int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }

static int count ( int [ ] a , int [ ] b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] + lookup [ i - 1 ] == b [ j - 1 ] ; } return lookup [ m ] [ n ] [ j ] ; } return lookup [ m ] [ n ] ; } }

static int count ( int [ ] a , int [ ] b ) { int m = len ( a ) ; int n = len ( b ) ; int lookup [ ] [ 0 ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j - 1 ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }

57.51
59.75
47.9
53.57
def maxDecimalValue ( mat , i , j , p ) : if i >= N or j >= N : return 0 result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) if mat [ i ] [ j ] == 1 : return pow ( 2 , p ) + result else : return result

static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N || j >= N ) { return 0 ; } int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( int ) ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } }

static int maxDecimalValue ( int mat [ ] , int i , int j , int p ) { int result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j + 1 , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return result ; }

static int maxDecimalValue ( double [ ] mat , int i , int j , int p ) { if ( i >= N || j >= N ) return 0 ; int result = maxDecimalValue ( mat , i , j , p + 1 ) ; if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; }

57.52
51.81
61.19
56.14
def countBT ( h ) : MOD = 1000000007 dp = [ 0 for i in range ( h + 1 ) ] dp [ 0 ] = 1 dp [ 1 ] = 1 for i in range ( 2 , h + 1 ) : dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD return dp [ h ]

public static long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }

static int countBT ( int h ) { int dp [ ] = new int [ 2 ] ; for ( int i = 1 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ; } return dp [ h ] ; }

static int countBT ( int h ) { int MOD = 1000000007 ; int dp [ ] = new int [ 2 ] ; for ( int i = 0 ; i < h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; } return dp [ h ] ; }

57.56
57.38
68.76
67.05
def minRotation ( input , unlock_code ) : rotation = 0 while ( input > 0 or unlock_code > 0 ) : input_digit = input % 10 code_digit = unlock_code % 10 rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) input = int ( input / 10 ) unlock_code = int ( unlock_code / 10 ) return rotation

static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 || unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }

static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; while ( input > 0 or unlock_code > 0 ) { int input_digit = input % 10 ; int code_digit = unlock_code / 10 ; rotation += abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; } return rotation ; }

static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; while ( input > 0 || unlock_code > 0 ) { int input_digit = input % 10 ; int code_digit = unlock_code % 10 ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input = int ( input / 10 ) ; unlock_code = int ( unlock_code / 10 ) ; } return rotation ; }

57.65
47.36
52.64
45.04
def find3largest ( arr , n ) : arr = sorted ( arr ) check = 0 count = 1 for i in range ( 1 , n + 1 ) : if ( count < 4 ) : if ( check != arr [ n - i ] ) : print ( arr [ n - i ] , end = "" ) check = arr [ n - i ] count += 1 else : break

void find3largest ( int [ ] arr ) { Arrays . sort ( arr ) ; int n = arr . length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } }

static int find3largest ( int arr [ ] , int n ) { int check = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check != arr [ n - i ] ) { print ( arr [ n - i ] , end = "" ) check = arr [ n - i ] ; count += 1 ; } else { if ( count < 4 ) { if ( check != arr [ n - i ] ) check = arr

static void find3largest ( int arr [ ] , int n ) { int check = 0 ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ i ] ) { if ( check != arr [ i ] ) { if ( check != arr [ i ] ) { print ( arr [ i ] , end = "" ) ; check = arr [ i ] ; count ++ ; } } else { break ; } } } } }

57.71
52.84
55.54
53.43
def minXOR ( arr , n ) : arr . sort ( ) min_xor = 999999 val = 0 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n - 1 ) : val = arr [ i ] ^ arr [ j ] min_xor = min ( min_xor , val ) return min_xor

static int minXOR ( int arr [ ] , int n ) { int min_xor = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ; return min_xor ; }

static int minXOR ( int arr [ ] , int n ) { int min_xor = 999999 ; for ( int i = 0 ; i < n ; i ++ ) { val = arr [ i ] ^ arr [ j ] ; min_xor = min ( min_xor , val ) ; } return min_xor ; }

; } static int minXOR ( int arr [ ] , int n ) { int min_xor = 999999 ; int val = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { val = arr [ i ] ^ arr [ j ] ; min_xor = min ( min_xor , val ) ; } return min_xor ; }

57.73
60.93
73.43
72.79
def dealnnoy ( n , m ) : dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] for i in range ( m ) : dp [ 0 ] [ i ] = 1 for i in range ( 1 , m + 1 ) : dp [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] return dp [ m ] [ n ]

static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }

static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; } return dp [ m ] [ n ] ; }

static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] + dp [ i ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }

57.82
53.16
51.59
67.39
def sortInWave ( arr , n ) : for i in range ( 0 , n , 2 ) : if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) : arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]

void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ; } }

static void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 and arr [ i ] > arr [ i - 1 ] ) arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] ; if ( i < n - 1 and arr [ i ] > arr [ i + 1 ] ) arr [ i ] , arr

static void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i > 0 && arr [ i - 1 ] < arr [ i + 1 ] ) arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] ; } }

57.88
60.15
64.7
64.4
def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 res = 0 sum = 0 for i in range ( position , length ) : sum = sum + int ( num [ i ] ) if ( sum >= previous_sum ) : res = res + countGroups ( i + 1 , sum , length , num ) return res

static int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }

static int countGroups ( int position , int previous_sum , int length , int [ ] num ) { int res = 0 ; int sum = 0 ; for ( int i = 0 ; i < position ; i ++ ) { if ( sum >= previous_sum ) res = res + countGroups ( i , sum , previous_sum , length , num ) ; else res = res + countGroups ( i , previous_sum , length , num ) ; } return res ;

static int countGroups ( int position , int previous_sum , int length , int num [ ] ) { int res = 0 ; int sum = 0 ; for ( int i = 0 ; i < position ; i ++ ) { sum = sum + int ( num [ i ] ) ; if ( sum >= previous_sum ) res = res + countGroups ( i + 1 , sum , length , num ) ; } return res ; }

58.01
62.49
67.72
72.75
def countLattice ( r ) : if ( r <= 0 ) : return 0 result = 4 for x in range ( 1 , r ) : ySquare = r * r - x * x y = int ( math . sqrt ( ySquare ) ) if ( y * y == ySquare ) : result += 4 return result

static int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }

static int countLattice ( int r ) { int result = 0 ; for ( int x = 1 ; x <= r ; x ++ ) { int y = int ( math . sqrt ( r * r - x * x ) ) ; if ( y * y == ySquare ) { result += 4 ; } } return result ; }

static int countLattice ( int r ) { int result = 0 ; for ( int x = 1 ; x <= r ; x ++ ) { int ySquare = r * r - x * x ; int y = int ( math . sqrt ( ySquare ) ) ; if ( y * y == ySquare ) result ++ ; } return result ; }

58.01
52.63
49.15
51.3
def longestAlternating ( arr , n ) : count = [ None ] * n count [ n - 1 ] = 1 i = n - 2 while i >= 0 : if ( arr [ i ] * arr [ i + 1 ] < 0 ) : count [ i ] = count [ i + 1 ] + 1 else : count [ i ] = 1 i = i - 1 i = 0 while i < n : print ( count [ i ] , end = "" ) i = i + 1

public static void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + " " ) ; }

static int longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; int i = 0 ; while ( i < n ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = count [ i ] + 1 ; } return

; int longestAlternating ( int arr [ ] , int n ) { int count [ ] = new int [ n ] ; int i = n - 1 ; while ( i >= 0 ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = count [ i + 1 ] + 1 ; } i = i - 1 ; } while ( i >= 0 ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; i = i - 1 ; } return count [ n - 1 ] ; }

58.05
53.29
83.37
70.83
def decimalToBinary ( N ) : B_Number = 0 cnt = 0 while ( N != 0 ) : rem = N % 2 c = pow ( 10 , cnt ) B_Number += rem * c N //= 2 cnt += 1 return B_Number

static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }

static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { B_Number += pow ( 10 , cnt ) ; N //= 2 cnt ++ ; } return B_Number ; }

static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = pow ( 10 , cnt ) ; B_Number += rem * c ; N //= 2 cnt ++ ; } return B_Number ; }

58.06
61.92
55.53
56.91
def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) count = [ 0 ] * MAX_CHAR for i in range ( n ) : count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR ) : result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) return result

static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }

static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { result += count [ i ] * ( count [ i ] + 1 ) / 2 ; } return result ; }

static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { count [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 ; } return result ; } }

58.1
55.52
59.42
57.76
def findNth ( n ) : count = 0 for curr in itertools . count ( ) : sum = 0 x = curr while ( x ) : sum = sum + x % 10 x = x // 10 if ( sum == 10 ) : count = count + 1 if ( count == n ) : return curr return - 1

public static int findNth ( int n ) { int count = 0 ; for ( int curr = 1 ; ; curr ++ ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }

static int findNth ( int n ) { int count = 0 ; for ( int curr = 0 ; curr < n ; curr ++ ) { int sum = 0 ; while ( x ) { if ( sum == 10 ) count = count + 1 ; if ( count == n ) return curr ; } } return - 1 ; }

static int findNth ( int n ) { int count = 0 ; for ( int curr = 0 ; curr < itertools . count ( ) ; curr ++ ) { int sum = 0 ; for ( int x = 0 ; x < curr ; x ++ ) { sum = sum + x % 10 ; sum = sum + x % 10 ; x = x // 10 ; if ( sum == 10 ) count = count + 1 ; if ( count == n ) return curr ; } } return - 1 ; }

58.15
52.29
73.27
62.29
def reorder ( arr , index , n ) : for i in range ( 0 , n ) : while ( index [ i ] != i ) : oldTargetI = index [ index [ i ] ] oldTargetE = arr [ index [ i ] ] arr [ index [ i ] ] = arr [ i ] index [ index [ i ] ] = index [ i ] index [ i ] = oldTargetI arr [ i ] = oldTargetE

static void reorder ( ) { for ( int i = 0 ; i < arr . length ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = ( char ) arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }

static void reorder ( int arr [ ] , int index [ ] , int n ) { int oldTargetI = arr [ index [ i ] ] ; int oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ i ] = i ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != oldTargetI ) arr [ i ] = oldTargetE ;

int index [ ] , int n ) { reorder ( arr , index , n ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { oldTargetI = arr [ index [ i ] ] ; oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ index [ i ] ] ; index [ i ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }

58.2
55.72
68.11
69.4
def printknapSack ( W , wt , val , n ) : K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] res = K [ n ] [ W ] print ( res ) w = W for i in range ( n , 0 , - 1 ) : if res <= 0 : break if res == K [ i - 1 ] [ w ] : continue else : print ( wt [ i - 1 ] ) res = res - val [ i - 1 ] w = w - wt [ i - 1 ]

static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + " " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }

static void printknapSack ( int W , int [ ] wt , int [ ] val , int n ) { int [ ] K [ ] [ ] = new int [ W + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int w = W ; w <= w ; w ++ ) { if ( val [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w ] , K [ i - 1 ] [ w - wt [ i - 1 ] + K [ i - 1 ] [ w ] ; } } } ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = w ; i ++ ) { if ( w <= w ) { if ( w - wt [ i - 1 ] <= w ) K [ i ] [ w ] = K [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] [ w ] ; w - wt [ i - 1 ] [ w - wt [ i - 1 ] = K [ i ] [ w ] = K [ i ] [ w

static void printknapSack ( int W , int wt , int val [ ] , int n ) { int [ ] K = new int [ W + 1 ] ; for ( int i = 0 ; i < W ; i ++ ) { for ( int w = W ; w < n ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } res = K [ i ] [ w ] ; if ( res <= 0 ) break ; if ( res == K [ i - 1 ] [ w ] ) continue ; else print ( wt [ i - 1 ] ) res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } return ; }

58.33
53.3
57.34
58.8
def MinOperation ( a , b , n ) : a . sort ( reverse = False ) b . sort ( reverse = False ) result = 0 for i in range ( 0 , n , 1 ) : if ( a [ i ] > b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) elif ( a [ i ] < b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) return result

static int MinOperation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }

static int MinOperation ( int [ ] a , int [ ] b , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > b [ i ] ) result = result + abs ( a [ i ] - b [ i ] ) ; else result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }

static int MinOperation ( int a , int b , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > b [ i ] ) result = result + abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] > b [ i ] ) result = result + abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }

58.35
74.49
60.13
75.88
def count_of_ways ( n ) : count = 0 for i in range ( 0 , n + 1 ) : for j in range ( 0 , n + 1 ) : for k in range ( 0 , n + 1 ) : if ( i + j + k == n ) : count = count + 1 return count

static long count_of_ways ( long n ) { long count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) count ++ ; return count ; }

static int count_of_ways ( int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( i + j + k == n ) { count = count + 1 ; } } } return count ; }

static int count_of_ways ( int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( i + j + k == n ) count = count + 1 ; } } } return count ; }

58.44
53.71
72.55
65.48
def insertionSortRecursive ( arr , n ) : if n <= 1 : return insertionSortRecursive ( arr , n - 1 ) last = arr [ n - 1 ] j = n - 2 while ( j >= 0 and arr [ j ] > last ) : arr [ j + 1 ] = arr [ j ] j = j - 1 arr [ j + 1 ] = last

static void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }

static int insertionSortRecursive ( int arr [ ] , int n ) { int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 and arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] j = j - 1 ; while ( arr [ j ] > last ) { arr [ j ] = arr [ j ] j = j - 1 ; } return arr [ n - 1 ] ; }

static int insertionSortRecursive ( int arr [ ] , int n ) { int last = arr [ n - 1 ] ; int j = n - 1 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; arr [ j + 1 ] = arr [ j ] ; } return insertionSortRecursive ( arr , n ) ; }

58.51
58.01
49.1
46.13
def countTransformation ( a , b ) : n = len ( a ) m = len ( b ) if m == 0 : return 1 dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] for i in range ( m ) : for j in range ( i , n ) : if i == 0 : if j == 0 : if a [ j ] == b [ i ] : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 0 elif a [ j ] == b [ i ] : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] else : if a [ j ] == b [ i ] : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] return dp [ m - 1 ] [ n - 1 ]

static int countTransformation ( String a , String b ) { int n = a . length ( ) , m = b . length ( ) ; if ( m == 0 ) { return 1 ; } int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) { dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( i ) ) ? 1 : 0 ; } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }

static int countTransformation ( int [ ] a , int [ ] b ) { int n = a . length ; int m = b . length ; int [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] == b [ i ] ) { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i ] [ j - 1 ] + 1 ] ; } } return dp [ m - 1 ] [ j - 1 ] [ j - 1 ] [ j - 1 ] ; } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j ++ ) { if ( j == 0 ) { if ( a [ j ] == b [ i ] ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ j - 1 ] + dp [ j ] = 1 ; } } return dp [ m - 1 ] [ j - 1 ] + dp [ j - 1 ] ; } } for ( int

static int countTransformation ( int a , int b ) { int n = len ( a ) ; int m = len ( b ) ; int dp [ ] [ ] = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) if ( j == 0 ) if ( j == 0 ) if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = 0 ; else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } return dp [ m - 1 ] [ n - 1 ] ; }

58.55
61.94
65.33
66.56
def subset ( ar , n ) : res = 0 ar . sort ( ) for i in range ( 0 , n ) : count = 1 for i in range ( n - 1 ) : if ar [ i ] == ar [ i + 1 ] : count += 1 else : break res = max ( res , count ) return res

public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }

static int subset ( int ar [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) res = max ( res , count ) ; else res = max ( res , count ) ; } return res ; }

static int subset ( int ar [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < ar . length ; i ++ ) { int count = 1 ; for ( int j = 0 ; j < ar . length ; j ++ ) { if ( ar [ i ] == ar [ j + 1 ] ) count ++ ; else if ( ar [ i ] == ar [ j + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; }

58.58
52.5
82.19
65.95
def maxSubarrayXOR ( arr , n ) : ans = - 2147483648 for i in range ( n ) : curr_xor = 0 for j in range ( i , n ) : curr_xor = curr_xor ^ arr [ j ] ans = max ( ans , curr_xor ) return ans

static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }

static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = arr [ i ] ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } return ans ; }

static int maxSubarrayXOR ( int arr , int n ) { int ans = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } } return ans ; }

58.64
59.79
61.7
58.48
def maxTripletSum ( arr , n ) : sm = - 1000000 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : for k in range ( j + 1 , n ) : if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : sm = arr [ i ] + arr [ j ] + arr [ k ] return sm

static int maxTripletSum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }

static long maxTripletSum ( long [ ] arr , int n ) { long sm = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) { sm = arr [ i ] + arr [ j ] + arr [ k ] ) ; } } return sm ; }

static int maxTripletSum ( int arr [ ] , int n ) { int sm = - 1000000 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { for ( int k = 0 ; k < arr . length ; k ++ ) { if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) { sm = arr [ i ] + arr [ j ] + arr [ k ] ; } } } return sm ; }

58.72
52.31
50.95
52.62
def largest ( arr , n ) : max = arr [ 0 ] for i in range ( 1 , n ) : if arr [ i ] > max : max = arr [ i ] return max

static int largest ( ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < arr . length ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }

static long largest ( long arr [ ] , int n ) { long max = arr [ 0 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }

static int largest ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }

58.83
60.48
65.19
68.7
def FirstRepeated ( string ) : checker = 0 pos = 0 for i in string : val = ord ( i ) - ord ( 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) : return pos checker |= ( 1 << val ) pos += 1 return - 1

static int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }

static int FirstRepeated ( String string ) { int checker = 0 ; int pos = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( checker & ( 1 << val ) ) return pos ; checker |= ( 1 << val ) ; pos ++ ; } return - 1 ; } return - 1 ; }

static int FirstRepeated ( String string ) { int checker = 0 ; int pos = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { int val = ord ( string [ i ] ) - ord ( 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return pos ; checker |= ( 1 << val ) ; pos ++ ; } return - 1 ; }

58.84
63.17
88.82
90.18
def octalToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while ( temp ) : last_digit = temp % 10 temp = int ( temp / 10 ) dec_value += last_digit * base base = base * 8 return dec_value

static int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }

static int octalToDecimal ( int n ) { int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }

static int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { last_digit = temp % 10 ; temp = int ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }

58.84
63.17
90.99
94.0
def binaryToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while ( temp ) : last_digit = temp % 10 temp = int ( temp / 10 ) dec_value += last_digit * base base = base * 2 return dec_value

static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }

static int binaryToDecimal ( int n ) { int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }

static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = int ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }

58.89
58.66
77.04
70.8
def findString ( n , k ) : res = "" for i in range ( k ) : res = res + chr ( ord ( 'a' ) + i ) count = 0 for i in range ( n - k ) : res = res + chr ( ord ( 'a' ) + count ) count += 1 if ( count == k ) : count = 0 ; return res

static String findString ( int n , int k ) { String res = "" ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( 'a' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( 'a' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }

static String findString ( int n , int k ) { String res = "" ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res + chr ( ord ( 'a' ) + count ) ; count ++ ; if ( count == k ) res = res + chr ( 'a' ) + count ) ; count ++ ; if ( count == n ) res = res + chr ( 'a' ) + count ;

static String findString ( int n , int k ) { String res = "" ; for ( int i = 0 ; i < n ; i ++ ) { res = res + chr ( 'a' ) ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { res = res + chr ( 'a' ) + count ; count ++ ; if ( count == k ) count = 0 ; } } return res ; }

58.92
53.55
69.46
66.74
def smallestSumSubarr ( arr , n ) : min_ending_here = sys . maxsize min_so_far = sys . maxsize for i in range ( n ) : if ( min_ending_here > 0 ) : min_ending_here = arr [ i ] else : min_ending_here += arr [ i ] min_so_far = min ( min_so_far , min_ending_here ) return min_so_far

static int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }

static int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] else : min_ending_here = arr [ i ] else : min_ending_here = arr [ i ] min_so_far = min ( min_so_

static int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 0 ; int min_so_far = sys . maxsize ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) { min_ending_here = arr [ i ] ; } else { min_so_far = arr [ i ] ; } } return min_so_far ; }

58.94
52.65
57.71
57.47
def minCost ( cost , m , n ) : tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , m + 1 ) : tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , n + 1 ) : tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return tc [ m ] [ n ]

private static int minCost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }

static int minCost ( int [ ] cost , int m , int n ) { int [ ] tc = new int [ C ] [ R ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i ] [ j - 1 ] , tc [ i ] [ j - 1 ] [ j ] ) + cost [ i ] [ j - 1 ] , tc [ i ] [ j - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i ] [ j - 1 ] , tc [ i ] [ j - 1 ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } } return tc [ i ] [ j ] ; } } } return tc [ m ] [ n ] ; } } return tc [ m ] [

static int minCost ( double [ ] cost , int m , int n ) { double [ ] tc = new double [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { tc [ i ] [ j ] = tc [ i - 1 ] [ j - 1 ] + cost [ i ] [ j ] ; for ( int j = 1 ; j < n + 1 ; j ++ ) { tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } } return tc [ m ] [ n ] ; }

59.0
62.02
40.54
54.98
def findMinDiff ( arr , n ) : arr = sorted ( arr ) diff = 10 ** 20 for i in range ( n - 1 ) : if arr [ i + 1 ] - arr [ i ] < diff : diff = arr [ i + 1 ] - arr [ i ] return diff

static int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }

static int findMinDiff ( int arr [ ] , int n ) { int diff = 10 ** 20 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i ] < diff ) diff = arr [ i ] - arr [ i ] ; } return diff ; } return 0 ; }

static int findMinDiff ( int arr [ ] , int n ) { int diff = 10 ** 20 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; } return diff ; }

59.02
57.8
69.99
67.63
def swapDiagonal ( matrix ) : for i in range ( N ) : matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \ matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ]

static void swapDiagonal ( int matrix [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { int temp = matrix [ i ] [ i ] ; matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ; matrix [ i ] [ N - i - 1 ] = temp ; } }

static void swapDiagonal ( int matrix [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \ matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ N - i - 1 ] ; for ( int i = 0 ; i <

static void swapDiagonal ( int [ ] [ ] matrix [ ] [ ] , int [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ N - i - 1 ] ; } }

59.1
56.64
79.84
77.09
def checkIsAP ( arr , n ) : if ( n == 1 ) : return True arr . sort ( ) d = arr [ 1 ] - arr [ 0 ] for i in range ( 2 , n ) : if ( arr [ i ] - arr [ i - 1 ] != d ) : return False return True

static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }

static boolean checkIsAP ( int arr [ ] , int n ) { if ( arr [ 0 ] - arr [ 1 ] != d ) return false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i ] - arr [ i ] != d ) return false ; } return true ; }

static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int d = arr [ 0 ] - arr [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; } return true ; }

59.16
56.96
65.78
64.04
def minCells ( mat , m , n ) : dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( m ) : for j in range ( n ) : if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : return dp [ m - 1 ] [ n - 1 ] return - 1

static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }

static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] [ ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( dp [ i ] [ j ] != MAX ) dp [ i ] [ j ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != MAX ) dp [ i ] [ j ] = dp [ i ] [ j ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != MAX ) { for ( int i = 0 ; i < m ; i ++ ) if ( dp [ i ] [ j ] != MAX ) if ( dp [ i ] [ j ] [ j ] [ j ] [ j ] [ j ] + 1 ; if ( dp [ i ] [ j ] + mat [ i ] [ j ] [ j ] [ j ] [ j ] [ j ] [ j ] [ j ] + 1 ; } } return dp [ i ] [ j ] [ j ] [ j ] + 1 ;

static int minCells ( int [ ] mat , int m , int n ) { int [ ] dp = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != MAX && ( i + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] ) ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] ) ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 )

59.23
66.3
56.02
74.01
def countSubStr ( st , n ) : m = 0 for i in range ( 0 , n ) : if ( st [ i ] == '1' ) : m = m + 1 return m * ( m - 1 ) // 2

int countSubStr ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }

static int countSubStr ( String st , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( st [ i ] == '0' ) { m = m + 1 ; } } return m ; }

; static int countSubStr ( String st , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( st [ i ] == '1' ) m = m + 1 ; else if ( st [ i ] == '0' ) m = m + 1 ; else m = m + 1 ; } return m * ( m - 1 ) / 2 ; }

59.26
62.32
59.26
63.24
def first ( str ) : for i in range ( 0 , len ( str ) ) : if ( str [ i ] . istitle ( ) ) : return str [ i ] return 0

static char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }

static String first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] . istitle ( ) ) return str [ i ] ; } return 0 ; }

static int first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] . istitle ( ) ) return str [ i ] ; } return 0 ; }

59.26
55.64
65.12
67.1
def sumAtKthLevel ( tree , k ) : level = - 1 sum = 0 n = len ( tree ) for i in range ( n ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 else : if ( level == k ) : sum += ( ord ( tree [ i ] ) - ord ( '0' ) ) return sum

static int sumAtKthLevel ( String tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) sum += ( tree . charAt ( i ) - '0' ) ; } } return sum ; }

static int sumAtKthLevel ( String tree , int k ) { int level = - 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( level == k ) sum += ( tree [ i ] - '0' ) ) ; else sum += ( ord ( tree [ i ] ) - '0' ) ) ; } } return sum ; }

static int sumAtKthLevel ( String tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == '(' ) { level += 1 ; } else if ( tree [ i ] == ')' ) { level -= 1 ; } else { if ( level == k ) { sum += ( ord ( tree [ i ] ) - ord ( '0' ) ) ; } } } return sum ; }

59.26
55.13
42.77
65.84
def breakSum ( n ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) return dp [ n ]

static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }

static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) ; } return dp [ n ] ; }

static int breakSum ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] ; int dp [ ] [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; dp [ 1 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] = max ( dp [ i ] + dp [ int ( j / 2 ) ] + dp [ int ( j / 3 ) ] + dp [ int ( j / 4 ) ] + dp [ int ( j / 5 ) ] , i ) ; } return dp [ n ] ; } }

59.3
76.02
85.61
87.35
def maxTasks ( high , low , n ) : if ( n <= 0 ) : return 0 return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) )

static int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }

static int maxTasks ( int [ ] high , int [ ] low , int n ) { if ( n <= 1 ) return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) , high [ n - 2 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] +

static int maxTasks ( int [ ] high , int [ ] low , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }

59.3
65.43
62.63
71.02
def divSum ( n ) : result = 0 for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : if ( n % i == 0 ) : if ( i == ( n / i ) ) : result = result + i else : result = result + ( i + n // i ) return ( result + n + 1 )

static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }

static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) result = result + ( i + n / i ) ; else result = result + ( i + n / i ) ; else result = result + ( i + n / i ) ; } return result ; } return 0 ; }

public static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i < ( int ) ( math . sqrt ( n ) + 1 ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result = result + i ; else result = result + ( i + n // i ) ; } else result = result + ( i + n // i ) ; } return ( result + n + 1 ) ; }

59.34
65.84
90.27
93.45
def sumOfSeries ( n ) : sum = 0 for i in range ( 1 , n + 1 ) : sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) return sum

static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }

static long sumOfSeries ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + 2 * i - 1 ; } return sum ; }

static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; } return sum ; }

59.35
58.29
42.23
56.74
def alternateSubarray ( arr , n ) : len = [ ] for i in range ( n + 1 ) : len . append ( 0 ) len [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] ^ arr [ i + 1 ] == True ) : len [ i ] = len [ i + 1 ] + 1 else : len [ i ] = 1 for i in range ( n ) : print ( len [ i ] , "" , end = "" )

static void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " " ) ; }

static void alternateSubarray ( boolean arr [ ] , int n ) { int [ ] len = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if (

static void alternateSubarray ( int arr [ ] , int n ) { int [ ] len = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } } return ; }

59.47
59.37
71.76
67.5
def printSeries ( n ) : for i in range ( 1 , n + 1 ) : num = i * ( i + 1 ) * ( i + 2 ) // 6 print ( num , end = '' )

static void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " " ) ; } }

static void printSeries ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { print ( i * ( i + 1 ) * ( i + 2 ) / 6 ) ; } }

static void printSeries ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) ; print ( num , end = '' ) ; } }

59.48
62.41
80.07
67.54
def checkForSorting ( arr , n ) : for i in range ( 0 , n - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : if ( arr [ i ] - arr [ i + 1 ] == 1 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] else : return False return True

static boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }

static boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) arr [ i ] , arr [ i + 1 ] = arr [ i ] , arr [ i ] ; else return false ; } return true ; }

static boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] ; else return false ; } } return true ; }

59.49
49.44
83.66
87.98
def getMissingNo ( a , n ) : i , total = 0 , 1 for i in range ( 2 , n + 2 ) : total += i total -= a [ i - 2 ] return total

static int getMissingNo ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }

static int getMissingNo ( int a [ ] , int n ) { int i , total = 0 , 1 ; for ( i = 2 ; i <= n ; i ++ ) { total += i ; } return total ; }

static int getMissingNo ( int a [ ] , int n ) { int total = 0 , 1 ; for ( int i = 2 ; i < n ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }

59.5
72.16
82.7
76.01
def maximumSegments ( n , a , b , c ) : dp = [ - 1 ] * ( n + 10 ) dp [ 0 ] = 0 for i in range ( 0 , n ) : if ( dp [ i ] != - 1 ) : if ( i + a <= n ) : dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) if ( i + b <= n ) : dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) if ( i + c <= n ) : dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) return dp [ n ]

static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }

static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i ] = max ( dp [ i ] + 1 , dp [ i ] + c ] <= n ) { if ( dp [ i ] + b <= n ) dp [ i ] = max ( dp [ i ] + 1 , dp [ i ] + 1 , dp [ i ] ) ; if ( i + c <= n ) dp [ i ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ; if ( i + c <= n ) dp [ i ] + 1 , dp [ i ] + 1 , dp [ i ] + c ] ) ; }

static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }

59.52
56.69
64.84
60.57
def modularSum ( arr , n , m ) : if ( n > m ) : return True DP = [ False for i in range ( m ) ] for i in range ( n ) : if ( DP [ 0 ] ) : return True temp = [ False for i in range ( m ) ] for j in range ( m ) : if ( DP [ j ] == True ) : if ( DP [ ( j + arr [ i ] ) % m ] == False ) : temp [ ( j + arr [ i ] ) % m ] = True for j in range ( m ) : if ( temp [ j ] ) : DP [ j ] = True DP [ arr [ i ] % m ] = True return DP [ 0 ]

static boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }

static boolean modularSum ( int arr [ ] , int n , int m ) { boolean DP [ ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ i ] == true ) temp [ ( j + arr [ i ] ) % m ] = false ; for ( int j = 0 ; j < m ; j ++ ) { if ( temp [ ( j + arr [ i ] ) % m ] == false ) DP [ ( j + arr [ i ] ) { if ( DP [ j ] == false ) DP [ j ] = true ; for ( int j = 0 ; j < m ; j ++ ) if ( DP [ j ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; for ( int j = 0 ; j < m ; j ++ ) { if ( temp [ j ] == false ) temp [ j ] == true ) DP [ j ] = true ; DP [ j ] == false ) temp [ j ] = true ; DP [ j ] = true ; } } } return DP [ j ] == true ) DP [ j ] = true ; } }

static boolean modularSum ( int arr [ ] , int n , int m ) { boolean DP [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ i ] == true ) { if ( DP [ ( i + arr [ i ] ) % m ] == false ) DP [ ( i + arr [ i ] ) % m ] = true ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ ( i + arr [ i ] ) % m ] == false ) DP [ ( i + arr [ i ] ) % m ] = true ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ ( i + arr [ i ] ) % m ] == false ) DP [ ( i + arr [ i ] ) % m ] = true ; } } } } return DP [ 0 ] ; }

59.62
53.13
65.12
67.1
def productAtKthLevel ( tree , k ) : level = - 1 product = 1 n = len ( tree ) for i in range ( 0 , n ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 else : if ( level == k ) : product *= ( int ( tree [ i ] ) - int ( '0' ) ) return product

static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }

static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( level == k ) product *= ( int ( tree [ i ] ) - int ( '1' ) ) ; else product *= int ( tree [ i ] ) - int ( '0' ) ) ; } } return product ; }

static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == '(' ) { level += 1 ; } else if ( tree [ i ] == ')' ) { level -= 1 ; } else { if ( level == k ) { product *= ( int ( tree [ i ] ) - int ( '0' ) ) ; } } } return product ; }

59.73
51.99
60.74
44.65
def binarySearch ( arr , left , right ) : if ( left <= right ) : mid = ( left + right ) // 2 if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : return mid if ( arr [ mid ] < arr [ mid + 1 ] ) : return binarySearch ( arr , mid + 1 , right ) else : return binarySearch ( arr , left , mid - 1 ) return - 1

static int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }

static int binarySearch ( int arr [ ] , int left , int right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] > arr [ mid ] ) return mid - 1 ; if ( arr [ mid ] > arr [ mid ] ) return mid - 1 ; if ( arr [ mid ] < arr [ mid ] ) return mid - 1 ; if ( arr [ mid ] > arr [ mid ] ) return mid ; if ( arr

static int binarySearch ( int arr [ ] , int left , int right ) { int mid = ( left + right ) // 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] && arr [ mid + 1 ] < arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] > arr [ mid + 1 ] ) return mid ; return - 1 ; }

59.76
51.71
66.51
61.51
def printArray ( a , n ) : for i in a : print ( i , end = "" ) print ( )

static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " " ) ; System . out . println ( ) ; }

static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { print ( i + " " ) ; } }

static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < a . length ; i ++ ) { System . out . print ( a [ i ] ) ; } }

59.81
61.38
72.43
69.32
def pairInSortedRotated ( arr , n , x ) : for i in range ( 0 , n - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : break l = ( i + 1 ) % n r = i while ( l != r ) : if ( arr [ l ] + arr [ r ] == x ) : return True if ( arr [ l ] + arr [ r ] < x ) : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return False

static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }

static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int l = 0 ; int r = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] > x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }

static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return true ; if ( arr [ i ] + arr [ r ] == x ) return true ; if ( arr [ i ] + arr [ r ] < x ) l = ( l + 1 ) % n else r = ( n + r - 1 ) % n ; else l = ( n + r - 1 ) % n ; } return false ; }

59.85
54.43
73.7
78.66
def calc_Expectation ( a , n ) : prb = 1 / n sum = 0 for i in range ( 0 , n ) : sum += ( a [ i ] * prb ) return float ( sum )

static float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }

static float calc_Expectation ( int [ ] a , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( a [ i ] * prb ) ; } return sum ; }

static float calc_Expectation ( float [ ] a , int n ) { float prb = 1 / n ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] * prb ; } return sum ; }

59.9
62.14
62.03
63.86
def calculateEnergy ( mat , n ) : tot_energy = 0 for i in range ( n ) : for j in range ( n ) : q = mat [ i ] [ j ] // n i_des = q j_des = mat [ i ] [ j ] - ( n * q ) tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) return tot_energy

public static int calculateEnergy ( int mat [ ] [ ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }

static int calculateEnergy ( int mat [ ] [ ] , int n ) { int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += ( abs ( i_des - i ) + abs ( j_des -

static int calculateEnergy ( int mat [ ] [ ] , int n ) { int tot_energy = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { int q = mat [ i ] [ j ] ; int i_des = q ; int j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) ; } return tot_energy ; }

59.94
61.88
62.35
68.36
def countSubSets ( arr , n ) : us = set ( ) even_count = 0 for i in range ( n ) : if arr [ i ] % 2 == 0 : us . add ( arr [ i ] ) for i in us : even_count += 1 return pow ( 2 , even_count ) - 1

static int countSubsets ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < > ( ) ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ; even_count = us . size ( ) ; return ( int ) ( Math . pow ( 2 , even_count ) - 1 ) ; }

static int countSubSets ( int arr [ ] , int n ) { HashSet < int > us = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ; else even_count += 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) us . add

static int countSubSets ( int arr [ ] , int n ) { int us = set ( ) ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { us . add ( arr [ i ] ) ; even_count ++ ; } } return pow ( 2 , even_count ) - 1 ; }

59.95
52.77
67.51
57.03
def shortestDist ( graph ) : global INF dist = [ 0 ] * N dist [ N - 1 ] = 0 for i in range ( N - 2 , - 1 , - 1 ) : dist [ i ] = INF for j in range ( N ) : if graph [ i ] [ j ] == INF : continue dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) return dist [ 0 ]

public static int shortestDist ( int [ ] [ ] graph ) { int [ ] dist = new int [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { dist [ i ] = INF ; for ( int j = i ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) { continue ; } dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }

static int shortestDist ( int [ ] graph , int N ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int j = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( graph [ i ] [ j ] == INF ) dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } return dist [ 0 ] ; }

static int shortestDist ( int graph [ ] , int N ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dist [ i ] = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) continue ; dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }

60.02
55.6
74.54
69.47
def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 us = set ( ) for i in range ( m ) : us . add ( arr1 [ i ] ) for j in range ( n ) : if x - arr2 [ j ] in us : count += 1 return count

static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }

static int countPairs ( int arr1 , int arr2 , int m , int n , int x ) { HashSet < int > us = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( x - arr1 [ i ] in us ) count += 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( x - arr2 [ j ] in us ) count += 1

static int countPairs ( int arr1 , int arr2 , int m , int n , int x ) { int count = 0 ; Set < int > us = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { us . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( x - arr2 [ j ] in us ) count ++ ; } } return count ; }

60.03
65.0
57.72
59.1
def remainder ( st ) : ln = len ( st ) rem = 0 for i in range ( 0 , ln ) : num = rem * 10 + ( int ) ( st [ i ] ) rem = num % 11 return rem

static int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }

static int remainder ( String st ) { int ln = st . length ( ) ; int rem = 0 ; for ( int i = 0 ; i < ln ; i ++ ) { int num = rem * 10 + ( int ) ( st [ i ] ) ; rem = num / 11 ; } return rem ; }

( int st ) { int ln = st . length ( ) ; int rem = 0 ; for ( int i = 0 ; i < ln ; i ++ ) { int num = rem * 10 + ( int ) st [ i ] ; rem = num % 11 ; } return rem ; }

60.04
49.21
58.1
51.99
def findSum ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : if arr [ i ] not in s : s . add ( arr [ i ] ) for i in s : sum = sum + i return sum

static int findSum ( int arr [ ] , int n ) { int sum = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { sum += arr [ i ] ; s . add ( arr [ i ] ) ; } } return sum ; }

static int findSum ( int arr [ ] , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] not in s ) s . add ( arr [ i ] ) ; } return sum ; }

static int findSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != null ) { s . add ( arr [ i ] ) ; sum = sum + i ; } } return sum ; }

60.23
58.12
70.42
67.19
def numberofways ( n , m ) : dp = np . zeros ( ( n + 2 , n + 2 ) ) dp [ 0 ] [ n + 1 ] = 1 for k in range ( n , m - 1 , - 1 ) : for i in range ( n + 1 ) : dp [ i ] [ k ] = dp [ i ] [ k + 1 ] if ( i - k >= 0 ) : dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) return dp [ n ] [ m ]

static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }

static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < m ; i ++ ) { if ( i - k >= 0 ) dp [ i ] [ k ] = dp [ i ] [ k ] + dp [ i - k ] [ k ] ; } return dp [ n ] [ m ] [ k ] ; }

static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } return dp [ n ] [ m ] ; }

60.26
66.68
71.69
69.51
def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low i = low for i in range ( high ) : if arr [ i ] == x : return i if arr [ i ] < x and arr [ i + 1 ] >= x : return i + 1 return - 1

static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }

static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] <= x && arr [ i + 1 ] <= x ) return i + 1 ; } return - 1 ; }

; } static int ceilSearch ( int arr , int low , int high , int x ) { int i = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( x <= arr [ i ] ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }

60.42
60.74
71.53
73.29
def getSingle ( arr , n ) : result = 0 for i in range ( 0 , INT_SIZE ) : sm = 0 x = ( 1 << i ) for j in range ( 0 , n ) : if ( arr [ j ] & x ) : sm = sm + 1 if ( sm % 3 ) : result = result | x return result

static int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) == 0 ) result |= x ; } return result ; }

static int getSingle ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { int sm = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) { sm = sm + 1 ; if ( sm % 3 ) result = result | x ; if ( sm % 3 ) result = result | x ; if ( sm %

static int getSingle ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { int sm = 0 ; int x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) { sm = sm + 1 ; if ( sm % 3 ) { result = result | x ; } } } } return result ; }

60.43
63.18
92.46
92.29
def findInteger ( arr , n ) : neg = 0 pos = 0 sum = 0 for i in range ( 0 , n ) : sum += arr [ i ] if ( arr [ i ] < 0 ) : neg += 1 else : pos += 1 return ( sum / abs ( neg - pos ) )

static int findInteger ( int arr [ ] , int n ) { int neg = 0 , pos = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) neg ++ ; else pos ++ ; } return ( sum / Math . abs ( neg - pos ) ) ; }

static int findInteger ( int arr [ ] , int n ) { int sum = 0 ; int neg = 0 ; int pos = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { neg += 1 ; } else { pos += 1 ; } } return 0 ; }

static int findInteger ( int arr [ ] , int n ) { int neg = 0 ; int pos = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) neg ++ ; else pos ++ ; } return ( sum / abs ( neg - pos ) ) ; }

60.48
54.69
59.66
56.56
def areSumSame ( a , n , m ) : sum1 = 0 sum2 = 0 for i in range ( 0 , n ) : sum1 = 0 sum2 = 0 for j in range ( 0 , m ) : sum1 += a [ i ] [ j ] sum2 += a [ j ] [ i ] if ( sum1 == sum2 ) : return 1 return 0

static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }

static int areSumSame ( int [ ] [ ] a , int n , int m ) { int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; if ( sum1 == sum2 ) return 1 ; } return 0 ; }

static int areSumSame ( int [ ] a , int n , int m ) { int sum1 = 0 ; sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; if ( sum1 == sum2 ) return 1 ; } return 0 ; }

60.49
67.67
79.16
79.98
def findMajority ( arr , n ) : maxCount = 0 ; index = - 1 for i in range ( n ) : count = 0 for j in range ( n ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count > maxCount ) : maxCount = count index = i if ( maxCount > n // 2 ) : print ( arr [ index ] ) else : print ( "NoMajorityElement" )

static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( "No Majority Element" ) ; }

static int findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) { if ( count > maxCount ) maxCount = count ; if ( count > maxCount ) { maxCount = count ;

static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { count ++ ; if ( count > maxCount ) { maxCount = count ; index = i ; if ( maxCount > n // 2 ) { print ( arr [ index ] ) ; } else { print ( "NoMajorityElement" ) ; } } } } } return ; }

60.84
58.06
63.66
79.91
def findSum ( n ) : n -= 1 sum = 0 sum += ( n * ( n + 1 ) ) / 2 sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 return int ( sum )

static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }

static int findSum ( int n ) { int sum = 0 ; int sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }

static int findSum ( int n ) { int sum = 0 ; sum = 0 ; sum += n * ( n + 1 ) ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return int ( sum ) ; }

60.93
50.23
56.68
49.48
def isSubSeqDivisible ( str ) : n = len ( str ) dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] arr = [ 0 for i in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : arr [ i ] = int ( str [ i - 1 ] ) for i in range ( 1 , n + 1 ) : dp [ i ] [ arr [ i ] % 8 ] = 1 for j in range ( 8 ) : if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] for i in range ( 1 , n + 1 ) : if ( dp [ i ] [ 0 ] == 1 ) : return True return False

static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; int arr [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }

static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int [ ] dp = new int [ n + 1 ] [ 8 ] ; for ( int i = 1 ; i < n ; i ++ ) { int [ ] arr = new int [ n + 1 ] ; for ( int j = 0 ; j < 8 ; j ++ ) if ( dp [ i ] [ j ] > dp [ i ] [ j ] ) { dp [ i ] [ j ] = dp [ i ] [ j ] = dp [ i ] [ j ] ; if ( dp [ i ] [ j ] > dp [ i ] [ j ] ) { for ( int i = 1 ; i ++ ) { if ( dp [ i ] [ j ] > dp [ i ] [ j ] ; for ( int j = 0 ; j ++ ) if ( dp [ i ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i ] [ j ] [ j ] [ j ] [ j ] ; } } } return false ; } return true ; } return false ; } return false ; } } return false ; } for ( int i = 0 ; i

static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] = new int [ n ] ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i ] [ j ] > dp [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } if ( dp [ i ] [ j ] > dp [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } if ( dp [ i ] [ j ] > dp [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } if ( dp [ i ] [ j ] > dp [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } } return false ; }

60.99
50.39
64.76
53.7
def maxSubArraySum ( a , size ) : max_so_far = - maxint - 1 max_ending_here = 0 for i in range ( 0 , size ) : max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if max_ending_here < 0 : max_ending_here = 0 return max_so_far

static int maxSubArraySum ( int a [ ] ) { int size = a . length ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }

static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = - maxint - 1 ; int max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if (

static int maxSubArraySum ( int a , int size ) { int max_so_far = - maxint - 1 ; int max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_so_far = max_so_far + a [ i ] ; max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }

60.99
66.11
56.82
63.14
def LowerInsertionPoint ( arr , n , X ) : if ( X < arr [ 0 ] ) : return 0 elif ( X > arr [ n - 1 ] ) : return n lowerPnt = 0 i = 1 while ( i < n and arr [ i ] < X ) : lowerPnt = i i = i * 2 while ( lowerPnt < n and arr [ lowerPnt ] < X ) : lowerPnt += 1 return lowerPnt

static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }

static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i + 1 ; i = i * 2 ; while ( lowerPnt < n && arr [ lowerPnt ] < X ) { lowerPnt ++ ; } } return 0 ; }

static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i ++ ; while ( lowerPnt < n && arr [ lowerPnt ] < X ) { lowerPnt ++ ; } } return lowerPnt ; }

61.02
68.64
80.92
77.99
def isTriangular ( num ) : if ( num < 0 ) : return False sum , n = 0 , 1 while ( sum <= num ) : sum = sum + n if ( sum == num ) : return True n += 1 return False

static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }

static boolean isTriangular ( int num ) { int sum = 0 ; int n = 1 ; while ( sum <= num ) { sum = sum + n ; if ( sum == num ) return true n += 1 ; } return false ; }

static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; int n = 0 ; while ( sum <= num ) { sum = sum + n ; if ( sum == num ) return true ; n ++ ; } return false ; }

61.06
56.49
50.12
42.81
def shuffle ( card , n ) : for i in range ( n ) : r = i + ( random . randint ( 0 , 55 ) % ( 52 - i ) ) tmp = card [ i ] card [ i ] = card [ r ] card [ r ] = tmp

public static void shuffle ( int card [ ] , int n ) { Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + rand . nextInt ( 52 - i ) ; int temp = card [ r ] ; card [ r ] = card [ i ] ; card [ i ] = temp ; } }

static void shuffle ( int card [ ] , int n ) { int i = 0 ; for ( int r = 0 ; i < n ; i ++ ) { int tmp = card [ i ] ; card [ i ] = card [ r ] ; card [ r ] = tmp ; } }

; for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( random . randint ( 0 , 55 ) % ( 52 - i ) ) ; card [ i ] = card [ r ] ; card [ r ] = tmp ; } }

61.08
69.45
72.95
56.48
def modInverse ( a , m ) : m0 = m y = 0 x = 1 if ( m == 1 ) : return 0 while ( a > 1 ) : q = a // m t = m m = a % m a = t t = y y = x - q * y x = t if ( x < 0 ) : x = x + m0 return x

static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }

static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 ; int x = 1 ; while ( a > 1 ) { int q = 1 ; int t = m ; m = a % m ; a = t ; y = x - q * y ; x = t ; } return y ; }

static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 ; int x = 1 ; while ( a > 1 ) { int q = a // m t = m ; m = a % m ; a = t ; t = y ; y = x - q * y x = t ; if ( x < 0 ) x = x + m0 ; } return x ; }

61.18
76.81
82.07
88.18
def countNumberOfTriangles ( n ) : return ( n * ( n - 1 ) * ( n - 2 ) // 6 )

static int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }

static int countNumberOfTriangles ( int n ) { int i = 0 ; i < n ; i ++ ) ( n - 1 ) * ( n - 2 ) / 6 ; }

static int countNumberOfTriangles ( int n ) { return ( n * ( n - 1 ) * ( n - 2 ) / 6 ) ; }

61.29
64.88
82.59
84.27
def MinOperation ( a , n , k ) : result = 0 for i in range ( n ) : if ( a [ i ] != 1 and a [ i ] > k ) : result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) else : result = result + k - a [ i ] return result

static int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }

static int MinOperation ( int [ ] a , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != 1 ) result = ( result + a [ i ] % k , k - a [ i ] % k ) ; else result = result + k ; } return result ; }

static int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != 1 && a [ i ] > k ) result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) ; else result = result + k - a [ i ] ; } return result ; }

61.34
62.66
61.34
62.69
def abFree ( s ) : b_count = 0 res = 0 for i in range ( len ( s ) ) : if s [ ~ i ] == 'a' : res = ( res + b_count ) b_count = ( b_count * 2 ) else : b_count += 1 return res

static int abFree ( char [ ] s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ s . length - i - 1 ] == 'a' ) { res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } else { b_count += 1 ; } } return res ; }

static int abFree ( String s ) { int res = 0 ; int b_count = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( s [ ~ i ] == 'a' ) res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } return res ; }

static int abFree ( String s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ ~ i ] == 'a' ) res = ( res + b_count ) ; else res = ( res * 2 ) ; } return res ; }

61.41
58.64
58.41
59.55
def findRepeating ( arr , n ) : missingElement = 0 for i in range ( 0 , n ) : element = arr [ abs ( arr [ i ] ) ] if ( element < 0 ) : missingElement = arr [ i ] break arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] return abs ( missingElement )

static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ Math . abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; break ; } arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; } return Math . abs ( missingElement ) ; }

static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ abs ( arr [ i ] ) ] ; arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; } return missingElement ; }

static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int element = arr [ abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; } return abs ( missingElement ) ; } }

61.44
48.89
46.09
40.79
def isPresent ( s , q ) : freq = [ 0 ] * MAX_CHAR for i in range ( 0 , len ( s ) ) : freq [ ord ( s [ i ] ) ] += 1 for i in range ( 0 , len ( q ) ) : freq [ ord ( q [ i ] ) ] -= 1 if ( freq [ ord ( q [ i ] ) ] < 0 ) : return False return True

static boolean isPresent ( String s , String q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; }

static boolean isPresent ( String s , String q ) { int freq [ ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( freq [ ord ( s [ i ] ) ] > 0 ) return false ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { if ( freq [ ord ( s [ i ] ) ] < 0 ) return false ; for ( int i = 0 ; i < s .

public static boolean isPresent ( String s , String q ) { int freq [ ] = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) { freq [ ord ( s [ i ] ) ] += 1 ; freq [ ord ( q [ i ] ) ] -= 1 ; if ( freq [ ord ( q [ i ] ) ] < 0 ) return false ; } return true ; }

61.47
52.0
85.97
74.25
def countIslands ( mat ) : count = 0 for i in range ( 0 , M ) : for j in range ( 0 , N ) : if ( mat [ i ] [ j ] == 'X' ) : if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) and ( j == 0 or mat [ i ] [ j - 1 ] == 'O' ) ) : count = count + 1 return count

static int countIslands ( int mat [ ] [ ] , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 'X' ) { if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) count ++ ; } } } return count ; }

static int countIslands ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 'X' ) { if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) ) { count = count + 1 ; } else { if

static int countIslands ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 'X' ) { if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) { count = count + 1 ; } } } } return count ; }

61.49
64.67
40.45
59.41
def minmaxProduct ( arr1 , arr2 , n1 , n2 ) : arr1 . sort ( ) arr2 . sort ( ) return arr1 [ n1 - 1 ] * arr2 [ 0 ]

public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }

static double minmaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int arr1 [ ] . sort ( ) ; int arr2 [ ] . sort ( ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] . sort ( ) ; }

; public static int minmaxProduct ( int arr1 , int arr2 , int n1 , int n2 ) { for ( int i = 0 ; i < arr1 . length ; i ++ ) { minmaxProduct ( arr1 [ i ] , arr2 [ i ] , n1 , n2 ) ; } return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }

61.56
66.32
53.75
67.93
def divisible ( num ) : n = len ( num ) sum = 0 for i in range ( n ) : sum += int ( num [ i ] ) if ( sum % 3 == 0 ) : return 0 if ( n == 1 ) : return - 1 for i in range ( n ) : if ( sum % 3 == int ( num [ i ] ) % 3 ) : return 1 if ( n == 2 ) : return - 1 return 2

static int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }

static int divisible ( int [] num ) { int n = num . length ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sum % 3 == 0 ) return 0 if ( n == 2 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sum % 3 == int ( num [ i ] ) % 3 ) return 1 ; if ( n == 3 ) return

; } static int divisible ( int num ) { int n = num . length ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += int ( num [ i ] ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += int ( num [ i ] ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += int ( num [ i ] ) ; if ( sum % 3 == 0 ) return 0 ; } } return - 1 ; }

61.57
68.06
60.13
55.14
def countNum ( arr , n ) : count = 0 arr . sort ( ) for i in range ( 0 , n - 1 ) : if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : count += arr [ i + 1 ] - arr [ i ] - 1 return count

static int countNum ( int [ ] arr , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }

static int countNum ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) count += arr [ i ] - arr [ i ] - 1 ; else count += arr [ i ] - 1 ; } return count ; }

static int countNum ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) { count ++ ; } } return count ; }

61.6
59.49
53.41
48.27
def multiply ( A , B , C ) : for i in range ( N ) : for j in range ( N ) : C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]

static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }

static void multiply ( int N , int [ ] A , int [ ] B , int [ ] C ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } } }

; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } }

61.66
64.3
72.66
74.37
def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i == j ) : principal += mat [ i ] [ j ] if ( ( i + j ) == ( n - 1 ) ) : secondary += mat [ i ] [ j ] print ( "PrincipalDiagonal:" , principal ) print ( "SecondaryDiagonal:" , secondary )

static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } System . out . println ( "Principal Diagonal:" + principal ) ; System . out . println ( "Secondary Diagonal:" + secondary ) ; }

static void printDiagonalSums ( int mat [ ] [ ] , int n ) { int principal = 0 ; int secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i + j ) == ( n - 1 ) ) { principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary +=

static void printDiagonalSums ( int mat [ ] [ ] , int n ) { int principal = 0 ; int secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } }

61.85
65.51
0.0
0.16
def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x i = 1 result = 1 while ( result <= x ) : i += 1 result = i * i return i - 1

static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }

static int floorSqrt ( int x ) { int i = 1 ; int result = 1 ; while ( result <= x ) { i += 1 ; result = i * i ; } return i - 1 ; }

; }

61.87
62.6
54.52
49.98
def findMinDiff ( arr , n ) : diff = 10 ** 20 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : if abs ( arr [ i ] - arr [ j ] ) < diff : diff = abs ( arr [ i ] - arr [ j ] ) return diff

static int findMinDiff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }

static int findMinDiff ( int arr [ ] , int n ) { int diff = 10 ** 20 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) < diff : diff = abs ( arr [ i ] - arr [ j ] ) ; } return diff ; }

static int findMinDiff ( int arr [ ] , int n ) { int diff = 10 ** 20 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] - arr [ j ] ) { if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ; } } } return diff ; }

61.9
64.82
68.47
73.76
def flipsPossible ( a , n ) : count_odd = 0 count_even = 0 for i in range ( n ) : if ( a [ i ] & 1 ) : count_odd += 1 else : count_even += 1 if ( count_odd % 2 and count_even % 2 ) : return False else : return True

static boolean flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }

static boolean flipsPossible ( int a [ ] , int n ) { int count_odd = 0 ; int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) { count_odd += 1 else : count_even += 1 if ( count_odd % 2 and count_even % 2 ) return false ; } } return true ; }

static boolean flipsPossible ( int a , int n ) { int count_odd = 0 ; int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) { count_odd ++ ; } else { count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; } return true ; }

61.94
60.05
75.24
63.05
def bellNumber ( n ) : bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] bell [ 0 ] [ 0 ] = 1 for i in range ( 1 , n + 1 ) : bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] for j in range ( 1 , i + 1 ) : bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] return bell [ n ] [ 0 ]

static int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }

static int bellNumber ( int n ) { int [ ] bell = new int [ n + 1 ] [ ] ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] + bell [ i ] [ j - 1 ] ; for ( int j = 1 ; j <= n ; j ++ ) { bell [ i ] [ j ] = b

static int bellNumber ( int n ) { int bell [ ] [ ] = new int [ n ] [ ] ; for ( int i = 1 ; i < n ; i ++ ) { bell [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) { bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } } return bell [ n ] [ 0 ] ; }

61.95
65.68
69.77
57.81
def count ( n , x ) : cnt = 0 for i in range ( 1 , n + 1 ) : if i <= x : if x // i <= n and x % i == 0 : cnt += 1 return cnt

static int count ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n && i <= x ; i ++ ) { if ( x / i <= n && x % i == 0 ) count ++ ; } return count ; }

static int count ( int n , int x ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x / i == 0 ) cnt += 1 ; } return cnt ; }

static int count ( int n , int x ) { int cnt = 0 ; for ( int i = 1 ; i <= x ; i ++ ) { if ( i <= x ) { if ( x // i <= n && x % i == 0 ) cnt ++ ; } } return cnt ; }

62.06
64.28
56.17
62.02
def count ( n ) : if n < 3 : return n elif n >= 3 and n < 10 : return n - 1 po = 1 while n / po > 9 : po = po * 10 msd = n / po if msd != 3 : return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) else : return count ( msd * po - 1 )

static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }

static int count ( int n ) { int po = 1 ; while ( n / po > 9 ) { int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( n % po ) ; else return count ( msd ) * count ( po - 1 ) + count ( n % po ) ; } return 0 ; }

static int count ( int n ) { int po = 1 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) + count ( n % po ) ; }

62.1
59.53
67.79
62.2
def minTime ( arr , n ) : if ( n <= 0 ) : return 0 incl = arr [ 0 ] excl = 0 for i in range ( 1 , n ) : incl_new = arr [ i ] + min ( excl , incl ) excl_new = incl incl = incl_new excl = excl_new return min ( incl , excl )

static int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }

static int minTime ( int arr [ ] , int n ) { int incl = arr [ 0 ] + min ( excl , incl ) ; int excl = arr [ 0 ] + min ( incl , excl ) ; for ( int i = 1 ; i <= n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; excl = incl_new ; } return 0 ; }

static int minTime ( int arr [ ] , int n ) { int incl = arr . length ; int excl = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; incl_new = incl_new ; excl_new = incl_new ; incl = incl_new ; excl = excl_new ; } return min ( incl , excl ) ; }

62.1
53.01
55.46
48.94
def printRepeating ( arr , size ) : print ( "Therepeatingelementsare" , end = "" ) for i in range ( 0 , size ) : if ( arr [ abs ( arr [ i ] ) ] > 0 ) : arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] else : print ( abs ( arr [ i ] ) , end = "" )

void printRepeating ( int arr [ ] , int size ) { int i ; System . out . println ( "The repeating elements are : " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + " " ) ; } }

static void printRepeating ( int arr [ ] , int size ) { System . out . print ( arr [ abs ( arr [ i ] ) ] + " " ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] < 0 ) arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] + " " ) ; } }

static void printRepeating ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) { arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] ; } else { print ( abs ( arr [ i ] ) , end = "" ) ; } } }

62.12
57.82
62.3
57.95
def numberOfPaths ( p , q ) : dp = [ 1 for i in range ( q ) ] for i in range ( p - 1 ) : for j in range ( 1 , q ) : dp [ j ] += dp [ j - 1 ] return dp [ q - 1 ]

static int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }

static int numberOfPaths ( int p , int q ) { int dp [ ] = new int [ p - 1 ] ; for ( int i = 1 ; i <= p ; i ++ ) { for ( int j = 1 ; j <= q ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } return dp [ q - 1 ] ; } }

public static int numberOfPaths ( int p , int q ) { int dp [ ] = new int [ 1 ] ; for ( int i = 1 ; i <= q ; i ++ ) { dp [ i ] = 1 ; for ( int j = 1 ; j <= p ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } return dp [ q - 1 ] ; } }

62.13
62.12
61.91
62.57
def xorZero ( str ) : one_count = 0 zero_count = 0 n = len ( str ) for i in range ( 0 , n , 1 ) : if ( str [ i ] == '1' ) : one_count += 1 else : zero_count += 1 if ( one_count % 2 == 0 ) : return zero_count return one_count

static int xorZero ( String s ) { int one_count = 0 , zero_count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }

static int xorZero ( String str ) { int one_count = 0 ; int zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { one_count += 1 else : zero_count += 1 if ( one_count % 2 == 0 ) return zero_count ; } return one_count ; } return zero_count ;

; } static int xorZero ( String str ) { int one_count = 0 ; int zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { one_count ++ ; } else { zero_count ++ ; } if ( zero_count % 2 == 0 ) return zero_count ; } return zero_count ; }

62.16
58.26
39.62
50.81
def eggDrop ( n , k ) : if ( k == 1 or k == 0 ) : return k if ( n == 1 ) : return k min = sys . maxsize for x in range ( 1 , k + 1 ) : res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) if ( res < min ) : min = res return min + 1

static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = Integer . MAX_VALUE ; int x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }

static int eggDrop ( int n , int k ) { if ( n == 0 ) return 0 ; for ( int x = 1 ; x <= k ; x ++ ) { int res = eggDrop ( n - 1 , x - 1 ) , eggDrop ( n - 1 , k - x ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min ; }  def eggDrop ( int n ,

static int eggDrop ( int n , int k ) { int min = sys . maxsize ; for ( int x = 1 ; x <= k ; x ++ ) { int res = eggDrop ( n - 1 , x - 1 ) ; if ( res < min ) min = res ; } return min ; }

62.3
59.91
76.17
65.83
def countOfSubstringWithKOnes ( s , K ) : N = len ( s ) res = 0 countOfOne = 0 freq = [ 0 for i in range ( N + 1 ) ] freq [ 0 ] = 1 for i in range ( 0 , N , 1 ) : countOfOne += ord ( s [ i ] ) - ord ( '0' ) if ( countOfOne >= K ) : res += freq [ countOfOne - K ] freq [ countOfOne ] += 1 return res

static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }

static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int freq [ ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( countOfOne >= K ) res += freq [ countOfOne - K ] ; freq [ countOfOne ] ++ ; } return res ; }

static int countOfSubstringWithKOnes ( String s , int K ) { int res = 0 ; int N = s . length ( ) ; int freq [ ] = new int [ N + 1 ] ; int countOfOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ord ( s [ i ] ) - ord ( '0' ) ; if ( countOfOne >= K ) res += freq [ countOfOne - K ] ; freq [ countOfOne ] ++ ; } return res ; }

62.34
55.25
57.74
56.55
def transpose ( A ) : for i in range ( N ) : for j in range ( i + 1 , N ) : A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ]

static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }

static void transpose ( int [ ] A , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { A [ i ] [ j ] , A [ j ] [ i ] = A [ i ] [ j ] , A [ j ] [ i ] ; A [ j ] [ i ] = A [ j ] [ i ] , A [ j ] [ j ] ; } }

public static void transpose ( int [ ] A [ ] [ ] , int [ ] A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] , A [ i ] [ j ] ; } }

62.37
59.57
78.28
69.63
def countStrings ( n ) : a = [ 0 ] * n b = [ 0 ] * n a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]

static int countStrings ( int n ) { int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }

static int countStrings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] + b [ i - 1 ] ; } return 0 ; }

; } static int countStrings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = b [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }

62.6
65.42
86.25
81.33
def maxSubArraySum ( a , size ) : max_so_far = a [ 0 ] curr_max = a [ 0 ] for i in range ( 1 , size ) : curr_max = max ( a [ i ] , curr_max + a [ i ] ) max_so_far = max ( max_so_far , curr_max ) return max_so_far

static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }

static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = 0 ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i <= size ; i ++ ) { max_so_far = max ( max_so_far , curr_max + a [ i ] ) ; } return max_so_far ; }

static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }

62.68
74.01
64.97
58.08
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : arr . sort ( ) result = 0 for i in range ( k1 , k2 - 1 ) : result += arr [ i ] return result

static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }

static long sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { long result = 0 ; for ( int i = k1 ; i <= k2 ; i ++ ) { result += arr [ i ] ; } return result ; }

static int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { int result = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { result += arr [ i ] ; } return result ; }

62.69
54.31
60.16
54.75
def printRepeating ( arr , size ) : count = [ 0 ] * size print ( "Repeatingelementsare" , end = "" ) for i in range ( 0 , size ) : if ( count [ arr [ i ] ] == 1 ) : print ( arr [ i ] , end = "" ) else : count [ arr [ i ] ] = count [ arr [ i ] ] + 1

void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( "Repeated elements are : " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }

static void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) { print ( arr [ i ] , end = "" ) ; } else { count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ; } } return ; }

static void printRepeating ( String [ ] arr , int size ) { int count [ ] = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) { print ( arr [ i ] , end = "" ) ; } else { count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ; } } }

62.72
73.65
97.1
99.25
def countSetBits ( n ) : if ( n == 0 ) : return 0 else : return ( n & 1 ) + countSetBits ( n >> 1 )

public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }

static int countSetBits ( int n ) { if ( n == 1 ) return countSetBits ( n >> 1 ) ; else return countSetBits ( n >> 1 ) ; } }

; public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }

62.73
57.6
68.24
63.11
def largestGCDSubsequence ( arr , n ) : ans = 0 maxele = max ( arr ) for i in range ( 2 , maxele + 1 ) : count = 0 for j in range ( n ) : if ( arr [ j ] % i == 0 ) : count += 1 ans = max ( ans , count ) return ans

static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }

static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = max ( arr ) ; for ( int i = 2 ; i <= maxele ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) count += 1 ; } } return ans ; }

static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = max ( arr ) ; for ( int i = 2 ; i < maxele + 1 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) { count ++ ; ans = max ( ans , count ) ; } } } return ans ; }

62.75
65.49
81.91
81.62
def maxLength ( s , n ) : invalidOpenBraces = 0 invalidCloseBraces = 0 for i in range ( n ) : if ( s [ i ] == '(' ) : invalidOpenBraces += 1 else : if ( invalidOpenBraces == 0 ) : invalidCloseBraces += 1 else : invalidOpenBraces -= 1 return ( n - ( invalidOpenBraces + invalidCloseBraces ) )

static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '(' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }

static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ')' ) { invalidCloseBraces += 1 else : invalidCloseBraces -= 1 } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; } return ( n - ( invalid

static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) { invalidOpenBraces ++ ; } else if ( invalidOpenBraces == 0 ) { invalidCloseBraces += 1 ; } else { invalidOpenBraces -= 1 ; } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }

62.8
71.11
62.87
75.42
def countFriendsPairings ( n ) : dp = [ - 1 ] * 100 if ( dp [ n ] != - 1 ) : return dp [ n ] if ( n > 2 ) : dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) return dp [ n ] else : dp [ n ] = n return dp [ n ]

static int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }

static int countFriendsPairings ( int n ) { int dp [ ] = new int [ 100 ] ; if ( dp [ n ] != - 1 ) { dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; return dp [ n ] ; } else { dp [ n ] = countFriendsPairings ( n ) ; return dp [ n ] ; } }

static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] * 100 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) { dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) ; return dp [ n ] ; } else { dp [ n ] = n ; } }

62.83
64.12
51.89
65.95
def findElements ( arr , n ) : arr . sort ( ) for i in range ( 0 , n - 2 ) : print ( arr [ i ] , end = "" )

static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }

static void findElements ( int arr [ ] , int n ) { System . out . print ( arr [ i ] ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] ) ; } }

static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] . sort ( ) ; for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] . print ( arr [ j ] ) ; } } }

62.84
52.79
73.76
80.42
def minTime ( arr , n , m ) : t = 0 while ( 1 ) : items = 0 for i in range ( n ) : items += ( t // arr [ i ] ) if ( items >= m ) : return t t += 1

static int minTime ( int [ ] arr , int n , int m ) { int t = 0 ; while ( true ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }

static long minTime ( long arr [ ] , int n , int m ) { long t = 0 ; while ( 1 ) { long items = 0 ; for ( int i = 0 ; i < n ; i ++ ) { items += ( t // arr [ i ] ) ; if ( items >= m ) { return t ; } } return t ; } }

private static int minTime ( int arr [ ] , int n , int m ) { int t = 0 ; while ( 1 ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) { items += t * arr [ i ] ; if ( items >= m ) return t ; t ++ ; } } return - 1 ; }

63.03
63.05
76.74
77.44
def countFriendsPairings ( n ) : a , b , c = 1 , 2 , 0 if ( n <= 2 ) : return n for i in range ( 3 , n + 1 ) : c = b + ( i - 1 ) * a a = b b = c return c

static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }

static int countFriendsPairings ( int n ) { int a , b , c ; for ( int i = 1 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return n ; }

static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return n ; }

63.07
52.66
61.49
50.73
def findFlips ( str , n ) : last = '' res = 0 for i in range ( n ) : if ( last != str [ i ] ) : res += 1 last = str [ i ] return res // 2

static int findFlips ( String str , int n ) { char last = ' ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; }

static int findFlips ( String str , int n ) { String last = str ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res += 1 ; last = str [ i ] ; } return res ; }

static int findFlips ( String str , int n ) { int res = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res ; }

63.14
74.89
93.94
96.37
def kthgroupsum ( k ) : return k * k * k

public static int kthgroupsum ( int k ) { return k * k * k ; }

static int kthgroupsum ( int k ) {  def kthgroupsum ( int k ) { return k * k

static int kthgroupsum ( int k ) { return k * k * k ; }

63.23
71.1
95.16
97.58
def isDivBy9 ( n ) : if ( n == 0 or n == 9 ) : return True if ( n < 9 ) : return False return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )

static boolean isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }

static boolean isDivBy9 ( int n ) { if ( n < 0 ) return false ; return isDivBy9 ( ( int ) ( n >> 6 ) - ( int ) ( n & 7 ) ) ; }

static boolean isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 0 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }

63.25
56.45
56.03
55.37
def isProduct ( arr , n , x ) : for i in arr : for j in arr : if i * j == x : return True return False

boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }

static boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) if ( i * j == x ) return true ; } return false ; }

static boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( isProduct ( arr [ i ] , n , x ) ) { if ( i * j == x ) return true ; } } return false ; }

63.39
71.08
79.37
84.36
def isPowerOfFour ( n ) : return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) )

static boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }

static boolean isPowerOfFour ( int n ) { return ( n != 0 and ( n & ( n - 1 ) ) == 0 ) and not ( n & 0x55555555 ) ) ; }

static boolean isPowerOfFour ( int n ) { return ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ) ; }

63.4
56.7
50.94
52.33
def leonardo ( n ) : dp = [ ] dp . append ( 1 ) dp . append ( 1 ) for i in range ( 2 , n + 1 ) : dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) return dp [ n ]

static int leonardo ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; }

static int leonardo ( int n ) { int dp [ ] = new int [ n + 1 ] + 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; } return 0 ; }

public static int leonardo ( int n ) { int dp [ ] . append ( 1 ) ; dp . append ( 1 ) ; dp . append ( 1 ) ; dp . append ( 1 ) ; for ( int i = 2 ; i < n + 1 ; i ++ ) { dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; } return dp [ n ] ; }

63.42
61.32
65.42
58.11
def gcdExtended ( a , b , x , y ) : if a == 0 : x = 0 y = 1 return b x1 = 1 y1 = 1 gcd = gcdExtended ( b % a , a , x1 , y1 ) x = y1 - ( b / a ) * x1 y = x1 return gcd

public static int gcdExtended ( int a , int b , int x , int y ) { if ( a == 0 ) { x = 0 ; y = 1 ; return b ; } int x1 = 1 , y1 = 1 ; int gcd = gcdExtended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 ; y = x1 ; return gcd ; }

static int gcdExtended ( int a , int b , int x , int y ) { int x1 = x ; int y1 = y ; int gcd = gcdExtended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 ; y = y1 ; return gcd ; }  def gcdExtended ( int a , int b , int x , int y ) { int x = x ; int y

static int gcdExtended ( int a , int b , int x , int y ) { int x1 = 1 ; int y1 = 1 ; int gcd = gcdExtended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 y = x1 ; return gcd ; }

63.69
57.94
44.79
55.49
def numofsubset ( arr , n ) : x = sorted ( arr ) count = 1 for i in range ( 0 , n - 1 ) : if ( x [ i ] + 1 != x [ i + 1 ] ) : count = count + 1 return count

static int numofsubset ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; }

static int numofsubset ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] + 1 != x [ i + 1 ] ) { count = count + 1 ; } } return count ; }

static int numofsubset ( int arr [ ] , int n ) { int x [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] + 1 != arr [ i + 1 ] ) { count = 1 ; for ( int j = 0 ; j < x . length ; j ++ ) { if ( x [ j ] + 1 != arr [ i + 1 ] ) { count = count + 1 ; } } } } return count ; }

63.72
61.63
65.84
57.6
def countSol ( coeff , n , rhs ) : dp = [ 0 for i in range ( rhs + 1 ) ] dp [ 0 ] = 1 for i in range ( n ) : for j in range ( coeff [ i ] , rhs + 1 ) : dp [ j ] += dp [ j - coeff [ i ] ] return dp [ rhs ]

static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }

static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < coeff [ i ] ; j ++ ) { dp [ j ] += dp [ j - coeff [ i ] ] ; } return dp [ rhs ] ; } }

private static int countSol ( int coeff , int n , int rhs ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < coeff . length ; j ++ ) { dp [ j ] += dp [ j - coeff [ i ] ] ; } return dp [ rhs ] ; } }

63.73
67.25
77.38
77.18
def printPairs ( arr , n , k ) : isPairFound = True for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i != j and arr [ i ] % arr [ j ] == k ) : print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , sep = "" , end = "" ) isPairFound = True return isPairFound

static boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ; isPairFound = true ; } } } return isPairFound ; }

static boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( i != j ) { if ( arr [ i ] % arr [ j ] == k ) { print ( arr [ i ] , "," , arr [ j ] , "," , arr [ j ] , "," ,

static boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , sep = "" , end = "" ) isPairFound = true ; } } } return isPairFound ; }

63.94
69.59
100.0
100.0
def countNonEmptySubstr ( str ) : n = len ( str ) return int ( n * ( n + 1 ) / 2 )

static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }

static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n ; }

static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }

64.02
66.28
92.11
89.63
def Resources ( process , need ) : minResources = 0 minResources = process * ( need - 1 ) + 1 return minResources

static int Resources ( int process , int need ) { int minResources = 0 ; minResources = process * ( need - 1 ) + 1 ; return minResources ; }

static int Resources ( int process , int need ) { int minResources = 0 ; int minResources = process * need ; int minResources = process * need ; return minResources ; }

static int Resources ( int process , int need ) { int minResources = 0 ; int minResources = process * ( need - 1 ) + 1 ; return minResources ; }

64.26
77.7
55.6
59.21
def CountSquares ( a , b ) : cnt = 0 for i in range ( a , b + 1 ) : j = 1 ; while j * j <= i : if j * j == i : cnt = cnt + 1 j = j + 1 i = i + 1 return cnt

static int countSquares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j <= i ; j ++ ) if ( j * j == i ) cnt ++ ; return cnt ; }

static int CountSquares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { int j = 1 ; while ( j * j <= i ) { if ( j * j == i ) cnt = cnt + 1 ; j = j + 1 ; } } return cnt ; }

static int CountSquares ( int a , int b ) { int cnt = 0 ; for ( int i = 1 ; i <= b ; i ++ ) { int j = 1 ; while ( j * j <= i ) { if ( j * j == i ) cnt = cnt + 1 ; j = j + 1 ; i = i + 1 ; } } return cnt ; }

64.29
54.94
76.93
67.12
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : maxSum = 0 arr . sort ( ) i = N - 1 while ( i >= 0 ) : if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i ] maxSum += arr [ i - 1 ] i -= 1 i -= 1 return maxSum

static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }

static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; while ( i >= 0 ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] maxSum += arr [ i - 1 ] i -= 1 ; } } return maxSum ; }

static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; maxSum += arr [ i - 1 ] ; } } return maxSum ; }

64.3
57.63
65.91
73.19
def search ( arr , n , x , k ) : i = 0 while ( i < n ) : if ( arr [ i ] == x ) : return i i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) print ( "numberisnotpresent!" ) return - 1

static int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k ) ; } System . out . println ( "number is " + "not present!" ) ; return - 1 ; }

static int search ( int arr [ ] , int x , int k ) { int i = 0 ; while ( i < arr . length ) { if ( arr [ i ] == x ) return i ; i = i + max ( 1 , arr [ i ] - x ) / k ) ; } print ( "numberisnotpresent!" ) return - 1 ; }

static int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + 1 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) ; } } return - 1 ; }

64.35
67.58
78.67
86.76
def getOddOccurrence ( arr , arr_size ) : for i in range ( 0 , arr_size ) : count = 0 for j in range ( 0 , arr_size ) : if arr [ i ] == arr [ j ] : count += 1 if ( count % 2 != 0 ) : return arr [ i ] return - 1

static int getOddOccurrence ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }

static int getOddOccurrence ( int arr [ ] , int arr_size ) { int count = 0 ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] == arr [ j ] ) count += 1 ; if ( count % 2 != 0 ) return arr [ i ] ; if ( count % 2 != 0 ) return arr [ i ] ; if ( count % 2 != 0 ) return arr [ i ] ; if

public static int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; if ( count % 2 != 0 ) return arr [ i ] ; if ( count % 2 != 0 ) return arr [ i ] ; } } return - 1 ; }

64.55
65.83
81.6
81.95
def maxSum ( arr , n ) : res = - sys . maxsize for i in range ( 0 , n ) : curr_sum = 0 for j in range ( 0 , n ) : index = int ( ( i + j ) % n ) curr_sum += j * arr [ index ] res = max ( res , curr_sum ) return res

static int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }

static int maxSum ( int arr [ ] , int n ) { int res = - sys . maxsize ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { res = max ( res , arr [ index ] ) ; } } return res ; }

static int maxSum ( int arr [ ] , int n ) { int res = - sys . maxsize ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { index = int ( ( i + j ) % n ) ; curr_sum += j * arr [ index ] ; res = max ( res , curr_sum ) ; } } return res ; }

64.62
62.98
51.78
48.35
def findSubsequenceCount ( S , T ) : m = len ( T ) n = len ( S ) if m > n : return 0 mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] for i in range ( 1 , m + 1 ) : mat [ i ] [ 0 ] = 0 for j in range ( n + 1 ) : mat [ 0 ] [ j ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if T [ i - 1 ] != S [ j - 1 ] : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] else : mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) return mat [ m ] [ n ]

static int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }

static int findSubsequenceCount ( int [ ] T , int [ ] S ) { int m = T . length ; int n = S . length ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] = mat [ i ] [ j - 1 ] ; } return mat [ m ] [ n ] ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] = mat [ i ] [ j - 1 ] + mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i ] [ j - 1 ] ; } return mat [ m ] [ n ] ;

static int findSubsequenceCount ( int [ ] S , int [ ] n ) { int m = len ( S ) ; int n = len ( S ) ; int [ ] mat = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) ; } } return mat [ m ] [ n ] ; }

64.73
55.76
64.01
53.63
def countSub ( arr , n ) : count = [ 0 for i in range ( 10 ) ] for i in range ( n ) : for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : count [ arr [ i ] ] += count [ j ] count [ arr [ i ] ] += 1 result = 0 for i in range ( 10 ) : result += count [ i ] return result

static int countSub ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }

static int countSub ( int arr [ ] , int n ) { int count [ ] = new int [ arr [ i ] - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) { count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] += 1 ; } return result ; } }

static int countSub ( int arr [ ] , int n ) { int count [ ] = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } } return result ; }

64.74
63.84
50.93
60.18
def mod ( num , a ) : res = 0 for i in range ( 0 , len ( num ) ) : res = ( res * 10 + int ( num [ i ] ) ) % a return res

static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; }

static int mod ( int num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { res = ( res * 10 + int ( num [ i ] ) ) % a ; } return res ; }

static int mod ( int num [ ] , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { res = ( res * 10 + int ( num [ i ] ) ) % a ; res = ( res * 10 + int ( num [ i ] ) ) % a ; } return res ; }

64.75
63.65
74.83
67.11
def countStrings ( n , k ) : dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] dp [ 1 ] [ 0 ] [ 0 ] = 1 dp [ 1 ] [ 0 ] [ 1 ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( k + 1 ) : dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] if j >= 1 : dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]

static int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }

static int countStrings ( int n , int k ) { int [ ] [ ] dp [ ] [ ] [ ] = new int [ n + 1 ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { if ( i >= 1 ) dp [ i ] [ j ] [ 0 ] += dp [ i - 1 ] [ j ] [ 1 ] ; if ( j >= 1 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j ] [ 1 ] ; if ( j >= 1 ) dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j ] [ j ] [ 0 ] + dp [ i ] [ j ] [ 1 ] ++ ; if ( j >= 1 ) dp [ i ] [ j ] [ 0 ] [ 1 ] += dp [ i ] [ j ] [ 1 ] [ 1 ] [ 1 ] [ 1 ] [ 1 ] [ 1 ] [ 0 ] [ 1 ] [ 1 ] [ 0 ] [ 1 ] ; } } return dp [ i ] [ j ]

static int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] [ ] = new int [ k + 1 ] [ ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) ; dp [ i ] [ j ] [ 1 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) ; dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }

64.78
64.5
73.32
71.63
def minCost ( cost ) : dist = [ 0 for i in range ( N ) ] for i in range ( N ) : dist [ i ] = INF dist [ 0 ] = 0 for i in range ( N ) : for j in range ( i + 1 , N ) : if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]

static int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }

static int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) if ( dist [ i ] > dist [ i ] + cost [ i ] [ j ] ) { dist [ i ] = dist [ i ] + cost [ i ] [ j ] ; } return dist [ 0 ] ; }

static int minCost ( int [ ] cost ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dist [ i ] = INF ; for ( int j = 0 ; j < N ; j ++ ) { dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) { dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; } } } return dist [ N - 1 ] ; }

64.91
61.38
78.39
79.62
def answerQuery ( a , n , l , r ) : count = 0 l = l - 1 for i in range ( l , r , 1 ) : element = a [ i ] divisors = 0 for j in range ( l , r , 1 ) : if ( a [ j ] % a [ i ] == 0 ) : divisors += 1 else : break if ( divisors == ( r - l ) ) : count += 1 return count

static int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }

static int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int divisors = 0 ; for ( int j = 0 ; j <= l ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { divisors += 1 ; } } if ( divisors == ( r - l ) ) {

static int answerQuery ( int [ ] a , int n , int l , int r ) { int count = 0 ; int l = l - 1 ; for ( int i = 0 ; i < l ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = 0 ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { divisors ++ ; } else { break ; } if ( divisors == ( r - l ) ) { count ++ ; } } } return count ; }

65.01
60.47
60.46
53.4
def lenghtOfLongestAP ( set , n ) : if ( n <= 2 ) : return n L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] llap = 2 for i in range ( n ) : L [ i ] [ n - 1 ] = 2 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while ( i >= 0 and k <= n - 1 ) : if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : k += 1 elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : L [ i ] [ j ] = 2 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) i -= 1 k += 1 while ( i >= 0 ) : L [ i ] [ j ] = 2 i -= 1 return llap

static int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ ] [ ] = new int [ n ] [ n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }

static int lenghtOfLongestAP ( int set [ ] , int n ) { int L [ ] [ ] = new int [ n ] [ n ] [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) { int k = j + 1 ; while ( k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) L [ i ] [ j ] = L [ j ] [ k ] + 1 ; else llap = max ( llap , L [ i ] [ j ] + 1 ; while ( i >= 0 ) L [ i ] [ j ] = L [ j ] [ k ] ; k ++ ) { for ( int i = j - 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ j ] > 2 * set [ j ] ) L [ i ] [ j ] = L [ j ] [ k ] + 1 ; else llap = L [ i ] [ j ] [ k ] + 1 ; } } } } while ( i >= 0 ) L [ i ] [ j ] [ k ] = L [ j ] ; k

int lenghtOfLongestAP ( int set , int n ) { int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i - 1 ; int k = i + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) { k += 1 ; if ( ( set [ i ] + set [ k ] > 2 * set [ j ] ) && ( set [ i ] + set [ k ] > 2 * set [ j ] ) ) L [ i ] [ j ] = 2 i -= 1 ; } else L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) ; i -= 1 k += 1 while ( i >= 0 ) { L [ i ] [ j ] = L [ i ] [ j ] + 1 llap = max ( llap , L [ i ] [ j ] ) ; i -= 1 k += 1 while ( i >= 0 ) { L [ i ] [ j ] = L [ i ] [ j ] + 1

65.09
61.25
53.41
48.27
def add ( A , B , C ) : for i in range ( N ) : for j in range ( N ) : C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]

static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }

static void add ( int N , int [ ] A , int [ ] B , int [ ] C ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } } }

; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } }

65.14
62.44
69.54
62.46
def minOps ( arr , n , k ) : max1 = max ( arr ) res = 0 for i in range ( 0 , n ) : if ( ( max1 - arr [ i ] ) % k != 0 ) : return - 1 else : res += ( max1 - arr [ i ] ) / k return int ( res )

static int minOps ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }

static int minOps ( int arr [ ] , int n , int k ) { int max1 = max ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max1 - arr [ i ] ) / k != 0 ) { res += ( max1 - arr [ i ] ) / k != 0 ) { res += ( max1 - arr [ i ] ) / k ; } } return - 1 ; }

static int minOps ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( max1 - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max1 - arr [ i ] ) / k ; } return res ; }

65.26
69.73
77.43
86.74
def nobleInteger ( arr ) : arr . sort ( ) n = len ( arr ) for i in range ( n - 1 ) : if arr [ i ] == arr [ i + 1 ] : continue if arr [ i ] == n - i - 1 : return arr [ i ] if arr [ n - 1 ] == 0 : return arr [ n - 1 ] return - 1

public static int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }

static int nobleInteger ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) return arr [ i ] ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; if ( arr [ i ] == 0 ) return arr [ i ] ; if ( arr [ i ] == n - i - 1 ) return

; } static int nobleInteger ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; } return - 1 ; }

65.27
64.11
42.73
59.91
def solve ( n , t , p ) : s = list ( p ) for i in range ( 0 , t ) : for j in range ( 0 , n - 1 ) : if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) : temp = s [ j ] s [ j ] = s [ j + 1 ] s [ j + 1 ] = temp j = j + 1 print ( '' . join ( s ) )

static void solve ( int n , int t , char s [ ] ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } System . out . print ( s ) ; }

static void solve ( int n , int t , int p [ ] ) { int temp ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s [ j ] == 'G' ) s [ j ] = s [ j + 1 ] ; s [ j ] = temp ; s [ j ] = s [ j + 1 ] ; s [ j ] = temp ;

static void solve ( int n , int t , List < String > p ) { for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) { temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; temp = j ; j = j + 1 ; } } } }

65.3
57.31
80.45
83.41
def countWays ( n , k ) : total = k mod = 1000000007 same , diff = 0 , k for i in range ( 2 , n + 1 ) : same = diff diff = total * ( k - 1 ) diff = diff % mod total = ( same + diff ) % mod return total

static long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }

static int countWays ( int n , int k ) { int total = 0 ; int diff = 0 ; for ( int i = 0 ; i < n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }

static int countWays ( int n , int k ) { int total = k ; int mod = 1000000007 ; int same = 0 ; int diff = 0 ; for ( int i = 2 ; i < n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }

65.4
59.9
83.85
86.79
def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 for i in range ( 0 , n ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return int ( abs ( area / 2.0 ) )

public static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }

static int polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return 0 ; }

static int polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return int ( abs ( area / 2.0 ) ) ; }

65.52
70.22
57.19
62.05
def allCharactersSame ( s ) : n = len ( s ) for i in range ( 1 , n ) : if s [ i ] != s [ 0 ] : return False return True

static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; }

static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != s [ i ] ) return false ; } return true ; }

static boolean allCharactersSame ( char [ ] s ) { int n = s . length ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! s [ i ] . equals ( s [ i ] ) ) return false ; } return true ; }

65.57
82.14
58.51
68.39
def slope ( x1 , y1 , x2 , y2 ) : return ( float ) ( y2 - y1 ) / ( x2 - x1 )

static float slope ( float x1 , float y1 , float x2 , float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; }

static float slope ( float x1 , float y1 , float x2 , float y2 ) { float slope = ( float ) ( x2 - x1 ) / ( y2 - y1 ) ; return slope ; }

public static float slope ( int x1 , int y1 , int x2 , int y2 ) { return ( float ) ( y2 - y1 ) / ( x2 - x1 ) ; }

65.6
65.08
90.31
87.95
def isOneFlip ( str ) : sum = 0 n = len ( str ) for i in range ( 0 , n ) : sum += int ( str [ i ] ) - int ( '0' ) return ( sum == n - 1 or sum == 1 )

static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += str . charAt ( i ) - '0' ; return ( sum == n - 1 || sum == 1 ) ; }

static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += int ( str [ i ] ) - int ( '0' ) ; } return false ; }

static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += str . charAt ( i ) ; } return ( sum == n - 1 || sum == 1 ) ; }

65.63
57.77
66.38
60.17
def countWays ( n ) : A = [ 0 ] * ( n + 1 ) B = [ 0 ] * ( n + 1 ) A [ 0 ] = 1 A [ 1 ] = 0 B [ 0 ] = 0 B [ 1 ] = 1 for i in range ( 2 , n + 1 ) : A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] B [ i ] = A [ i - 1 ] + B [ i - 2 ] return A [ n ]

static int countWays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }

static int countWays ( int n ) { int A [ ] = new int [ n + 1 ] ; int B [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + 2 * B [ i - 2 ] ; } return A [ n ] ; }

static int countWays ( int n ) { int A [ ] = new int [ n + 1 ] ; int B [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }

65.66
68.07
67.29
62.94
def splitArr ( arr , n , k ) : for i in range ( 0 , k ) : x = arr [ 0 ] for j in range ( 0 , n - 1 ) : arr [ j ] = arr [ j + 1 ] arr [ n - 1 ] = x

public static void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }

static void splitArr ( int arr [ ] , int n , int k ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = arr [ j ] + 1 ; arr [ n

static void splitArr ( int arr [ ] , int n , int k ) { int x = arr [ 0 ] ; for ( int j = 1 ; j < n ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }

65.67
72.52
49.03
75.26
def isHeap ( arr , i , n ) : if i > int ( ( n - 2 ) / 2 ) : return True if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : return True return False

static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; }

static boolean isHeap ( int arr [ ] , int i , int n ) { if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 2 , n ) and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) and isHeap ( arr , 2 * i +

static boolean isHeap ( int arr [ ] , int i , int n ) { if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) ) return true ; if ( arr [ i ] >= arr [ 2 * i + 2 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 2 , n ) ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) ) return true ; return false ; }

65.83
63.15
82.91
75.37
def maxSubArraySumRepeated ( a , n , k ) : max_so_far = - 2147483648 max_ending_here = 0 for i in range ( n * k ) : max_ending_here = max_ending_here + a [ i % n ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if ( max_ending_here < 0 ) : max_ending_here = 0 return max_so_far

static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }

static int maxSubArraySumRepeated ( int [ ] a , int n , int k ) { int max_so_far = - 2147483648 ; int max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_ending_here <

static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = - 2147483648 ; int max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_so_far = max_so_far + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }

65.84
62.65
72.74
68.44
def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : for j in range ( 0 , n - i - 1 ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ]

void bubbleSort ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } }

static void bubbleSort ( int [ ] arr ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) arr [ j ] , arr [ j + 1 ] = arr [ j ] , arr [ j ] ; } } return ; }

static void bubbleSort ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] ; } } }

65.95
57.31
70.73
73.47
def countPairs ( s ) : cnt = [ 0 for i in range ( 0 , MAX ) ] for i in range ( len ( s ) ) : cnt [ ord ( s [ i ] ) - 97 ] += 1 ans = 0 for i in range ( 0 , MAX ) : ans += cnt [ i ] * cnt [ i ] return ans

static int countPairs ( String s ) { int cnt [ ] = new int [ MAX ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s . charAt ( i ) ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; }

static int countPairs ( String s ) { int cnt = [ 0 for i in range ( 0 , MAX ) ] ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { ans += cnt [ i ] * cnt [ i ] ; } return ans ; } }

static int countPairs ( String s ) { int cnt [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { cnt [ ord ( s [ i ] ) - 97 ] += 1 ; ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { ans += cnt [ i ] * cnt [ i ] ; } } return ans ; }

66.11
66.81
66.19
73.68
def findCount ( str ) : result = 0 for i in range ( len ( str ) ) : if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : result += 1 return result

static int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - 'a' ) || i == ( str . charAt ( i ) - 'A' ) ) { result ++ ; } } return result ; }

static int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( i == str . charAt ( i ) ) - 'a' ) ) result += 1 ; else result += 1 ; } return result ; }

static int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) || ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) { result ++ ; } } return result ; }

66.13
67.99
64.63
66.46
def maximumChars ( str ) : n = len ( str ) res = - 1 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if ( str [ i ] == str [ j ] ) : res = max ( res , abs ( j - i - 1 ) ) return res

static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }

static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( str [ i ] == str [ j ] ) res = max ( res , abs ( j - i - 1 ) ) ; } } return res ; }

static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str [ i ] == str [ j ] ) { res = max ( res , abs ( j - i - 1 ) ) ; } } } return res ; }

66.22
63.95
56.27
50.59
def printRepeating ( arr , size ) : print ( "Repeatingelementsare" , end = '' ) for i in range ( 0 , size ) : for j in range ( i + 1 , size ) : if arr [ i ] == arr [ j ] : print ( arr [ i ] , end = '' )

void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( "Repeated Elements are :" ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " " ) ; } } }

static void printRepeating ( int arr [ ] , int size ) { System . out . print ( arr [ i ] ) ; System . out . print ( arr [ j ] ) ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = i ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] , end = '' ) ;

static void printRepeating ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { print ( arr [ i ] , end = '' ) ; } } } }

66.25
58.07
60.99
54.22
def doublefactorial ( n ) : res = 1 for i in range ( n , - 1 , - 2 ) : if ( i == 0 or i == 1 ) : return res else : res *= i

static int doublefactorial ( int n ) { int res = 1 ; for ( int i = n ; i >= 0 ; i = i - 2 ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }

static int doublefactorial ( int n ) { int res = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == 0 ) res *= i ; else res *= i ; } return res ; }

; int res = 1 ; for ( int n = 1 ; n <= 2 ; n ++ ) { res = 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }

66.3
45.96
89.14
60.41
def lastNon0Digit ( n ) : if ( n < 10 ) : return dig [ n ] if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 else : return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 return 0

static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }

static int lastNon0Digit ( int n ) { int lastNon0Digit = lastNon0Digit ( n ) ; if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) { return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 ; } else { return lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 ; } return lastNon0Digit ( n

static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n // 5 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 ; }

66.32
70.11
44.35
57.23
def assignValue ( a , b , x ) : arr = [ a , b ] return ( arr [ x ] )

static int assignValue ( int a , int b , int x ) { int arr [ ] = { a , b }; return ( arr [ x ] ) ; }

static int assignValue ( int a, int b, int x) {  int assignValue ( int a , int b , int x ) { return ( arr [ x ] ) ; }

public static boolean assignValue ( int a , int b , int x ) { return assignValue ( a , b , x ) ; }

66.33
67.93
69.5
74.07
def calculate ( A , B , C , M ) : res = pow ( B , C , M - 1 ) ans = pow ( A , res , M ) return ans

static int Calculate ( int A , int B , int C , int M ) { int res , ans ; res = power ( B , C , M - 1 ) ; ans = power ( A , res , M ) ; return ans ; }

static int calculate ( int A , int B , int C , int M ) { int res = pow ( A , B , M - 1 ) ; int ans = pow ( A , res , M ) ; return ans ; }

static int calculate ( int A , int B , int C , int M ) { int res = pow ( B , C , M - 1 ) ; int ans = pow ( A , res , M - 1 ) ; return ans ; }

66.4
65.29
70.95
67.19
def distancesum ( x , y , n ) : sum = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) return sum

static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }

static double distancesum ( double x [ ] , double y [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( x [ i ] - x [ j ] ) sum += ( abs ( y [ i ] - y [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; } return

static int distancesum ( int x , int y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { sum += abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ; } } return sum ; }

66.44
71.06
66.44
68.96
def isNumber ( s ) : for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) != True : return False return True

static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ; return true ; }

static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] . isalpha ( ) != True ) return false ; } return true ; }

public static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] . isdigit ( ) != true ) return false ; } return true ; }

66.5
56.11
74.4
76.72
def minDifferenceAmongMaxMin ( arr , N , K ) : arr . sort ( ) res = 2147483647 for i in range ( ( N - K ) + 1 ) : curSeqDiff = arr [ i + K - 1 ] - arr [ i ] res = min ( res , curSeqDiff ) return res

static int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }

static int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { int res = 2147483647 ; for ( int i = 0 ; i < N ; i ++ ) { int curSeqDiff = arr [ i ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; }

static int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { int res = 2147483647 ; for ( int i = 0 ; i < N ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; }

66.53
74.3
60.81
64.72
def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) for i in range ( n ) : for j in range ( i , n ) : if ( s [ i ] == s [ j ] ) : result = result + 1 return result

static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }

static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( s [ i ] == s [ j ] ) { result = result + 1 ; } } return result ; } return 0 ; }

static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ] ) { result = result + 1 ; break ; } } } return result ; }

66.54
63.44
69.87
70.2
def leftRotate ( arr , n , k ) : for i in range ( k , k + n ) : print ( str ( arr [ i % n ] ) , end = "" )

static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " " ) ; }

static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { print ( str ( arr [ i % n ] ) , end = "" ) ; } }

static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( arr [ i ] ) ; } }

66.57
68.23
97.47
98.46
def find ( n , k ) : if ( n + 1 >= k ) : return ( k - 1 ) else : return ( 2 * n + 1 - k )

public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }

static int find ( int n , int k ) { if ( n >= k ) return ( n - 1 ) ; else return ( k - 1 ) ; } }

static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }

66.57
60.52
55.26
45.75
def transpose ( A , B ) : for i in range ( N ) : for j in range ( N ) : B [ i ] [ j ] = A [ j ] [ i ]

static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }

static void transpose ( int N , int [ ] [ ] A , int [ ] [ ] B ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { B [ i ] [ j ] = A [ j ] [ i ] ; } } }

; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { B [ i ] [ j ] = A [ j ] [ i ] ; } }

66.6
68.86
63.74
58.53
def squareRootExists ( n , p ) : n = n % p for x in range ( 2 , p , 1 ) : if ( ( x * x ) % p == n ) : return True return False

static boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }

static boolean squareRootExists ( int n , int p ) { int x ; for ( x = 2 ; x <= p ; x ++ ) { if ( ( x * x ) % p == n ) { return true ; } } return false ; }

static boolean squareRootExists ( int n , int p ) { int n = n ; for ( int x = 2 ; x < p ; x ++ ) { if ( squareRootExists ( x , p ) ) return true ; } return false ; }

66.6
69.11
74.48
82.37
def modInverse ( a , m ) : a = a % m for x in range ( 1 , m ) : if ( ( a * x ) % m == 1 ) : return x return 1

static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }

static int modInverse ( int a , int m ) { int x ; for ( x = 1 ; x <= m ; x ++ ) { if ( ( a * x ) % m == 1 ) { return x ; } } return 1 ; }

; } static int modInverse ( int a , int m ) { int a = a % m ; for ( int x = 1 ; x <= m ; x ++ ) { if ( ( a * x ) % m == 1 ) return x ; } return - 1 ; }

66.64
84.12
100.0
100.0
def countObtuseAngles ( a , b , k ) : c1 = ( b - a ) - 1 c2 = ( k - b ) + ( a - 1 ) if ( c1 == c2 ) : return 0 return min ( c1 , c2 )

static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }

static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( k - a ) + ( a - 1 ) ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }  def countObtuseAngles ( int a , int b , int k ) { int c1 = (

static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }

66.84
70.42
78.72
80.49
def findMinX ( num , rem , k ) : x = 1 while ( True ) : j = 0 while ( j < k ) : if ( x % num [ j ] != rem [ j ] ) : break j += 1 if ( j == k ) : return x x += 1

static int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }

static int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j = 0 ; while ( j < k ) { if ( x % num [ j ] != rem [ j ] ) { break j += 1 } } return x ; } }

private static int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j = 0 ; while ( x % num [ j ] != rem [ j ] ) { break ; } j ++ ; if ( j == k ) return x ; x ++ ; } }

67.24
61.04
81.51
67.58
def ksmallest ( arr , n , k ) : b = [ 0 ] * MAX for i in range ( n ) : b [ arr [ i ] ] = 1 for j in range ( 1 , MAX ) : if ( b [ j ] != 1 ) : k -= 1 if ( k is not 1 ) : return j

static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Integer . MAX_VALUE ; }

static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( b [ arr [ i ] ] != 1 ) { b [ arr [ i ] ] = 1 ; for ( int j = 1 ; j <= MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -= 1 ; if ( k is not 1

static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -= 1 ; if ( k is not 1 ) return j ; } } } return - 1 ; }

67.32
72.17
90.29
88.16
def checkCount ( arr , n , k ) : for i in range ( n ) : count = 0 for j in range ( n ) : if arr [ j ] == arr [ i ] : count += 1 if count > 2 * k : return False return True

static boolean checkCount ( int [ ] arr , int n , int k ) { int count ; for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++ ; if ( count > 2 * k ) return false ; } } return true ; }

static boolean checkCount ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ j ] ) count += 1 ; if ( count > k ) return false ; if ( count > 2 * k ) return false ; if ( count > 2 * k ) return false ; for ( int j = 0 ; j < n ; j ++ ) if (

static boolean checkCount ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++ ; if ( count > 2 * k ) return false ; } } return true ; }

67.37
54.22
75.65
62.57
def numberOfPaths ( m , n ) : for i in range ( n , ( m + n - 1 ) ) : path *= i path //= ( i - n + 1 ) return path

static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }

static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { path *= i ; path //= ( i - n ) ; } return path ; }

static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = 0 ; i < m ; i ++ ) { path *= i ; path *= i ; path // = ( i - n + 1 ) ; } return path ; }

67.4
58.83
72.86
62.46
def minDiff ( arr , n , k ) : result = + 2147483647 arr . sort ( ) for i in range ( n - k + 1 ) : result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) return result

static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }

static int minDiff ( int arr [ ] , int n , int k ) { int result = - 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) ; } return result ; }

static int minDiff ( int arr [ ] , int n , int k ) { int result = + 2147483647 ; arr . sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { result = int . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; } return result ; }

67.46
66.1
95.11
98.71
def multiplyBySeven ( n ) : return ( ( n << 3 ) - n )

static int multiplyBySeven ( int n ) { return ( ( n << 3 ) - n ) ; }

static int multiplyBySeven ( int n ) { return ( n << 3 ) -

public static int multiplyBySeven ( int n ) { return ( ( n << 3 ) - n ) ; }

67.47
77.13
58.19
74.8
def findSum ( n ) : sm = 0 for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : sm = sm + i * j return sm

static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }

static int findSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { sm = sm + i * j ; } } return sm ; }

static int findSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { sm = sm + i * j ; if ( sm == 0 ) return sm ; } } return sm ; }

67.55
66.38
65.12
55.83
def CountWays ( n ) : table = [ 0 ] * ( n + 1 ) table [ 0 ] = 1 for i in range ( 1 , n ) : for j in range ( i , n + 1 ) : table [ j ] += table [ j - i ] return table [ n ]

static int countWays ( int n ) { int table [ ] = new int [ n + 1 ] ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; return table [ n ] ; }

static int CountWays ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { table [ j ] += table [ j - i ] ; } return table [ n ] ; } }

static int CountWays ( int n ) { int table [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { table [ i ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) table [ j ] += table [ j - i ] ; } return table [ n ] ; }

67.73
73.83
70.03
77.07
def countIntegralSolutions ( n ) : result = 0 for i in range ( n + 1 ) : for j in range ( n + 1 ) : for k in range ( n + 1 ) : if i + j + k == n : result += 1 return result

static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }

static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( i + j + k == n ) result += 1 ; } } } return result ; }

static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( i + j + k == n ) result ++ ; } } return result ; } }

67.88
74.96
70.3
77.55
def countNonDecreasing ( n ) : N = 10 count = 1 for i in range ( 1 , n + 1 ) : count = int ( count * ( N + i - 1 ) ) count = int ( count / i ) return count

static long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }

static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count = int ( count * N + i - 1 ) ; count = int ( count / i ) ; } return count ; }

static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count = int ( count * ( N + i - 1 ) ) ; count = count / i ; } return count ; }

67.9
68.7
64.44
63.61
def checkIfAllTogether ( s , c ) : oneSeen = False i = 0 n = len ( s ) while ( i < n ) : if ( s [ i ] == c ) : if ( oneSeen == True ) : return False while ( i < n and s [ i ] == c ) : i = i + 1 oneSeen = True else : i = i + 1 return True

static boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( oneSeen == true ) return false ; while ( i < n && s . charAt ( i ) == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }

static boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 ; int n = s . length ( ) ; while ( i < n ) { if ( oneSeen == true ) return false ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) { oneSeen = true ;

static boolean checkIfAllTogether ( char [ ] s , char c ) { boolean oneSeen = false ; int i = 0 ; int n = s . length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i = i + 1 ; oneSeen = true ; else i = i + 1 ; } } return true ; }

68.0
68.48
86.53
91.78
def findSum ( n ) : sum = 0 for i in range ( n ) : sum += i * ( n - i ) return 2 * sum

static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }

static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i ; }

; static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += i * ( n - i ) ; } return 2 * sum ; }

68.0
66.51
63.21
72.63
def canMakeAllSame ( str ) : zeros = 0 ones = 0 for i in range ( 0 , len ( str ) ) : ch = str [ i ] if ( ch == '0' ) : zeros = zeros + 1 else : ones = ones + 1 return ( zeros == 1 or ones == 1 )

static boolean canMakeAllSame ( String str ) { int zeros = 0 , ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '0' ) ++ zeros ; else ++ ones ; } return ( zeros == 1 || ones == 1 ) ; }

static boolean canMakeAllSame ( String str ) { int zeros = 0 ; int ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ch == '0' ) zeros = zeros + 1 ; else ones = ones + 1 ; } return ( zeros == 1 and ones == 1 ) ; }

static boolean canMakeAllSame ( String str ) { int zeros = 0 ; int ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch == '0' ) zeros = zeros + 1 ; else if ( ch == '1' ) zeros = zeros + 1 ; else ones = ones + 1 ; } return ( zeros == 1 || ones == 1 ) ; }

68.08
65.39
72.15
67.9
def isPowerOfFour ( n ) : if ( n == 0 ) : return False while ( n != 1 ) : if ( n % 4 != 0 ) : return False n = n // 4 return True

static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }

static boolean isPowerOfFour ( int n ) { if ( n == 0 ) return false ; while ( n != 0 ) { if ( n % 4 != 0 ) return false ; n = n // 4 ; } return true ; }

public static boolean isPowerOfFour ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 4 != 0 ) return false ; n = n // 4 ; } return true ; }

68.22
61.61
67.26
62.28
def isMinHeap ( level , n ) : for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : if level [ i ] > level [ 2 * i + 1 ] : return False if 2 * i + 2 < n : if level [ i ] > level [ 2 * i + 2 ] : return False return True

static boolean isMinHeap ( int [ ] level ) { int n = level . length - 1 ; for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }

static boolean isMinHeap ( int [ ] level , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; if ( 2 * i + 2 ] > level [ 2 * i + 2 ] ) return

static boolean isMinHeap ( int [ ] level , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; if ( 2 * i + 2 < n ) if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } return true ; }

68.24
78.58
69.96
82.18
def findMinSum ( num ) : sum = 0 i = 2 while ( i * i <= num ) : while ( num % i == 0 ) : sum += i num /= i i += 1 sum += num return sum

static int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }

static int findMinSum ( int num ) { int sum = 0 ; int i = 2 ; while ( i * i <= num ) { while ( i * i <= num ) { while ( num % i == 0 ) { sum += i ; num /= i ; i ++ ; } } return sum ; }

static int findMinSum ( int num ) { int sum = 0 ; int i = 2 ; while ( i * i <= num ) { while ( num % i == 0 ) { sum += i num /= i ; sum += i ; num /= i ; i ++ ; } sum += num ; } return sum ; }

68.64
71.6
88.92
91.02
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) radSumSq = ( r1 + r2 ) * ( r1 + r2 ) if ( distSq == radSumSq ) : return 1 elif ( distSq > radSumSq ) : return - 1 else : return 0

static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }

static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) + ( r1 - r2 ) * ( r1 - r2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 +

static int circle ( int x1 , int y1 , int x2 , int y2 , float r1 , float r2 ) { double distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; double radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }

68.66
69.91
94.85
95.07
def hexagonalNum ( n ) : return n * ( 2 * n - 1 )

int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }

static int hexagonalNum ( int n ) { return n * ( n - 1 )

static int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }

68.7
65.91
66.92
55.66
def minXOR ( arr , n ) : arr . sort ( ) minXor = int ( sys . float_info . max ) val = 0 for i in range ( 0 , n - 1 ) : val = arr [ i ] ^ arr [ i + 1 ] minXor = min ( minXor , val ) return minXor

static int minXOR ( int arr [ ] , int n ) { Arrays . parallelSort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }

static int minXOR ( int arr [ ] , int n ) { int minXor = int ( sys . float_info . max ) ; for ( int i = 0 ; i < n ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = min ( minXor , val ) ; } return minXor ; }

( int arr , int n ) { int minXor = int ( sys . float_info . max ) ; int val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = min ( minXor , val ) ; } return minXor ; }

68.83
70.34
28.04
41.93
def FindMaxProduct ( arr , n ) : max = 0 for i in range ( n ) : for j in range ( n ) : if ( ( j - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) if ( max < result ) : max = result if ( ( i - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) if ( max < result ) : max = result if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) if ( max < result ) : max = result return max

static int FindMaxProduct ( int arr [ ] [ ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } } } return max ; }

static int FindMaxProduct ( int [ ] arr , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i - 3 ) >= 0 ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) ; if ( ( max < result ) ) { max = result ; if ( ( max < result ) { max = result ; if ( ( i - 3 ) >= 0 ) { if ( ( j - 3 ) >= 0 ) { if ( ( i - 3 ) >= 0 ) { result = ( arr [ i ] [ j ] * arr [ i ] [ j ] * arr [ i ] [ j ] * arr [ j ] * arr [ i ] [ j ] * arr [ j ] ) ; if ( max < result ) { max = result ; if ( max < result ) { max = result ; if ( max < result ) { max = result ; } } } } } } } } } } } } } }

static int FindMaxProduct ( int [ ] arr , int n ) { int max = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) ; if ( max < result ) { max = result ; } } } } return max ; }

68.88
77.64
96.9
97.99
def middleOfThree ( a , b , c ) : x = a - b y = b - c z = a - c if x * y > 0 : return b elif ( x * z > 0 ) : return else : return a

public static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }

static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( y * z > 0 ) { return c ; } else { return a ; } }

; } static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }

68.95
66.45
86.63
85.07
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) return math . ceil ( d // ( 2 * r ) )

static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }

static int minRevolutions ( int r , int x1 , int y1 , int x2 , int y2 ) { int d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return 0 ; }

static int minRevolutions ( int r , int x1 , int y1 , int x2 , int y2 ) { int d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }

68.95
61.68
81.97
71.12
def maxLen ( arr ) : max_len = 0 for i in range ( len ( arr ) ) : curr_sum = 0 for j in range ( i , len ( arr ) ) : curr_sum += arr [ j ] if curr_sum == 0 : max_len = max ( max_len , j - i + 1 ) return max_len

static int maxLen ( int arr [ ] , int n ) { int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ; } } return max_len ; }

static int maxLen ( int arr [ ] ) { int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < arr . length ; j ++ ) { if ( curr_sum == 0 ) max_len = max ( max_len , j - i + 1 ) ; else max_len = max ( max_len , j - i +

static int maxLen ( int arr [ ] ) { int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = max ( max_len , j - i + 1 ) ; } } return max_len ; }

68.96
64.4
64.18
50.48
def printSquares ( n ) : square = 0 ; prev_x = 0 ; for x in range ( 0 , n ) : square = ( square + x + prev_x ) print ( square , end = "" ) prev_x = x

static void printSquares ( int n ) { int square = 0 , prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; System . out . print ( square + " " ) ; prev_x = x ; } }

static void printSquares ( int n ) { int square = 0 ; int prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + prev_x ) + ( square + prev_x ) ; print ( square , end = "" ) ; } }

; int square = 0 ; int prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; print ( square , end = "" ) ; prev_x = x ; } return square ; }

69.12
70.94
85.92
82.6
def countWays ( n , m ) : count = [ ] for i in range ( n + 2 ) : count . append ( 0 ) count [ 0 ] = 0 for i in range ( 1 , n + 1 ) : if ( i > m ) : count [ i ] = count [ i - 1 ] + count [ i - m ] elif ( i < m ) : count [ i ] = 1 else : count [ i ] = 2 return count [ n ]

static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }

static int countWays ( int n , int m ) { int count [ ] = new int [ n + 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else count [ i ] = 0 ; } return count [ n ] ; }

static int countWays ( int n , int m ) { int count [ ] = new int [ n + 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }

69.15
74.53
66.97
69.21
def findMissing ( a , b , n , m ) : for i in range ( n ) : for j in range ( m ) : if ( a [ i ] == b [ j ] ) : break if ( j == m - 1 ) : print ( a [ i ] , end = "" )

static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " " ) ; } }

static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] == b [ j ] ) { break if ( j == m - 1 ) print ( a [ i ] , end = "" ) ; if ( j == m - 1 ) print ( b [

static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ j ] ) break ; if ( j == m - 1 ) { print ( a [ i ] , end = "" ) ; } } }

69.27
64.19
55.26
46.73
def transpose ( A , B ) : for i in range ( N ) : for j in range ( M ) : B [ i ] [ j ] = A [ j ] [ i ]

static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }

static void transpose ( int [ ] [ ] A , int [ ] [ ] B ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { B [ i ] [ j ] = A [ j ] [ i ] ; } } }

; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { B [ i ] [ j ] = A [ j ] [ i ] ; } }

69.33
70.24
68.91
69.19
def findNth ( n ) : count = 0 curr = 19 while ( True ) : sum = 0 x = curr while ( x > 0 ) : sum = sum + x % 10 x = int ( x / 10 ) if ( sum == 10 ) : count += 1 if ( count == n ) : return curr curr += 9 return - 1

public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }

static int findNth ( int n ) { int count = 0 ; int curr = 19 ; while ( true ) { int sum = 0 ; int x = curr ; while ( x > 0 ) { sum = sum + x % 10 ; x = x / 10 ; } if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; curr ++ ; } return curr ; } }

static int findNth ( int n ) { int count = 0 ; int curr = 19 ; while ( true ) { int sum = 0 ; int x = curr ; while ( x > 0 ) { sum = sum + x % 10 ; x = int ( x / 10 ) ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; curr ++ ; } } }

69.4
57.72
84.46
85.67
def pushZerosToEnd ( arr , n ) : count = 0 for i in range ( n ) : if arr [ i ] != 0 : arr [ count ] = arr [ i ] count += 1 while count < n : arr [ count ] = 0 count += 1

static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }

static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != 0 ) arr [ count ] = arr [ i ] ; count ++ ; } return ; }

static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) arr [ count ] = arr [ i ] ; count ++ ; } while ( count < n ) arr [ count ] = 0 ; }

69.56
68.07
76.54
74.58
def search ( arr , n , x ) : i = 0 while ( i <= n - 1 ) : if ( arr [ i ] == x ) : return i i += abs ( arr [ i ] - x ) return - 1

static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i ; i += Math . abs ( arr [ i ] - x ) ; } return - 1 ; }

static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n ) { if ( arr [ i ] == x ) return i + 1 ; } return - 1 ; } return - 1 ; }

static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i ; i ++ ; } return - 1 ; }

69.58
80.34
67.67
76.55
def isSparse ( array , m , n ) : counter = 0 for i in range ( 0 , m ) : for j in range ( 0 , n ) : if ( array [ i ] [ j ] == 0 ) : counter = counter + 1 return ( counter > ( ( m * n ) // 2 ) )

static boolean isSparse ( int array [ ] [ ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; }

static boolean isSparse ( int array [ ] [ ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( array [ i ] [ j ] == 0 ) { counter = counter + 1 ; } } return ( counter > ( m * n ) / 2 ) ; return ( counter > 0 ) ; } return (

static boolean isSparse ( int [ ] array , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( array [ i ] [ j ] == 0 ) { counter = counter + 1 ; return ( counter > ( ( m * n ) // 2 ) ) ; } } return false ; } }

69.61
52.0
77.39
76.7
def squareRoot ( n ) : x = n y = 1 e = 0.000001 while ( x - y > e ) : x = ( x + y ) / 2 y = n / x return x

static float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }

static int squareRoot ( int n ) { int x = n / 2 ; int y = 1 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }

static int squareRoot ( int n ) { int x = n ; int y = 1 ; int e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }

69.67
76.13
65.64
59.76
def maxSum ( arr , n ) : arr . sort ( ) sum = 0 for i in range ( n ) : sum += arr [ i ] * i return sum

static int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }

static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * i ; } return sum ; }

static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] * i ; } return sum ; }

70.06
62.66
75.33
81.4
def getSingle ( arr , n ) : ones = 0 twos = 0 for i in range ( n ) : twos = twos | ( ones & arr [ i ] ) ones = ones ^ arr [ i ] common_bit_mask = ~ ( ones & twos ) ones &= common_bit_mask twos &= common_bit_mask return ones

static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }

static int getSingle ( int arr [ ] , int n ) { int ones = 0 ; int twos = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int common_bit_mask = ~ ( ones & twos ) ; ones = ones | ( twos & arr [ i ] ) ; twos = twos ^ arr [ i ] ; } return ones ; }

static int getSingle ( int arr [ ] , int n ) { int ones = 0 ; int twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ones = ones | arr [ i ] ; twos = twos | arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; } return ones ; }

70.14
66.67
70.14
66.67
def catalan ( n ) : if n <= 1 : return 1 res = 0 for i in range ( n ) : res += catalan ( i ) * catalan ( n - i - 1 ) return res

int catalan ( int n ) { int res = 0 ; if ( n <= 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }

static int catalan ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }

static int catalan ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }

70.3
69.06
69.29
69.43
def findFrequency ( arr , n , left , right , element ) : count = 0 for i in range ( left - 1 , right ) : if ( arr [ i ] == element ) : count += 1 return count

public static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i < right ; ++ i ) if ( arr [ i ] == element ) ++ count ; return count ; }

static int findFrequency ( int arr [ ] , int left , int right , int element ) { int count = 0 ; for ( int i = left ; i <= right ; i ++ ) { if ( arr [ i ] == element ) count += 1 ; } return count ; }

static int findFrequency ( int arr , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left ; i <= right ; i ++ ) { if ( arr [ i ] == element ) { count ++ ; } } return count ; }

70.31
85.98
66.3
84.64
def findSum ( N , K ) : ans = 0 y = N / K x = N % K ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) return int ( ans )

static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }

static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; int y = N / K ; int x = N % K ; int ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; return int ( ans ) ; }

static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ( ( K * ( K - 1 ) / 2 ) * ans + ( x * ( x + 1 ) ) / 2 ) ; }

70.8
64.22
78.39
69.05
def areDisjoint ( set1 , set2 , m , n ) : for i in range ( 0 , m ) : for j in range ( 0 , n ) : if ( set1 [ i ] == set2 [ j ] ) : return False return True

boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { for ( int i = 0 ; i < set1 . length ; i ++ ) { for ( int j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }

static boolean areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( set1 [ i ] != set2 [ j ] ) { return false ; } } return true ; } }

static boolean areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }

70.95
63.5
59.29
66.6
def getInvCount ( arr , n ) : inv_count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : inv_count += 1 return inv_count

static int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }

static int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) inv_count += 1 ; } } return inv_count ; }

static int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { inv_count ++ ; } } } return inv_count ; }

71.06
63.64
67.2
62.53
def KnapSack ( val , wt , n , W ) : dp = [ 0 ] * ( W + 1 ) for i in range ( n ) : for j in range ( W , wt [ i ] , - 1 ) : dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) return dp [ W ]

static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }

static int KnapSack ( int val [ ] , int wt [ ] , int W ) { int dp [ ] = new int [ W + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < wt [ i ] ; j ++ ) { dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; } return dp [ W ] ; }

static int KnapSack ( int val [ ] , int wt [ ] , int n ) { int dp [ ] = new int [ W ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; } return dp [ W ] ; } }

71.1
73.47
76.97
73.6
def sequence ( n ) : if n == 1 or n == 2 : return 1 else : return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;

static int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }

static int sequence ( int n ) { if ( n == 0 ) return 1 ; else return sequence ( n - 1 ) + sequence ( n - sequence ( n - 2 ) ) ; } }

static int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( n - 1 ) + sequence ( n - 1 ) ; }

71.26
72.21
82.18
75.96
def isIdentity ( mat , N ) : for row in range ( N ) : for col in range ( N ) : if ( row == col and mat [ row ] [ col ] != 1 ) : return False elif ( row != col and mat [ row ] [ col ] != 0 ) : return False return True

static boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }

static boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col and mat [ row ] [ col ] != 0 ) { return false ; } } return true ; } }

public static boolean isIdentity ( int mat [ ] [ ] , int row , int col ) { for ( int row = 0 ; row < mat . length ; row ++ ) { for ( int col = 0 ; col < mat . length ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }

71.26
66.77
79.84
77.72
def coutSubSeq ( A , N , M ) : sum = 0 ans = 0 for i in range ( 0 , N ) : for j in range ( i + 1 , N ) : for k in range ( j + 1 , N ) : sum = A [ i ] + A [ j ] + A [ k ] if ( sum % M == 0 ) : ans = ans + 1 return ans

static int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }

static int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ k ] % M == 0 ) { ans =

static int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; sum = sum + A [ k ] + A [ i ] ; if ( sum % M == 0 ) { ans = ans + 1 ; } } } } return ans ; }

71.38
79.73
78.28
82.44
def twoWaySort ( arr , n ) : for i in range ( 0 , n ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1 arr . sort ( ) for i in range ( 0 , n ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1

static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }

static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; arr . sort ( ) for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 2 ) arr [ i ] *= - 1 ; arr . sort ( ) for ( int i = 0 ; i <

static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; arr . sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; arr . sort ( ) ; } } }

71.4
71.26
75.83
69.57
def minSum ( a , n ) : a = sorted ( a ) num1 , num2 = 0 , 0 for i in range ( n ) : if i % 2 == 0 : num1 = num1 * 10 + a [ i ] else : num2 = num2 * 10 + a [ i ] return num2 + num1

static int minSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }

static int minSum ( int [ ] a , int n ) { int num1 , num2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num1 + num2 ; } return 0 ; }

static int minSum ( int a , int n ) { int num1 = 0 , num2 = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }

71.42
63.33
85.31
84.53
def sortit ( arr , n ) : for i in range ( n ) : arr [ i ] = i + 1

static void sortit ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } }

static void sortit ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i < arr . length ) arr [ i ] = i + 1 ; } }

; int sortit ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } }

71.48
62.45
53.07
60.32
def search ( arr , n , x ) : i = 0 while ( i < n ) : if ( arr [ i ] == x ) : return i i = i + abs ( arr [ i ] - x ) print ( "numberisnotpresent!" ) return - 1

static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( "number is not" + " present!" ) ; return - 1 ; }

static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < arr . length ) { if ( arr [ i ] == x ) return i ; i = i + abs ( arr [ i ] - x ) ; } print ( "numberisnotpresent!" ) return - 1 ; }

static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i ++ ; } return - 1 ; }

71.57
69.64
74.94
81.24
def findRepeating ( arr , n ) : res = 0 for i in range ( 0 , n - 1 ) : res = res ^ ( i + 1 ) ^ arr [ i ] res = res ^ arr [ n - 1 ] return res

static int findRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ; res = res ^ arr [ n - 1 ] ; return res ; }

static int findRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; res = res ^ arr [ i ] ; } return res ; }

static int findRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { res = res ^ ( i + 1 ) ^ arr [ i ] ; res = res ^ arr [ i ] ; res = res ^ arr [ n - 1 ] ; } return res ; }

71.73
62.42
75.01
69.26
def countWays ( arr , m , N ) : count = [ 0 for i in range ( N + 1 ) ] count [ 0 ] = 1 for i in range ( 1 , N + 1 ) : for j in range ( m ) : if ( i >= arr [ j ] ) : count [ i ] += count [ i - arr [ j ] ] return count [ N ]

static int countWays ( int N ) { int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; }

static int countWays ( int arr [ ] , int m , int N ) { int count [ ] = 0 ; for ( int i = 1 ; i <= arr [ m ] ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; } return count [ N ] ; }

static int countWays ( int arr [ ] , int m , int N ) { int count [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; } } return count [ N ] ; }

71.78
68.1
38.89
43.56
def MatrixChainOrder ( p , i , j ) : if i == j : return 0 _min = sys . maxsize for k in range ( i , j ) : count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) if count < _min : _min = count return _min

static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }

static int MatrixChainOrder ( int [ ] p , int i , int j ) { int _min = 0 ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; if ( count < _min ) _min = count ; } return

static int MatrixChainOrder ( int p , int i , int j ) { int _min = 0 ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) ; if ( count < _min ) _min = count ; } return _min ; }

71.88
75.56
97.08
97.62
def findCountOfSolutions ( n , p ) : ans = 0 for x in range ( 1 , p ) : if ( ( x * x ) % p == 1 ) : last = x + p * ( n / p ) if ( last > n ) : last -= p ans += ( ( last - x ) / p + 1 ) return int ( ans )

static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }

static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int last = x + p * ( n / p ) ; if ( last > n ) { ans += ( ( last - x ) / p + 1 ) ; } } return int ( ans ) ; }

static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < n ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }

72.26
73.14
65.32
69.21
def count ( s , c ) : res = 0 for i in range ( len ( s ) ) : if ( s [ i ] == c ) : res = res + 1 return res

public static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) res ++ ; } return res ; }

static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < len ( s ) ; i ++ ) { if ( s [ i ] == c ) res = res + 1 ; } return res ; }

static int count ( String s , int c ) { int res = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == c ) { res = res + 1 ; break ; } } return res ; }

72.31
67.33
74.94
73.34
def countDigits ( a , b ) : count = 0 p = abs ( a * b ) if ( p == 0 ) : return 1 while ( p > 0 ) : count = count + 1 p = p // 10 return count

static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }

static int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; while ( p > 0 ) { count = count + 1 ; p = p / 10 ; } return count ; }

static int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count = count + 1 ; p = p / 10 ; if ( p == 0 ) return 1 ; } return count ; }

72.31
68.91
80.87
69.32
def countPairs ( arr , n ) : result = 0 ; for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] ; for k in range ( 0 , n ) : if ( arr [ k ] == product ) : result = result + 1 ; break ; return result ;

static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }

static int countPairs ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) if ( arr [ k ] == product ) { result = result + 1 ; break ; } } return result ; }

static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < arr . length ; k ++ ) { if ( arr [ k ] == product ) { result = result + 1 ; break ; } } } } return result ; }

72.65
70.04
70.71
79.0
def findMinZero ( p ) : first = 1 second = 1 number = 2 next = 1 while ( next ) : next = ( first + second ) % p first = second second = next number = number + 1 return number

static int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }

static int findMinZero ( int p ) { int first = 1 ; int second = 1 ; int number = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number = number + 1 ; } return number ; }

static int findMinZero ( int p ) { int first = 1 ; int second = 1 ; int number = 2 ; int next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number = number + 1 ; } return number ; }

72.67
57.0
81.7
81.54
def PositionRightmostSetbit ( n ) : position = 1 m = 1 while ( not ( n & m ) ) : m = m << 1 position += 1 return position

static int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }

static int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( m != 0 ) { m = m << 1 ; } return position ; }

static int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) { m = m << 1 ; position += 1 ; } return position ; }

72.69
85.41
100.0
100.0
def swapNibbles ( x ) : return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )

static int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }

static int swapNibbles ( int x ) { return ( x & 0xF ) << 4 | ( x & 0x0F ) >> 4 | ( x & 0xF0 ) >> 4 ) ; }

static int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }

72.72
70.26
76.35
69.35
def countDivisibles ( arr , n ) : res = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : res += 1 return res

static int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; return res ; }

static int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) res += 1 ; } } return res ; }

static int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; } } return res ; }

73.15
79.31
73.15
79.31
def modFact ( n , p ) : if n >= p : return 0 result = 1 for i in range ( 1 , n + 1 ) : result = ( result * i ) % p return result

static int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }

static int modFact ( int n , int p ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { result = ( result * i ) % p ; } return result ; }

static int modFact ( int n , int p ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { result = ( result * i ) % p ; } return result ; }

73.25
67.57
54.86
60.63
def checkcircle ( r , R , r1 , x1 , y1 ) : dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) return ( dis - r1 >= R and dis + r1 <= r )

public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }

static boolean checkcircle ( int R , int r1 , int x1 , int y1 ) { int dis = int ( math . sqrt ( R * R + x1 * x1 + y1 * y1 ) ) ; return ( dis - r1 >= R and dis + r1 <= r ) ; }

static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { return ( dis - r1 >= R && dis + r1 <= r ) ; }

73.35
78.89
67.03
68.06
def russianPeasant ( a , b ) : res = 0 while ( b > 0 ) : if ( b & 1 ) : res = res + a a = a << 1 b = b >> 1 return res

static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( ( b & 1 ) != 0 ) res = res + a ; a = a << 1 ; b = b >> 1 ; } return res ; }

static int russianPeasant ( int a , int b ) { int res = 0 ; while ( a > 0 ) res = res + a ; a = a << 1 ; b = b >> 1 ; } return res ; }

static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( b & 1 ) res = res + a ; else res = res + a ; } return res ; }

73.43
76.98
59.04
80.86
def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }

static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { if ( wt [ n - 1 ] > W ) return knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W , wt , val , n - 1 ) , knapSack ( W , wt , val , n

static int knapSack ( int W , int [ ] wt , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return 0 ; if ( val [ n - 1 ] > W ) return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ) ; }

73.43
76.98
59.04
80.86
def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }

static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { if ( wt [ n - 1 ] > W ) return knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W , wt , val , n - 1 ) , knapSack ( W , wt , val , n

static int knapSack ( int W , int [ ] wt , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return 0 ; if ( val [ n - 1 ] > W ) return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ) ; }

73.43
76.98
59.04
80.86
def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )

static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }

static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { if ( wt [ n - 1 ] > W ) return knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W , wt , val , n - 1 ) , knapSack ( W , wt , val , n

static int knapSack ( int W , int [ ] wt , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return 0 ; if ( val [ n - 1 ] > W ) return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ) ; }

73.49
68.86
72.7
68.92
def nCrModp ( n , r , p ) : C = [ 0 for i in range ( r + 1 ) ] C [ 0 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( min ( i , r ) , 0 , - 1 ) : C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p return C [ r ]

static int nCrModp ( int n , int r , int p ) { int C [ ] = new int [ r + 1 ] ; Arrays . fill ( C , 0 ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }

static int nCrModp ( int n , int r , int p ) { int C [ ] = new int [ r + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < r ; j ++ ) { C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }

static int nCrModp ( int n , int r , int p ) { int C [ ] = new int [ r + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < r ; j ++ ) { C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } } return C [ r ] ; }

73.59
69.53
70.67
68.25
def countNegative ( M , n , m ) : count = 0 i = 0 j = m - 1 while j >= 0 and i < n : if M [ i ] [ j ] < 0 : count += ( j + 1 ) i += 1 else : j -= 1 return count

static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }

static int countNegative ( int [ ] [ ] M , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 and i < n ) { if ( M [ i ] [ j ] < 0 ) count += ( j + 1 ) i ++ ; else j -- ; } return count ; }

static int countNegative ( int [ ] M , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ; ) { if ( M [ i ] [ j ] < 0 ) count ++ ; i ++ ; else j -- ; } return count ; }

73.64
78.93
76.69
79.95
def countSol ( coeff , start , end , rhs ) : if ( rhs == 0 ) : return 1 result = 0 for i in range ( start , end + 1 ) : if ( coeff [ i ] <= rhs ) : result += countSol ( coeff , i , end , rhs - coeff [ i ] ) return result

static int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }

static int countSol ( int [ ] coeff , int start , int end , int rhs ) { int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( coeff [ i ] >= rhs ) { result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; } } return result ; }

static int countSol ( int coeff , int start , int end , int rhs ) { int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( coeff [ i ] <= rhs ) { result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; } } return result ; }

73.76
79.4
89.83
94.21
def calculateSum ( n ) : sum = 0 for row in range ( n ) : sum = sum + ( 1 << row ) return sum

static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }

static int calculateSum ( int n ) { int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) sum = sum + ( 1 << row ) ; }

static int calculateSum ( int n ) { int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }

73.76
78.29
63.35
70.53
def nonFibonacci ( n ) : prevPrev = 1 prev = 2 curr = 3 while n > 0 : prevPrev = prev prev = curr curr = prevPrev + prev n = n - ( curr - prev - 1 ) n = n + ( curr - prev - 1 ) return prev + n

static int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }

static int nonFibonacci ( int n ) { int prevPrev = 1 ; int prev = 2 ; int curr = 3 ; while ( n > 0 ) { prevPrev = prevPrev ; prev = prev ; prev = curr ; curr = prevPrev + prev ; n = n + ( curr - prev - 1 ) ; } return prev + n ; }

static int nonFibonacci ( int n ) { int prevPrev = 1 ; int prev = 2 ; int curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; n = n - ( curr - prev - 1 ) ; } return prev + n ; }

73.8
67.87
82.75
83.26
def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 for i in range ( 0 , n ) : area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return abs ( area // 2.0 )

static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }

static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return area ; }

static int polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return abs ( area / 2.0 ) ; }

73.85
85.76
54.0
61.78
def findSmallest ( arr , n ) : res = 1 for i in range ( 0 , n ) : if arr [ i ] <= res : res = res + arr [ i ] else : break return res

int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }

static int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= res ) res = res + arr [ i ] ; else res ++ ; } return res ; }

static int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] <= res ) res = res + arr [ i ] ; else if ( arr [ i ] == res ) res = res + arr [ i ] ; else break ; } return res ; }

73.91
80.0
67.05
80.97
def isDivisible ( str , k ) : n = len ( str ) c = 0 for i in range ( 0 , k ) : if ( str [ n - i - 1 ] == '0' ) : c += 1 return ( c == k )

static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }

static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( str [ n - i - 1 ] == '0' ) c += 1 ; } return ( c == k ) ; } return ( false ) ; }

static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( str [ n - i - 1 ] == '0' ) c ++ ; else if ( str [ n - i - 1 ] == '0' ) c ++ ; } return ( c == k ) ; }

74.11
69.91
84.34
71.23
def longestCommonSum ( arr1 , arr2 , n ) : maxLen = 0 for i in range ( 0 , n ) : sum1 = 0 sum2 = 0 for j in range ( i , n ) : sum1 += arr1 [ j ] sum2 += arr2 [ j ] if ( sum1 == sum2 ) : len = j - i + 1 if ( len > maxLen ) : maxLen = len return maxLen

static int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }

static int longestCommonSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 ; int sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) { maxLen = len ;

static int longestCommonSum ( int arr1 , int arr2 , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { len = j - i + 1 ; if ( len > maxLen ) { maxLen = len ; } } } } return maxLen ; }

74.53
74.36
100.0
100.0
def swapBits ( x ) : even_bits = x & 0xAAAAAAAA odd_bits = x & 0x55555555 even_bits >>= 1 odd_bits <<= 1 return ( even_bits | odd_bits )

static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits | odd_bits ) ; }

static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; return ( even_bits | odd_bits ) ; }

static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits | odd_bits ) ; }

74.72
75.11
74.72
75.11
def isReversible ( str ) : i = 0 j = len ( str ) - 1 while ( i < j ) : if ( str [ i ] != str [ j ] ) : return False i += 1 j -= 1 return True

static boolean isReversible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }

static boolean isReversible ( String str ) { int i = 0 ; int j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }

static boolean isReversible ( String str ) { int i = 0 ; int j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }

74.73
83.3
84.03
91.9
def isPossible ( str , n ) : l = len ( str ) if ( l >= n ) : return True return False

static boolean isPossible ( String str , int n ) { int len = str . length ( ) ; if ( len >= n ) return true ; return false ; }

static boolean isPossible ( String str , int n ) { int l = str . length ( ) ; if ( l >= n ) return false ; return true ; }

static boolean isPossible ( String str , int n ) { int l = str . length ( ) ; if ( l >= n ) return true ; return false ; }

74.87
76.55
68.83
71.09
def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : d1 = d1 + arr [ i ] [ i ] d2 = d2 + arr [ i ] [ n - i - 1 ] return abs ( d1 - d2 )

public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }

static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 ; int d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 = d1 + arr [ i ] [ i - 1 ] ; d2 = d2 + arr [ i ] [ n - i - 1 ] ; } return 0 ; }

static int difference ( int [ ] arr , int n ) { int d1 = 0 ; int d2 = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { d1 = d1 + arr [ i ] [ i ] ; d2 = d2 + arr [ i ] [ n - i - 1 ] ; return abs ( d1 - d2 ) ; } }

74.97
69.29
84.41
74.42
def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return a [ n - 1 ] + b [ n - 1 ]

static int countStrings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }

static int countStrings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] + b [ i - 1 ] ; } return 0 ; }

; } static int countStrings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = b [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }

75.0
77.66
83.99
90.21
def power ( x , y , p ) : res = 1 x = x % p while ( y > 0 ) : if ( ( y & 1 ) == 1 ) : res = ( res * x ) % p y = y >> 1 x = ( x * x ) % p return res

static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }

static int power ( int x , int y , int p ) { int res = 1 ; while ( ( y & 1 ) == 0 ) res = ( res * x ) % p ; while ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; } return res ; }

static int power ( int x , int y , int p ) { int res = 1 ; int x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; else res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }

75.07
81.83
0.0
0.19
def minSum ( n ) : sum = 0 while ( n > 0 ) : sum += ( n % 10 ) n //= 10 if ( sum == 1 ) : return 10 return sum

static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }

static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; }

; }

75.43
65.43
75.65
66.76
def maxRemoval ( arr , n ) : count = 0 cummulative_sum = 0 arr . sort ( ) for i in range ( n ) : if arr [ i ] >= cummulative_sum : count += 1 cummulative_sum += arr [ i ] return count

static int maxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cummulative_sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cummulative_sum ) { count ++ ; cummulative_sum += arr [ i ] ; } } return count ; }

static int maxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cummulative_sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] >= cummulative_sum ) count += 1 cummulative_sum += arr [ i ] ; } return count ; }

static int maxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cummulative_sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] >= cummulative_sum ) count ++ ; cummulative_sum = arr [ i ] ; } return count ; }

75.48
78.92
52.34
77.02
def maxProduct ( arr , n ) : if n < 3 : return - 1 arr . sort ( ) return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )

static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }

static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; return max ( arr [ 0 ] * arr [ 1 ] , arr [ 1 ] * arr [ 2 ] * arr [ n - 3 ] , arr [ n - 2 ] * arr [ n - 3 ] ) ; } return - 1 ; }

static int maxProduct ( int [ ] arr , int n ) { if ( n < 1 ) return - 1 ; if ( arr . length > 1 ) return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 2 ] , arr [ n - 3 ] * arr [ n - 1 ] * arr [ n - 3 ] ) ; }

75.58
67.28
62.1
54.45
def numberOfTriangles ( n ) : answer = [ None ] * ( n + 1 ) answer [ 0 ] = 1 i = 1 while i <= n : answer [ i ] = answer [ i - 1 ] * 3 + 2 i = i + 1 return answer [ n ]

public static int numberOfTriangles ( int n ) { int [ ] answer = new int [ n + 1 ] ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2 ; return answer [ n ] ; }

static int numberOfTriangles ( int n ) { int answer [ ] = new int [ n + 1 ] * 3 + 2 ; for ( int i = 1 ; i <= n ; i ++ ) { answer [ i ] = answer [ i - 1 ] * 3 + 2 ; } return answer [ n ] ; }

public static int numberOfTriangles ( int n ) { int answer [ ] = new int [ n ] ; int i = 1 ; while ( i <= n ) { answer [ i ] = answer [ i - 1 ] * 3 + 2 ; i ++ ; } return answer [ n ] ; }

75.63
74.25
67.72
69.52
def findRoot ( arr , n ) : root = 0 for i in range ( n ) : root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) return root

static int findRoot ( pair arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . first - arr [ i ] . second ) ; } return root ; }

static int findRoot ( int arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) / 2 ; } return root ; }

static int findRoot ( int [ ] arr , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += arr [ i ] [ 0 ] ; root += arr [ i ] [ 1 ] ; } return root ; }

75.64
73.61
65.13
61.17
def findGreatest ( arr , n ) : result = - 1 for i in range ( n ) : for j in range ( n - 1 ) : for k in range ( j + 1 , n ) : if ( arr [ j ] * arr [ k ] == arr [ i ] ) : result = max ( result , arr [ i ] ) return result

static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }

static int findGreatest ( int arr [ ] , int n ) { int result = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) { result = max ( result , arr [ i ] ) ; } } return result ; }

static int findGreatest ( int arr [ ] , int n ) { int result = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { for ( int k = 0 ; k < arr . length ; k ++ ) { if ( arr [ j ] * arr [ k ] == arr [ i ] ) { result = max ( result , arr [ i ] ) ; } } } } return result ; }

75.94
79.91
58.6
54.42
def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( n ) : for j in range ( m ) : if ( arr2 [ i ] == arr1 [ j ] ) : break if ( j == m ) : return 0 return 1

static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) if ( arr2 [ i ] == arr1 [ j ] ) break ; if ( j == m ) return false ; } return true ; }

static int isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr2 [ i ] == arr1 [ j ] ) { break if ( j == m ) return 0 ; } } return 1 ; } return 0 ; }

static int isSubset ( int arr1 , int arr2 , int m ) { int i = 0 ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] == arr1 [ j ] ) return 0 ; if ( j == m ) return 0 ; if ( i == m ) return 0 ; if ( j == m ) return 0 ; } return 1 ; }

75.99
72.82
85.19
87.1
def getSum ( n ) : sum = 0 while ( n != 0 ) : sum = sum + int ( n % 10 ) n = int ( n / 10 ) return sum

static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }

static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + int ( n / 10 ) ; } return sum ; }

static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + int ( n % 10 ) ; n = n / 10 ; } return sum ; }

76.07
77.94
62.33
61.68
def findRotations ( str ) : tmp = str + str n = len ( str ) for i in range ( 1 , n + 1 ) : substring = tmp [ i : n ] if ( str == substring ) : return i return n

static int findRotations ( String str ) { String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . substring ( i , str . length ( ) ) ; if ( str == substring ) return i ; } return n ; }

static int findRotations ( String str ) { String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp [ i : n ] ; if ( substring == str ) return i ; } return n ; }

static int findRotations ( String str ) { String tmp = "" ; int n = str . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { String substring = str + str [ i ] ; if ( str == substring ) return i ; substring = tmp [ i : n ] ; if ( str == substring ) return i ; } return - 1 ; }

76.17
69.33
74.82
68.99
def search ( arr , n , x ) : i = 0 for i in range ( i , n ) : if ( arr [ i ] == x ) : return i return - 1

static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { return i ; } } return - 1 ; }

static int search ( int arr [ ] , int n , int x ) { int i = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

private static int search ( int arr [ ] , int n , int x ) { int i = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

76.17
63.14
74.24
66.08
def getInvCount ( arr ) : n = len ( arr ) invcount = 0 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if arr [ i ] > arr [ j ] : for k in range ( j + 1 , n ) : if arr [ j ] > arr [ k ] : invcount += 1 return invcount

int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) invcount ++ ; } } } } return invcount ; }

static int getInvCount ( int arr [ ] ) { int n = arr . length ; int invcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) invcount += 1 ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) invcount ++ ; } } return invcount ; }

int getInvCount ( int arr [ ] ) { int n = arr . length ; int invcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = 0 ; k < arr . length ; k ++ ) { if ( arr [ j ] > arr [ k ] ) { invcount ++ ; } } } } } return invcount ; }

76.24
77.6
73.31
62.31
def constructArr ( arr , pair , n ) : arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 for i in range ( 1 , n ) : arr [ i ] = pair [ i - 1 ] - arr [ 0 ]

static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }

static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ i - 1 ] ) / 2 ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = ( pair [ i ] + pair [ i - 1 ] - arr [ 0 ] ) / 2 ; } }

; int constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = ( pair [ i ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; } }

76.26
65.59
66.02
52.01
def SieveOfEratosthenes ( n , isPrime ) : isPrime [ 0 ] = isPrime [ 1 ] = False for i in range ( 2 , n + 1 ) : isPrime [ i ] = True for p in range ( 2 , n + 1 ) : if ( p * p <= n and isPrime [ p ] == True ) : for i in range ( p * 2 , n + 1 , p ) : isPrime [ i ] = False p += 1

static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }

static void SieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 0 ; i < n ; i ++ ) { isPrime [ i ] = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = 0 ; i < n ; i ++ ) isPrime [ i ] = false ; } } }

static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { isPrime [ i ] = isPrime [ i ] == true ; for ( int p = 0 ; p < n ; p ++ ) { if ( p * p <= n && isPrime [ p ] == true ) { for ( int i = 0 ; i < n ; i ++ ) isPrime [ i ] = false ; } } } }

76.26
72.18
82.1
73.2
def countPairsWithDiffK ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : count += 1 return count

static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }

static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ i ] - arr [ j ] == k ) count += 1 ; } } return count ; }

static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } } return count ; }

76.32
73.75
71.66
76.77
def MaximumHeight ( a , n ) : result = 1 for i in range ( 1 , n ) : y = ( i * ( i + 1 ) ) / 2 if ( y < n ) : result = i else : break return result

static int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }

static int MaximumHeight ( int a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int y = ( i * i ) / 2 ; if ( y < n ) result = i ; else result = i ; } return result ; }

static int MaximumHeight ( int a , int n ) { int result = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int y = i * ( i + 1 ) / 2 ; if ( y < n ) { result = i ; } else { break ; } } return result ; }

76.48
64.27
67.17
58.95
def compute ( graph , N ) : count = 0 for i in range ( 1 , N + 1 ) : if ( len ( graph [ i ] ) == 0 ) : count += 1 return count

static int compute ( int [ ] graph , int N ) { int count = 0 ; for ( int i = 1 ; i < 7 ; i ++ ) { if ( graph [ i ] == 0 ) count ++ ; } return count ; }

static int compute ( int [ ] graph , int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( len ( graph [ i ] ) == 0 ) count += 1 ; } return count ; }

static int compute ( Graph graph , int N ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( graph [ i ] == null ) count ++ ; else if ( graph [ i ] . length == 0 ) count ++ ; } return count ; }

76.59
77.96
61.94
74.5
def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for i in range ( m ) : for j in range ( n ) : if arr1 [ i ] + arr2 [ j ] == x : count = count + 1 return count

static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }

static int countPairs ( int arr1 , int arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr1 [ i ] + arr2 [ j ] == x ) count = count + 1 ; } } return count ; }

static int countPairs ( int arr1 , int arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr1 [ i ] + arr2 [ j ] == x ) count = count + 1 ; else if ( arr1 [ i ] + arr2 [ j ] == x ) count = count + 1 ; } } return count ; }

76.66
68.13
69.53
60.33
def isScalarMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False for i in range ( 0 , N - 1 ) : if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : return False return True

static boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }

static boolean isScalarMatrix ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i ] ) return false ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i =

static boolean isScalarMatrix ( int [ ] mat ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! isScalarMatrix ( mat [ i ] ) ) return false ; } } } return true ; }

76.74
69.83
53.07
58.24
def isDDM ( m , n ) : for i in range ( 0 , n ) : sum = 0 for j in range ( 0 , n ) : sum = sum + abs ( m [ i ] [ j ] ) sum = sum - abs ( m [ i ] [ i ] ) if ( abs ( m [ i ] [ i ] ) < sum ) : return False return True

static boolean isDDM ( int m [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ; sum -= Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }

static boolean isDDM ( int [ ] [ ] m , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( m [ i ] [ i ] ) > sum ) return false ; for ( int j = 0 ; j < n ; j ++ ) { sum = sum + abs ( m [ i ] [ j ] ) ; sum = sum - abs ( m [ i ] [ i ] ) ; } return true ; }

static boolean isDDM ( int [ ] m , int n ) { for ( int i = 0 ; i < m . length ; i ++ ) { for ( int j = 0 ; j < m . length ; j ++ ) { sum = 0 ; for ( int i = 0 ; i < m . length ; i ++ ) { sum = sum + abs ( m [ i ] [ j ] ) ; sum = sum + abs ( m [ i ] [ i ] ) ; sum = sum + abs ( m [ i ] [ j ] ) ; sum = sum - abs ( m [ i ] [ i ] ) ; if ( sum < sum ) return false ; } } return true ; }

76.8
86.04
66.82
85.39
def isPrime ( n ) : if ( n <= 1 ) : return False for i in range ( 2 , n ) : if ( n % i == 0 ) : return False return True

static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }

static boolean isPrime ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }

public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) return false ; if ( n % i == 0 ) return false ; } return true ; }

76.8
86.04
77.1
86.7
def isPrime ( n ) : if n <= 1 : return False for i in range ( 2 , n ) : if n % i == 0 : return False return True

static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }

static boolean isPrime ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }

public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }

77.06
80.84
71.98
81.22
def findPairs ( arr1 , arr2 , n , m , x ) : for i in range ( 0 , n ) : for j in range ( 0 , m ) : if ( arr1 [ i ] + arr2 [ j ] == x ) : print ( arr1 [ i ] , arr2 [ j ] )

static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " " + arr2 [ j ] ) ; }

static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] + arr2 [ j ] == x ) { if ( arr2 [ i ] + arr2 [ j ] == x ) { if ( arr1 [ i ] + arr

static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] + arr2 [ j ] == x ) { if ( arr1 [ i ] + arr2 [ j ] == x ) { print ( arr1 [ i ] , arr2 [ j ] ) ; } } } } }

77.2
71.45
90.85
90.96
def swapBits ( x , p1 , p2 , n ) : set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) xor = ( set1 ^ set2 ) xor = ( xor << p1 ) | ( xor << p2 ) result = x ^ xor return result

static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }

static int swapBits ( int x , int p1 , int p2 , int n ) { int result = 0 ; int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; set1 = ( set1 ^ set2 ) ; set2 = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | (

static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; result = ( x ^ xor ) ; }

77.26
78.77
68.93
75.83
def findLastIndex ( str , x ) : index = - 1 for i in range ( 0 , len ( str ) ) : if str [ i ] == x : index = i return index

static int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }

static int findLastIndex ( String str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == x ) index = i ; } return index ; }

static int findLastIndex ( String str , int x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == x ) { index = i ; break ; } } return index ; }

77.29
84.82
77.29
84.82
def divisorSum ( n ) : sum = 0 for i in range ( 1 , n + 1 ) : sum += int ( n / i ) * i return int ( sum )

static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }

static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += int ( n / i ) * i ; } return sum ; }

static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += int ( n / i ) * i ; } return sum ; }

77.32
68.83
96.94
98.48
def countFriendsPairings ( n ) : dp = [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) : if ( i <= 2 ) : dp [ i ] = i else : dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] return dp [ n ]

static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }

static int countFriendsPairings ( int n ) { int dp [ ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }

static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }

77.41
81.31
100.0
100.0
def oppositeSigns ( x , y ) : return ( ( x ^ y ) < 0 )

static boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }

static boolean oppositeSigns ( int x , int y ) { return ( x ^ y ) < 0

static boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }

77.46
74.05
72.35
88.99
def countOccurrences ( arr , n , x ) : res = 0 for i in range ( n ) : if x == arr [ i ] : res += 1 return res

static int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }

static int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( x == arr [ i ] ) res += 1 ; } return res ; }

static int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; else if ( x == arr [ i ] ) res ++ ; } return res ; }

77.52
66.12
83.15
70.27
def linearSearch ( arr , n ) : for i in range ( n ) : if arr [ i ] is i : return i return - 1

static int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }

static int linearSearch ( int arr [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] is i ) return i ; } return - 1 ; }

static int linearSearch ( int arr [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }

78.04
71.25
69.39
62.7
def answer_query ( a , n , l , r ) : count = 0 for i in range ( l , r ) : if ( a [ i ] == a [ i + 1 ] ) : count += 1 return count

static int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }

static int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) { count += 1 ; } } return count ; }

static int answer_query ( char [ ] a , int n , int l , int r ) { int count = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) { count ++ ; } } return count ; }

78.06
68.56
81.62
83.9
def rearrange ( arr , n ) : max_ele = arr [ n - 1 ] min_ele = arr [ 0 ] for i in range ( n ) : if i % 2 == 0 : arr [ i ] = max_ele max_ele -= 1 else : arr [ i ] = min_ele min_ele += 1

public static void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }

static void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 2 ] ; int min_ele = arr [ 0 ] ; int min_ele = arr [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] = min_ele min_ele += 1 ; else arr [ i ] = max_ele max_ele -- ;

static void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] = max_ele ; else arr [ i ] = min_ele ; min_ele += 1 ; } }

78.21
82.7
65.62
79.67
def isHeap ( arr , n ) : for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : if arr [ 2 * i + 1 ] > arr [ i ] : return False if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : return False return True

static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }

static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }

static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }

78.46
75.75
73.32
70.16
def findExtra ( arr1 , arr2 , n ) : index = n left = 0 right = n - 1 while ( left <= right ) : mid = ( int ) ( ( left + right ) / 2 ) if ( arr2 [ mid ] == arr1 [ mid ] ) : left = mid + 1 else : index = mid right = mid - 1 return index

static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }

static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = 0 ; int left = 0 ; int right = n - 1 ; while ( left <= right ) { int mid = ( int ) ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) { index = mid + 1 ; } else { index = mid - 1 ; } } return index ; }

static int findExtra ( int arr1 , int arr2 , int n ) { int index = 0 ; int left = 0 ; int right = n - 1 ; while ( left <= right ) { int mid = ( int ) ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else index = mid - 1 ; } return index ; }

78.79
69.22
43.2
47.01
def cutRod ( price , n ) : val = [ 0 for x in range ( n + 1 ) ] val [ 0 ] = 0 for i in range ( 1 , n + 1 ) : max_val = INT_MIN for j in range ( i ) : max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) val [ i ] = max_val return val [ n ]

static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }

static int cutRod ( int price [ ] , int n ) { int val [ ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( int j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }

static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { val [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { val [ i ] = 0 ; for ( int x = 0 ; x < n ; x ++ ) { val [ i ] = 0 ; for ( int x = 1 ; x < n ; x ++ ) { val [ i ] = 0 ; for ( int x = 1 ; x < n ; x ++ ) { val [ x ] = 0 ; } } } } return val [ n ] ; }

79.11
84.9
92.11
95.99
def getAbs ( n ) : mask = n >> ( SIZE_INT * CHARBIT - 1 ) return ( ( n + mask ) ^ mask )

static int getAbs ( int n ) { int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ; return ( ( n + mask ) ^ mask ) ; }

static int getAbs ( int n ) { int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ; return ( n + mask ) ^ mask ; }

static int getAbs ( int n ) { int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ; return ( ( n + mask ) ^ mask ) ; }

79.15
75.51
72.57
70.38
def findElement ( arr , n , key ) : for i in range ( n ) : if ( arr [ i ] == key ) : return i return - 1

static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }

static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == key ) return i ; } return - 1 ; } }

; } static int findElement ( int arr [ ] , int n , String key ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == key ) return i ; } return - 1 ; }

79.6
85.31
83.86
86.36
def countDyckPaths ( n ) : res = 1 for i in range ( 0 , n ) : res *= ( 2 * n - i ) res /= ( i + 1 ) return res / ( n + 1 )

public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }

static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res ; }

private static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { res *= 2 * n - i ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }

79.79
86.53
81.72
71.16
def findExtra ( arr1 , arr2 , n ) : for i in range ( 0 , n ) : if ( arr1 [ i ] != arr2 [ i ] ) : return i return n

static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }

static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { return i ; } } return - 1 ; }

static int findExtra ( int arr1 [ ] , int arr2 [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) return i ; } return - 1 ; }

80.24
87.42
69.5
75.88
def repeat ( s , n ) : s1 = s for i in range ( 1 , n ) : s += s1 return s

static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }

static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 0 ; i < n ; i ++ ) { s += s1 ; } return s ; }

static int repeat ( int s , int n ) { int s1 = s ; for ( int i = 1 ; i < n ; i ++ ) { s += s1 ; } return s ; }

80.6
69.28
77.89
67.55
def findRepeating ( arr , n ) : s = set ( ) for i in range ( n ) : if arr [ i ] in s : return arr [ i ] s . add ( arr [ i ] ) rteurn - 1

static int findRepeating ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) return arr [ i ] ; s . add ( arr [ i ] ) ; } return - 1 ; }

static int findRepeating ( int arr [ ] , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] in s ) return arr [ i ] ; s . add ( arr [ i ] ) ; } return - 1 ; }

static int findRepeating ( int arr [ ] , int n ) { HashSet s = new HashSet ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in s ) return arr [ i ] ; s . add ( arr [ i ] ) ; } return - 1 ; }

80.69
81.87
93.18
94.03
def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i == j ) : d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) : d2 += arr [ i ] [ j ] return abs ( d1 - d2 )

public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }

static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 ; int d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] if ( i == n

static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 ; int d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return abs ( d1 - d2 ) ; }

81.1
86.8
92.34
94.62
def seiresSum ( n , a ) : return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) )

static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }

static int seiresSum ( int n , int a [ ] ) { int seiresSum = n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; return seiresSum ; }

static int seiresSum ( int n , int [ ] a ) { return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) ; }

81.33
82.37
74.52
84.8
def compute_average ( a , b ) : return floor ( ( a + b ) / 2 )

static int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }

static double compute_average ( int a , int b ) { return ( a + b ) / 2

static int compute_average ( int a , int b ) { return floor ( ( a + b ) / 2 ) ; }

81.42
81.66
69.42
72.93
def maxvolume ( s ) : maxvalue = 0 i = 1 for i in range ( s - 1 ) : j = 1 for j in range ( s ) : k = s - i - j maxvalue = max ( maxvalue , i * j * k ) return maxvalue

static int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }

static int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s ; i ++ ) { int j = 1 ; for ( int j = 1 ; j <= s ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k + 1 ) ; } } return maxvalue ; }

static int maxvolume ( int s ) { int maxvalue = 0 ; int i = 1 ; for ( int j = 1 ; j <= s ; j ++ ) { int k = s - i - j ; int maxvalue = max ( maxvalue , i * j * k ) ; maxvalue = max ( maxvalue , i * j * k ) ; } return maxvalue ; }

81.48
77.41
89.34
88.16
def Add ( x , y ) : while ( y != 0 ) : carry = x & y x = x ^ y y = carry << 1 return x

static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }

static int Add ( int x , int y ) { int carry = 0 ; while ( carry != 0 ) { carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }

static int Add ( int x , int y ) { int carry ; while ( y != 0 ) { carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }

81.87
78.58
67.39
63.42
def countPairs ( arr , n ) : ans = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : ans += 1 return ans

static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }

static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) ans += 1 ; } } return ans ; }

static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { ans ++ ; } } } return ans ; }

82.04
71.9
82.77
69.64
def search ( arr , n , x ) : for i in range ( 0 , n ) : if ( arr [ i ] == x ) : return i return - 1

public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

private static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }

82.62
82.99
96.54
94.14
def turnOffK ( n , k ) : if ( k <= 0 ) : return n return ( n & ~ ( 1 << ( k - 1 ) ) )

static int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ) ; }

static int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << k ) ) ; } return n ; }

static int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ; }

83.1
77.84
87.72
92.08
def isDiagonalMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False return True

static boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }

static boolean isDiagonalMatrix ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; } return true ; }

static boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; } } return true ; }

83.14
83.33
88.12
87.07
def seiresSum ( n , a ) : res = 0 for i in range ( 0 , 2 * n ) : if ( i % 2 == 0 ) : res += a [ i ] * a [ i ] else : res -= a [ i ] * a [ i ] return res

static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }

static int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }

static int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }

83.6
89.86
71.24
87.57
def unitDigitXRaisedY ( x , y ) : res = 1 for i in range ( y ) : res = ( res * x ) % 10 return res

static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }

static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) { res = ( res * x ) / 10 ; } return res ; }

static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) { res = ( res * x ) / 10 ; res = ( res * y ) % 10 ; } return res ; }

83.7
66.46
79.94
71.2
def squareRoot ( n ) : x = n y = 1 while ( x > y ) : x = ( x + y ) / 2 y = n / x return x

static long squareRoot ( int n ) { int x = n ; int y = 1 ; while ( x > y ) { x = ( x + y ) / 2 ; y = n / x ; } return ( long ) x ; }

static int squareRoot ( int n ) { int x = n / 2 ; int y = 1 ; while ( x > y ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }

static int squareRoot ( int n ) { int x = 1 ; int y = n ; while ( x > y ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }

83.71
85.99
72.18
70.78
def maxSum ( arr , n ) : sum = 0 arr . sort ( ) for i in range ( 0 , int ( n / 2 ) ) : sum -= ( 2 * arr [ i ] ) sum += ( 2 * arr [ n - i - 1 ] ) return sum

static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }

static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }

static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; arr . sort ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum -= 2 * arr [ i ] ; sum += 2 * arr [ n - i - 1 ] ; } return sum ; }

84.0
84.45
92.23
79.96
def getIndexInSortedArray ( arr , n , idx ) : result = 0 for i in range ( n ) : if ( arr [ i ] < arr [ idx ] ) : result += 1 if ( arr [ i ] == arr [ idx ] and i < idx ) : result += 1 return result ;

static int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }

static int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ idx ] ) result += 1 ; if ( arr [ i ] == arr [ idx ] and i < idx ) result += 1 ; } return result ; }

static int getIndexInSortedArray ( int arr [ ] , int idx ) { int result = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }

84.36
85.61
78.12
84.42
def Right_most_setbit ( num ) : pos = 1 for i in range ( INT_SIZE ) : if not ( num & ( 1 << i ) ) : pos += 1 else : break return pos

static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }

static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( num & ( 1 << i ) ) pos ++ ; else pos ++ ; } return pos ; }

static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ! ( num & ( 1 << i ) ) ) { pos ++ ; } else { break ; } } return pos ; }

84.39
75.16
76.85
72.68
def solve ( arr , n ) : arr . sort ( ) a = 0 b = 0 for i in range ( n ) : if ( i % 2 != 0 ) : a = a * 10 + arr [ i ] else : b = b * 10 + arr [ i ] return a + b

static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }

static int solve ( int arr [ ] , int n ) { int a = 0 ; int b = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } return 0 ; }

static int solve ( int arr [ ] , int n ) { int a = 0 ; int b = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }

84.49
89.17
85.51
91.55
def isSymmetric ( mat , N ) : for i in range ( N ) : for j in range ( N ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : return False return True

static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }

static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) { return false ; } } return true ; }

static boolean isSymmetric ( int mat [ ] [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; } } return true ; }

84.99
80.75
87.03
80.74
def countRotations ( arr , n ) : min = arr [ 0 ] for i in range ( 0 , n ) : if ( min > arr [ i ] ) : min = arr [ i ] min_index = i return min_index

static int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }

static int countRotations ( int arr [ ] , int n ) { int min_index = 0 ; int min = arr [ 0 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }

static int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }

85.27
88.97
88.55
91.01
def minimumflip ( mat , n ) : flip = 0 for i in range ( n ) : for j in range ( i ) : if mat [ i ] [ j ] != mat [ j ] [ i ] : flip += 1 return flip

static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }

static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip += 1 ; } } return flip ; }

int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; } } return flip ; }

85.39
89.28
57.35
82.22
def countCommon ( mat , n ) : res = 0 for i in range ( n ) : if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : res = res + 1 return res

static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }

static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res = res + 1 ; } return res ; }

static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res = res + 1 ; else if ( mat [ i ] [ n - i - 1 ] == mat [ i ] [ n - i - 1 ] ) res = res + 1 ; } return res ; }

85.86
91.25
83.8
87.71
def horner ( poly , n , x ) : result = poly [ 0 ] for i in range ( 1 , n ) : result = result * x + poly [ i ] return result

static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }

static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i <= n ; i ++ ) { result = result * x + poly [ i ] ; } return result ; }

static int horner ( int [ ] poly , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { result = result * x + poly [ i ] ; } return result ; }

86.61
76.56
93.31
93.98
def countInRange ( arr , n , x , y ) : count = 0 ; for i in range ( n ) : if ( arr [ i ] >= x and arr [ i ] <= y ) : count += 1 return count

static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }

static int countInRange ( int arr [ ] , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count += 1 ; } return count ; }

static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) { count ++ ; } } return count ; }

88.2
92.16
79.6
64.8
def findSum ( N , K ) : ans = 0 for i in range ( 1 , N + 1 ) : ans += ( i % K ) return ans

static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }

static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ans += ( i % K ) ; } return ans ; }

static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ans += i ; } return ans ; }

88.25
88.98
100.0
100.0
def intersection ( n ) : return n * ( n - 1 )

static int intersection ( int n ) { return n * ( n - 1 ) ; }

static int intersection ( int n ) { return n * ( n - 1 )

static int intersection ( int n ) { return n * ( n - 1 ) ; }

88.69
69.68
87.87
80.13
def CountPairs ( n ) : k = n imin = 1 ans = 0 while ( imin <= n ) : imax = n / k ans += k * ( imax - imin + 1 ) imin = imax + 1 k = n / imin return ans

static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }

static int CountPairs ( int n ) { int k = n / 2 ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; } return ans ; }

static int CountPairs ( int n ) { int k = n ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / k ; } return ans ; }

88.73
80.47
71.82
68.81
def isPowerOfTwo ( n ) : if ( n == 0 ) : return False while ( n != 1 ) : if ( n % 2 != 0 ) : return False n = n // 2 return True

static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }

static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 0 ) { if ( n % 2 != 0 ) return false ; n = n // 2 ; } return true ; }

public static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( ! isPowerOfTwo ( n ) ) return false ; n = n / 2 ; if ( n == 0 ) return false ; } return true ; }

89.18
92.75
72.07
60.18
def scalarProductMat ( mat , k ) : for i in range ( N ) : for j in range ( N ) : mat [ i ] [ j ] = mat [ i ] [ j ] * k

static void scalarProductMat ( int mat [ ] [ ] , int k ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k ; }

static void scalarProductMat ( int mat [ ] [ ] , int k ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] * k ; } } }

; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] * k ; } }

90.64
92.94
77.79
89.68
def isPossibleToMakeDivisible ( arr , n ) : remainder = 0 for i in range ( 0 , n ) : remainder = ( remainder + arr [ i ] ) % 3 return ( remainder == 0 )

public static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; }

static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) { remainder = ( remainder + arr [ i ] ) % 3 ; } return ( remainder == 0 ) ; }

static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) { remainder = ( remainder + arr [ i ] ) % 3 ; if ( remainder == 0 ) return ( remainder == 0 ) ; } return false ; }

90.73
88.63
76.57
81.76
def countNegative ( M , n , m ) : count = 0 for i in range ( n ) : for j in range ( m ) : if M [ i ] [ j ] < 0 : count += 1 else : break return count

static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }

static int countNegative ( int [ ] [ ] M , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 else : break ; } } return count ; }

static int countNegative ( int [ ] M , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count ++ ; else if ( M [ i ] [ j ] > 0 ) count ++ ; else break ; } } return count ; }

92.01
83.06
79.13
72.44
def countPairs ( a , n ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( a [ i ] & a [ j ] ) == 0 : count += 2 return count

static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; }

static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } } return count ; }

static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] & a [ j ] ) { count ++ ; } } } return count ; }

92.09
91.11
64.63
69.59
def findMaximum ( arr , low , high ) : max = arr [ low ] i = low for i in range ( high + 1 ) : if arr [ i ] > max : max = arr [ i ] return max

static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }

static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; for ( int i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }

static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr . length - 1 ; for ( int i = 0 ; i < high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }

