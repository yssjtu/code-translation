def printArray ( matrix ) : rowCount = len ( matrix ) if rowCount == 0 : return columnCount = len ( matrix [ 0 ] ) if columnCount == 0 : return row_output_format = "" . join ( [ "%s" ] * columnCount ) printed = { } for row in matrix : routput = row_output_format % tuple ( row ) if routput not in printed : printed [ routput ] = True print ( routput )
def printSubStr ( st , low , high ) : sys . stdout . write ( st [ low : high + 1 ] ) sys . stdout . flush ( ) return ''
def longestCommonSum ( arr1 , arr2 , n ) : maxLen = 0 for i in range ( 0 , n ) : sum1 = 0 sum2 = 0 for j in range ( i , n ) : sum1 += arr1 [ j ] sum2 += arr2 [ j ] if ( sum1 == sum2 ) : len = j - i + 1 if ( len > maxLen ) : maxLen = len return maxLen
def SieveOfEratosthenes ( n , isPrime ) : isPrime [ 0 ] = isPrime [ 1 ] = False for i in range ( 2 , n + 1 ) : isPrime [ i ] = True for p in range ( 2 , n + 1 ) : if ( p * p <= n and isPrime [ p ] == True ) : for i in range ( p * 2 , n + 1 , p ) : isPrime [ i ] = False p += 1
def print_sequence ( n , k ) : b = int ( n / ( k * ( k + 1 ) / 2 ) ) if b == 0 : print ( "-1" ) else : r = 1 x = 1 while x ** 2 <= n : if n % x != 0 : continue elif x <= b and x > r : r = x elif n / x <= b and n / x > r : r = n / x x = x + 1 i = 1 while i < k : print ( r * i , end = "" ) i = i + 1 last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) print ( last_term )
def lineFromPoints ( P , Q ) : a = Q [ 1 ] - P [ 1 ] b = P [ 0 ] - Q [ 0 ] c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) if ( b < 0 ) : print ( "ThelinepassingthroughpointsPandQis:" , a , "x" , b , "y=" , c , "\n" ) else : print ( "ThelinepassingthroughpointsPandQis:" , a , "x+" , b , "y=" , c , "\n" )
def printSquares ( n ) : square = 0 odd = 1 for x in range ( 0 , n ) : print ( square , end = "" ) square = square + odd odd = odd + 2
def countPaths ( maze ) : if ( maze [ 0 ] [ 0 ] == - 1 ) : return 0 for i in range ( R ) : if ( maze [ i ] [ 0 ] == 0 ) : maze [ i ] [ 0 ] = 1 else : break for i in range ( 1 , C , 1 ) : if ( maze [ 0 ] [ i ] == 0 ) : maze [ 0 ] [ i ] = 1 else : break for i in range ( 1 , R , 1 ) : for j in range ( 1 , C , 1 ) : if ( maze [ i ] [ j ] == - 1 ) : continue if ( maze [ i - 1 ] [ j ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) if ( maze [ i ] [ j - 1 ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : return maze [ R - 1 ] [ C - 1 ] else : return 0
def longestSubsequence ( a , n ) : mp = { i : 0 for i in range ( 13 ) } dp = [ 0 for i in range ( n ) ] maximum = - sys . maxsize - 1 index = - 1 for i in range ( n ) : if ( ( a [ i ] - 1 ) in mp ) : lastIndex = mp [ a [ i ] - 1 ] - 1 dp [ i ] = 1 + dp [ lastIndex ] else : dp [ i ] = 1 mp [ a [ i ] ] = i + 1 if ( maximum < dp [ i ] ) : maximum = dp [ i ] index = i for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) : print ( curr , end = "" )
def minimumCostOfBreaking ( X , Y , m , n ) : res = 0 X . sort ( reverse = True ) Y . sort ( reverse = True ) hzntl = 1 vert = 1 i = 0 j = 0 while ( i < m and j < n ) : if ( X [ i ] > Y [ j ] ) : res += X [ i ] * vert hzntl += 1 i += 1 else : res += Y [ j ] * hzntl vert += 1 j += 1 total = 0 while ( i < m ) : total += X [ i ] i += 1 res += total * vert total = 0 while ( j < n ) : total += Y [ j ] j += 1 res += total * hzntl return res
def countPS ( str ) : N = len ( str ) cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] for i in range ( N ) : cps [ i ] [ i ] = 1 for L in range ( 2 , N + 1 ) : for i in range ( N ) : k = L + i - 1 if ( k < N ) : if ( str [ i ] == str [ k ] ) : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) else : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) return cps [ 0 ] [ N - 1 ]
def printDistinct ( str ) : count = [ 0 ] * NO_OF_CHARS for i in range ( len ( str ) ) : if ( str [ i ] != '' ) : count [ ord ( str [ i ] ) ] += 1 n = i for i in range ( n ) : if ( count [ ord ( str [ i ] ) ] == 1 ) : print ( str [ i ] , end = "" )
def sortString ( str ) : str = '' . join ( sorted ( str ) ) print ( str )
def bestApproximate ( x , y , n ) : sum_x = 0 sum_y = 0 sum_xy = 0 sum_x2 = 0 for i in range ( 0 , n ) : sum_x += x [ i ] sum_y += y [ i ] sum_xy += x [ i ] * y [ i ] sum_x2 += pow ( x [ i ] , 2 ) m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) c = ( float ) ( sum_y - m * sum_x ) / n print ( "m=" , m ) print ( "c=" , c )
def printPath ( str ) : i = 0 curX = 0 curY = 0 while ( i < len ( str ) ) : nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 ) nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5 while ( curX > nextX ) : print ( "MoveUp" ) curX -= 1 while ( curY > nextY ) : print ( "MoveLeft" ) curY -= 1 while ( curX < nextX ) : print ( "MoveDown" ) curX += 1 while ( curY < nextY ) : print ( "MoveRight" ) curY += 1 print ( "PressOK" ) i += 1
def nextWord ( s ) : if ( s == "" ) : return "a" i = len ( s ) - 1 while ( s [ i ] == 'z' and i >= 0 ) : i -= 1 if ( i == - 1 ) : s = s + 'a' else : s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) return s
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : if ( k > n1 * n2 ) : print ( "kpairsdon'texist" ) return index2 = [ 0 for i in range ( n1 ) ] while ( k > 0 ) : min_sum = sys . maxsize min_index = 0 for i1 in range ( 0 , n1 , 1 ) : if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : min_index = i1 min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] print ( "(" , arr1 [ min_index ] , "," , arr2 [ index2 [ min_index ] ] , ")" , end = "" ) index2 [ min_index ] += 1 k -= 1
def transpose ( A ) : for i in range ( N ) : for j in range ( i + 1 , N ) : A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ]
def longest ( a , n , k ) : freq = [ 0 ] * n start = 0 end = 0 now = 0 l = 0 for i in range ( n ) : freq [ a [ i ] ] += 1 if ( freq [ a [ i ] ] == 1 ) : now += 1 while ( now > k ) : freq [ a [ l ] ] -= 1 if ( freq [ a [ l ] ] == 0 ) : now -= 1 l += 1 if ( i - l + 1 >= end - start + 1 ) : end = i start = l for i in range ( start , end + 1 ) : print ( a [ i ] , end = "" )
def interLeaveQueue ( q ) : if ( q . qsize ( ) % 2 != 0 ) : print ( "Inputevennumberofintegers." ) s = [ ] halfSize = int ( q . qsize ( ) / 2 ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) for i in range ( halfSize ) : q . put ( q . queue [ 0 ] ) q . get ( ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) q . put ( q . queue [ 0 ] ) q . get ( )
def rearrangeArr ( arr , n ) : evenPos = int ( n / 2 ) oddPos = n - evenPos tempArr = np . empty ( n , dtype = object ) for i in range ( 0 , n ) : tempArr [ i ] = arr [ i ] tempArr . sort ( ) j = oddPos - 1 for i in range ( 0 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j - 1 j = oddPos for i in range ( 1 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j + 1 for i in range ( 0 , n ) : print ( arr [ i ] , end = '' )
def power ( x , y ) : if ( y == 0 ) : return 1 elif ( int ( y % 2 ) == 0 ) : return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) else : return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) )
def checkCollision ( a , b , c , x , y , radius ) : dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) if ( radius == dist ) : print ( "Touch" ) elif ( radius > dist ) : print ( "Intersect" ) else : print ( "Outside" )
def lcsOf3 ( X , Y , Z , m , n , o ) : L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : for k in range ( o + 1 ) : if ( i == 0 or j == 0 or k == 0 ) : L [ i ] [ j ] [ k ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 else : L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) return L [ m ] [ n ] [ o ]
def getMinStepToReachEnd ( arr , N ) : visit = [ False for i in range ( N ) ] distance = [ 0 for i in range ( N ) ] digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ] for i in range ( 1 , N ) : digit [ arr [ i ] ] . append ( i ) distance [ 0 ] = 0 visit [ 0 ] = True q = [ ] q . append ( 0 ) while ( len ( q ) > 0 ) : idx = q [ 0 ] q . remove ( q [ 0 ] ) if ( idx == N - 1 ) : break d = arr [ idx ] for i in range ( len ( digit [ d ] ) ) : nextidx = digit [ d ] [ i ] if ( visit [ nextidx ] == False ) : visit [ nextidx ] = True q . append ( nextidx ) distance [ nextidx ] = distance [ idx ] + 1 if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : visit [ idx - 1 ] = True q . append ( idx - 1 ) distance [ idx - 1 ] = distance [ idx ] + 1 if ( idx + 1 < N and visit [ idx + 1 ] == False ) : visit [ idx + 1 ] = True q . append ( idx + 1 ) distance [ idx + 1 ] = distance [ idx ] + 1 return distance [ N - 1 ]
def calculate ( N ) : length = len ( N ) l = int ( ( length ) / 2 ) count = 0 for i in range ( l + 1 ) : s = N [ 0 : 0 + i ] l1 = len ( s ) t = N [ i : l1 + i ] try : if s [ 0 ] == '0' or t [ 0 ] == '0' : continue except : continue if s == t : count += 1 return count
def constructTree ( n , d , h ) : if d == 1 : if n == 2 and h == 1 : print ( "12" ) return 0 print ( "-1" ) return 0 if d > 2 * h : print ( "-1" ) return 0 for i in range ( 1 , h + 1 ) : print ( i , "" , i + 1 ) if d > h : print ( 1 , "" , h + 2 ) for i in range ( h + 2 , d + 1 ) : print ( i , "" , i + 1 ) for i in range ( d + 1 , n ) : k = 1 if d == h : k = 2 print ( k , "" , i + 1 )
def midPointCircleDraw ( x_centre , y_centre , r ) : x = r y = 0 print ( "(" , x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) if ( r > 0 ) : print ( "(" , x + x_centre , "," , - y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , x + y_centre , ")" , sep = "" ) P = 1 - r while ( x > y ) : y += 1 if ( P <= 0 ) : P = P + 2 * y + 1 else : x -= 1 P = P + 2 * y - 2 * x + 1 if ( x < y ) : break print ( "(" , x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - x + x_centre , "," , y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , x + x_centre , "," , - y + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - x + x_centre , "," , - y + y_centre , ")" , sep = "" ) if ( x != y ) : print ( "(" , y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , y + x_centre , "," , - x + y_centre , ")" , sep = "" , end = "" ) print ( "(" , - y + x_centre , "," , - x + y_centre , ")" , sep = "" )
def countSetBits ( n ) : i = 0 ans = 0 while ( ( 1 << i ) <= n ) : k = 0 change = 1 << i for j in range ( 0 , n + 1 ) : ans += k if change == 1 : k = not k change = 1 << i else : change -= 1 i += 1 return ans
def areElementsContiguous ( arr ) : us = set ( ) for i in arr : us . add ( i ) count = 1 curr_ele = arr [ 0 ] - 1 while curr_ele in us : count += 1 curr_ele -= 1 curr_ele = arr [ 0 ] + 1 while curr_ele in us : count += 1 curr_ele += 1 return ( count == len ( us ) )
def commonCharacters ( strings , n ) : prim = [ True ] * MAX_CHAR for i in range ( n ) : sec = [ False ] * MAX_CHAR for j in range ( len ( strings [ i ] ) ) : if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) : sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = True for i in range ( MAX_CHAR ) : prim [ i ] = sec [ i ] for i in range ( 26 ) : if ( prim [ i ] ) : print ( "%c" % ( i + ord ( 'a' ) ) , end = "" )
def dfs ( List , node , arrival ) : print ( node ) for i in range ( len ( List [ node ] ) ) : if ( List [ node ] [ i ] != arrival ) : dfs ( List , List [ node ] [ i ] , node )
def groupElements ( arr , n ) : visited = [ False ] * n for i in range ( 0 , n ) : visited [ i ] = False for i in range ( 0 , n ) : if ( visited [ i ] == False ) : print ( arr [ i ] , end = "" ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] , end = "" ) visited [ j ] = True
def longestRepeatedSubSeq ( str ) : n = len ( str ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) res = '' i = n j = n while ( i > 0 and j > 0 ) : if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : res += str [ i - 1 ] i -= 1 j -= 1 elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : i -= 1 else : j -= 1 res = '' . join ( reversed ( res ) ) return res
def binomialCoeffSum ( n ) : return ( 1 << n )
def findMaximumPieces ( n ) : return int ( 1 + n * ( n + 1 ) / 2 )
def canFormPalindrome ( strr ) : listt = [ ] for i in range ( len ( strr ) ) : if ( strr [ i ] in listt ) : listt . remove ( strr [ i ] ) else : listt . append ( strr [ i ] ) if ( len ( strr ) % 2 == 0 and len ( listt ) == 0 or \ ( len ( strr ) % 2 == 1 and len ( listt ) == 1 ) ) : return True else : return False
def dealnnoy ( n , m ) : dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] for i in range ( m ) : dp [ 0 ] [ i ] = 1 for i in range ( 1 , m + 1 ) : dp [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] return dp [ m ] [ n ]
def maximizecube ( l , b , h ) : side = gcd ( l , gcd ( b , h ) ) num = int ( l / side ) num = int ( num * b / side ) num = int ( num * h / side ) print ( side , num )
def isSparse ( array , m , n ) : counter = 0 for i in range ( 0 , m ) : for j in range ( 0 , n ) : if ( array [ i ] [ j ] == 0 ) : counter = counter + 1 return ( counter > ( ( m * n ) // 2 ) )
def divSum ( num ) : result = 0 i = 2 while i <= ( math . sqrt ( num ) ) : if ( num % i == 0 ) : if ( i == ( num / i ) ) : result = result + i ; else : result = result + ( i + num / i ) ; i = i + 1 return ( result + 1 ) ;
def findSum ( n ) : multiTerms = n * ( n + 1 ) // 2 sm = multiTerms for i in range ( 2 , n + 1 ) : multiTerms = multiTerms - ( i - 1 ) sm = sm + multiTerms * i return sm
def ifPossible ( arr , n ) : cp = [ 0 ] * n cp = arr cp . sort ( ) for i in range ( 0 , n ) : if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : return False return True
def printClosest ( arr , n , x ) : res_l , res_r = 0 , 0 l , r , diff = 0 , n - 1 , MAX_VAL while r > l : if abs ( arr [ l ] + arr [ r ] - x ) < diff : res_l = l res_r = r diff = abs ( arr [ l ] + arr [ r ] - x ) if arr [ l ] + arr [ r ] > x : r -= 1 else : l += 1 print ( 'Theclosestpairis{}and{}' . format ( arr [ res_l ] , arr [ res_r ] ) )
def maximumChars ( str1 ) : n = len ( str1 ) res = - 1 firstInd = [ - 1 for i in range ( MAX_CHAR ) ] for i in range ( n ) : first_ind = firstInd [ ord ( str1 [ i ] ) ] if ( first_ind == - 1 ) : firstInd [ ord ( str1 [ i ] ) ] = i else : res = max ( res , abs ( i - first_ind - 1 ) ) return res
def compute_average ( a , b ) : return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 )
def findStep ( n ) : if ( n == 1 or n == 0 ) : return 1 elif ( n == 2 ) : return 2 else : return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 )
def countDer ( n ) : if ( n == 1 ) : return 0 if ( n == 0 ) : return 1 if ( n == 2 ) : return 1 return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )
def maximumNumberDistinctPrimeRange ( m , n ) : factorCount = [ 0 ] * ( n + 1 ) prime = [ False ] * ( n + 1 ) for i in range ( n + 1 ) : factorCount [ i ] = 0 prime [ i ] = True for i in range ( 2 , n + 1 ) : if ( prime [ i ] == True ) : factorCount [ i ] = 1 for j in range ( i * 2 , n + 1 , i ) : factorCount [ j ] += 1 prime [ j ] = False max = factorCount [ m ] num = m for i in range ( m , n + 1 ) : if ( factorCount [ i ] > max ) : max = factorCount [ i ] num = i return num
def bestFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : bestIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if bestIdx == - 1 : bestIdx = j elif blockSize [ bestIdx ] > blockSize [ j ] : bestIdx = j if bestIdx != - 1 : allocation [ i ] = bestIdx blockSize [ bestIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )
def compute ( st , n ) : reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" l = len ( st ) answer = "" for i in range ( 0 , n ) : answer = answer + st [ i ] for i in range ( n , l ) : answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( 'a' ) ] ) return answer
def cutRod ( price , n ) : val = [ 0 for x in range ( n + 1 ) ] val [ 0 ] = 0 for i in range ( 1 , n + 1 ) : max_val = INT_MIN for j in range ( i ) : max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) val [ i ] = max_val return val [ n ]
def maxTasks ( high , low , n ) : if ( n <= 0 ) : return 0 return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) )
def sortedCount ( mat , r , c ) : result = 0 for i in range ( r ) : j = 0 for j in range ( c - 1 ) : if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : break if j == c - 2 : result += 1 for i in range ( 0 , r ) : j = 0 for j in range ( c - 1 , 0 , - 1 ) : if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : break if c > 1 and j == 1 : result += 1 return result
def check ( st ) : n = len ( st ) if ( n == 0 ) : return False if ( n == 1 ) : return ( ( st [ 0 ] - '0' ) % 4 == 0 ) last = ( int ) ( st [ n - 1 ] ) second_last = ( int ) ( st [ n - 2 ] ) return ( ( second_last * 10 + last ) % 4 == 0 )
def remainderWith7 ( num ) : series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] series_index = 0 result = 0 for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : digit = ord ( num [ i ] ) - 48 result += digit * series [ series_index ] series_index = ( series_index + 1 ) % 6 result %= 7 if ( result < 0 ) : result = ( result + 7 ) % 7 return result
def subset ( ar , n ) : res = 0 ar . sort ( ) for i in range ( 0 , n ) : count = 1 for i in range ( n - 1 ) : if ar [ i ] == ar [ i + 1 ] : count += 1 else : break res = max ( res , count ) return res
def freq ( ar , m , n ) : even = 0 odd = 0 for i in range ( m ) : for j in range ( n ) : if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : even += 1 else : odd += 1 print ( "Frequencyofoddnumber=" , odd ) print ( "Frequencyofevennumber=" , even )
def MatrixChainOrder ( p , i , j ) : if i == j : return 0 _min = sys . maxsize for k in range ( i , j ) : count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) if count < _min : _min = count return _min
def getSum ( n ) : sum = 0 while ( n > 0 ) : sum += int ( n % 10 ) n = int ( n / 10 ) return sum
def compute_average ( a , b ) : return floor ( ( a + b ) / 2 )
def generate ( st , s ) : if len ( s ) == 0 : return if s not in st : st . add ( s ) for i in range ( len ( s ) ) : t = list ( s ) . copy ( ) t . remove ( s [ i ] ) t = '' . join ( t ) generate ( st , t ) return
def floorSearch ( arr , low , high , x ) : if ( low > high ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )
def pairsInSortedRotated ( arr , n , x ) : for i in range ( n ) : if arr [ i ] > arr [ i + 1 ] : break l = ( i + 1 ) % n r = i cnt = 0 while ( l != r ) : if arr [ l ] + arr [ r ] == x : cnt += 1 if l == ( r - 1 + n ) % n : return cnt l = ( l + 1 ) % n r = ( r - 1 + n ) % n elif arr [ l ] + arr [ r ] < x : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return cnt
def printArray ( a , n ) : for i in a : print ( i , end = "" ) print ( )
def isAnBn ( str ) : n = len ( str ) for i in range ( n ) : if ( str [ i ] != 'a' ) : break if ( i * 2 != n ) : return False for j in range ( i , n ) : if ( str [ j ] != 'b' ) : return False return True
def countOfBinaryNumberLessThanN ( N ) : q = deque ( ) q . append ( 1 ) cnt = 0 while ( q ) : t = q . popleft ( ) if ( t <= N ) : cnt = cnt + 1 q . append ( t * 10 ) q . append ( t * 10 + 1 ) return cnt
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , m + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 if ( cnt [ i ] [ j ] >= k ) : for a in range ( k , cnt [ i ] [ j ] + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) return lcs [ n ] [ m ]
def checkCount ( arr , n , k ) : for i in range ( n ) : count = 0 for j in range ( n ) : if arr [ j ] == arr [ i ] : count += 1 if count > 2 * k : return False return True
def lexicographicSubConcat ( s ) : n = len ( s ) sub_count = ( n * ( n + 1 ) ) // 2 arr = [ 0 ] * sub_count index = 0 for i in range ( n ) : for j in range ( 1 , n - i + 1 ) : arr [ index ] = s [ i : i + j ] index += 1 arr . sort ( ) res = "" for i in range ( sub_count ) : res += arr [ i ] return res
def antiSpiralTraversal ( m , n , a ) : k = 0 l = 0 stk = [ ] while ( k <= m and l <= n ) : for i in range ( l , n + 1 ) : stk . append ( a [ k ] [ i ] ) k += 1 for i in range ( k , m + 1 ) : stk . append ( a [ i ] [ n ] ) n -= 1 if ( k <= m ) : for i in range ( n , l - 1 , - 1 ) : stk . append ( a [ m ] [ i ] ) m -= 1 if ( l <= n ) : for i in range ( m , k - 1 , - 1 ) : stk . append ( a [ i ] [ l ] ) l += 1 while len ( stk ) != 0 : print ( str ( stk [ - 1 ] ) , end = "" ) stk . pop ( )
def reverseFibonacci ( n ) : a = [ 0 ] * n a [ 0 ] = 0 a [ 1 ] = 1 for i in range ( 2 , n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] for i in range ( n - 1 , - 1 , - 1 ) : print ( a [ i ] , end = "" )
def maxLen ( arr ) : max_len = 0 for i in range ( len ( arr ) ) : curr_sum = 0 for j in range ( i , len ( arr ) ) : curr_sum += arr [ j ] if curr_sum == 0 : max_len = max ( max_len , j - i + 1 ) return max_len
def MaximumHeight ( a , n ) : return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2
def checkJumbled ( num ) : if ( num // 10 == 0 ) : return True while ( num != 0 ) : if ( num // 10 == 0 ) : return True digit1 = num % 10 digit2 = ( num // 10 ) % 10 if ( abs ( digit2 - digit1 ) > 1 ) : return False num = num // 10 return True
def sumAtKthLevel ( tree , k , i , level ) : if ( tree [ i [ 0 ] ] == '(' ) : i [ 0 ] += 1 if ( tree [ i [ 0 ] ] == ')' ) : return 0 sum = 0 if ( level == k ) : sum = int ( tree [ i [ 0 ] ] ) i [ 0 ] += 1 leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) i [ 0 ] += 1 rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) i [ 0 ] += 1 return sum + leftsum + rightsum
def smallest ( x , y , z ) : c = 0 while ( x and y and z ) : x = x - 1 y = y - 1 z = z - 1 c = c + 1 return c
def selectRandom ( x ) : res = 0 count = 0 count += 1 if ( count == 1 ) : res = x else : i = random . randrange ( count ) if ( i == count - 1 ) : res = x return res
def minAbsSumPair ( arr , arr_size ) : inv_count = 0 if arr_size < 2 : print ( "InvalidInput" ) return min_l = 0 min_r = 1 min_sum = arr [ 0 ] + arr [ 1 ] for l in range ( 0 , arr_size - 1 ) : for r in range ( l + 1 , arr_size ) : sum = arr [ l ] + arr [ r ] if abs ( min_sum ) > abs ( sum ) : min_sum = sum min_l = l min_r = r print ( "Thetwoelementswhosesumisminimumare" , arr [ min_l ] , "and" , arr [ min_r ] )
def getMissingNo ( A ) : n = len ( A ) total = ( n + 1 ) * ( n + 2 ) / 2 sum_of_A = sum ( A ) return total - sum_of_A
def maximumSum ( a , n ) : global M for i in range ( 0 , n ) : a [ i ] . sort ( ) sum = a [ n - 1 ] [ M - 1 ] prev = a [ n - 1 ] [ M - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : for j in range ( M - 1 , - 1 , - 1 ) : if ( a [ i ] [ j ] < prev ) : prev = a [ i ] [ j ] sum += prev break if ( j == - 1 ) : return 0 return sum
def countP ( n , k ) : dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( k + 1 ) : dp [ 0 ] [ k ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : if ( j == 1 or i == j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) return dp [ n ] [ k ]
def findPairs ( arr , n ) : Hash = { } for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum = arr [ i ] + arr [ j ] if sum in Hash . keys ( ) : prev = Hash . get ( sum ) print ( str ( prev ) + "and(%d,%d)" % ( arr [ i ] , arr [ j ] ) ) return True else : Hash [ sum ] = ( arr [ i ] , arr [ j ] )
def countWays ( n , k ) : total = k mod = 1000000007 same , diff = 0 , k for i in range ( 2 , n + 1 ) : same = diff diff = total * ( k - 1 ) diff = diff % mod total = ( same + diff ) % mod return total
def printPrevSmaller ( arr , n ) : print ( "_," , end = "" ) for i in range ( 1 , n ) : for j in range ( i - 1 , - 2 , - 1 ) : if ( arr [ j ] < arr [ i ] ) : print ( arr [ j ] , "," , end = "" ) break if ( j == - 1 ) : print ( "_," , end = "" )
def printSuperSeq ( a , b ) : m = len ( a ) n = len ( b ) dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( 0 , m + 1 ) : for j in range ( 0 , n + 1 ) : if not i : dp [ i ] [ j ] = j elif not j : dp [ i ] [ j ] = i elif ( a [ i - 1 ] == b [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] res = [ "" ] * ( index ) i = m j = n while ( i > 0 and j > 0 ) : if ( a [ i - 1 ] == b [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 j -= 1 index -= 1 elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 else : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 while ( i > 0 ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 while ( j > 0 ) : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 print ( "" . join ( res ) )
def isPermutedMatrix ( mat , n ) : str_cat = "" for i in range ( n ) : str_cat = str_cat + "-" + str ( mat [ 0 ] [ i ] ) str_cat = str_cat + str_cat for i in range ( 1 , n ) : curr_str = "" for j in range ( n ) : curr_str = curr_str + "-" + str ( mat [ i ] [ j ] ) if ( str_cat . find ( curr_str ) ) : return True return False
def minCost ( cost ) : dist = [ 0 for i in range ( N ) ] for i in range ( N ) : dist [ i ] = INF dist [ 0 ] = 0 for i in range ( N ) : for j in range ( i + 1 , N ) : if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]
def findMaxSegment ( s , k ) : seg_len = len ( s ) - k res = 0 for i in range ( seg_len ) : res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) seg_len_pow = pow ( 10 , seg_len - 1 ) curr_val = res for i in range ( 1 , len ( s ) - seg_len ) : curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) res = max ( res , curr_val ) return res
def minInsertion ( tr1 ) : n = len ( str1 ) res = 0 count = [ 0 for i in range ( 26 ) ] for i in range ( n ) : count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( 26 ) : if ( count [ i ] % 2 == 1 ) : res += 1 if ( res == 0 ) : return 0 else : return res - 1
def count ( S , m , n ) : if ( n == 0 ) : return 1 if ( n < 0 ) : return 0 if ( m <= 0 and n >= 1 ) : return 0 return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] )
def countWays ( arr , m , N ) : count = [ 0 for i in range ( N + 1 ) ] count [ 0 ] = 1 for i in range ( 1 , N + 1 ) : for j in range ( m ) : if ( i >= arr [ j ] ) : count [ i ] += count [ i - arr [ j ] ] return count [ N ]
def mostFrequent ( arr , n ) : arr . sort ( ) max_count = 1 res = arr [ 0 ] curr_count = 1 for i in range ( 1 , n ) : if ( arr [ i ] == arr [ i - 1 ] ) : curr_count += 1 else : if ( curr_count > max_count ) : max_count = curr_count res = arr [ i - 1 ] curr_count = 1 if ( curr_count > max_count ) : max_count = curr_count res = arr [ n - 1 ] return res
def findGreatest ( arr , n ) : result = - 1 for i in range ( n ) : for j in range ( n - 1 ) : for k in range ( j + 1 , n ) : if ( arr [ j ] * arr [ k ] == arr [ i ] ) : result = max ( result , arr [ i ] ) return result
def findSumSubsets ( n ) : return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) )
def squareRoot ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( ( x * x ) % p == n ) : print ( "Squarerootis" , x ) return print ( "Squarerootdoesn'texist" )
def findFirstMissing ( array , start , end ) : if ( start > end ) : return end + 1 if ( start != array [ start ] ) : return start mid = int ( ( start + end ) / 2 ) if ( array [ mid ] == mid ) : return findFirstMissing ( array , mid + 1 , end ) return findFirstMissing ( array , start , mid )
def isPrime ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return True if ( n % 2 == 0 or n % 3 == 0 ) : return False i = 5 while ( i * i <= n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return False i = i + 6 return True
def mostFrequent ( arr , n ) : Hash = dict ( ) for i in range ( n ) : if arr [ i ] in Hash . keys ( ) : Hash [ arr [ i ] ] += 1 else : Hash [ arr [ i ] ] = 1 max_count = 0 res = - 1 for i in Hash : if ( max_count < Hash [ i ] ) : res = i max_count = Hash [ i ] return res
def isSubSequence ( str1 , str2 , m , n ) : j = 0 i = 0 while j < m and i < n : if str1 [ j ] == str2 [ i ] : j = j + 1 i = i + 1 return j == m
