def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count
def largestSumOfAverages ( A , K ) : n = len ( A ) pre_sum = [ 0 ] * ( n + 1 ) pre_sum [ 0 ] = 0 for i in range ( n ) : pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] dp = [ 0 ] * n sum = 0 for i in range ( n ) : dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) for k in range ( K - 1 ) : for i in range ( n ) : for j in range ( i + 1 , n ) : dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) return int ( dp [ 0 ] )
def maxSumBitonicSubArr ( arr , n ) : msis = [ None ] * n msds = [ None ] * n max_sum = 0 msis [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ i - 1 ] ) : msis [ i ] = msis [ i - 1 ] + arr [ i ] else : msis [ i ] = arr [ i ] msds [ n - 1 ] = arr [ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : msds [ i ] = msds [ i + 1 ] + arr [ i ] else : msds [ i ] = arr [ i ] for i in range ( n ) : if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) return max_sum
def sortString ( str , n ) : new_str = "" for i in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : for j in range ( n ) : if ( str [ j ] == chr ( i ) ) : new_str += str [ j ] return new_str
def largestSubset ( a , n ) : a . sort ( ) dp = [ 0 for i in range ( n ) ] dp [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : mxm = 0 for j in range ( i + 1 , n ) : if a [ j ] % a [ i ] == 0 : mxm = max ( mxm , dp [ j ] ) dp [ i ] = 1 + mxm return max ( dp )
def isPerfectSquare ( n ) : i = 1 the_sum = 0 while the_sum < n : the_sum += i if the_sum == n : return True i += 2 return False
def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count
def alternateSubarray ( arr , n ) : count = 1 prev = arr [ 0 ] for i in range ( 1 , n ) : if ( ( arr [ i ] ^ prev ) == 0 ) : while ( count ) : print ( count , end = "" ) count -= 1 count += 1 prev = arr [ i ] while ( count ) : print ( count , end = "" ) count -= 1
def minValue ( A , B , n ) : sorted ( A ) sorted ( B ) result = 0 for i in range ( n ) : result += ( A [ i ] * B [ n - i - 1 ] ) return result
def countSetBits ( n ) : count = 0 while ( n ) : count += n & 1 n >>= 1 return count
def to_upper ( string ) : for i in range ( len ( string ) ) : if ( 'a' <= string [ i ] <= 'z' ) : string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] ) return string
def countSetBits ( n ) : if ( n == 0 ) : return 0 else : return 1 + countSetBits ( n & ( n - 1 ) )
def printStringAlternate ( string ) : occ = { } for i in range ( 0 , len ( string ) ) : temp = string [ i ] . lower ( ) occ [ temp ] = occ . get ( temp , 0 ) + 1 if occ [ temp ] & 1 : print ( string [ i ] , end = "" ) print ( )
def longestSubseqWithDiffOne ( arr , n ) : dp = [ 1 for i in range ( n ) ] for i in range ( n ) : for j in range ( i ) : if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) result = 1 for i in range ( n ) : if ( result < dp [ i ] ) : result = dp [ i ] return result
def findExtra ( arr1 , arr2 , n ) : index = n left = 0 right = n - 1 while ( left <= right ) : mid = ( int ) ( ( left + right ) / 2 ) if ( arr2 [ mid ] == arr1 [ mid ] ) : left = mid + 1 else : index = mid right = mid - 1 return index
def minTime ( arr , n , m ) : t = 0 while ( 1 ) : items = 0 for i in range ( n ) : items += ( t // arr [ i ] ) if ( items >= m ) : return t t += 1
def permutatedRows ( mat , m , n , r ) : s = set ( ) for j in range ( n ) : s . add ( mat [ r ] [ j ] ) for i in range ( m ) : if i == r : continue for j in range ( n ) : if mat [ i ] [ j ] not in s : j = j - 2 break if j + 1 != n : continue print ( i )
def printPairs ( arr , n , k ) : isPairFound = True for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i != j and arr [ i ] % arr [ j ] == k ) : print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , sep = "" , end = "" ) isPairFound = True return isPairFound
def Right_most_setbit ( num ) : pos = 1 for i in range ( INT_SIZE ) : if not ( num & ( 1 << i ) ) : pos += 1 else : break return pos
def countSolutions ( n ) : x = 0 res = 0 yCount = 0 while ( yCount * yCount < n ) : yCount = yCount + 1 while ( yCount != 0 ) : res = res + yCount x = x + 1 while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : yCount = yCount - 1 return res
def findLongestRepeatingSubSeq ( X , m , n ) : if ( dp [ m ] [ n ] != - 1 ) : return dp [ m ] [ n ] if ( m == 0 or n == 0 ) : dp [ m ] [ n ] = 0 return dp [ m ] [ n ] if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 return dp [ m ] [ n ] dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) return dp [ m ] [ n ]
def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( n ) : for j in range ( m ) : if ( arr2 [ i ] == arr1 [ j ] ) : break if ( j == m ) : return 0 return 1
def nonFibonacci ( n ) : prevPrev = 1 prev = 2 curr = 3 while n > 0 : prevPrev = prev prev = curr curr = prevPrev + prev n = n - ( curr - prev - 1 ) n = n + ( curr - prev - 1 ) return prev + n
def myCopy ( s1 , s2 , index ) : s2 [ index ] = s1 [ index ] if ( index == len ( s1 ) - 1 ) : return myCopy ( s1 , s2 , index + 1 )
def maxArea ( mat ) : hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] for i in range ( 0 , C , 1 ) : hist [ 0 ] [ i ] = mat [ 0 ] [ i ] for j in range ( 1 , R , 1 ) : if ( ( mat [ j ] [ i ] == 0 ) ) : hist [ j ] [ i ] = 0 else : hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 for i in range ( 0 , R , 1 ) : count = [ 0 for i in range ( R + 1 ) ] for j in range ( 0 , C , 1 ) : count [ hist [ i ] [ j ] ] += 1 col_no = 0 j = R while ( j >= 0 ) : if ( count [ j ] > 0 ) : for k in range ( 0 , count [ j ] , 1 ) : hist [ i ] [ col_no ] = j col_no += 1 j -= 1 max_area = 0 for i in range ( 0 , R , 1 ) : for j in range ( 0 , C , 1 ) : curr_area = ( j + 1 ) * hist [ i ] [ j ] if ( curr_area > max_area ) : max_area = curr_area return max_area
def isNumber ( s ) : for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) != True : return False return True
def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return a [ n - 1 ] + b [ n - 1 ]
def HalfDiagonalSums ( mat , n ) : diag1_left = 0 diag1_right = 0 diag2_left = 0 diag2_right = 0 i = 0 j = n - 1 while i < n : if ( i < n // 2 ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ j ] [ i ] elif ( i > n // 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] i += 1 j -= 1 return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )
def count ( n ) : if ( n < 4 ) : return - 1 rem = n % 4 if ( rem == 0 ) : return n // 4 if ( rem == 1 ) : if ( n < 9 ) : return - 1 return ( n - 9 ) // 4 + 1 if ( rem == 2 ) : return ( n - 6 ) // 4 + 1 if ( rem == 3 ) : if ( n < 15 ) : return - 1 return ( n - 15 ) // 4 + 2
def maxSquare ( b , m ) : return ( b / m - 1 ) * ( b / m ) / 2
def findArea ( arr , n ) : arr . sort ( reverse = True ) dimension = [ 0 , 0 ] i = 0 j = 0 while ( i < n - 1 and j < 2 ) : if ( arr [ i ] == arr [ i + 1 ] ) : dimension [ j ] = arr [ i ] j += 1 i += 1 i += 1 return ( dimension [ 0 ] * dimension [ 1 ] )
def minCost ( a , n , k ) : dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : for m in range ( i - 1 , - 1 , - 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) return dp [ n ] [ k ]
def printDistinct ( arr , n ) : s = dict ( ) for i in range ( n ) : if ( arr [ i ] not in s . keys ( ) ) : s [ arr [ i ] ] = arr [ i ] print ( arr [ i ] , end = "" )
def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low i = low for i in range ( high ) : if arr [ i ] == x : return i if arr [ i ] < x and arr [ i + 1 ] >= x : return i + 1 return - 1
def getRemainder ( num , divisor ) : return ( num - divisor * ( num // divisor ) )
def findArea ( arr , n ) : s = [ ] first = 0 second = 0 for i in range ( n ) : if arr [ i ] not in s : s . append ( arr [ i ] ) continue if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] return ( first * second )
def reorder ( arr , index , n ) : temp = [ 0 ] * n for i in range ( 0 , n ) : temp [ index [ i ] ] = arr [ i ] for i in range ( 0 , n ) : arr [ i ] = temp [ i ] index [ i ] = i
def printNos ( n ) : if n > 0 : printNos ( n - 1 ) print ( n , end = '' )
def CountWays ( n ) : table = [ 0 ] * ( n + 1 ) table [ 0 ] = 1 for i in range ( 1 , n ) : for j in range ( i , n + 1 ) : table [ j ] += table [ j - i ] return table [ n ]
def checkCorrectOrNot ( s ) : global MAX_CHAR count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR n = len ( s ) if n == 1 : return true i = 0 j = n - 1 while ( i < j ) : count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 i += 1 j -= 1 for i in range ( MAX_CHAR ) : if count1 [ i ] != count2 [ i ] : return False return True
def superSeq ( X , Y , m , n ) : dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if ( not i ) : dp [ i ] [ j ] = j elif ( not j ) : dp [ i ] [ j ] = i elif ( X [ i - 1 ] == Y [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) return dp [ m ] [ n ]
def waysToIncreaseLCSBy1 ( str1 , str2 ) : m = len ( str1 ) n = len ( str2 ) position = [ [ ] for i in range ( M ) ] for i in range ( 1 , n + 1 , 1 ) : position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i ) lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] lcsr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] for i in range ( 1 , m + 1 , 1 ) : for j in range ( 1 , n + 1 , 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] else : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) for i in range ( m , 0 , - 1 ) : for j in range ( n , 0 , - 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] else : lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ways = 0 for i in range ( 0 , m + 1 , 1 ) : for C in range ( 0 , 26 , 1 ) : for j in range ( 0 , len ( position [ C ] ) , 1 ) : p = position [ C ] [ j ] if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : ways += 1 return ways
def isPrime ( n , i = 2 ) : if ( n <= 2 ) : return True if ( n == 2 ) else False if ( n % i == 0 ) : return False if ( i * i > n ) : return true return isPrime ( n , i + 1 )
def isSymmetric ( mat , N ) : for i in range ( N ) : for j in range ( N ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : return False return True
def findLIS ( A , n ) : hash = dict ( ) LIS_size , LIS_index = 1 , 0 hash [ A [ 0 ] ] = 1 for i in range ( 1 , n ) : if A [ i ] - 1 not in hash : hash [ A [ i ] - 1 ] = 0 hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 if LIS_size < hash [ A [ i ] ] : LIS_size = hash [ A [ i ] ] LIS_index = A [ i ] print ( "LIS_size=" , LIS_size ) print ( "LIS:" , end = "" ) start = LIS_index - LIS_size + 1 while start <= LIS_index : print ( start , end = "" ) start += 1
def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 for i in range ( 0 , n ) : area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return abs ( area // 2.0 )
def findSum ( N ) : ans = 0 for i in range ( 1 , N + 1 ) : for j in range ( 1 , N + 1 ) : ans += i // j return ans
def findRepeating ( arr , n ) : s = set ( ) for i in range ( n ) : if arr [ i ] in s : return arr [ i ] s . add ( arr [ i ] ) rteurn - 1
def manipulated_seive ( N ) : isprime [ 0 ] = isprime [ 1 ] = False for i in range ( 2 , N ) : if isprime [ i ] == True : prime . append ( i ) SPF [ i ] = i j = 0 while ( j < len ( prime ) and i * prime [ j ] < N and prime [ j ] <= SPF [ i ] ) : isprime [ i * prime [ j ] ] = False SPF [ i * prime [ j ] ] = prime [ j ] j += 1
def maxProd ( n ) : if ( n == 0 or n == 1 ) : return 0 max_val = 0 for i in range ( 1 , n - 1 ) : max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) return max_val
def sumOfSeries ( n ) : return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 )
def arrangeBraces ( n , pos , k ) : h = [ False for i in range ( N ) ] dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] for i in range ( k ) : h [ pos [ i ] ] = 1 dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , 2 * n + 1 ) : for j in range ( 2 * n + 1 ) : if ( h [ i ] ) : if ( j != 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 0 else : if ( j != 0 ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) else : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] return dp [ 2 * n ] [ 0 ]
def findSum ( N , K ) : ans = 0 for i in range ( 1 , N + 1 ) : ans += ( i % K ) return ans
def eulerian ( n , m ) : dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 0 , m + 1 ) : if ( i > j ) : if ( j == 0 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) return dp [ n ] [ m ]
def maxTripletSum ( arr , n ) : maxA = - 100000000 maxB = - 100000000 maxC = - 100000000 for i in range ( 0 , n ) : if ( arr [ i ] > maxA ) : maxC = maxB maxB = maxA maxA = arr [ i ] elif ( arr [ i ] > maxB ) : maxC = maxB maxB = arr [ i ] elif ( arr [ i ] > maxC ) : maxC = arr [ i ] return ( maxA + maxB + maxC )
def decToBinary ( n ) : for i in range ( 31 , - 1 , - 1 ) : k = n >> i if ( k & 1 ) : print ( "1" , end = "" ) else : print ( "0" , end = "" )
def printkthnode ( adj , wt , n , k ) : for i in range ( n ) : adj [ i ] . sort ( ) for i in range ( n ) : if ( len ( adj [ i ] ) >= k ) : print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = "" ) else : print ( "-1" , end = "" )
def find ( p ) : return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) )
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : for i in range ( 0 , n1 ) : for j in range ( 0 , n2 ) : for k in range ( 0 , n3 ) : if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : return True return False
def volumeOfEllipsoid ( r1 , r2 , r3 ) : return 1.33 * math . pi * r1 * r2 * r3
def maxPrimeFactors ( n ) : maxPrime = - 1 while n % 2 == 0 : maxPrime = 2 n >>= 1 for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : while n % i == 0 : maxPrime = i n = n / i if n > 2 : maxPrime = n return int ( maxPrime )
def multiply ( A , B , C ) : for i in range ( N ) : for j in range ( N ) : C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]
def nextPowerOf2 ( n ) : p = 1 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( p < n ) : p <<= 1 return p
def squareRootExists ( n , p ) : n = n % p for x in range ( 2 , p , 1 ) : if ( ( x * x ) % p == n ) : return True return False
def findArea ( a , b , c ) : if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : print ( 'Notavalidtrianglen' ) return s = ( a + b + c ) / 2 area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 print ( 'Areaofatraingleis%f' % area )
def convertOpposite ( str ) : ln = len ( str ) for i in range ( ln ) : if str [ i ] >= 'a' and str [ i ] <= 'z' : str [ i ] = chr ( ord ( str [ i ] ) - 32 ) elif str [ i ] >= 'A' and str [ i ] <= 'Z' : str [ i ] = chr ( ord ( str [ i ] ) + 32 )
def find ( n , k ) : if ( n + 1 >= k ) : return ( k - 1 ) else : return ( 2 * n + 1 - k )
def find_maximum ( a , n , k ) : b = dict ( ) for i in range ( n ) : x = a [ i ] d = min ( 1 + i , n - i ) if x not in b . keys ( ) : b [ x ] = d else : b [ x ] = min ( d , b [ x ] ) ans = 10 ** 9 for i in range ( n ) : x = a [ i ] if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) return ans
def findLength ( str ) : n = len ( str ) maxlen = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n , 2 ) : length = j - i + 1 leftsum = 0 rightsum = 0 for k in range ( 0 , int ( length / 2 ) ) : leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) ) if ( leftsum == rightsum and maxlen < length ) : maxlen = length return maxlen
def check ( degree , n ) : deg_sum = sum ( degree ) if ( 2 * ( n - 1 ) == deg_sum ) : return True else : return False
def swap ( xp , yp ) : xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]
def swapUpperToLower ( arr ) : n = 4 ; for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; for i in range ( 0 , n ) : for j in range ( 0 , n ) : print ( arr [ i ] [ j ] , end = "" ) ; print ( "" ) ;
def eulerian ( n , m ) : if ( m >= n or n == 0 ) : return 0 if ( m == 0 ) : return 1 return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) )
def isMajority ( a ) : mp = { } for i in a : if i in mp : mp [ i ] += 1 else : mp [ i ] = 1 for x in mp : if mp [ x ] >= len ( a ) // 2 : return True return False
def minMaxValues ( arr , n , m ) : sum = 0 INF = 1000000000 MAX = 50 for i in range ( 0 , ( n + m ) ) : sum += arr [ i ] arr [ i ] += 50 dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 0 , ( n + m ) ) : for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : for j in range ( 0 , MAX * MAX + 1 ) : if ( dp [ k - 1 ] [ j ] ) : dp [ k ] [ j + arr [ i ] ] = 1 max_value = - 1 * INF min_value = INF for i in range ( 0 , MAX * MAX + 1 ) : if ( dp [ n ] [ i ] ) : temp = i - 50 * n max_value = max ( max_value , temp * ( sum - temp ) ) min_value = min ( min_value , temp * ( sum - temp ) ) print ( "MaximumValue:{}\nMinimumValue:{}" . format ( max_value , min_value ) )
def countPairsWithDiffK ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : count += 1 return count
def minRange ( arr , n , k ) : l = 0 r = n for i in range ( n ) : s = [ ] for j in range ( i , n ) : s . append ( arr [ j ] ) if ( len ( s ) == k ) : if ( ( j - i ) < ( r - l ) ) : r = j l = i break if ( j == n ) : break if ( l == 0 and r == n ) : print ( "Invalidk" ) else : print ( l , r )
def firstNonRepeating ( arr , n ) : for i in range ( n ) : j = 0 while ( j < n ) : if ( i != j and arr [ i ] == arr [ j ] ) : break j += 1 if ( j == n ) : return arr [ i ] return - 1
def sumOfSeries ( n ) : return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n )
def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for i in range ( m ) : for j in range ( n ) : if arr1 [ i ] + arr2 [ j ] == x : count = count + 1 return count
def find3largest ( arr , n ) : arr = sorted ( arr ) check = 0 count = 1 for i in range ( 1 , n + 1 ) : if ( count < 4 ) : if ( check != arr [ n - i ] ) : print ( arr [ n - i ] , end = "" ) check = arr [ n - i ] count += 1 else : break
def findSubsequenceCount ( S , T ) : m = len ( T ) n = len ( S ) if m > n : return 0 mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] for i in range ( 1 , m + 1 ) : mat [ i ] [ 0 ] = 0 for j in range ( n + 1 ) : mat [ 0 ] [ j ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if T [ i - 1 ] != S [ j - 1 ] : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] else : mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) return mat [ m ] [ n ]
def minHeight ( area , base ) : return math . ceil ( ( 2 * area ) / base )
def seiresSum ( n , a ) : return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) )
def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len
def swapBits ( x , p1 , p2 , n ) : set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) xor = ( set1 ^ set2 ) xor = ( xor << p1 ) | ( xor << p2 ) result = x ^ xor return result
def maxProfit ( prices , n , k ) : profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , k + 1 ) : max_so_far = 0 for l in range ( i ) : max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) return profit [ n - 1 ] [ k ]
def numoffbt ( arr , n ) : maxvalue = - 2147483647 minvalue = 2147483647 for i in range ( n ) : maxvalue = max ( maxvalue , arr [ i ] ) minvalue = min ( minvalue , arr [ i ] ) mark = [ 0 for i in range ( maxvalue + 2 ) ] value = [ 0 for i in range ( maxvalue + 2 ) ] for i in range ( n ) : mark [ arr [ i ] ] = 1 value [ arr [ i ] ] = 1 ans = 0 for i in range ( minvalue , maxvalue + 1 ) : if ( mark [ i ] != 0 ) : j = i + i while ( j <= maxvalue and j // i <= i ) : if ( mark [ j ] == 0 ) : continue value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) if ( i != j // i ) : value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) j += i ans += value [ i ] return ans
def printFun ( test ) : if ( test < 1 ) : return else : print ( test , end = "" ) printFun ( test - 1 ) print ( test , end = "" ) return
def gcdExtended ( a , b , x , y ) : if a == 0 : x = 0 y = 1 return b x1 = 1 y1 = 1 gcd = gcdExtended ( b % a , a , x1 , y1 ) x = y1 - ( b / a ) * x1 y = x1 return gcd
def hexagonArea ( s ) : return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 )
def maxArea ( a , b , c , d ) : semiperimeter = ( a + b + c + d ) / 2 return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )
def modularSum ( arr , n , m ) : if ( n > m ) : return True DP = [ False for i in range ( m ) ] for i in range ( n ) : if ( DP [ 0 ] ) : return True temp = [ False for i in range ( m ) ] for j in range ( m ) : if ( DP [ j ] == True ) : if ( DP [ ( j + arr [ i ] ) % m ] == False ) : temp [ ( j + arr [ i ] ) % m ] = True for j in range ( m ) : if ( temp [ j ] ) : DP [ j ] = True DP [ arr [ i ] % m ] = True return DP [ 0 ]
def isScalarMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False for i in range ( 0 , N - 1 ) : if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : return False return True
def calculate ( s ) : ans = 6 for i in range ( 10 ) : for j in range ( 10 ) : for k in range ( 10 ) : for l in range ( 10 ) : for m in range ( 10 ) : for n in range ( 10 ) : if ( i + j + k == l + m + n ) : c = 0 if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : c += 1 if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : c += 1 if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : c += 1 if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : c += 1 if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : c += 1 if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : c += 1 if ( c < ans ) : ans = c return ans
def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] start = 0 i = 1 while i <= n : while curr_sum > sum and start < i - 1 : curr_sum = curr_sum - arr [ start ] start += 1 if curr_sum == sum : print ( "Sumfoundbetweenindexes" ) print ( "%dand%d" % ( start , i - 1 ) ) return 1 if i < n : curr_sum = curr_sum + arr [ i ] i += 1 print ( "Nosubarrayfound" ) return 0
def decode ( Str ) : integerstack = [ ] stringstack = [ ] temp = "" result = "" for i in range ( len ( Str ) ) : count = 0 if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) i += 1 i -= 1 integerstack . append ( count ) elif ( Str [ i ] == ']' ) : temp = "" count = 0 if ( len ( integerstack ) != 0 ) : count = integerstack [ - 1 ] integerstack . pop ( ) while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) : temp = stringstack [ - 1 ] + temp stringstack . pop ( ) if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) : stringstack . pop ( ) for j in range ( count ) : result = result + temp for j in range ( len ( result ) ) : stringstack . append ( result [ j ] ) result = "" elif ( Str [ i ] == '[' ) : if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : stringstack . append ( Str [ i ] ) else : stringstack . append ( Str [ i ] ) integerstack . append ( 1 ) else : stringstack . append ( Str [ i ] ) while len ( stringstack ) != 0 : result = stringstack [ - 1 ] + result stringstack . pop ( ) return result
def getRemainder ( num , divisor ) : if ( divisor == 0 ) : return False if ( divisor < 0 ) : divisor = - divisor if ( num < 0 ) : num = - num i = 1 product = 0 while ( product <= num ) : product = divisor * i i += 1 return num - ( product - divisor )
def numberOfPaths ( m , n ) : count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] for i in range ( m ) : count [ i ] [ 0 ] = 1 ; for j in range ( n ) : count [ 0 ] [ j ] = 1 ; for i in range ( 1 , m ) : for j in range ( n ) : count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] return count [ m - 1 ] [ n - 1 ]
