def summingSeries ( n ) : return math . pow ( n , 2 )
def Resources ( process , need ) : minResources = 0 minResources = process * ( need - 1 ) + 1 return minResources
def check_duck ( num ) : l = len ( num ) count_zero = 0 i = 1 while i < l : ch = num [ i ] if ( ch == "0" ) : count_zero = count_zero + 1 i = i + 1 return count_zero
def convert ( s ) : n = len ( s ) s1 = "" s1 = s1 + s [ 0 ] . lower ( ) i = 1 while i < n : if ( s [ i ] == '' and i <= n ) : s1 = s1 + "" + ( s [ i + 1 ] ) . lower ( ) i = i + 1 else : s1 = s1 + ( s [ i ] ) . upper ( ) i = i + 1 return s1
def numberOfWays ( x ) : if x == 0 or x == 1 : return 1 else : return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )
def minAdjustmentCost ( A , n , target ) : dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] for j in range ( M + 1 ) : dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) for i in range ( 1 , n ) : for j in range ( M + 1 ) : dp [ i ] [ j ] = 100000000 for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) res = 10000000 for j in range ( M + 1 ) : res = min ( res , dp [ n - 1 ] [ j ] ) return res
def lenOfLongestGP ( sett , n ) : if n < 2 : return n if n == 2 : return ( sett [ 1 ] % sett [ 0 ] == 0 ) sett . sort ( ) L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] llgp = 1 for i in range ( 0 , n ) : if sett [ n - 1 ] % sett [ i ] == 0 : L [ i ] [ n - 1 ] = 2 else : L [ i ] [ n - 1 ] = 1 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while i >= 0 and k <= n - 1 : if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : k += 1 elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 if L [ i ] [ j ] > llgp : llgp = L [ i ] [ j ] i -= 1 k + 1 while i >= 0 : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 return llgp
def minRemovalsDP ( arr , n ) : longest_start = - 1 longest_end = 0 for start in range ( n ) : min = sys . maxsize max = - sys . maxsize for end in range ( start , n ) : val = arr [ end ] if ( val < min ) : min = val if ( val > max ) : max = val if ( 2 * min <= max ) : break if ( end - start > longest_end - longest_start or longest_start == - 1 ) : longest_start = start longest_end = end if ( longest_start == - 1 ) : return n return ( n - ( longest_end - longest_start + 1 ) )
def isSparse ( array , m , n ) : counter = 0 for i in range ( 0 , m ) : for j in range ( 0 , n ) : if ( array [ i ] [ j ] == 0 ) : counter = counter + 1 return ( counter > ( ( m * n ) // 2 ) )
def sum ( a , n ) : cnt = dict ( ) ans = 0 pre_sum = 0 for i in range ( n ) : ans += ( i * a [ i ] ) - pre_sum pre_sum += a [ i ] if ( a [ i ] - 1 ) in cnt : ans -= cnt [ a [ i ] - 1 ] if ( a [ i ] + 1 ) in cnt : ans += cnt [ a [ i ] + 1 ] if a [ i ] not in cnt : cnt [ a [ i ] ] = 0 cnt [ a [ i ] ] += 1 return ans
def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24
def printFibonacciNumbers ( n ) : f1 = 0 f2 = 1 if ( n < 1 ) : return for x in range ( 0 , n ) : print ( f2 , end = "" ) next = f1 + f2 f1 = f2 f2 = next
def countSink ( n , m , edgeFrom , edgeTo ) : mark = [ 0 ] * ( n + 1 ) for i in range ( m ) : mark [ edgeFrom [ i ] ] = 1 count = 0 for i in range ( 1 , n + 1 ) : if ( not mark [ i ] ) : count += 1 return count
def isPrime ( n ) : if ( n <= 1 ) : return False for i in range ( 2 , n ) : if ( n % i == 0 ) : return False return True
def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 res = 0 sum = 0 for i in range ( position , length ) : sum = sum + int ( num [ i ] ) if ( sum >= previous_sum ) : res = res + countGroups ( i + 1 , sum , length , num ) return res
def dealnnoy ( n , m ) : dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] for i in range ( m ) : dp [ 0 ] [ i ] = 1 for i in range ( 1 , m + 1 ) : dp [ i ] [ 0 ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] return dp [ m ] [ n ]
def area_of_segment ( radius , angle ) : area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) area_of_triangle = 1 / 2 * ( radius * radius ) * math . sin ( ( angle * pi ) / 180 ) return area_of_sector - area_of_triangle ;
def check ( st ) : n = len ( st ) oddDigSum = 0 evenDigSum = 0 for i in range ( 0 , n ) : if ( i % 2 == 0 ) : oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) else : evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) return ( ( oddDigSum - evenDigSum ) % 11 == 0 )
def seiresSum ( n , a ) : return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) )
def countWays ( arr , m , N ) : count = [ 0 for i in range ( N + 1 ) ] count [ 0 ] = 1 for i in range ( 1 , N + 1 ) : for j in range ( m ) : if ( i >= arr [ j ] ) : count [ i ] += count [ i - arr [ j ] ] return count [ N ]
def waysToIncreaseLCSBy1 ( str1 , str2 ) : m = len ( str1 ) n = len ( str2 ) position = [ [ ] for i in range ( M ) ] for i in range ( 1 , n + 1 , 1 ) : position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i ) lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] lcsr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] for i in range ( 1 , m + 1 , 1 ) : for j in range ( 1 , n + 1 , 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] else : lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) for i in range ( m , 0 , - 1 ) : for j in range ( n , 0 , - 1 ) : if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] else : lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ways = 0 for i in range ( 0 , m + 1 , 1 ) : for C in range ( 0 , 26 , 1 ) : for j in range ( 0 , len ( position [ C ] ) , 1 ) : p = position [ C ] [ j ] if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : ways += 1 return ways
def bin ( n ) : if ( n > 1 ) : bin ( n >> 1 ) print ( n & 1 , end = "" )
def interLeaveQueue ( q ) : if ( q . qsize ( ) % 2 != 0 ) : print ( "Inputevennumberofintegers." ) s = [ ] halfSize = int ( q . qsize ( ) / 2 ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) for i in range ( halfSize ) : q . put ( q . queue [ 0 ] ) q . get ( ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) q . put ( q . queue [ 0 ] ) q . get ( )
def findRoots ( a , b , c ) : if a == 0 : print ( "Invalid" ) return - 1 d = b * b - 4 * a * c sqrt_val = math . sqrt ( abs ( d ) ) if d > 0 : print ( "Rootsarerealanddifferent" ) print ( ( - b + sqrt_val ) / ( 2 * a ) ) print ( ( - b - sqrt_val ) / ( 2 * a ) ) elif d == 0 : print ( "Rootsarerealandsame" ) print ( - b / ( 2 * a ) ) else : print ( "Rootsarecomplex" ) print ( - b / ( 2 * a ) , "+i" , sqrt_val ) print ( - b / ( 2 * a ) , "-i" , sqrt_val )
def countFriendsPairings ( n ) : a , b , c = 1 , 2 , 0 if ( n <= 2 ) : return n for i in range ( 3 , n + 1 ) : c = b + ( i - 1 ) * a a = b b = c return c
def SumNodes ( l ) : leafNodeCount = pow ( 2 , l - 1 ) vec = [ [ ] for i in range ( l ) ] for i in range ( 1 , leafNodeCount + 1 ) : vec [ l - 1 ] . append ( i ) for i in range ( l - 2 , - 1 , - 1 ) : k = 0 while ( k < len ( vec [ i + 1 ] ) - 1 ) : vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) k += 2 Sum = 0 for i in range ( l ) : for j in range ( len ( vec [ i ] ) ) : Sum += vec [ i ] [ j ] return Sum
def Right_most_setbit ( num ) : pos = 1 for i in range ( INT_SIZE ) : if not ( num & ( 1 << i ) ) : pos += 1 else : break return pos
def solve ( X , Y , l , r , k , dp ) : if k == 0 : return 0 if l < 0 or r < 0 : return 1000000000 if dp [ l ] [ r ] [ k ] != - 1 : return dp [ l ] [ r ] [ k ] cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) ) dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] ) return dp [ l ] [ r ] [ k ]
def isPowerOfTwo ( n ) : if ( n == 0 ) : return False while ( n != 1 ) : if ( n % 2 != 0 ) : return False n = n // 2 return True
def MaximumPath ( Mat ) : result = 0 dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] for i in range ( N ) : for j in range ( 1 , N + 1 ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \ Mat [ i ] [ j - 1 ] for i in range ( N + 1 ) : result = max ( result , dp [ N - 1 ] [ i ] ) return result
def fib ( n ) : if ( n <= 1 ) : return n return fib ( n - 1 ) + fib ( n - 2 )
def findLargestSumPair ( arr , n ) : if arr [ 0 ] > arr [ 1 ] : first = arr [ 0 ] second = arr [ 1 ] else : first = arr [ 1 ] second = arr [ 0 ] for i in range ( 2 , n ) : if arr [ i ] > first : second = first first = arr [ i ] elif arr [ i ] > second and arr [ i ] != first : second = arr [ i ] return ( first + second )
def bestFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : bestIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if bestIdx == - 1 : bestIdx = j elif blockSize [ bestIdx ] > blockSize [ j ] : bestIdx = j if bestIdx != - 1 : allocation [ i ] = bestIdx blockSize [ bestIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )
def getOddOccurrence ( arr , size ) : Hash = dict ( ) for i in range ( size ) : Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 for i in Hash : if ( Hash [ i ] % 2 != 0 ) : return i return - 1
def printDistSum ( arr , n ) : Sum = sum ( arr ) dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : dp [ i ] [ arr [ i - 1 ] ] = True for j in range ( 1 , Sum + 1 ) : if ( dp [ i - 1 ] [ j ] == True ) : dp [ i ] [ j ] = True dp [ i ] [ j + arr [ i - 1 ] ] = True for j in range ( Sum + 1 ) : if ( dp [ n ] [ j ] == True ) : print ( j , end = "" )
def evaluateBoolExpr ( s ) : n = len ( s ) for i in range ( 0 , n - 2 , 2 ) : if ( s [ i + 1 ] == "A" ) : if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) : s [ i + 2 ] = "0" else : s [ i + 2 ] = "1" elif ( s [ i + 1 ] == "B" ) : if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) : s [ i + 2 ] = "1" else : s [ i + 2 ] = "0" else : if ( s [ i + 2 ] == s [ i ] ) : s [ i + 2 ] = "0" else : s [ i + 2 ] = "1" return ord ( s [ n - 1 ] ) - ord ( "0" )
def maxRemoval ( arr , n ) : count = 0 cummulative_sum = 0 arr . sort ( ) for i in range ( n ) : if arr [ i ] >= cummulative_sum : count += 1 cummulative_sum += arr [ i ] return count
def leafNode ( preorder , n ) : s = [ ] i = 0 for j in range ( 1 , n ) : found = False if preorder [ i ] > preorder [ j ] : s . append ( preorder [ i ] ) else : while len ( s ) != 0 : if preorder [ j ] > s [ - 1 ] : s . pop ( - 1 ) found = True else : break if found : print ( preorder [ i ] , end = "" ) i += 1 print ( preorder [ n - 1 ] )
def countSubarrWithEqualZeroAndOne ( arr , n ) : mp = dict ( ) Sum = 0 count = 0 for i in range ( n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 Sum += arr [ i ] if ( Sum == 0 ) : count += 1 if ( Sum in mp . keys ( ) ) : count += mp [ Sum ] mp [ Sum ] = mp . get ( Sum , 0 ) + 1 return count
def printPairs ( arr , n , k ) : isPairFound = True for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i != j and arr [ i ] % arr [ j ] == k ) : print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , sep = "" , end = "" ) isPairFound = True return isPairFound
def solve ( i , par , a , n , k , current_ans ) : if ( par > k ) : return 0 global ans if ( par == k and i == n - 1 ) : ans = min ( ans , current_ans ) return 0 for j in range ( i + 1 , n ) : solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) )
def minInsertionStepToSortArray ( arr , N ) : lis = [ 0 ] * N for i in range ( N ) : lis [ i ] = 1 for i in range ( 1 , N ) : for j in range ( i ) : if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 max = 0 for i in range ( N ) : if ( max < lis [ i ] ) : max = lis [ i ] return ( N - max )
def generateGrayarr ( n ) : if ( n <= 0 ) : return arr = list ( ) arr . append ( "0" ) arr . append ( "1" ) i = 2 j = 0 while ( True ) : if i >= 1 << n : break for j in range ( i - 1 , - 1 , - 1 ) : arr . append ( arr [ j ] ) for j in range ( i ) : arr [ j ] = "0" + arr [ j ] for j in range ( i , 2 * i ) : arr [ j ] = "1" + arr [ j ] i = i << 1 for i in range ( len ( arr ) ) : print ( arr [ i ] )
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]
def printDistinct ( arr , n ) : s = dict ( ) for i in range ( n ) : if ( arr [ i ] not in s . keys ( ) ) : s [ arr [ i ] ] = arr [ i ] print ( arr [ i ] , end = "" )
def checkcircle ( r , R , r1 , x1 , y1 ) : dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) return ( dis - r1 >= R and dis + r1 <= r )
def printInSortedOrder ( arr , n ) : index = [ 0 ] * n for i in range ( n ) : index [ i ] = i for i in range ( n - 1 ) : min = i for j in range ( i + 1 , n ) : if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : min = j if ( min != i ) : index [ min ] , index [ i ] = index [ i ] , index [ min ] for i in range ( n ) : print ( arr [ index [ i ] ] , end = "" )
def countDyckPaths ( n ) : res = 1 for i in range ( 0 , n ) : res *= ( 2 * n - i ) res /= ( i + 1 ) return res / ( n + 1 )
def gnomeSort ( arr , n ) : index = 0 while index < n : if index == 0 : index = index + 1 if arr [ index ] >= arr [ index - 1 ] : index = index + 1 else : arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] index = index - 1 return arr
def totalNodes ( adjac , n , x , y ) : visited = [ 0 ] * ( n + 1 ) p = [ None ] * n q = queue . Queue ( ) q . put ( x ) visited [ x ] = True m = None while ( not q . empty ( ) ) : m = q . get ( ) for i in range ( len ( adjac [ m ] ) ) : h = adjac [ m ] [ i ] if ( not visited [ h ] ) : visited [ h ] = True p [ h ] = m q . put ( h ) count = 0 i = p [ y ] while ( i != x ) : count += 1 i = p [ i ] return count
def findVolume ( l , b , h ) : return ( ( l * b * h ) / 2 )
def findMinInsertions ( str , l , h ) : if ( l > h ) : return sys . maxsize if ( l == h ) : return 0 if ( l == h - 1 ) : return 0 if ( str [ l ] == str [ h ] ) else 1 if ( str [ l ] == str [ h ] ) : return findMinInsertions ( str , l + 1 , h - 1 ) else : return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )
def seiresSum ( n , a ) : res = 0 for i in range ( 0 , 2 * n ) : if ( i % 2 == 0 ) : res += a [ i ] * a [ i ] else : res -= a [ i ] * a [ i ] return res
def countLattice ( r ) : if ( r <= 0 ) : return 0 result = 4 for x in range ( 1 , r ) : ySquare = r * r - x * x y = int ( math . sqrt ( ySquare ) ) if ( y * y == ySquare ) : result += 4 return result
def swap ( xp , yp ) : if ( xp [ 0 ] == yp [ 0 ] ) : return xp [ 0 ] = xp [ 0 ] + yp [ 0 ] yp [ 0 ] = xp [ 0 ] - yp [ 0 ] xp [ 0 ] = xp [ 0 ] - yp [ 0 ]
def MaxSumDifference ( a , n ) : np . sort ( a ) j = 0 finalSequence = [ 0 for x in range ( n ) ] for i in range ( 0 , int ( n / 2 ) ) : finalSequence [ j ] = a [ i ] finalSequence [ j + 1 ] = a [ n - i - 1 ] j = j + 2 MaximumSum = 0 for i in range ( 0 , n - 1 ) : MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) print ( MaximumSum )
def nextGreater ( num1 ) : l = len ( num1 ) num = list ( num1 ) i = l - 1 while ( i >= 0 ) : if ( num [ i ] == '0' ) : num [ i ] = '1' break else : num [ i ] = '0' i -= 1 num1 = '' . join ( num ) if ( i < 0 ) : num1 = '1' + num1 return num1
def power ( x , y ) : if ( y == 0 ) : return 1 elif ( int ( y % 2 ) == 0 ) : return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) else : return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) )
def waysToArrange ( N , K , k ) : C = np . zeros ( ( N + 1 , N + 1 ) ) for i in range ( N + 1 ) : for j in range ( i + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) dp = np . zeros ( ( K + 1 ) ) count = 0 dp [ 0 ] = 1 for i in range ( K ) : dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) count += k [ i ] return dp [ K ]
def ZigZag ( rows , columns , numbers ) : k = 0 arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] for i in range ( rows ) : if ( i % 2 == 0 ) : j = 0 while j < columns and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j += 1 else : j = columns - 1 while j >= 0 and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j -= 1 for i in arr : for j in i : print ( j , end = "" ) print ( )
def findFourElements ( arr , n ) : mp = dict ( ) for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : mp [ arr [ i ] + arr [ j ] ] = ( i , j ) d = - 10 ** 9 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : abs_diff = abs ( arr [ i ] - arr [ j ] ) if abs_diff in mp . keys ( ) : p = mp [ abs_diff ] if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : d = max ( d , max ( arr [ i ] , arr [ j ] ) ) return d
def lis ( arr ) : n = len ( arr ) lis = [ 1 ] * n for i in range ( 1 , n ) : for j in range ( 0 , i ) : if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : lis [ i ] = lis [ j ] + 1 maximum = 0 for i in range ( n ) : maximum = max ( maximum , lis [ i ] ) return maximum
def bestApproximate ( x , y , n ) : sum_x = 0 sum_y = 0 sum_xy = 0 sum_x2 = 0 for i in range ( 0 , n ) : sum_x += x [ i ] sum_y += y [ i ] sum_xy += x [ i ] * y [ i ] sum_x2 += pow ( x [ i ] , 2 ) m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) c = ( float ) ( sum_y - m * sum_x ) / n print ( "m=" , m ) print ( "c=" , c )
def findMaxProduct ( arr , n ) : ans = - float ( 'inf' ) maxval = 1 minval = 1 for i in range ( 0 , n ) : if arr [ i ] > 0 : maxval = maxval * arr [ i ] minval = min ( 1 , minval * arr [ i ] ) elif arr [ i ] == 0 : minval = 1 maxval = 0 elif arr [ i ] < 0 : prevMax = maxval maxval = minval * arr [ i ] minval = prevMax * arr [ i ] ans = max ( ans , maxval ) if maxval <= 0 : maxval = 1 return ans
def Dragon_Curve_Sequence ( n ) : s = "1" for i in range ( 2 , n + 1 ) : temp = "1" prev = '1' zero = '0' one = '1' for j in range ( len ( s ) ) : temp += s [ j ] if ( prev == '0' ) : temp += one prev = one else : temp += zero prev = zero s = temp return s
def decode ( Str ) : integerstack = [ ] stringstack = [ ] temp = "" result = "" for i in range ( len ( Str ) ) : count = 0 if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) i += 1 i -= 1 integerstack . append ( count ) elif ( Str [ i ] == ']' ) : temp = "" count = 0 if ( len ( integerstack ) != 0 ) : count = integerstack [ - 1 ] integerstack . pop ( ) while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) : temp = stringstack [ - 1 ] + temp stringstack . pop ( ) if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) : stringstack . pop ( ) for j in range ( count ) : result = result + temp for j in range ( len ( result ) ) : stringstack . append ( result [ j ] ) result = "" elif ( Str [ i ] == '[' ) : if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : stringstack . append ( Str [ i ] ) else : stringstack . append ( Str [ i ] ) integerstack . append ( 1 ) else : stringstack . append ( Str [ i ] ) while len ( stringstack ) != 0 : result = stringstack [ - 1 ] + result stringstack . pop ( ) return result
def countOccurrences ( s , K ) : n = len ( s ) c1 = 0 c2 = 0 C = 0 for i in range ( n ) : if s [ i ] == 'a' : c1 += 1 if s [ i ] == 'b' : c2 += 1 C += c1 return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2
def lis ( arr , n ) : mpis = [ 0 ] * ( n ) for i in range ( n ) : mpis [ i ] = arr [ i ] for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] return max ( mpis )
def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if ( B [ i ] == 1 ) : j = i while ( B [ j ] == 1 ) : j = j + 1 A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] i = j for i in range ( 0 , n ) : if ( A [ i ] != i + 1 ) : return False return True
def cassini ( n ) : return - 1 if ( n & 1 ) else 1
def findSubsequenceCount ( S , T ) : m = len ( T ) n = len ( S ) if m > n : return 0 mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] for i in range ( 1 , m + 1 ) : mat [ i ] [ 0 ] = 0 for j in range ( n + 1 ) : mat [ 0 ] [ j ] = 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if T [ i - 1 ] != S [ j - 1 ] : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] else : mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) return mat [ m ] [ n ]
def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 if ( dp [ position ] [ previous_sum ] != - 1 ) : return dp [ position ] [ previous_sum ] dp [ position ] [ previous_sum ] = 0 res = 0 sum = 0 for i in range ( position , length ) : sum += ( ord ( num [ i ] ) - ord ( '0' ) ) if ( sum >= previous_sum ) : res += countGroups ( i + 1 , sum , length , num ) dp [ position ] [ previous_sum ] = res return res
def findPossibleMoves ( mat , p , q ) : global n , m X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] count = 0 for i in range ( 8 ) : x = p + X [ i ] y = q + Y [ i ] if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) : count += 1 return count
def antiSpiralTraversal ( m , n , a ) : k = 0 l = 0 stk = [ ] while ( k <= m and l <= n ) : for i in range ( l , n + 1 ) : stk . append ( a [ k ] [ i ] ) k += 1 for i in range ( k , m + 1 ) : stk . append ( a [ i ] [ n ] ) n -= 1 if ( k <= m ) : for i in range ( n , l - 1 , - 1 ) : stk . append ( a [ m ] [ i ] ) m -= 1 if ( l <= n ) : for i in range ( m , k - 1 , - 1 ) : stk . append ( a [ i ] [ l ] ) l += 1 while len ( stk ) != 0 : print ( str ( stk [ - 1 ] ) , end = "" ) stk . pop ( )
def interpolationSearch ( arr , n , x ) : lo = 0 hi = ( n - 1 ) while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : if lo == hi : if arr [ lo ] == x : return lo ; return - 1 ; pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ) if arr [ pos ] == x : return pos if arr [ pos ] < x : lo = pos + 1 ; else : hi = pos - 1 ; return - 1
def psuedoBinary ( n ) : while ( n > 0 ) : temp = n m = 0 p = 1 while ( temp ) : rem = temp % 10 temp = int ( temp / 10 ) if ( rem != 0 ) : m += p p *= 10 print ( m , end = "" ) n = n - m
def getInvCount ( arr , n ) : inv_count = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : inv_count += 1 return inv_count
def MinOperation ( a , n , k ) : result = 0 for i in range ( n ) : if ( a [ i ] != 1 and a [ i ] > k ) : result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) else : result = result + k - a [ i ] return result
def minCost ( coin , n , k ) : coin . sort ( ) coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) ans = 0 for i in range ( coins_needed - 1 + 1 ) : ans += coin [ i ] return ans
def sumOfLargePrimeFactor ( n ) : prime = [ 0 ] * ( n + 1 ) sum = 0 max = int ( n / 2 ) for p in range ( 2 , max + 1 ) : if prime [ p ] == 0 : for i in range ( p * 2 , n + 1 , p ) : prime [ i ] = p for p in range ( 2 , n + 1 ) : if prime [ p ] : sum += prime [ p ] else : sum += p return sum
def minJumps ( arr , n ) : jumps = [ 0 for i in range ( n ) ] if ( n == 0 ) or ( arr [ 0 ] == 0 ) : return float ( 'inf' ) jumps [ 0 ] = 0 for i in range ( 1 , n ) : jumps [ i ] = float ( 'inf' ) for j in range ( i ) : if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) : jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) break return jumps [ n - 1 ]
def addOne ( x ) : m = 1 while ( x & m ) : x = x ^ m m <<= 1 x = x ^ m return x
def repeat ( s , n ) : s1 = s for i in range ( 1 , n ) : s += s1 return s
def countRotations ( n ) : l = len ( n ) if ( l == 1 ) : oneDigit = ( int ) ( n [ 0 ] ) if ( oneDigit % 4 == 0 ) : return 1 return 0 count = 0 for i in range ( 0 , l - 1 ) : twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 return count
def findWays ( f , d , s ) : mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] mem [ 0 ] [ 0 ] = 1 for i in range ( 1 , d + 1 ) : for j in range ( 1 , s + 1 ) : mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] if j - f - 1 >= 0 : mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] return mem [ d ] [ s ]
def findTrailingZeros ( n ) : count = 0 i = 5 while ( n / i >= 1 ) : count += int ( n / i ) i *= 5 return int ( count )
def binarySearch ( arr , l , r , x ) : if ( r >= l ) : mid = int ( l + ( r - l ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > l and arr [ mid - 1 ] == x ) : return ( mid - 1 ) if ( mid < r and arr [ mid + 1 ] == x ) : return ( mid + 1 ) if ( arr [ mid ] > x ) : return binarySearch ( arr , l , mid - 2 , x ) return binarySearch ( arr , mid + 2 , r , x ) return - 1
def search ( mat , n , x ) : i = 0 j = n - 1 while ( i < n and j >= 0 ) : if ( mat [ i ] [ j ] == x ) : print ( "nFoundat" , i , "," , j ) return 1 if ( mat [ i ] [ j ] > x ) : j -= 1 else : i += 1 print ( "Elementnotfound" ) return 0
def recaman ( n ) : arr = [ 0 ] * n arr [ 0 ] = 0 print ( arr [ 0 ] , end = "," ) for i in range ( 1 , n ) : curr = arr [ i - 1 ] - i for j in range ( 0 , i ) : if ( ( arr [ j ] == curr ) or curr < 0 ) : curr = arr [ i - 1 ] + i break arr [ i ] = curr print ( arr [ i ] , end = "," )
def checkForSorting ( arr , n ) : for i in range ( 0 , n - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : if ( arr [ i ] - arr [ i + 1 ] == 1 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] else : return False return True
def firstNonRepeating ( arr , n ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 for i in range ( n ) : if mp [ arr [ i ] ] == 1 : return arr [ i ] return - 1
def subset ( ar , n ) : res = 0 ar . sort ( ) for i in range ( 0 , n ) : count = 1 for i in range ( n - 1 ) : if ar [ i ] == ar [ i + 1 ] : count += 1 else : break res = max ( res , count ) return res
def printSquares ( n ) : square = 0 ; prev_x = 0 ; for x in range ( 0 , n ) : square = ( square + x + prev_x ) print ( square , end = "" ) prev_x = x
def countPairs ( str1 ) : result = 0 ; n = len ( str1 ) for i in range ( 0 , n ) : for j in range ( 1 , MAX_CHAR + 1 ) : if ( ( i + j ) < n ) : if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : result += 1 ; return result
def subsequence ( s , t , n , k ) : last = 0 cnt = 0 new_last = 0 size = 0 string = 'zyxwvutsrqponmlkjihgfedcba' for ch in string : cnt = 0 for i in range ( last , n ) : if s [ i ] == ch : cnt += 1 if cnt >= k : for i in range ( last , n ) : if s [ i ] == ch : t [ size ] = ch new_last = i size += 1 last = new_last
def fib ( n , a = 0 , b = 1 ) : if n == 0 : return a if n == 1 : return b return fib ( n - 1 , b , a + b ) ;
def squareRootExists ( n , p ) : n = n % p for x in range ( 2 , p , 1 ) : if ( ( x * x ) % p == n ) : return True return False
def bitonicGenerator ( arr , n ) : i = 1 j = n - 1 if ( j % 2 != 0 ) : j = j - 1 while ( i < j ) : arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ] i = i + 2 j = j - 2 arr_f = [ ] arr_s = [ ] for i in range ( int ( ( n + 1 ) / 2 ) ) : arr_f . append ( arr [ i ] ) i = int ( ( n + 1 ) / 2 ) while ( i < n ) : arr_s . append ( arr [ i ] ) i = i + 1 arr_f . sort ( ) arr_s . sort ( reverse = True ) for i in arr_s : arr_f . append ( i ) return arr_f
def printIntersection ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and j < n : if arr1 [ i ] < arr2 [ j ] : i += 1 elif arr2 [ j ] < arr1 [ i ] : j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1
def countkDist ( str1 , k ) : n = len ( str1 ) res = 0 cnt = [ 0 ] * 27 for i in range ( 0 , n ) : dist_count = 0 cnt = [ 0 ] * 27 for j in range ( i , n ) : if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : dist_count += 1 cnt [ ord ( str1 [ j ] ) - 97 ] += 1 if ( dist_count == k ) : res += 1 if ( dist_count > k ) : break return res
def search ( mat , fromRow , toRow , fromCol , toCol , key ) : i = fromRow + ( toRow - fromRow ) // 2 j = fromCol + ( toCol - fromCol ) // 2 if ( mat [ i ] [ j ] == key ) : print ( "Found" , key , "at" , i , "" , j ) else : if ( i != toRow or j != fromCol ) : search ( mat , fromRow , i , j , toCol , key ) if ( fromRow == toRow and fromCol + 1 == toCol ) : if ( mat [ fromRow ] [ toCol ] == key ) : print ( "Found" , key , "at" , fromRow , "" , toCol ) if ( mat [ i ] [ j ] < key ) : if ( i + 1 <= toRow ) : search ( mat , i + 1 , toRow , fromCol , toCol , key ) else : if ( j - 1 >= fromCol ) : search ( mat , fromRow , toRow , fromCol , j - 1 , key )
def numberofways ( A , B , N , M ) : pos = [ [ ] for _ in range ( MAX ) ] for i in range ( M ) : pos [ ord ( B [ i ] ) ] . append ( i + 1 ) dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( 1 , N + 1 ) : for j in range ( 1 , M + 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 else : dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) LCS = dpl [ N ] [ M ] dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( N , 0 , - 1 ) : for j in range ( M , 0 , - 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 else : dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ans = 0 for i in range ( N + 1 ) : for j in range ( MAX ) : for x in pos [ j ] : if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : ans += 1 break return ans
def parabola ( a , b , c ) : print ( "Vertex:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) , ")" , sep = "" ) print ( "Focus:(" , ( - b / ( 2 * a ) ) , "," , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , ")" , sep = "" ) print ( "Directrix:y=" , c - ( ( b * b ) + 1 ) * 4 * a , sep = "" )
def check ( st ) : n = len ( st ) if ( n == 0 ) : return False if ( n == 1 ) : return ( ( st [ 0 ] - '0' ) % 4 == 0 ) last = ( int ) ( st [ n - 1 ] ) second_last = ( int ) ( st [ n - 2 ] ) return ( ( second_last * 10 + last ) % 4 == 0 )
def subArraySum ( arr , n , Sum ) : Map = { } curr_sum = 0 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if curr_sum == Sum : print ( "Sumfoundbetweenindexes0to" , i ) return if ( curr_sum - Sum ) in Map : print ( "Sumfoundbetweenindexes" , \ Map [ curr_sum - Sum ] + 1 , "to" , i ) return Map [ curr_sum ] = i print ( "Nosubarraywithgivensumexists" )
def horner ( poly , n , x ) : result = poly [ 0 ] for i in range ( 1 , n ) : result = result * x + poly [ i ] return result
def countWays ( n ) : A = [ 0 ] * ( n + 1 ) B = [ 0 ] * ( n + 1 ) A [ 0 ] = 1 A [ 1 ] = 0 B [ 0 ] = 0 B [ 1 ] = 1 for i in range ( 2 , n + 1 ) : A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] B [ i ] = A [ i - 1 ] + B [ i - 2 ] return A [ n ]
def breakSum ( n ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) return dp [ n ]
def kthSmallest ( arr , n , k ) : arr . sort ( ) return arr [ k - 1 ]
def sortUsingHash ( a , n ) : Max = max ( a ) Hash = [ 0 ] * ( Max + 1 ) for i in range ( 0 , n ) : Hash [ a [ i ] ] += 1 for i in range ( 0 , Max + 1 ) : if Hash [ i ] != 0 : for j in range ( 0 , Hash [ i ] ) : print ( i , end = "" )
def findRepeatFirst ( s ) : p = - 1 hash = [ 0 for i in range ( MAX_CHAR ) ] pos = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( len ( s ) ) : k = ord ( s [ i ] ) if ( hash [ k ] == 0 ) : hash [ k ] += 1 pos [ k ] = i elif ( hash [ k ] == 1 ) : hash [ k ] += 1 for i in range ( MAX_CHAR ) : if ( hash [ i ] == 2 ) : if ( p == - 1 ) : p = pos [ i ] elif ( p > pos [ i ] ) : p = pos [ i ] return p
def sequence ( n ) : f = array . array ( 'i' , [ 0 , 1 , 1 ] ) for i in range ( 3 , n + 1 ) : r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] f . append ( r ) ; return r
def PositionRightmostSetbit ( n ) : position = 1 m = 1 while ( not ( n & m ) ) : m = m << 1 position += 1 return position
def isPrime ( p ) : checkNumber = 2 ** p - 1 nextval = 4 % checkNumber for i in range ( 1 , p - 1 ) : nextval = ( nextval * nextval - 2 ) % checkNumber if ( nextval == 0 ) : return True else : return False
def countSolutions ( n ) : res = 0 x = 0 while ( x * x < n ) : y = 0 while ( x * x + y * y < n ) : res = res + 1 y = y + 1 x = x + 1 return res
def evenFibSum ( limit ) : if ( limit < 2 ) : return 0 ef1 = 0 ef2 = 2 sm = ef1 + ef2 while ( ef2 <= limit ) : ef3 = 4 * ef2 + ef1 if ( ef3 > limit ) : break ef1 = ef2 ef2 = ef3 sm = sm + ef2 return sm
def solve ( a , b , n ) : s = 0 for i in range ( 0 , n ) : s += a [ i ] + b [ i ] if n == 1 : return a [ 0 ] + b [ 0 ] if s % n != 0 : return - 1 x = s // n for i in range ( 0 , n ) : if a [ i ] > x : return - 1 if i > 0 : a [ i ] += b [ i - 1 ] b [ i - 1 ] = 0 if a [ i ] == x : continue y = a [ i ] + b [ i ] if i + 1 < n : y += b [ i + 1 ] if y == x : a [ i ] = y b [ i ] = 0 if i + 1 < n : b [ i + 1 ] = 0 continue if a [ i ] + b [ i ] == x : a [ i ] += b [ i ] b [ i ] = 0 continue if i + 1 < n and a [ i ] + b [ i + 1 ] == x : a [ i ] += b [ i + 1 ] b [ i + 1 ] = 0 continue return - 1 for i in range ( 0 , n ) : if b [ i ] != 0 : return - 1 return x
def findHeight ( parent , n ) : res = 0 for i in range ( n ) : p = i current = 1 while ( parent [ p ] != - 1 ) : current += 1 p = parent [ p ] res = max ( res , current ) return res
def center ( x1 , x2 , y1 , y2 ) : print ( int ( ( x1 + x2 ) / 2 ) , end = "" ) print ( "," , int ( ( y1 + y2 ) / 2 ) )
def unitDigitXRaisedY ( x , y ) : res = 1 for i in range ( y ) : res = ( res * x ) % 10 return res
def MatrixChainOrder ( p , n ) : m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] for i in range ( 1 , n ) : m [ i ] [ i ] = 0 for L in range ( 2 , n ) : for i in range ( 1 , n - L + 1 ) : j = i + L - 1 m [ i ] [ j ] = sys . maxint for k in range ( i , j ) : q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] if q < m [ i ] [ j ] : m [ i ] [ j ] = q return m [ 1 ] [ n - 1 ]
def survival ( S , N , M ) : if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : print ( "No" ) else : days = ( M * S ) / N if ( ( ( M * S ) % N ) != 0 ) : days += 1 print ( "Yes" ) , print ( days )
def countFact ( low , high ) : fact = 1 x = 1 while ( fact < low ) : fact = fact * x x += 1 res = 0 while ( fact <= high ) : res += 1 fact = fact * x x += 1 return res
def areElementsContiguous ( arr ) : us = set ( ) for i in arr : us . add ( i ) count = 1 curr_ele = arr [ 0 ] - 1 while curr_ele in us : count += 1 curr_ele -= 1 curr_ele = arr [ 0 ] + 1 while curr_ele in us : count += 1 curr_ele += 1 return ( count == len ( us ) )
def printDistinct ( arr , n ) : for i in range ( 0 , n ) : d = 0 for j in range ( 0 , i ) : if ( arr [ i ] == arr [ j ] ) : d = 1 break if ( d == 0 ) : print ( arr [ i ] )
def ifPossible ( arr , n ) : cp = [ 0 ] * n cp = arr cp . sort ( ) for i in range ( 0 , n ) : if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : return False return True
def smallest ( x , y , z ) : c = 0 while ( x and y and z ) : x = x - 1 y = y - 1 z = z - 1 c = c + 1 return c
def countSetBits ( n ) : if ( n == 0 ) : return 0 else : return 1 + countSetBits ( n & ( n - 1 ) )
def sumofFactors ( n ) : res = 1 for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : curr_sum = 1 curr_term = 1 while n % i == 0 : n = n / i curr_term = curr_term * i curr_sum += curr_term res = res * curr_sum if n > 2 : res = res * ( 1 + n ) return res
def findLength ( string ) : n = len ( string ) maxlen = 0 Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( 0 , n ) : Sum [ i ] [ i ] = int ( string [ i ] ) for length in range ( 2 , n + 1 ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 k = length // 2 Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : maxlen = length return maxlen
def prevPermutation ( str ) : n = len ( str ) - 1 i = n while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : i -= 1 if ( i <= 0 ) : return False j = i - 1 while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : j += 1 str = list ( str ) temp = str [ i - 1 ] str [ i - 1 ] = str [ j ] str [ j ] = temp str = '' . join ( str ) str [ : : - 1 ] return True , str
def minCost ( cost ) : dist = [ 0 for i in range ( N ) ] for i in range ( N ) : dist [ i ] = INF dist [ 0 ] = 0 for i in range ( N ) : for j in range ( i + 1 , N ) : if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]
def countEndless ( input_mat , n ) : row = np . zeros ( ( n , n ) ) col = np . zeros ( ( n , n ) ) for j in range ( n ) : isEndless = 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 col [ i ] [ j ] = isEndless for i in range ( n ) : isEndless = 1 for j in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 row [ i ] [ j ] = isEndless ans = 0 for i in range ( n ) : for j in range ( 1 , n ) : if ( row [ i ] [ j ] and col [ i ] [ j ] ) : ans += 1 return ans
def countSubstrs ( str , i , j , n ) : if ( n == 1 ) : return 1 if ( n <= 0 ) : return 0 res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) if ( str [ i ] == str [ j ] ) : res += 1 return res
def findLongestRepeatingSubSeq ( str ) : n = len ( str ) dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) return dp [ n ] [ n ]
def pushZerosToEnd ( arr , n ) : count = 0 for i in range ( n ) : if arr [ i ] != 0 : arr [ count ] = arr [ i ] count += 1 while count < n : arr [ count ] = 0 count += 1
def maxSubsequenceSubstring ( x , y , n , m ) : dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if ( x [ j - 1 ] == y [ i - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ans = 0 for i in range ( 1 , m + 1 ) : ans = max ( ans , dp [ i ] [ n ] ) return ans
def intersection ( n ) : return n * ( n - 1 )
def singleNumber ( nums ) : return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2
def maxProduct ( arr , n ) : if ( n < 2 ) : print ( "Nopairsexists" ) return if ( n == 2 ) : print ( arr [ 0 ] , "" , arr [ 1 ] ) return posa = 0 posb = 0 nega = 0 negb = 0 for i in range ( n ) : if ( arr [ i ] > posa ) : posb = posa posa = arr [ i ] elif ( arr [ i ] > posb ) : posb = arr [ i ] if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : negb = nega nega = arr [ i ] elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : negb = arr [ i ] if ( nega * negb > posa * posb ) : print ( "Maxproductpairis{" , nega , "," , negb , "}" ) else : print ( "Maxproductpairis{" , posa , "," , posb , "}" )
def findCountOfSolutions ( n , p ) : ans = 0 for x in range ( 1 , p ) : if ( ( x * x ) % p == 1 ) : last = x + p * ( n / p ) if ( last > n ) : last -= p ans += ( ( last - x ) / p + 1 ) return int ( ans )
def canFormPalindrome ( strr ) : listt = [ ] for i in range ( len ( strr ) ) : if ( strr [ i ] in listt ) : listt . remove ( strr [ i ] ) else : listt . append ( strr [ i ] ) if ( len ( strr ) % 2 == 0 and len ( listt ) == 0 or \ ( len ( strr ) % 2 == 1 and len ( listt ) == 1 ) ) : return True else : return False
def printHosoya ( n ) : dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 for i in range ( 2 , n ) : for j in range ( n ) : if ( i > j ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) for i in range ( n ) : for j in range ( i + 1 ) : print ( dp [ i ] [ j ] , end = '' ) print ( )
def bonacciseries ( n , m ) : a = [ 0 ] * m a [ n - 1 ] = 1 for i in range ( n , m ) : for j in range ( i - n , i ) : a [ i ] = a [ i ] + a [ j ] for i in range ( 0 , m ) : print ( a [ i ] , end = "" )
def findLongestRepeatingSubSeq ( X , m , n ) : if ( dp [ m ] [ n ] != - 1 ) : return dp [ m ] [ n ] if ( m == 0 or n == 0 ) : dp [ m ] [ n ] = 0 return dp [ m ] [ n ] if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 return dp [ m ] [ n ] dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) return dp [ m ] [ n ]
def getSum ( n ) : sum = 0 while ( n > 0 ) : sum += int ( n % 10 ) n = int ( n / 10 ) return sum
def find ( arr ) : n = len ( arr ) i = 0 j = n - 1 res = - 1 while i < n and j >= 0 : if arr [ i ] [ j ] == 0 : while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : j -= 1 if j == - 1 : res = i break else : i += 1 else : while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : i += 1 if i == n : res = j break else : j -= 1 if res == - 1 : return res for i in range ( 0 , n ) : if res != i and arr [ i ] [ res ] != 1 : return - 1 for j in range ( 0 , j ) : if res != j and arr [ res ] [ j ] != 0 : return - 1 ; return res ;
def findoptimal ( N ) : if ( N <= 6 ) : return N screen = [ 0 ] * N for n in range ( 1 , 7 ) : screen [ n - 1 ] = n for n in range ( 7 , N + 1 ) : screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) return screen [ N - 1 ]
def maxvolume ( s ) : maxvalue = 0 i = 1 for i in range ( s - 1 ) : j = 1 for j in range ( s ) : k = s - i - j maxvalue = max ( maxvalue , i * j * k ) return maxvalue
def calculateSum ( n ) : if ( n <= 0 ) : return 0 fibo = [ 0 ] * ( n + 1 ) fibo [ 1 ] = 1 sm = fibo [ 0 ] + fibo [ 1 ] for i in range ( 2 , n + 1 ) : fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] sm = sm + fibo [ i ] return sm
def printSuperSeq ( a , b ) : m = len ( a ) n = len ( b ) dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( 0 , m + 1 ) : for j in range ( 0 , n + 1 ) : if not i : dp [ i ] [ j ] = j elif not j : dp [ i ] [ j ] = i elif ( a [ i - 1 ] == b [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] res = [ "" ] * ( index ) i = m j = n while ( i > 0 and j > 0 ) : if ( a [ i - 1 ] == b [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 j -= 1 index -= 1 elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 else : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 while ( i > 0 ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 while ( j > 0 ) : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 print ( "" . join ( res ) )
def largestSubset ( a , n ) : a . sort ( ) dp = [ 0 for i in range ( n ) ] dp [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : mxm = 0 for j in range ( i + 1 , n ) : if a [ j ] % a [ i ] == 0 : mxm = max ( mxm , dp [ j ] ) dp [ i ] = 1 + mxm return max ( dp )
def count ( n ) : if ( n < 4 ) : return - 1 rem = n % 4 if ( rem == 0 ) : return n // 4 if ( rem == 1 ) : if ( n < 9 ) : return - 1 return ( n - 9 ) // 4 + 1 if ( rem == 2 ) : return ( n - 6 ) // 4 + 1 if ( rem == 3 ) : if ( n < 15 ) : return - 1 return ( n - 15 ) // 4 + 2
def findRandomIndexOfMax ( arr , n ) : mp = dict ( ) for i in range ( n ) : if ( arr [ i ] in mp ) : mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 else : mp [ arr [ i ] ] = 1 max_element = - 323567 max_so_far = - 323567 for p in mp : if ( mp [ p ] > max_so_far ) : max_so_far = mp [ p ] max_element = p r = int ( ( ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) ) i = 0 count = 0 while ( i < n ) : if ( arr [ i ] == max_element ) : count = count + 1 if ( count == r ) : print ( "Elementwithmaximumfrequencypresentatindex" , i ) break i = i + 1
def countDer ( n ) : der = [ 0 for i in range ( n + 1 ) ] der [ 0 ] = 1 der [ 1 ] = 0 der [ 2 ] = 1 for i in range ( 3 , n + 1 ) : der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) return der [ n ]
def middleOfThree ( a , b , c ) : if a > b : if ( b > c ) : return b elif ( a > c ) : return c else : return a else : if ( a > c ) : return a elif ( b > c ) : return c else : return b
def findIndex ( n ) : if ( n <= 1 ) : return n a = 0 b = 1 c = 1 res = 1 while ( c < n ) : c = a + b res = res + 1 a = b b = c return res
def numberOfTriangles ( n ) : answer = [ None ] * ( n + 1 ) answer [ 0 ] = 1 i = 1 while i <= n : answer [ i ] = answer [ i - 1 ] * 3 + 2 i = i + 1 return answer [ n ]
def checkSentence ( string ) : length = len ( string ) if string [ 0 ] < 'A' or string [ 0 ] > 'Z' : return False if string [ length - 1 ] != '.' : return False prev_state = 0 curr_state = 0 index = 1 while ( string [ index ] ) : if string [ index ] >= 'A' and string [ index ] <= 'Z' : curr_state = 0 elif string [ index ] == '' : curr_state = 1 elif string [ index ] >= 'a' and string [ index ] <= 'z' : curr_state = 2 elif string [ index ] == '.' : curr_state = 3 if prev_state == curr_state and curr_state != 2 : return False if prev_state == 2 and curr_state == 0 : return False if curr_state == 3 and prev_state != 1 : return True index += 1 prev_state = curr_state return False
def findMaximum ( arr , low , high ) : if low == high : return arr [ low ] if high == low + 1 and arr [ low ] >= arr [ high ] : return arr [ low ] if high == low + 1 and arr [ low ] < arr [ high ] : return arr [ high ] mid = ( low + high ) // 2 if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : return arr [ mid ] if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : return findMaximum ( arr , low , mid - 1 ) else : return findMaximum ( arr , mid + 1 , high )
def areaOctagon ( side ) : return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side )
def middlesum ( mat , n ) : row_sum = 0 col_sum = 0 for i in range ( n ) : row_sum += mat [ n // 2 ] [ i ] print ( "Sumofmiddlerow=" , row_sum ) for i in range ( n ) : col_sum += mat [ i ] [ n // 2 ] print ( "Sumofmiddlecolumn=" , col_sum )
def maximumDifferenceSum ( arr , N ) : dp = [ [ 0 , 0 ] for i in range ( N ) ] for i in range ( N ) : dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 for i in range ( N - 1 ) : dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )
def carveCross ( str ) : n = len ( str ) if ( n % 2 == 0 ) : print ( "Notpossible.Pleaseenter" , "oddlengthstring.\n" ) else : arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] m = n // 2 for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = 'X' for i in range ( n ) : arr [ i ] [ m ] = str [ i ] for i in range ( n ) : arr [ m ] [ i ] = str [ i ] for i in range ( n ) : for j in range ( n ) : print ( arr [ i ] [ j ] , end = "" ) print ( )
def maxHamming ( arr , n ) : brr = [ 0 ] * ( 2 * n + 1 ) for i in range ( n ) : brr [ i ] = arr [ i ] for i in range ( n ) : brr [ n + i ] = arr [ i ] maxHam = 0 for i in range ( 1 , n ) : currHam = 0 k = 0 for j in range ( i , i + n ) : if brr [ j ] != arr [ k ] : currHam += 1 k = k + 1 if currHam == n : return n maxHam = max ( maxHam , currHam ) return maxHam
def printRect ( X , Y , n ) : Xmax = max ( X ) Xmin = min ( X ) Ymax = max ( Y ) Ymin = min ( Y ) print ( "{" , Xmin , "," , Ymin , "}" , sep = "" ) print ( "{" , Xmin , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymax , "}" , sep = "" ) print ( "{" , Xmax , "," , Ymin , "}" , sep = "" )
def encrypt ( text , s ) : result = "" for i in range ( len ( text ) ) : char = text [ i ] if ( char . isupper ( ) ) : result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) else : result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) return result
def rearrange ( arr , n ) : i = - 1 for j in range ( n ) : if ( arr [ j ] < 0 ) : i += 1 arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] pos , neg = i + 1 , 0 while ( pos < n and neg < pos and arr [ neg ] < 0 ) : arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] pos += 1 neg += 2
def maxProfit ( prices , n , k ) : profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , k + 1 ) : max_so_far = 0 for l in range ( i ) : max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) return profit [ n - 1 ] [ k ]
def strToBinary ( s ) : bin_conv = [ ] for c in s : ascii_val = ord ( c ) binary_val = bin ( ascii_val ) bin_conv . append ( binary_val [ 2 : ] ) return ( '' . join ( bin_conv ) )
def simplify ( Str ) : Len = len ( Str ) res = [ None ] * Len index = 0 i = 0 s = [ ] s . append ( 0 ) while ( i < Len ) : if ( Str [ i ] == '+' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '-' index += 1 if ( s [ - 1 ] == 0 ) : res [ index ] = '+' index += 1 elif ( Str [ i ] == '-' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '+' index += 1 elif ( s [ - 1 ] == 0 ) : res [ index ] = '-' index += 1 elif ( Str [ i ] == '(' and i > 0 ) : if ( Str [ i - 1 ] == '-' ) : x = 0 if ( s [ - 1 ] == 1 ) else 1 s . append ( x ) elif ( Str [ i - 1 ] == '+' ) : s . append ( s [ - 1 ] ) elif ( Str [ i ] == ')' ) : s . pop ( ) else : res [ index ] = Str [ i ] index += 1 i += 1 return res
def isConvertible ( str1 , str2 , k ) : if ( ( len ( str1 ) + len ( str2 ) ) < k ) : return True commonLength = 0 for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : if ( str1 [ i ] == str2 [ i ] ) : commonLength += 1 else : break if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : return True return False
def lenghtOfLongestAP ( set , n ) : if ( n <= 2 ) : return n L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] llap = 2 for i in range ( n ) : L [ i ] [ n - 1 ] = 2 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while ( i >= 0 and k <= n - 1 ) : if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : k += 1 elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : L [ i ] [ j ] = 2 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) i -= 1 k += 1 while ( i >= 0 ) : L [ i ] [ j ] = 2 i -= 1 return llap
def findSum ( n ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = abs ( i - j ) sum = 0 for i in range ( n ) : for j in range ( n ) : sum += arr [ i ] [ j ] return sum
def prefixSum2D ( a ) : global C , R psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] for i in range ( 1 , C ) : psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) for i in range ( 0 , R ) : psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) for i in range ( 1 , R ) : for j in range ( 1 , C ) : psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) for i in range ( 0 , R ) : for j in range ( 0 , C ) : print ( psa [ i ] [ j ] , end = "" ) print ( )
def numOfIncSubseqOfSizeK ( arr , n , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ] for i in range ( n ) : dp [ 0 ] [ i ] = 1 for l in range ( 1 , k ) : for i in range ( l , n ) : dp [ l ] [ i ] = 0 for j in range ( l - 1 , i ) : if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ l - 1 ] [ j ] Sum = 0 for i in range ( k - 1 , n ) : Sum += dp [ k - 1 ] [ i ] return Sum
def isPossible ( n , index , modulo , M , arr , dp ) : modulo = ( ( modulo % M ) + M ) % M if ( index == n ) : if ( modulo == 0 ) : return 1 return 0 if ( dp [ index ] [ modulo ] != - 1 ) : return dp [ index ] [ modulo ] placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) res = bool ( placeAdd or placeMinus ) dp [ index ] [ modulo ] = res return res
def findnumberofTriangles ( arr ) : n = len ( arr ) arr . sort ( ) count = 0 for i in range ( 0 , n - 2 ) : k = i + 2 for j in range ( i + 1 , n ) : while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : k += 1 if ( k > j ) : count += k - j - 1 return count
def countNonDecreasing ( n ) : N = 10 count = 1 for i in range ( 1 , n + 1 ) : count = int ( count * ( N + i - 1 ) ) count = int ( count / i ) return count
def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( "InvalidInput" ) return first = arr [ 0 ] for i in range ( 1 , arr_size ) : if ( arr [ i ] > first ) : first = arr [ i ] second = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > second and arr [ i ] < first ) : second = arr [ i ] third = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > third and arr [ i ] < second ) : third = arr [ i ] print ( "TheThirdLargest" , "elementis" , third )
def minValue ( A , B , n ) : sorted ( A ) sorted ( B ) result = 0 for i in range ( n ) : result += ( A [ i ] * B [ n - i - 1 ] ) return result
def pythagorean_quadruple ( a , b , c , d ) : sum = a * a + b * b + c * c if ( d * d == sum ) : return True else : return False
def KnapSack ( val , wt , n , W ) : mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ] i = 0 while i < n : j = 0 if i % 2 == 0 : while j < W : j += 1 if wt [ i ] <= j : mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) else : mat [ 1 ] [ j ] = mat [ 0 ] [ j ] else : while j < W : j += 1 if wt [ i ] <= j : mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) else : mat [ 0 ] [ j ] = mat [ 1 ] [ j ] i += 1 if n % 2 == 0 : return mat [ 0 ] [ W ] else : return mat [ 1 ] [ W ]
def minCost ( cost , m , n ) : tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , m + 1 ) : tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , n + 1 ) : tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return tc [ m ] [ n ]
def swapDiagonal ( matrix ) : for i in range ( N ) : matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \ matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ]
def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i == j ) : d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) : d2 += arr [ i ] [ j ] return abs ( d1 - d2 )
def assignValue ( a , b , x ) : arr = [ a , b ] return ( arr [ x ] )
def findMinDiff ( arr , n , m ) : if ( m == 0 or n == 0 ) : return 0 arr . sort ( ) if ( n < m ) : return - 1 min_diff = sys . maxsize first = 0 last = 0 i = 0 while ( i + m - 1 < n ) : diff = arr [ i + m - 1 ] - arr [ i ] if ( diff < min_diff ) : min_diff = diff first = i last = i + m - 1 i += 1 return ( arr [ last ] - arr [ first ] )
def canMakeAllSame ( str ) : zeros = 0 ones = 0 for i in range ( 0 , len ( str ) ) : ch = str [ i ] if ( ch == '0' ) : zeros = zeros + 1 else : ones = ones + 1 return ( zeros == 1 or ones == 1 )
def maxcoefficientvalue ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n + 1 ) : for j in range ( min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) maxvalue = 0 for i in range ( n + 1 ) : maxvalue = max ( maxvalue , C [ n ] [ i ] ) return maxvalue
def binomialCoeffSum ( n ) : return ( 1 << n )
def getMinSteps ( n ) : table = [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) : table [ i ] = n - i for i in range ( n , 0 , - 1 ) : if ( not ( i % 2 ) ) : table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) if ( not ( i % 3 ) ) : table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) return table [ 1 ]
def printDistinct ( Str ) : n = len ( Str ) count = [ 0 for i in range ( MAX_CHAR ) ] index = [ n for i in range ( MAX_CHAR ) ] for i in range ( n ) : x = ord ( Str [ i ] ) count [ x ] += 1 if ( count [ x ] == 1 and x != '' ) : index [ x ] = i if ( count [ x ] == 2 ) : index [ x ] = n index = sorted ( index ) for i in range ( MAX_CHAR ) : if index [ i ] == n : break print ( Str [ index [ i ] ] , end = "" )
def sumOfSeries ( n ) : return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) )
def nextPowerOf2 ( n ) : p = 1 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( p < n ) : p <<= 1 return p
def printPairs ( arr , n ) : v = [ ] for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : v . append ( abs ( arr [ i ] ) ) if ( len ( v ) == 0 ) : return ; v . sort ( ) for i in range ( len ( v ) ) : print ( - v [ i ] , "" , v [ i ] , end = "" )
def findElements ( arr , n ) : for i in range ( n ) : count = 0 for j in range ( 0 , n ) : if arr [ j ] > arr [ i ] : count = count + 1 if count >= 2 : print ( arr [ i ] , end = "" )
def countRotationsDivBy8 ( n ) : l = len ( n ) count = 0 if ( l == 1 ) : oneDigit = int ( n [ 0 ] ) if ( oneDigit % 8 == 0 ) : return 1 return 0 if ( l == 2 ) : first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) if ( first % 8 == 0 ) : count += 1 if ( second % 8 == 0 ) : count += 1 return count threeDigit = 0 for i in range ( 0 , ( l - 2 ) ) : threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) if ( threeDigit % 8 == 0 ) : count += 1 return count
def circumferenceparallelogram ( a , b ) : return ( ( 2 * a ) + ( 2 * b ) )
def countWays ( n , k ) : total = k mod = 1000000007 same , diff = 0 , k for i in range ( 2 , n + 1 ) : same = diff diff = total * ( k - 1 ) diff = diff % mod total = ( same + diff ) % mod return total
def printPascal ( n : int ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for line in range ( 0 , n ) : for i in range ( 0 , line + 1 ) : if ( i is 0 or i is line ) : arr [ line ] [ i ] = 1 print ( arr [ line ] [ i ] , end = "" ) else : arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) print ( arr [ line ] [ i ] , end = "" ) print ( "\n" , end = "" )
def findWinner ( x , y , n ) : dp = [ 0 for i in range ( n + 1 ) ] dp [ 0 ] = False dp [ 1 ] = True for i in range ( 2 , n + 1 ) : if ( i - 1 >= 0 and not dp [ i - 1 ] ) : dp [ i ] = True elif ( i - x >= 0 and not dp [ i - x ] ) : dp [ i ] = True elif ( i - y >= 0 and not dp [ i - y ] ) : dp [ i ] = True else : dp [ i ] = False return dp [ n ]
def cosXSertiesSum ( x , n ) : x = x * ( PI / 180.0 ) res = 1 sign = 1 fact = 1 pow = 1 for i in range ( 1 , 5 ) : sign = sign * - 1 fact = fact * ( 2 * i - 1 ) * ( 2 * i ) pow = pow * x * x res = res + sign * pow / fact return res
def LeibnizHarmonicTriangle ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , i + 1 ) : print ( "1/" , end = "" ) print ( i * C [ i - 1 ] [ j - 1 ] , end = "" ) print ( )
def maxSumBitonicSubArr ( arr , n ) : msis = [ None ] * n msds = [ None ] * n max_sum = 0 msis [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ i - 1 ] ) : msis [ i ] = msis [ i - 1 ] + arr [ i ] else : msis [ i ] = arr [ i ] msds [ n - 1 ] = arr [ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] > arr [ i + 1 ] ) : msds [ i ] = msds [ i + 1 ] + arr [ i ] else : msds [ i ] = arr [ i ] for i in range ( n ) : if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) return max_sum
def findRepeatingElement ( arr , low , high ) : if low > high : return - 1 mid = ( low + high ) / 2 if ( arr [ mid ] != mid + 1 ) : if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : return mid return findRepeatingElement ( arr , low , mid - 1 ) return findRepeatingElement ( arr , mid + 1 , high )
def sortInWave ( arr , n ) : for i in range ( 0 , n , 2 ) : if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) : arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]
def printSmall ( arr , n , k ) : for i in range ( k , n ) : max_var = arr [ k - 1 ] pos = k - 1 for j in range ( k - 2 , - 1 , - 1 ) : if ( arr [ j ] > max_var ) : max_var = arr [ j ] pos = j if ( max_var > arr [ i ] ) : j = pos while ( j < k - 1 ) : arr [ j ] = arr [ j + 1 ] j += 1 arr [ k - 1 ] = arr [ i ] for i in range ( 0 , k ) : print ( arr [ i ] , end = "" )
def distancesum ( x , y , n ) : sum = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) return sum
def findMinDiff ( arr , n ) : diff = 10 ** 20 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : if abs ( arr [ i ] - arr [ j ] ) < diff : diff = abs ( arr [ i ] - arr [ j ] ) return diff
def count_of_ways ( n ) : count = 0 count = ( n + 1 ) * ( n + 2 ) // 2 return count
def maxvolume ( s ) : length = int ( s / 3 ) s -= length breadth = s / 2 height = s - breadth return int ( length * breadth * height )
def sumDigits ( no ) : return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) )
def findMaxGCD ( arr , n ) : high = 0 for i in range ( 0 , n ) : high = max ( high , arr [ i ] ) count = [ 0 ] * ( high + 1 ) for i in range ( 0 , n ) : count [ arr [ i ] ] += 1 counter = 0 for i in range ( high , 0 , - 1 ) : j = i while ( j <= high ) : if ( count [ j ] > 0 ) : counter += count [ j ] j += i if ( counter == 2 ) : return i counter = 0
def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 for i in range ( n ) : for j in range ( m ) : if ( arr2 [ i ] == arr1 [ j ] ) : break if ( j == m ) : return 0 return 1
def maxArea ( a , b , c , d ) : semiperimeter = ( a + b + c + d ) / 2 return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )
def generate_derangement ( N ) : S = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : S [ i ] = i D = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 , 2 ) : if i == N : D [ N ] = S [ N - 1 ] D [ N - 1 ] = S [ N ] else : D [ i ] = i + 1 D [ i + 1 ] = i for i in range ( 1 , N + 1 ) : print ( D [ i ] , end = "" ) print ( )
def findString ( str , n , k ) : if ( k == 0 ) : print ( str ) return str2 = str p = 0 for i in range ( 0 , n , 1 ) : if ( str2 [ i ] != 'a' ) : str2 = str2 . replace ( str2 [ i ] , 'a' ) p += 1 if ( p == k ) : break if ( p < k ) : i = n - 1 while ( i >= 0 ) : if ( str [ i ] == 'a' ) : str2 = str2 . replace ( str2 [ i ] , 'b' ) p += 1 if ( p == k ) : break i -= 1 print ( str2 )
def zodiac_sign ( day , month ) : if month == 'december' : astro_sign = 'Sagittarius' if ( day < 22 ) else 'capricorn' elif month == 'january' : astro_sign = 'Capricorn' if ( day < 20 ) else 'aquarius' elif month == 'february' : astro_sign = 'Aquarius' if ( day < 19 ) else 'pisces' elif month == 'march' : astro_sign = 'Pisces' if ( day < 21 ) else 'aries' elif month == 'april' : astro_sign = 'Aries' if ( day < 20 ) else 'taurus' elif month == 'may' : astro_sign = 'Taurus' if ( day < 21 ) else 'gemini' elif month == 'june' : astro_sign = 'Gemini' if ( day < 21 ) else 'cancer' elif month == 'july' : astro_sign = 'Cancer' if ( day < 23 ) else 'leo' elif month == 'august' : astro_sign = 'Leo' if ( day < 23 ) else 'virgo' elif month == 'september' : astro_sign = 'Virgo' if ( day < 23 ) else 'libra' elif month == 'october' : astro_sign = 'Libra' if ( day < 23 ) else 'scorpio' elif month == 'november' : astro_sign = 'scorpio' if ( day < 22 ) else 'sagittarius' print ( astro_sign )
def isPalindrome ( string ) : l = 0 h = len ( string ) - 1 while h > l : l += 1 h -= 1 if string [ l - 1 ] != string [ h + 1 ] : return False return True
def countSubStr ( st , n ) : res = 0 for i in range ( 0 , n ) : if ( st [ i ] == '1' ) : for j in range ( i + 1 , n ) : if ( st [ j ] == '1' ) : res = res + 1 return res
def printArray ( a , n ) : for i in a : print ( i , end = "" ) print ( )
def findTriplets ( x ) : fact = [ ] factors = set ( ) for i in range ( 2 , int ( sqrt ( x ) ) ) : if ( x % i == 0 ) : fact . append ( i ) if ( x / i != i ) : fact . append ( x // i ) factors . add ( i ) factors . add ( x // i ) found = False k = len ( fact ) for i in range ( k ) : a = fact [ i ] for j in range ( k ) : b = fact [ j ] if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : print ( a , b , x // ( a * b ) ) found = True break if ( found ) : break if ( not found ) : print ( "-1" )
def russianPeasant ( a , b ) : res = 0 while ( b > 0 ) : if ( b & 1 ) : res = res + a a = a << 1 b = b >> 1 return res
def maxProduct ( arr , n ) : if ( n < 2 ) : print ( "Nopairsexists" ) return a = arr [ 0 ] b = arr [ 1 ] for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] * arr [ j ] > a * b ) : a = arr [ i ] b = arr [ j ] print ( "Maxproductpairis{" , a , "," , b , "}" , sep = "" )
def myCopy ( s1 , s2 , index ) : s2 [ index ] = s1 [ index ] if ( index == len ( s1 ) - 1 ) : return myCopy ( s1 , s2 , index + 1 )
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : maxSum = 0 arr . sort ( ) i = N - 1 while ( i >= 0 ) : if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i ] maxSum += arr [ i - 1 ] i -= 1 i -= 1 return maxSum
def countSetBits ( n ) : count = 0 while ( n ) : n &= ( n - 1 ) count += 1 return count
def returnMaxSum ( A , B , n ) : mp = set ( ) result = 0 curr_sum = curr_begin = 0 for i in range ( 0 , n ) : while A [ i ] in mp : mp . remove ( A [ curr_begin ] ) curr_sum -= B [ curr_begin ] curr_begin += 1 mp . add ( A [ i ] ) curr_sum += B [ i ] result = max ( result , curr_sum ) return result
def isProduct ( arr , n , x ) : if n < 2 : return False s = set ( ) for i in range ( 0 , n ) : if arr [ i ] == 0 : if x == 0 : return True else : continue if x % arr [ i ] == 0 : if x // arr [ i ] in s : return True s . add ( arr [ i ] ) return False
def isSubSequence ( string1 , string2 , m , n ) : if m == 0 : return True if n == 0 : return False if string1 [ m - 1 ] == string2 [ n - 1 ] : return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) return isSubSequence ( string1 , string2 , m , n - 1 )
def minCost ( a , n , k ) : dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : for m in range ( i - 1 , - 1 , - 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) return dp [ n ] [ k ]
def getArea ( a ) : area = ( math . pi * a * a ) / 4 return area
def isDivisible999 ( num ) : n = len ( num ) ; if ( n == 0 or num [ 0 ] == '0' ) : return true if ( ( n % 3 ) == 1 ) : num = "00" + num if ( ( n % 3 ) == 2 ) : num = "0" + num gSum = 0 for i in range ( 0 , n , 3 ) : group = 0 group += ( ord ( num [ i ] ) - 48 ) * 100 group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 group += ( ord ( num [ i + 2 ] ) - 48 ) gSum += group if ( gSum > 1000 ) : num = str ( gSum ) n = len ( num ) gSum = isDivisible999 ( num ) return ( gSum == 999 )
def binaryToDecimal ( n ) : num = n dec_value = 0 base1 = 1 len1 = len ( num ) for i in range ( len1 - 1 , - 1 , - 1 ) : if ( num [ i ] == '1' ) : dec_value += base1 base1 = base1 * 2 return dec_value
def cost ( a , n ) : return ( ( n - 1 ) * min ( a ) )
def fib ( n ) : if n < 6 : return f [ n ] t = 5 fn = 5 while t < n : fn = round ( fn * PHI ) t += 1 return fn
def findMaxAverage ( arr , n , k ) : if k > n : return - 1 csum = [ 0 ] * n csum [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : csum [ i ] = csum [ i - 1 ] + arr [ i ] max_sum = csum [ k - 1 ] max_end = k - 1 for i in range ( k , n ) : curr_sum = csum [ i ] - csum [ i - k ] if curr_sum > max_sum : max_sum = curr_sum max_end = i return max_end - k + 1
def countDivisbleby4 ( s ) : n = len ( s ) count = 0 for i in range ( 0 , n , 1 ) : if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : count += 1 for i in range ( 0 , n - 1 , 1 ) : h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) if ( h % 4 == 0 ) : count = count + i + 1 return count
def minimumBox ( arr , n ) : q = collections . deque ( [ ] ) arr . sort ( ) q . append ( arr [ 0 ] ) for i in range ( 1 , n ) : now = q [ 0 ] if ( arr [ i ] >= 2 * now ) : q . popleft ( ) q . append ( arr [ i ] ) return len ( q )
def findElement ( arr , n ) : leftMax = [ None ] * n leftMax [ 0 ] = float ( '-inf' ) for i in range ( 1 , n ) : leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) rightMin = float ( 'inf' ) for i in range ( n - 1 , - 1 , - 1 ) : if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] : return i rightMin = min ( rightMin , arr [ i ] ) return - 1
def multiply ( num1 , num2 ) : len1 = len ( num1 ) len2 = len ( num2 ) if len1 == 0 or len2 == 0 : return "0" result = [ 0 ] * ( len1 + len2 ) i_n1 = 0 i_n2 = 0 for i in range ( len1 - 1 , - 1 , - 1 ) : carry = 0 n1 = ord ( num1 [ i ] ) - 48 i_n2 = 0 for j in range ( len2 - 1 , - 1 , - 1 ) : n2 = ord ( num2 [ j ] ) - 48 summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry carry = summ // 10 result [ i_n1 + i_n2 ] = summ % 10 i_n2 += 1 if ( carry > 0 ) : result [ i_n1 + i_n2 ] += carry i_n1 += 1 i = len ( result ) - 1 while ( i >= 0 and result [ i ] == 0 ) : i -= 1 if ( i == - 1 ) : return "0" s = "" while ( i >= 0 ) : s += chr ( result [ i ] + 48 ) i -= 1 return s
def leonardo ( n ) : dp = [ ] dp . append ( 1 ) dp . append ( 1 ) for i in range ( 2 , n + 1 ) : dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) return dp [ n ]
def subsetDifference ( n ) : s = int ( n * ( n + 1 ) / 2 ) if n % 4 == 0 : print ( "Firstsubsetsum=" , int ( s / 2 ) ) print ( "Secondsubsetsum=" , int ( s / 2 ) ) print ( "Difference=" , 0 ) else : if n % 4 == 1 or n % 4 == 2 : print ( "Firstsubsetsum=" , int ( s / 2 ) ) print ( "Secondsubsetsum=" , int ( s / 2 ) + 1 ) print ( "Difference=" , 1 ) else : print ( "Firstsubsetsum=" , int ( s / 2 ) ) print ( "Secondsubsetsum=" , int ( s / 2 ) ) print ( "Difference=" , 0 )
def printFirstNegativeInteger ( arr , n , k ) : Di = deque ( ) for i in range ( k ) : if ( arr [ i ] < 0 ) : Di . append ( i ) for i in range ( k , n ) : if ( not Di ) : print ( 0 , end = '' ) else : print ( arr [ Di [ 0 ] ] , end = '' ) while Di and Di [ 0 ] <= ( i - k ) : Di . popleft ( ) if ( arr [ i ] < 0 ) : Di . append ( i ) if not Di : print ( 0 ) else : print ( arr [ Di [ 0 ] ] , end = "" )
def isMagicSquare ( mat ) : s = 0 for i in range ( 0 , N ) : s = s + mat [ i ] [ i ] s2 = 0 for i in range ( 0 , N ) : s2 = s2 + mat [ i ] [ N - i - 1 ] if ( s != s2 ) : return False for i in range ( 0 , N ) : rowSum = 0 for j in range ( 0 , N ) : rowSum += mat [ i ] [ j ] if ( rowSum != s ) : return False for i in range ( 0 , N ) : colSum = 0 for j in range ( 0 , N ) : colSum += mat [ j ] [ i ] if ( s != colSum ) : return False return True
def minimumSquare ( m , n ) : vertical_min = 10000000000 horizontal_min = 10000000000 if m == n : return 1 if dp [ m ] [ n ] != 0 : return dp [ m ] [ n ] for i in range ( 1 , m // 2 + 1 ) : horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) for j in range ( 1 , n // 2 + 1 ) : vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) return dp [ m ] [ n ]
def getMaxGold ( gold , m , n ) : goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] for col in range ( n - 1 , - 1 , - 1 ) : for row in range ( m ) : if ( col == n - 1 ) : right = 0 else : right = goldTable [ row ] [ col + 1 ] if ( row == 0 or col == n - 1 ) : right_up = 0 else : right_up = goldTable [ row - 1 ] [ col + 1 ] if ( row == m - 1 or col == n - 1 ) : right_down = 0 else : right_down = goldTable [ row + 1 ] [ col + 1 ] goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) res = goldTable [ 0 ] [ 0 ] for i in range ( 1 , m ) : res = max ( res , goldTable [ i ] [ 0 ] ) return res
def findMinDiff ( arr , n ) : arr = sorted ( arr ) diff = 10 ** 20 for i in range ( n - 1 ) : if arr [ i + 1 ] - arr [ i ] < diff : diff = arr [ i + 1 ] - arr [ i ] return diff
def arrangeBraces ( n , pos , k ) : h = [ False for i in range ( N ) ] dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] for i in range ( k ) : h [ pos [ i ] ] = 1 dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , 2 * n + 1 ) : for j in range ( 2 * n + 1 ) : if ( h [ i ] ) : if ( j != 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 0 else : if ( j != 0 ) : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) else : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] return dp [ 2 * n ] [ 0 ]
def nobleInteger ( arr , size ) : for i in range ( 0 , size ) : count = 0 for j in range ( 0 , size ) : if ( arr [ i ] < arr [ j ] ) : count += 1 if ( count == arr [ i ] ) : return arr [ i ] return - 1
def countSeq ( n , diff ) : if ( abs ( diff ) > n ) : return 0 if ( n == 1 and diff == 0 ) : return 2 if ( n == 1 and abs ( diff ) == 1 ) : return 1 res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) return res
def lis ( arr ) : n = len ( arr ) lis = [ 1 ] * n for i in range ( 1 , n ) : for j in range ( 0 , i ) : if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : lis [ i ] = lis [ j ] + 1 maximum = 0 for i in range ( n ) : maximum = max ( maximum , lis [ i ] ) return maximum
def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 if m < n : return 0 arr1 . sort ( ) arr2 . sort ( ) while i < n and j < m : if arr1 [ j ] < arr2 [ i ] : j += 1 elif arr1 [ j ] == arr2 [ i ] : j += 1 i += 1 elif arr1 [ j ] > arr2 [ i ] : return 0 return False if i < n else True
def find_maximum ( a , n , k ) : b = dict ( ) for i in range ( n ) : x = a [ i ] d = min ( 1 + i , n - i ) if x not in b . keys ( ) : b [ x ] = d else : b [ x ] = min ( d , b [ x ] ) ans = 10 ** 9 for i in range ( n ) : x = a [ i ] if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) return ans
def longestSubseqWithK ( str , k ) : n = len ( str ) freq = [ 0 ] * MAX_CHARS for i in range ( n ) : freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) : print ( str [ i ] , end = "" )
def isDivisible ( str , k ) : n = len ( str ) c = 0 for i in range ( 0 , k ) : if ( str [ n - i - 1 ] == '0' ) : c += 1 return ( c == k )
def isDvisibleBy12 ( num ) : if ( len ( num ) >= 3 ) : d1 = int ( num [ len ( num ) - 1 ] ) if ( d1 % 2 != 0 ) : return False d2 = int ( num [ len ( num ) - 2 ] ) sum = 0 for i in range ( 0 , len ( num ) ) : sum += int ( num [ i ] ) return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) else : number = int ( num ) return ( number % 12 == 0 )
def findMaxPath ( mat ) : res = - 1 for i in range ( M ) : res = max ( res , mat [ 0 ] [ i ] ) for i in range ( 1 , N ) : res = - 1 for j in range ( M ) : if ( j > 0 and j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) elif ( j > 0 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) elif ( j < M - 1 ) : mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) res = max ( mat [ i ] [ j ] , res ) return res
def findpath ( graph ) : n = len ( graph ) numofadj = list ( ) for i in range ( n ) : numofadj . append ( sum ( graph [ i ] ) ) startpoint = 0 numofodd = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( numofadj [ i ] % 2 == 1 ) : numofodd += 1 startpoint = i if ( numofodd > 2 ) : print ( "NoSolution" ) return stack = list ( ) path = list ( ) cur = startpoint while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) : if ( sum ( graph [ cur ] ) == 0 ) : path . append ( cur + 1 ) cur = stack . pop ( - 1 ) else : for i in range ( n ) : if graph [ cur ] [ i ] == 1 : stack . append ( cur ) graph [ cur ] [ i ] = 0 graph [ i ] [ cur ] = 0 cur = i break for ele in path : print ( ele , "->" , end = '' ) print ( cur + 1 )
def find ( n , k ) : if ( n + 1 >= k ) : return ( k - 1 ) else : return ( 2 * n + 1 - k )
def bellNumber ( n ) : bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] bell [ 0 ] [ 0 ] = 1 for i in range ( 1 , n + 1 ) : bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] for j in range ( 1 , i + 1 ) : bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] return bell [ n ] [ 0 ]
def isPerfectSquare ( n ) : i = 1 the_sum = 0 while the_sum < n : the_sum += i if the_sum == n : return True i += 2 return False
def noAdjacentDup ( s ) : n = len ( s ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = "a" while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 return s
def lcsOf3 ( X , Y , Z , m , n , o ) : L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : for k in range ( o + 1 ) : if ( i == 0 or j == 0 or k == 0 ) : L [ i ] [ j ] [ k ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 else : L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) return L [ m ] [ n ] [ o ]
def timeToMeet ( s , v ) : V = 3 * v / 2 time = s / V print ( time )
def minMaxLengthWords ( inp ) : length = len ( inp ) si = ei = 0 min_length = length min_start_index = max_length = max_start_index = 0 while ei <= length : if ( ei < length ) and ( inp [ ei ] != "" ) : ei += 1 else : curr_length = ei - si if curr_length < min_length : min_length = curr_length min_start_index = si if curr_length > max_length : max_length = curr_length max_start_index = si ei += 1 si = ei minWord = inp [ min_start_index : min_start_index + min_length ] maxWord = inp [ max_start_index : max_length ] print ( "Minimumlengthword:" , minWord ) print ( "Maximumlengthword:" , maxWord )
def findExtra ( arr1 , arr2 , n ) : index = n left = 0 right = n - 1 while ( left <= right ) : mid = ( int ) ( ( left + right ) / 2 ) if ( arr2 [ mid ] == arr1 [ mid ] ) : left = mid + 1 else : index = mid right = mid - 1 return index
def isPowerOfK ( n , k ) : oneSeen = False while ( n > 0 ) : digit = n % k if ( digit > 1 ) : return False if ( digit == 1 ) : if ( oneSeen ) : return False oneSeen = True n //= k return True
def kLargest ( arr , k ) : arr . sort ( reverse = True ) for i in range ( k ) : print ( arr [ i ] , end = "" )
def findgroups ( arr , n ) : c = [ 0 , 0 , 0 ] res = 0 for i in range ( 0 , n ) : c [ arr [ i ] % 3 ] += 1 res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) res += c [ 1 ] * c [ 2 ] res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) res += c [ 0 ] * c [ 1 ] * c [ 2 ] return res
def maxSumSubarrayRemovingOneEle ( arr , n ) : fw = [ 0 for k in range ( n ) ] bw = [ 0 for k in range ( n ) ] cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] for i in range ( n ) : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) fw [ i ] = cur_max cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] i = n - 2 while i >= 0 : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) bw [ i ] = cur_max i -= 1 fans = max_so_far for i in range ( 1 , n - 1 ) : fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) return fans
def lastPosition ( n , m , k ) : if ( m <= n - k + 1 ) : return m + k - 1 m = m - ( n - k + 1 ) if ( m % n == 0 ) : return n else : return m % n
def countToMake0lternate ( s ) : result = 0 for i in range ( len ( s ) - 1 ) : if ( s [ i ] == s [ i + 1 ] ) : result += 1 return result
def getNthUglyNo ( n ) : ugly = [ 0 ] * n ugly [ 0 ] = 1 i2 = i3 = i5 = 0 next_multiple_of_2 = 2 next_multiple_of_3 = 3 next_multiple_of_5 = 5 for l in range ( 1 , n ) : ugly [ l ] = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) if ugly [ l ] == next_multiple_of_2 : i2 += 1 next_multiple_of_2 = ugly [ i2 ] * 2 if ugly [ l ] == next_multiple_of_3 : i3 += 1 next_multiple_of_3 = ugly [ i3 ] * 3 if ugly [ l ] == next_multiple_of_5 : i5 += 1 next_multiple_of_5 = ugly [ i5 ] * 5 return ugly [ - 1 ]
def isDiagonalMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False return True
def CountSquares ( a , b ) : cnt = 0 for i in range ( a , b + 1 ) : j = 1 ; while j * j <= i : if j * j == i : cnt = cnt + 1 j = j + 1 i = i + 1 return cnt
def floorSearch ( arr , low , high , x ) : if ( low > high ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )
def maximumZeros ( arr , n , k ) : global MAX5 subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1 ) ] subset [ 0 ] [ 0 ] = 0 for p in arr : pw2 , pw5 = 0 , 0 while not p % 2 : pw2 += 1 p //= 2 while not p % 5 : pw5 += 1 p //= 5 for i in range ( k - 1 , - 1 , - 1 ) : for j in range ( MAX5 ) : if subset [ i ] [ j ] != - 1 : subset [ i + 1 ] [ j + pw5 ] = ( max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ) ans = 0 for i in range ( MAX5 ) : ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) return ans
def numofAP ( a , n ) : minarr = + 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( minarr , a [ i ] ) maxarr = max ( maxarr , a [ i ] ) dp = [ 0 for i in range ( n + 1 ) ] ans = n + 1 for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : sum = [ 0 for i in range ( MAX + 1 ) ] for i in range ( n ) : dp [ i ] = 1 if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : dp [ i ] += sum [ a [ i ] - d ] ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] return ans
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : if ( k > n1 * n2 ) : print ( "kpairsdon'texist" ) return index2 = [ 0 for i in range ( n1 ) ] while ( k > 0 ) : min_sum = sys . maxsize min_index = 0 for i1 in range ( 0 , n1 , 1 ) : if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : min_index = i1 min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] print ( "(" , arr1 [ min_index ] , "," , arr2 [ index2 [ min_index ] ] , ")" , end = "" ) index2 [ min_index ] += 1 k -= 1
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) radSumSq = ( r1 + r2 ) * ( r1 + r2 ) if ( distSq == radSumSq ) : return 1 elif ( distSq > radSumSq ) : return - 1 else : return 0
def minSwap ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : if ( arr [ i ] <= k ) : count = count + 1 bad = 0 for i in range ( 0 , count ) : if ( arr [ i ] > k ) : bad = bad + 1 ans = bad j = count for i in range ( 0 , n ) : if ( j == n ) : break if ( arr [ i ] > k ) : bad = bad - 1 if ( arr [ j ] > k ) : bad = bad + 1 ans = min ( ans , bad ) j = j + 1 return ans
def fix ( A , len ) : for i in range ( 0 , len ) : if ( A [ i ] != - 1 and A [ i ] != i ) : x = A [ i ] while ( A [ x ] != - 1 and A [ x ] != x ) : y = A [ x ] A [ x ] = x x = y A [ x ] = x if ( A [ i ] != i ) : A [ i ] = - 1
def sortInWave ( arr , n ) : arr . sort ( ) for i in range ( 0 , n - 1 , 2 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]
def minInsertion ( tr1 ) : n = len ( str1 ) res = 0 count = [ 0 for i in range ( 26 ) ] for i in range ( n ) : count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( 26 ) : if ( count [ i ] % 2 == 1 ) : res += 1 if ( res == 0 ) : return 0 else : return res - 1
def checkIfAllTogether ( s , c ) : oneSeen = False i = 0 n = len ( s ) while ( i < n ) : if ( s [ i ] == c ) : if ( oneSeen == True ) : return False while ( i < n and s [ i ] == c ) : i = i + 1 oneSeen = True else : i = i + 1 return True
def printCountDP ( dist ) : count = [ 0 ] * ( dist + 1 ) count [ 0 ] = 1 count [ 1 ] = 1 count [ 2 ] = 2 for i in range ( 3 , dist + 1 ) : count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) return count [ dist ]
def checkPair ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : sum += arr [ i ] if sum % 2 != 0 : return False sum = sum / 2 for i in range ( n ) : val = sum - arr [ i ] if arr [ i ] not in s : s . add ( arr [ i ] ) if val in s : print ( "Pairelementsare" , arr [ i ] , "and" , int ( val ) )
def count ( n ) : if n < 3 : return n elif n >= 3 and n < 10 : return n - 1 po = 1 while n / po > 9 : po = po * 10 msd = n / po if msd != 3 : return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) else : return count ( msd * po - 1 )
def isLucky ( n ) : ar = [ 0 ] * 10 while ( n > 0 ) : digit = math . floor ( n % 10 ) if ( ar [ digit ] ) : return 0 ar [ digit ] = 1 n = n / 10 return 1
def nearestSmallerEqFib ( n ) : if ( n == 0 or n == 1 ) : return n f1 , f2 , f3 = 0 , 1 , 1 while ( f3 <= n ) : f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; return f2 ;
def countPaths ( n , m ) : if ( n == 0 or m == 0 ) : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )
def calculate ( s ) : ans = 6 for i in range ( 10 ) : for j in range ( 10 ) : for k in range ( 10 ) : for l in range ( 10 ) : for m in range ( 10 ) : for n in range ( 10 ) : if ( i + j + k == l + m + n ) : c = 0 if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : c += 1 if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : c += 1 if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : c += 1 if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : c += 1 if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : c += 1 if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : c += 1 if ( c < ans ) : ans = c return ans
def factorize ( n ) : count = 0 while ( ( n % 2 > 0 ) == False ) : n >>= 1 count += 1 if ( count > 0 ) : print ( 2 , count ) for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : count = 0 while ( n % i == 0 ) : count += 1 n = int ( n / i ) if ( count > 0 ) : print ( i , count ) i += 2 if ( n > 2 ) : print ( n , 1 )
def maxSumWO3Consec ( n ) : if ( sum [ n ] != - 1 ) : return sum [ n ] if ( n == 0 ) : sum [ n ] = 0 return sum [ n ] if ( n == 1 ) : sum [ n ] = arr [ 0 ] return sum [ n ] if ( n == 2 ) : sum [ n ] = arr [ 1 ] + arr [ 0 ] return sum [ n ] sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) return sum [ n ]
def findLargestd ( S , n ) : found = False S . sort ( ) for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( 0 , n ) : if ( i == j ) : continue for k in range ( j + 1 , n ) : if ( i == k ) : continue for l in range ( k + 1 , n ) : if ( i == l ) : continue if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = True return S [ i ] if ( found == False ) : return - 1
def breakSum ( n ) : if ( n == 0 or n == 1 ) : return n return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n )
def printknapSack ( W , wt , val , n ) : K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] res = K [ n ] [ W ] print ( res ) w = W for i in range ( n , 0 , - 1 ) : if res <= 0 : break if res == K [ i - 1 ] [ w ] : continue else : print ( wt [ i - 1 ] ) res = res - val [ i - 1 ] w = w - wt [ i - 1 ]
def countPattern ( s ) : length = len ( s ) oneSeen = False count = 0 for i in range ( length ) : if ( s [ i ] == '1' and oneSeen ) : if ( s [ i - 1 ] == '0' ) : count += 1 if ( s [ i ] == '1' and oneSeen == 0 ) : oneSeen = True if ( s [ i ] != '0' and s [ i ] != '1' ) : oneSeen = False return count
def pad ( n ) : pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 for i in range ( 3 , n + 1 ) : pNext = pPrevPrev + pPrev pPrevPrev = pPrev pPrev = pCurr pCurr = pNext return pNext ;
def commonCharacters ( strings , n ) : prim = [ True ] * MAX_CHAR for i in range ( n ) : sec = [ False ] * MAX_CHAR for j in range ( len ( strings [ i ] ) ) : if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) : sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = True for i in range ( MAX_CHAR ) : prim [ i ] = sec [ i ] for i in range ( 26 ) : if ( prim [ i ] ) : print ( "%c" % ( i + ord ( 'a' ) ) , end = "" )
def printRotatedString ( str ) : lenn = len ( str ) temp = [ 0 ] * ( lenn ) for i in range ( lenn ) : j = i k = 0 while ( j < len ( str ) ) : temp [ k ] = str [ j ] k += 1 j += 1 j = 0 while ( j < i ) : temp [ k ] = str [ j ] j += 1 k += 1 print ( * temp , sep = "" )
def findSubarraySum ( arr , n ) : res = 0 m = dict ( ) for i in range ( n ) : Sum = 0 for j in range ( i , n ) : Sum += arr [ j ] m [ Sum ] = m . get ( Sum , 0 ) + 1 for x in m : if m [ x ] == 1 : res += x return res
def minRotation ( input , unlock_code ) : rotation = 0 while ( input > 0 or unlock_code > 0 ) : input_digit = input % 10 code_digit = unlock_code % 10 rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) input = int ( input / 10 ) unlock_code = int ( unlock_code / 10 ) return rotation
def findMaxAverage ( arr , n , k ) : if ( k > n ) : return - 1 sum = arr [ 0 ] for i in range ( 1 , k ) : sum += arr [ i ] max_sum = sum max_end = k - 1 for i in range ( k , n ) : sum = sum + arr [ i ] - arr [ i - k ] if ( sum > max_sum ) : max_sum = sum max_end = i return max_end - k + 1
def replaceSpaces ( string ) : string = string . strip ( ) i = len ( string ) space_count = string . count ( '' ) new_length = i + space_count * 2 if new_length > MAX : return - 1 index = new_length - 1 string = list ( string ) for f in range ( i - 2 , new_length - 2 ) : string . append ( '0' ) for j in range ( i - 1 , 0 , - 1 ) : if string [ j ] == '' : string [ index ] = '0' string [ index - 1 ] = '2' string [ index - 2 ] = '%' index = index - 3 else : string [ index ] = string [ j ] index -= 1 return '' . join ( string )
def find_prob ( N , P ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 1 dp [ 1 ] = 0 dp [ 2 ] = P dp [ 3 ] = 1 - P for i in range ( 4 , N + 1 ) : dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] return dp [ N ]
def isPrime ( n ) : if n <= 1 : return False for i in range ( 2 , n ) : if n % i == 0 : return False return True
def checkDuplicatesWithinK ( arr , n , k ) : myset = [ ] for i in range ( n ) : if arr [ i ] in myset : return True myset . append ( arr [ i ] ) if ( i >= k ) : myset . remove ( arr [ i - k ] ) return False
def numberOfPaths ( p , q ) : dp = [ 1 for i in range ( q ) ] for i in range ( p - 1 ) : for j in range ( 1 , q ) : dp [ j ] += dp [ j - 1 ] return dp [ q - 1 ]
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]
def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 for i in range ( 0 , n - 1 ) : sum = - 1 if ( arr [ i ] == 0 ) else 1 for j in range ( i + 1 , n ) : sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 if ( sum == 0 and maxsize < j - i + 1 ) : maxsize = j - i + 1 startindex = i if ( maxsize == - 1 ) : print ( "Nosuchsubarray" ) else : print ( startindex , "to" , startindex + maxsize - 1 ) return maxsize
def getMedian ( ar1 , ar2 , n ) : i = 0 j = 0 m1 = - 1 m2 = - 1 count = 0 while count < n + 1 : count += 1 if i == n : m1 = m2 m2 = ar2 [ 0 ] break elif j == n : m1 = m2 m2 = ar1 [ 0 ] break if ar1 [ i ] < ar2 [ j ] : m1 = m2 m2 = ar1 [ i ] i += 1 else : m1 = m2 m2 = ar2 [ j ] j += 1 return ( m1 + m2 ) / 2
def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) count = [ 0 ] * MAX_CHAR for i in range ( n ) : count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR ) : result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) return result
def findAndPrintUncommonChars ( str1 , str2 ) : present = [ 0 ] * MAX_CHAR for i in range ( 0 , MAX_CHAR ) : present [ i ] = 0 l1 = len ( str1 ) l2 = len ( str2 ) for i in range ( 0 , l1 ) : present [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = 1 for i in range ( 0 , l2 ) : if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == - 1 ) : present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = - 1 else : present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = 2 for i in range ( 0 , MAX_CHAR ) : if ( present [ i ] == 1 or present [ i ] == 2 ) : print ( chr ( i + ord ( 'a' ) ) , end = "" )
def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len
def kth ( arr1 , arr2 , m , n , k ) : sorted1 = [ 0 ] * ( m + n ) i = 0 j = 0 d = 0 while ( i < m and j < n ) : if ( arr1 [ i ] < arr2 [ j ] ) : sorted1 [ d ] = arr1 [ i ] i += 1 else : sorted1 [ d ] = arr2 [ j ] j += 1 d += 1 while ( i < m ) : sorted1 [ d ] = arr1 [ i ] d += 1 i += 1 while ( j < n ) : sorted1 [ d ] = arr2 [ j ] d += 1 j += 1 return sorted1 [ k - 1 ]
