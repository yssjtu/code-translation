def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n
def lbs ( arr ) : n = len ( arr ) lis = [ 1 for i in range ( n + 1 ) ] for i in range ( 1 , n ) : for j in range ( 0 , i ) : if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : lis [ i ] = lis [ j ] + 1 lds = [ 1 for i in range ( n + 1 ) ] for i in reversed ( range ( n - 1 ) ) : for j in reversed ( range ( i - 1 , n ) ) : if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : lds [ i ] = lds [ j ] + 1 maximum = lis [ 0 ] + lds [ 0 ] - 1 for i in range ( 1 , n ) : maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) return maximum
def findSum ( n ) : sm = 0 for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : sm = sm + i * j return sm
def check ( s ) : if ( len ( s ) >= 10 ) : return True for i in range ( 1 , len ( s ) ) : for j in range ( i + 1 , len ( s ) ) : for k in range ( j + 1 , len ( s ) ) : s1 = s [ 0 : i ] s2 = s [ i : j - i ] s3 = s [ j : k - j ] s4 = s [ k : len ( s ) - k ] if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : return True return False
def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )
def query ( s , i , j ) : n = len ( s ) i %= n j %= n print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" )
def maxProd ( n ) : if ( n == 0 or n == 1 ) : return 0 max_val = 0 for i in range ( 1 , n - 1 ) : max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) return max_val
def countNum ( arr , n ) : count = 0 arr . sort ( ) for i in range ( 0 , n - 1 ) : if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : count += arr [ i + 1 ] - arr [ i ] - 1 return count
def sequence ( n ) : f = [ 0 , 1 , 1 ] print ( f [ 1 ] , end = "" ) , print ( f [ 2 ] , end = "" ) , for i in range ( 3 , n + 1 ) : f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) print ( f [ i ] , end = "" ) ,
def maxSumWO3Consec ( arr , n ) : sum = [ 0 for k in range ( n ) ] if n >= 1 : sum [ 0 ] = arr [ 0 ] if n >= 2 : sum [ 1 ] = arr [ 0 ] + arr [ 1 ] if n > 2 : sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) for i in range ( 3 , n ) : sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) return sum [ n - 1 ]
def findmin ( p , n ) : a , b , c , d = 0 , 0 , 0 , 0 for i in range ( n ) : if ( p [ i ] [ 0 ] <= 0 ) : a += 1 elif ( p [ i ] [ 0 ] >= 0 ) : b += 1 if ( p [ i ] [ 1 ] >= 0 ) : c += 1 elif ( p [ i ] [ 1 ] <= 0 ) : d += 1 return min ( [ a , b , c , d ] )
def divisible ( num ) : n = len ( num ) sum = 0 for i in range ( n ) : sum += int ( num [ i ] ) if ( sum % 3 == 0 ) : return 0 if ( n == 1 ) : return - 1 for i in range ( n ) : if ( sum % 3 == int ( num [ i ] ) % 3 ) : return 1 if ( n == 2 ) : return - 1 return 2
def MaxDotProduct ( A , B , m , n ) : dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 , 1 ) : for j in range ( i , m + 1 , 1 ) : dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) return dp [ n ] [ m ]
def minSum ( ar , n ) : if ( n <= 4 ) : return min ( ar ) sum = [ 0 for i in range ( n ) ] sum [ 0 ] = ar [ 0 ] sum [ 1 ] = ar [ 1 ] sum [ 2 ] = ar [ 2 ] sum [ 3 ] = ar [ 3 ] for i in range ( 4 , n ) : sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) return min ( sum [ n - 4 : n ] )
def printGrouped ( string ) : n = len ( string ) count = [ 0 ] * MAX_CHAR for i in range ( n ) : count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1 for i in range ( n ) : while count [ ord ( string [ i ] ) - ord ( "a" ) ] : print ( string [ i ] , end = "" ) count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1 count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0
def hexagonArea ( s ) : return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 )
def countDer ( n ) : if ( n == 1 ) : return 0 if ( n == 0 ) : return 1 if ( n == 2 ) : return 1 return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )
def isScalarMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False for i in range ( 0 , N - 1 ) : if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : return False return True
def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] start = 0 i = 1 while i <= n : while curr_sum > sum and start < i - 1 : curr_sum = curr_sum - arr [ start ] start += 1 if curr_sum == sum : print ( "Sumfoundbetweenindexes" ) print ( "%dand%d" % ( start , i - 1 ) ) return 1 if i < n : curr_sum = curr_sum + arr [ i ] i += 1 print ( "Nosubarrayfound" ) return 0
def countObtuseAngles ( a , b , k ) : c1 = ( b - a ) - 1 c2 = ( k - b ) + ( a - 1 ) if ( c1 == c2 ) : return 0 return min ( c1 , c2 )
def countManipulations ( s1 , s2 ) : count = 0 char_count = [ 0 ] * 26 for i in range ( 26 ) : char_count [ i ] = 0 for i in range ( len ( s1 ) ) : char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( s2 ) ) : char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1 if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] < 0 ) : count += 1 return count
def countRotations ( arr , n ) : min = arr [ 0 ] for i in range ( 0 , n ) : if ( min > arr [ i ] ) : min = arr [ i ] min_index = i return min_index
def kthgroupsum ( k ) : return k * k * k
def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if B [ i ] : if A [ i ] != i + 1 : A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] for i in range ( n ) : if A [ i ] != i + 1 : return False return True
def reverseFibonacci ( n ) : a = [ 0 ] * n a [ 0 ] = 0 a [ 1 ] = 1 for i in range ( 2 , n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] for i in range ( n - 1 , - 1 , - 1 ) : print ( a [ i ] , end = "" )
def eggDrop ( n , k ) : eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : eggFloor [ i ] [ 1 ] = 1 eggFloor [ i ] [ 0 ] = 0 for j in range ( 1 , k + 1 ) : eggFloor [ 1 ] [ j ] = j for i in range ( 2 , n + 1 ) : for j in range ( 2 , k + 1 ) : eggFloor [ i ] [ j ] = INT_MAX for x in range ( 1 , j + 1 ) : res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) if res < eggFloor [ i ] [ j ] : eggFloor [ i ] [ j ] = res return eggFloor [ n ] [ k ]
def isOneFlip ( str ) : sum = 0 n = len ( str ) for i in range ( 0 , n ) : sum += int ( str [ i ] ) - int ( '0' ) return ( sum == n - 1 or sum == 1 )
def printShortestSuperSeq ( x , y ) : m = len ( x ) n = len ( y ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if i == 0 : dp [ i ] [ j ] = j elif j == 0 : dp [ i ] [ j ] = i elif x [ i - 1 ] == y [ j - 1 ] : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] string = "" i = m j = n while i > 0 and j > 0 : if x [ i - 1 ] == y [ j - 1 ] : string += x [ i - 1 ] i -= 1 j -= 1 index -= 1 elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] : string += y [ j - 1 ] j -= 1 index -= 1 else : string += x [ i - 1 ] i -= 1 index -= 1 while i > 0 : string += x [ i - 1 ] i -= 1 index -= 1 while j > 0 : string += y [ j - 1 ] j -= 1 index -= 1 string = list ( string ) string . reverse ( ) return '' . join ( string )
def findTriplets ( arr , n ) : found = False arr . sort ( ) for i in range ( 0 , n - 1 ) : l = i + 1 r = n - 1 x = arr [ i ] while ( l < r ) : if ( x + arr [ l ] + arr [ r ] == 0 ) : print ( x , arr [ l ] , arr [ r ] ) l += 1 r -= 1 found = True elif ( x + arr [ l ] + arr [ r ] < 0 ) : l += 1 else : r -= 1 if ( found == False ) : print ( "NoTripletFound" )
def isNumber ( s ) : for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) != True : return False return True
def countSol ( coeff , n , rhs ) : dp = [ 0 for i in range ( rhs + 1 ) ] dp [ 0 ] = 1 for i in range ( n ) : for j in range ( coeff [ i ] , rhs + 1 ) : dp [ j ] += dp [ j - coeff [ i ] ] return dp [ rhs ]
def groupElements ( arr , n ) : visited = [ False ] * n for i in range ( 0 , n ) : visited [ i ] = False for i in range ( 0 , n ) : if ( visited [ i ] == False ) : print ( arr [ i ] , end = "" ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] , end = "" ) visited [ j ] = True
def perimeter ( diameter , height ) : return 2 * ( diameter + height )
def maxLower ( str ) : n = len ( str ) i = 0 for i in range ( n ) : if str [ i ] >= 'A' and str [ i ] <= 'Z' : i += 1 break maxCount = 0 count = [ ] for j in range ( MAX_CHAR ) : count . append ( 0 ) for j in range ( i , n ) : if str [ j ] >= 'A' and str [ j ] <= 'Z' : currCount = 0 for k in range ( MAX_CHAR ) : if count [ k ] > 0 : currCount += 1 maxCount = max ( maxCount , currCount ) for y in count : y = 0 if str [ j ] >= 'a' and str [ j ] <= 'z' : count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1 return maxCount
def calculate ( a , n ) : a . sort ( ) s = [ ] i = 0 j = n - 1 while ( i < j ) : s . append ( ( a [ i ] + a [ j ] ) ) i += 1 j -= 1 mini = min ( s ) maxi = max ( s ) return abs ( maxi - mini )
def sumOfSeries ( n ) : sum = 0 for i in range ( 1 , n + 1 ) : sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) return sum
def rotateMatrix ( mat ) : if not len ( mat ) : return top = 0 bottom = len ( mat ) - 1 left = 0 right = len ( mat [ 0 ] ) - 1 while left < right and top < bottom : prev = mat [ top + 1 ] [ left ] for i in range ( left , right + 1 ) : curr = mat [ top ] [ i ] mat [ top ] [ i ] = prev prev = curr top += 1 for i in range ( top , bottom + 1 ) : curr = mat [ i ] [ right ] mat [ i ] [ right ] = prev prev = curr right -= 1 for i in range ( right , left - 1 , - 1 ) : curr = mat [ bottom ] [ i ] mat [ bottom ] [ i ] = prev prev = curr bottom -= 1 for i in range ( bottom , top - 1 , - 1 ) : curr = mat [ i ] [ left ] mat [ i ] [ left ] = prev prev = curr left += 1 return mat
def sumofoddFactors ( n ) : res = 1 while n % 2 == 0 : n = n // 2 for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : count = 0 curr_sum = 1 curr_term = 1 while n % i == 0 : count += 1 n = n // i curr_term *= i curr_sum += curr_term res *= curr_sum if n >= 2 : res *= ( 1 + n ) return res
def findSmallestRange ( arr , n , k ) : i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 for i in range ( k + 1 ) : ptr [ i ] = 0 minrange = 10 ** 9 while ( 1 ) : minind = - 1 minval = 10 ** 9 maxval = - 10 ** 9 flag = 0 for i in range ( k ) : if ( ptr [ i ] == n ) : flag = 1 break if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : minind = i minval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] if ( flag ) : break ptr [ minind ] += 1 if ( ( maxval - minval ) < minrange ) : minel = minval maxel = maxval minrange = maxel - minel print ( "Thesmallestrangeis[" , minel , maxel , "]" )
def pre_compute ( a , n , index , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n ) : if a [ i ] > a [ 0 ] : dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] else : dp [ 0 ] [ i ] = a [ i ] for i in range ( 1 , n ) : for j in range ( n ) : if a [ j ] > a [ i ] and j > i : if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return dp [ index ] [ k ]
def alternateSubarray ( arr , n ) : len = [ ] for i in range ( n + 1 ) : len . append ( 0 ) len [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] ^ arr [ i + 1 ] == True ) : len [ i ] = len [ i + 1 ] + 1 else : len [ i ] = 1 for i in range ( n ) : print ( len [ i ] , "" , end = "" )
def mirrorImage ( a , b , c , x1 , y1 ) : temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) x = temp * a + x1 y = temp * b + y1 return ( x , y )
def findLongestConseqSubseq ( arr , n ) : S = set ( ) for i in range ( n ) : S . add ( arr [ i ] ) ans = 0 for i in range ( n ) : if S . __contains__ ( arr [ i ] ) : j = arr [ i ] while ( S . __contains__ ( j ) ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans
def compute_average ( a , b ) : return floor ( ( a + b ) / 2 )
def numberOfSquares ( base ) : base = ( base - 2 ) base = base / 2 return base * ( base + 1 ) / 2
def reverse ( string ) : if len ( string ) == 0 : return temp = string [ 0 ] reverse ( string [ 1 : ] ) print ( temp , end = '' )
def multiplyWith3Point5 ( x ) : return ( x << 1 ) + x + ( x >> 1 )
def check ( st ) : n = len ( st ) digitSum = 0 for i in range ( 0 , n ) : digitSum = digitSum + ( int ) ( st [ i ] ) return ( digitSum % 9 == 0 )
def numberOfPaths ( m , n ) : for i in range ( n , ( m + n - 1 ) ) : path *= i path //= ( i - n + 1 ) return path
def countParenth ( symb , oper , n ) : F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n ) : if symb [ i ] == 'F' : F [ i ] [ i ] = 1 else : F [ i ] [ i ] = 0 if symb [ i ] == 'T' : T [ i ] [ i ] = 1 else : T [ i ] [ i ] = 0 for gap in range ( 1 , n ) : i = 0 for j in range ( gap , n ) : T [ i ] [ j ] = F [ i ] [ j ] = 0 for g in range ( gap ) : k = i + g tik = T [ i ] [ k ] + F [ i ] [ k ] tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] if oper [ k ] == '&' : T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) if oper [ k ] == '|' : F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) if oper [ k ] == '^' : T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) i += 1 return T [ 0 ] [ n - 1 ]
def longestRepeatedSubSeq ( str ) : n = len ( str ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) res = '' i = n j = n while ( i > 0 and j > 0 ) : if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : res += str [ i - 1 ] i -= 1 j -= 1 elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : i -= 1 else : j -= 1 res = '' . join ( reversed ( res ) ) return res
def minDifferenceAmongMaxMin ( arr , N , K ) : arr . sort ( ) res = 2147483647 for i in range ( ( N - K ) + 1 ) : curSeqDiff = arr [ i + K - 1 ] - arr [ i ] res = min ( res , curSeqDiff ) return res
def SieveOfEratosthenes ( n , isPrime ) : isPrime [ 0 ] = isPrime [ 1 ] = False for i in range ( 2 , n + 1 ) : isPrime [ i ] = True for p in range ( 2 , n + 1 ) : if ( p * p <= n and isPrime [ p ] == True ) : for i in range ( p * 2 , n + 1 , p ) : isPrime [ i ] = False p += 1
def findRoot ( arr , n ) : root = 0 for i in range ( n ) : root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) return root
def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) return math . floor ( x ) + 1
def numberOfWays ( x ) : if x == 0 or x == 1 : return 1 else : return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )
def printPowerSet ( set , set_size ) : pow_set_size = ( int ) ( math . pow ( 2 , set_size ) ) counter = 0 j = 0 for counter in range ( 0 , pow_set_size ) : for j in range ( 0 , set_size ) : if ( ( counter & ( 1 << j ) ) > 0 ) : print ( set [ j ] , end = "" ) print ( "" )
def minOperations ( str , n ) : lastUpper = - 1 firstLower = - 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( str [ i ] . isupper ( ) ) : lastUpper = i break for i in range ( n ) : if ( str [ i ] . islower ( ) ) : firstLower = i break if ( lastUpper == - 1 or firstLower == - 1 ) : return 0 countUpper = 0 for i in range ( firstLower , n ) : if ( str [ i ] . isupper ( ) ) : countUpper += 1 countLower = 0 for i in range ( lastUpper ) : if ( str [ i ] . islower ( ) ) : countLower += 1 return min ( countLower , countUpper )
def allCharactersSame ( s ) : n = len ( s ) for i in range ( 1 , n ) : if s [ i ] != s [ 0 ] : return False return True
def firstNonRepeating ( arr , n ) : for i in range ( n ) : j = 0 while ( j < n ) : if ( i != j and arr [ i ] == arr [ j ] ) : break j += 1 if ( j == n ) : return arr [ i ] return - 1
def checkIsAP ( arr , n ) : if ( n == 1 ) : return True arr . sort ( ) d = arr [ 1 ] - arr [ 0 ] for i in range ( 2 , n ) : if ( arr [ i ] - arr [ i - 1 ] != d ) : return False return True
def nthPalindrome ( n , k ) : if ( k & 1 ) : temp = k // 2 else : temp = k // 2 - 1 palindrome = 10 ** temp palindrome = palindrome + n - 1 print ( palindrome , end = "" ) if ( k & 1 ) : palindrome = palindrome // 10 while ( palindrome ) : print ( palindrome % 10 , end = "" ) palindrome = palindrome // 10
def distance ( lat1 , lat2 , lon1 , lon2 ) : lon1 = radians ( lon1 ) lon2 = radians ( lon2 ) lat1 = radians ( lat1 ) lat2 = radians ( lat2 ) dlon = lon2 - lon1 dlat = lat2 - lat1 a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 c = 2 * asin ( sqrt ( a ) ) r = 6371 return ( c * r )
def maxGameByWinner ( N ) : dp = [ 0 for i in range ( N ) ] dp [ 0 ] = 1 dp [ 1 ] = 2 i = 1 while dp [ i ] <= N : i = i + 1 dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return ( i - 1 )
def kthLargestSum ( arr , n , k ) : sum = [ ] sum . append ( 0 ) sum . append ( arr [ 0 ] ) for i in range ( 2 , n + 1 ) : sum . append ( sum [ i - 1 ] + arr [ i - 1 ] ) Q = [ ] heapq . heapify ( Q ) for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : x = sum [ j ] - sum [ i - 1 ] if len ( Q ) < k : heapq . heappush ( Q , x ) else : if Q [ 0 ] < x : heapq . heappop ( Q ) heapq . heappush ( Q , x ) return Q [ 0 ]
def printSumSimple ( mat , k ) : if ( k > n ) : return for i in range ( n - k + 1 ) : for j in range ( n - k + 1 ) : sum = 0 for p in range ( i , k + i ) : for q in range ( j , k + j ) : sum += mat [ p ] [ q ] print ( sum , end = "" ) print ( )
def sumEqualProduct ( a , n ) : zero = 0 two = 0 for i in range ( n ) : if a [ i ] == 0 : zero += 1 if a [ i ] == 2 : two += 1 cnt = ( zero * ( zero - 1 ) ) // 2 + \ ( two * ( two - 1 ) ) // 2 return cnt
def getInvCount ( arr , n ) : invcount = 0 for i in range ( 1 , n - 1 ) : small = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : small += 1 great = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( arr [ i ] < arr [ j ] ) : great += 1 invcount += great * small return invcount
def getMinDiff ( arr , n , k ) : if ( n == 1 ) : return 0 arr . sort ( ) ans = arr [ n - 1 ] - arr [ 0 ] small = arr [ 0 ] + k big = arr [ n - 1 ] - k if ( small > big ) : small , big = big , small for i in range ( 1 , n - 1 ) : subtract = arr [ i ] - k add = arr [ i ] + k if ( subtract >= small or add <= big ) : continue if ( big - subtract <= add - small ) : small = subtract else : big = add return min ( ans , big - small )
def findElement ( arr , ranges , rotations , index ) : for i in range ( rotations - 1 , - 1 , - 1 ) : left = ranges [ i ] [ 0 ] right = ranges [ i ] [ 1 ] if ( left <= index and right >= index ) : if ( index == left ) : index = right else : index = index - 1 return arr [ index ]
def constructArr ( arr , pair , n ) : arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 for i in range ( 1 , n ) : arr [ i ] = pair [ i - 1 ] - arr [ 0 ]
def findCount ( str ) : result = 0 for i in range ( len ( str ) ) : if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : result += 1 return result
def findInteger ( arr , n ) : neg = 0 pos = 0 sum = 0 for i in range ( 0 , n ) : sum += arr [ i ] if ( arr [ i ] < 0 ) : neg += 1 else : pos += 1 return ( sum / abs ( neg - pos ) )
def counterClockspiralPrint ( m , n , arr ) : k = 0 l = 0 cnt = 0 total = m * n while ( k < m and l < n ) : if ( cnt == total ) : break for i in range ( k , m ) : print ( arr [ i ] [ l ] , end = "" ) cnt += 1 l += 1 if ( cnt == total ) : break for i in range ( l , n ) : print ( arr [ m - 1 ] [ i ] , end = "" ) cnt += 1 m -= 1 if ( cnt == total ) : break if ( k < m ) : for i in range ( m - 1 , k - 1 , - 1 ) : print ( arr [ i ] [ n - 1 ] , end = "" ) cnt += 1 n -= 1 if ( cnt == total ) : break if ( l < n ) : for i in range ( n - 1 , l - 1 , - 1 ) : print ( arr [ k ] [ i ] , end = "" ) cnt += 1 k += 1
def splitArr ( arr , n , k ) : for i in range ( 0 , k ) : x = arr [ 0 ] for j in range ( 0 , n - 1 ) : arr [ j ] = arr [ j + 1 ] arr [ n - 1 ] = x
def evenlength ( n ) : res = n for j in range ( len ( n ) - 1 , - 1 , - 1 ) : res += n [ j ] return res
def printMaxSubSquare ( M ) : R = len ( M ) C = len ( M [ 0 ] ) S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ] for i in range ( 1 , R ) : for j in range ( 1 , C ) : if ( M [ i ] [ j ] == 1 ) : S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1 else : S [ i ] [ j ] = 0 max_of_s = S [ 0 ] [ 0 ] max_i = 0 max_j = 0 for i in range ( R ) : for j in range ( C ) : if ( max_of_s < S [ i ] [ j ] ) : max_of_s = S [ i ] [ j ] max_i = i max_j = j print ( "Maximumsizesub-matrixis:" ) for i in range ( max_i , max_i - max_of_s , - 1 ) : for j in range ( max_j , max_j - max_of_s , - 1 ) : print ( M [ i ] [ j ] , end = "" ) print ( "" )
def pythagoreanTriplets ( limits ) : c , m = 0 , 2 while c < limits : for n in range ( 1 , m ) : a = m * m - n * n b = 2 * m * n c = m * m + n * n if c > limits : break print ( a , b , c ) m = m + 1
def sortString ( str ) : charCount = [ 0 ] * MAX_CHAR for i in range ( len ( str ) ) : charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : for j in range ( charCount [ i ] ) : print ( chr ( 97 + i ) , end = "" )
def arraySortedOrNot ( arr ) : n = len ( arr ) if n == 1 or n == 0 : return True return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] )
def minCoins ( coins , m , V ) : table = [ 0 for i in range ( V + 1 ) ] table [ 0 ] = 0 for i in range ( 1 , V + 1 ) : table [ i ] = sys . maxsize for i in range ( 1 , V + 1 ) : for j in range ( m ) : if ( coins [ j ] <= i ) : sub_res = table [ i - coins [ j ] ] if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : table [ i ] = sub_res + 1 return table [ V ]
def maxOverlap ( start , end ) : n = len ( start ) maxa = max ( start ) maxb = max ( end ) maxc = max ( maxa , maxb ) x = ( maxc + 2 ) * [ 0 ] cur = 0 idx = 0 for i in range ( 0 , n ) : x [ start [ i ] ] += 1 x [ end [ i ] + 1 ] -= 1 maxy = - 1 for i in range ( 0 , maxc + 1 ) : cur += x [ i ] if maxy < cur : maxy = cur idx = i print ( "Maximumvalueis:{0:d}" . format ( maxy ) , "atposition:{0:d}" . format ( idx ) )
def printSpiral ( mat , r , c ) : a = 0 b = 2 low_row = 0 if ( 0 > a ) else a low_column = 0 if ( 0 > b ) else b - 1 high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 while ( ( low_row > 0 - r and low_column > 0 - c ) ) : i = low_column + 1 while ( i <= high_column and i < c and low_row >= 0 ) : print ( mat [ low_row ] [ i ] , end = "" ) i += 1 low_row -= 1 i = low_row + 2 while ( i <= high_row and i < r and high_column < c ) : print ( mat [ i ] [ high_column ] , end = "" ) i += 1 high_column += 1 i = high_column - 2 while ( i >= low_column and i >= 0 and high_row < r ) : print ( mat [ high_row ] [ i ] , end = "" ) i -= 1 high_row += 1 i = high_row - 2 while ( i > low_row and i >= 0 and low_column >= 0 ) : print ( mat [ i ] [ low_column ] , end = "" ) i -= 1 low_column -= 1 print ( )
def findIndex ( str ) : l = len ( str ) open = [ None ] * ( l + 1 ) close = [ None ] * ( l + 1 ) index = - 1 open [ 0 ] = 0 close [ l ] = 0 if ( str [ 0 ] == '(' ) : open [ 1 ] = 1 if ( str [ l - 1 ] == ')' ) : close [ l - 1 ] = 1 for i in range ( 1 , l ) : if ( str [ i ] == '(' ) : open [ i + 1 ] = open [ i ] + 1 else : open [ i + 1 ] = open [ i ] for i in range ( l - 2 , - 1 , - 1 ) : if ( str [ i ] == ')' ) : close [ i ] = close [ i + 1 ] + 1 else : close [ i ] = close [ i + 1 ] if ( open [ l ] == 0 ) : return len if ( close [ 0 ] == 0 ) : return 0 for i in range ( l + 1 ) : if ( open [ i ] == close [ i ] ) : index = i return index
def printTwoElements ( arr , size ) : for i in range ( size ) : if arr [ abs ( arr [ i ] ) - 1 ] > 0 : arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] else : print ( "Therepeatingelementis" , abs ( arr [ i ] ) ) for i in range ( size ) : if arr [ i ] > 0 : print ( "andthemissingelementis" , i + 1 )
def rearrangeArr ( arr , n ) : evenPos = int ( n / 2 ) oddPos = n - evenPos tempArr = np . empty ( n , dtype = object ) for i in range ( 0 , n ) : tempArr [ i ] = arr [ i ] tempArr . sort ( ) j = oddPos - 1 for i in range ( 0 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j - 1 j = oddPos for i in range ( 1 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j + 1 for i in range ( 0 , n ) : print ( arr [ i ] , end = '' )
def generate ( st , s ) : if len ( s ) == 0 : return if s not in st : st . add ( s ) for i in range ( len ( s ) ) : t = list ( s ) . copy ( ) t . remove ( s [ i ] ) t = '' . join ( t ) generate ( st , t ) return
def LowerInsertionPoint ( arr , n , X ) : if ( X < arr [ 0 ] ) : return 0 elif ( X > arr [ n - 1 ] ) : return n lowerPnt = 0 i = 1 while ( i < n and arr [ i ] < X ) : lowerPnt = i i = i * 2 while ( lowerPnt < n and arr [ lowerPnt ] < X ) : lowerPnt += 1 return lowerPnt
def printRepeating ( arr , size ) : print ( "Therepeatingelementsare" , end = "" ) for i in range ( 0 , size ) : if ( arr [ abs ( arr [ i ] ) ] > 0 ) : arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] else : print ( abs ( arr [ i ] ) , end = "" )
def subsetGraph ( C ) : global N vertices = set ( ) for i in range ( N ) : vertices . add ( i ) while ( len ( vertices ) != 0 ) : if ( len ( vertices ) == 1 ) : return 1 someone_removed = False for x in vertices : values = set ( ) for y in vertices : if ( y != x ) : values . add ( C [ x ] [ y ] ) if ( len ( values ) == 1 ) : vertices . remove ( x ) someone_removed = True break if ( not someone_removed ) : break return len ( vertices )
def CountSquares ( a , b ) : return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 )
def countNonDecreasing ( n ) : dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] for i in range ( 10 ) : dp [ i ] [ 1 ] = 1 for digit in range ( 10 ) : for len in range ( 2 , n + 1 ) : for x in range ( digit + 1 ) : dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] count = 0 for i in range ( 10 ) : count += dp [ i ] [ n ] return count
def eulerian ( n , m ) : if ( m >= n or n == 0 ) : return 0 if ( m == 0 ) : return 1 return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) )
def isPowerOfFour ( n ) : return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) )
def minTime ( arr , n ) : if ( n <= 0 ) : return 0 incl = arr [ 0 ] excl = 0 for i in range ( 1 , n ) : incl_new = arr [ i ] + min ( excl , incl ) excl_new = incl incl = incl_new excl = excl_new return min ( incl , excl )
def sumofsquare ( n ) : C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) sum = 0 for i in range ( 0 , n + 1 ) : sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) return sum
def swapUpperToLower ( arr ) : n = 4 ; for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; for i in range ( 0 , n ) : for j in range ( 0 , n ) : print ( arr [ i ] [ j ] , end = "" ) ; print ( "" ) ;
def MaximumHeight ( a , n ) : result = 1 for i in range ( 1 , n ) : y = ( i * ( i + 1 ) ) / 2 if ( y < n ) : result = i else : break return result
def decimalToBinary ( N ) : B_Number = 0 cnt = 0 while ( N != 0 ) : rem = N % 2 c = pow ( 10 , cnt ) B_Number += rem * c N //= 2 cnt += 1 return B_Number
def randomize ( arr , n ) : for i in range ( n - 1 , 0 , - 1 ) : j = random . randint ( 0 , i + 1 ) arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] return arr
