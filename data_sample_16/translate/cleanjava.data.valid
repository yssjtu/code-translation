static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; }
static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
static void bubbleSort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; } }
static void printEqualSumSets ( int [ ] arr , int n ) { int i , currSum , sum = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; if ( ( sum & 1 ) == 1 ) { System . out . print ( "-1" ) ; return ; } int k = sum >> 1 ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ; for ( i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ i ] = false ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ; } } List < Integer > set1 = new ArrayList < Integer > ( ) ; List < Integer > set2 = new ArrayList < Integer > ( ) ; if ( ! dp [ n ] [ k ] ) { System . out . print ( "-1\n" ) ; return ; } i = n ; currSum = k ; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i -- ; set2 . add ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) { i -- ; currSum -= arr [ i ] ; set1 . add ( arr [ i ] ) ; } } System . out . print ( "Set 1 elements: " ) ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) System . out . print ( set1 . get ( i ) + " " ) ; System . out . print ( "\nSet 2 elements: " ) ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) System . out . print ( set2 . get ( i ) + " " ) ; }
public static String nextWord ( String str ) { if ( str == "" ) return "a" ; int i = str . length ( ) - 1 ; while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + 'a' ; else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ; return str ; }
static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { System . out . println ( "Right" ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { System . out . println ( "Right" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { System . out . println ( "Right" ) ; return ; } }
static float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }
static int maxSubArraySum ( int a [ ] ) { int size = a . length ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
static int numofAP ( int a [ ] , int n ) { int minarr = + 2147483647 ; int maxarr = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { minarr = Math . min ( minarr , a [ i ] ) ; maxarr = Math . max ( maxarr , a [ i ] ) ; } int dp [ ] = new int [ n ] ; int sum [ ] = new int [ MAX ] ; int ans = n + 1 ; for ( int d = ( minarr - maxarr ) ; d <= ( maxarr - minarr ) ; d ++ ) { Arrays . fill ( sum , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } } return ans ; }
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( "No such subarray" ) ; else System . out . println ( startindex + " to " + endindex ) ; return maxsize ; }
static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = "" ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } String reverse = "" ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) { reverse = reverse + res . charAt ( k ) ; } return reverse ; }
static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( "No pairs exists" ) ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } System . out . println ( "Max product pair is { " + a + ", " + b + "}" ) ; }
static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) { minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( "The smallest range is [%d , %d]\n" , minel , maxel ) ; }
static int policeThief ( char arr [ ] , int n , int k ) { int res = 0 ; ArrayList < Integer > thi = new ArrayList < Integer > ( ) ; ArrayList < Integer > pol = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 'P' ) pol . add ( i ) ; else if ( arr [ i ] == 'T' ) thi . add ( i ) ; } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi . get ( l ) < pol . get ( r ) ) l ++ ; else r ++ ; } return res ; }
