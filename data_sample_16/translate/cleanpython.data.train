def CountSubString ( Str , n ) : ans = ( n * ( n + 1 ) ) // 2 a_index = 0 b_index = 0 c_index = 0 for i in range ( n ) : if ( Str [ i ] == 'a' ) : a_index = i + 1 ans -= min ( b_index , c_index ) elif ( Str [ i ] == 'b' ) : b_index = i + 1 ans -= min ( a_index , c_index ) else : c_index = i + 1 ans -= min ( a_index , b_index ) return ans
def encodedChar ( str , k ) : expand = "" freq = 0 i = 0 while ( i < len ( str ) ) : temp = "" freq = 0 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) : temp += str [ i ] i += 1 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) i += 1 for j in range ( 1 , freq + 1 , 1 ) : expand += temp if ( freq == 0 ) : expand += temp return expand [ k - 1 ]
def floorSearch ( arr , low , high , x ) : if ( low > high ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )
def minSwaps ( arr ) : n = len ( arr ) arrpos = [ * enumerate ( arr ) ] arrpos . sort ( key = lambda it : it [ 1 ] ) vis = { k : False for k in range ( n ) } ans = 0 for i in range ( n ) : if vis [ i ] or arrpos [ i ] [ 0 ] == i : continue cycle_size = 0 j = i while not vis [ j ] : vis [ j ] = True j = arrpos [ j ] [ 0 ] cycle_size += 1 if cycle_size > 0 : ans += ( cycle_size - 1 ) return ans
def findLargestSumPair ( arr , n ) : if arr [ 0 ] > arr [ 1 ] : first = arr [ 0 ] second = arr [ 1 ] else : first = arr [ 1 ] second = arr [ 0 ] for i in range ( 2 , n ) : if arr [ i ] > first : second = first first = arr [ i ] elif arr [ i ] > second and arr [ i ] != first : second = arr [ i ] return ( first + second )
def minInitialPoints ( points ) : dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] m , n = R , C if points [ m - 1 ] [ n - 1 ] > 0 : dp [ m - 1 ] [ n - 1 ] = 1 else : dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 for i in range ( m - 2 , - 1 , - 1 ) : dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) for i in range ( 2 , - 1 , - 1 ) : dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) for i in range ( m - 2 , - 1 , - 1 ) : for j in range ( n - 2 , - 1 , - 1 ) : min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) return dp [ 0 ] [ 0 ]
def fill0X ( m , n ) : i , k , l = 0 , 0 , 0 r = m c = n a = [ [ None ] * n for i in range ( m ) ] x = 'X' while k < m and l < n : for i in range ( l , n ) : a [ k ] [ i ] = x k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = x n -= 1 if k < m : for i in range ( n - 1 , l - 1 , - 1 ) : a [ m - 1 ] [ i ] = x m -= 1 if l < n : for i in range ( m - 1 , k - 1 , - 1 ) : a [ i ] [ l ] = x l += 1 x = 'X' if x == '0' else '0' for i in range ( r ) : for j in range ( c ) : print ( a [ i ] [ j ] , end = "" ) print ( )
def equilibrium ( arr ) : leftsum = 0 rightsum = 0 n = len ( arr ) for i in range ( n ) : leftsum = 0 rightsum = 0 for j in range ( i ) : leftsum += arr [ j ] for j in range ( i + 1 , n ) : rightsum += arr [ j ] if leftsum == rightsum : return i return - 1
def middlesum ( mat , n ) : row_sum = 0 col_sum = 0 for i in range ( n ) : row_sum += mat [ n // 2 ] [ i ] print ( "Sumofmiddlerow=" , row_sum ) for i in range ( n ) : col_sum += mat [ i ] [ n // 2 ] print ( "Sumofmiddlecolumn=" , col_sum )
def match ( first , second ) : if len ( first ) == 0 and len ( second ) == 0 : return True if len ( first ) > 1 and first [ 0 ] == '*' and len ( second ) == 0 : return False if ( len ( first ) > 1 and first [ 0 ] == '?' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) : return match ( first [ 1 : ] , second [ 1 : ] ) ; if len ( first ) != 0 and first [ 0 ] == '*' : return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) return False
def pre_compute ( a , n , index , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n ) : if a [ i ] > a [ 0 ] : dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] else : dp [ 0 ] [ i ] = a [ i ] for i in range ( 1 , n ) : for j in range ( n ) : if a [ j ] > a [ i ] and j > i : if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return dp [ index ] [ k ]
def Add ( x , y ) : while ( y != 0 ) : carry = x & y x = x ^ y y = carry << 1 return x
def seiresSum ( n , a ) : return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) )
def printTwoElements ( arr , size ) : for i in range ( size ) : if arr [ abs ( arr [ i ] ) - 1 ] > 0 : arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] else : print ( "Therepeatingelementis" , abs ( arr [ i ] ) ) for i in range ( size ) : if arr [ i ] > 0 : print ( "andthemissingelementis" , i + 1 )
def findRoots ( a , b , c ) : if a == 0 : print ( "Invalid" ) return - 1 d = b * b - 4 * a * c sqrt_val = math . sqrt ( abs ( d ) ) if d > 0 : print ( "Rootsarerealanddifferent" ) print ( ( - b + sqrt_val ) / ( 2 * a ) ) print ( ( - b - sqrt_val ) / ( 2 * a ) ) elif d == 0 : print ( "Rootsarerealandsame" ) print ( - b / ( 2 * a ) ) else : print ( "Rootsarecomplex" ) print ( - b / ( 2 * a ) , "+i" , sqrt_val ) print ( - b / ( 2 * a ) , "-i" , sqrt_val )
def arekAnagrams ( str1 , str2 , k ) : n = len ( str1 ) if ( len ( str2 ) != n ) : return False count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR for i in range ( n ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 count = 0 for i in range ( MAX_CHAR ) : if ( count1 [ i ] > count2 [ i ] ) : count = count + abs ( count1 [ i ] - count2 [ i ] ) return ( count <= k )
