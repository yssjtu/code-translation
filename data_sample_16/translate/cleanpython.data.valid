def count ( n ) : if ( n < 4 ) : return - 1 rem = n % 4 if ( rem == 0 ) : return n // 4 if ( rem == 1 ) : if ( n < 9 ) : return - 1 return ( n - 9 ) // 4 + 1 if ( rem == 2 ) : return ( n - 6 ) // 4 + 1 if ( rem == 3 ) : if ( n < 15 ) : return - 1 return ( n - 15 ) // 4 + 2
def twoWaySort ( arr , n ) : for i in range ( 0 , n ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1 arr . sort ( ) for i in range ( 0 , n ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1
def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : swapped = False for j in range ( 0 , n - i - 1 ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] swapped = True if swapped == False : break
def printEqualSumSets ( arr , n ) : sum_array = sum ( arr ) if ( sum_array & 1 ) : print ( "-1" ) return k = sum_array >> 1 dp = np . zeros ( ( n + 1 , k + 1 ) ) for i in range ( 1 , k + 1 ) : dp [ 0 ] [ i ] = False for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : for currSum in range ( 1 , k + 1 ) : dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) set1 , set2 = [ ] , [ ] if ( not dp [ n ] [ k ] ) : print ( "-1" ) return i = n currSum = k while ( i > 0 and currSum >= 0 ) : if ( dp [ i - 1 ] [ currSum ] ) : i -= 1 set2 . append ( arr [ i ] ) elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) : i -= 1 currSum -= arr [ i ] set1 . append ( arr [ i ] ) print ( "Set1elements:" , end = "" ) for i in range ( len ( set1 ) ) : print ( set1 [ i ] , end = "" ) print ( "\nSet2elements:" , end = "" ) for i in range ( len ( set2 ) ) : print ( set2 [ i ] , end = "" )
def nextWord ( s ) : if ( s == "" ) : return "a" i = len ( s ) - 1 while ( s [ i ] == 'z' and i >= 0 ) : i -= 1 if ( i == - 1 ) : s = s + 'a' else : s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) return s
def addOne ( x ) : m = 1 while ( x & m ) : x = x ^ m m <<= 1 x = x ^ m return x
def direction ( R , C ) : if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if R == C and R % 2 != 0 and C % 2 != 0 : print ( "Right" ) return if R == C and R % 2 == 0 and C % 2 == 0 : print ( "Left" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return
def calc_Expectation ( a , n ) : prb = 1 / n sum = 0 for i in range ( 0 , n ) : sum += ( a [ i ] * prb ) return float ( sum )
def maxSubArraySum ( a , size ) : max_so_far = - maxint - 1 max_ending_here = 0 for i in range ( 0 , size ) : max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if max_ending_here < 0 : max_ending_here = 0 return max_so_far
def numofAP ( a , n ) : minarr = + 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( minarr , a [ i ] ) maxarr = max ( maxarr , a [ i ] ) dp = [ 0 for i in range ( n + 1 ) ] ans = n + 1 for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : sum = [ 0 for i in range ( MAX + 1 ) ] for i in range ( n ) : dp [ i ] = 1 if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : dp [ i ] += sum [ a [ i ] - d ] ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] return ans
def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 for i in range ( 0 , n - 1 ) : sum = - 1 if ( arr [ i ] == 0 ) else 1 for j in range ( i + 1 , n ) : sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 if ( sum == 0 and maxsize < j - i + 1 ) : maxsize = j - i + 1 startindex = i if ( maxsize == - 1 ) : print ( "Nosuchsubarray" ) else : print ( startindex , "to" , startindex + maxsize - 1 ) return maxsize
def longestRepeatedSubSeq ( str ) : n = len ( str ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) res = '' i = n j = n while ( i > 0 and j > 0 ) : if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : res += str [ i - 1 ] i -= 1 j -= 1 elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : i -= 1 else : j -= 1 res = '' . join ( reversed ( res ) ) return res
def maxProduct ( arr , n ) : if ( n < 2 ) : print ( "Nopairsexists" ) return a = arr [ 0 ] b = arr [ 1 ] for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] * arr [ j ] > a * b ) : a = arr [ i ] b = arr [ j ] print ( "Maxproductpairis{" , a , "," , b , "}" , sep = "" )
def nonDecNums ( n ) : a = np . zeros ( ( n + 1 , 10 ) ) for i in range ( 10 ) : a [ 0 ] [ i ] = 1 for i in range ( 1 , n + 1 ) : a [ i ] [ 9 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( 8 , - 1 , - 1 ) : a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] return int ( a [ n ] [ 0 ] )
def findSmallestRange ( arr , n , k ) : i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 for i in range ( k + 1 ) : ptr [ i ] = 0 minrange = 10 ** 9 while ( 1 ) : minind = - 1 minval = 10 ** 9 maxval = - 10 ** 9 flag = 0 for i in range ( k ) : if ( ptr [ i ] == n ) : flag = 1 break if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : minind = i minval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] if ( flag ) : break ptr [ minind ] += 1 if ( ( maxval - minval ) < minrange ) : minel = minval maxel = maxval minrange = maxel - minel print ( "Thesmallestrangeis[" , minel , maxel , "]" )
def policeThief ( arr , n , k ) : i = 0 l = 0 r = 0 res = 0 thi = [ ] pol = [ ] while i < n : if arr [ i ] == 'P' : pol . append ( i ) elif arr [ i ] == 'T' : thi . append ( i ) i += 1 while l < len ( thi ) and r < len ( pol ) : if ( abs ( thi [ l ] - pol [ r ] ) <= k ) : res += 1 l += 1 r += 1 elif thi [ l ] < pol [ r ] : l += 1 else : r += 1 return res
