def maxcoefficientvalue ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n + 1 ) : for j in range ( min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) maxvalue = 0 for i in range ( n + 1 ) : maxvalue = max ( maxvalue , C [ n ] [ i ] ) return maxvalue
def canMakeStr2 ( s1 , s2 ) : count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } for i in range ( len ( s1 ) ) : count [ s1 [ i ] ] += 1 for i in range ( len ( s2 ) ) : if count [ s2 [ i ] ] == 0 : return False count [ s2 [ i ] ] -= 1 return True
def multiplyWith3Point5 ( x ) : return ( x << 1 ) + x + ( x >> 1 )
def findDivision ( str , a , b ) : lenn = len ( str ) lr = [ 0 ] * ( lenn + 1 ) lr [ 0 ] = ( int ( str [ 0 ] ) ) % a for i in range ( 1 , lenn ) : lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str [ i ] ) ) % a rl = [ 0 ] * ( lenn + 1 ) rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b power10 = 10 for i in range ( lenn - 2 , - 1 , - 1 ) : rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b power10 = ( power10 * 10 ) % b for i in range ( 0 , lenn - 1 ) : if ( lr [ i ] != 0 ) : continue if ( rl [ i + 1 ] == 0 ) : print ( "YES" ) for k in range ( 0 , i + 1 ) : print ( str [ k ] , end = "" ) print ( "," , end = "" ) for i in range ( i + 1 , lenn ) : print ( str [ k ] , end = "" ) return print ( "NO" )
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , m + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 if ( cnt [ i ] [ j ] >= k ) : for a in range ( k , cnt [ i ] [ j ] + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) return lcs [ n ] [ m ]
def check ( num ) : digitSum = 0 while num > 0 : rem = num % 10 digitSum = digitSum + rem num = num // 10 return ( digitSum % 3 == 0 )
def printDivisors ( n ) : list = [ ] for i in range ( 1 , int ( math.sqrt ( n ) + 1 ) ) : if ( n % i == 0 ) : if ( n / i == i ) : print ( i , end = "" ) else : print ( i , end = "" ) list.append ( int ( n / i ) ) for i in list [ : : - 1 ] : print ( i , end = "" )
def findSum ( n ) : multiTerms = n * ( n + 1 ) // 2 sm = multiTerms for i in range ( 2 , n + 1 ) : multiTerms = multiTerms - ( i - 1 ) sm = sm + multiTerms * i return sm
def modFact ( n , p ) : if n >= p : return 0 result = 1 for i in range ( 1 , n + 1 ) : result = ( result * i ) % p return result
def psuedoBinary ( n ) : while ( n > 0 ) : temp = n m = 0 p = 1 while ( temp ) : rem = temp % 10 temp = int ( temp / 10 ) if ( rem != 0 ) : m += p p *= 10 print ( m , end = "" ) n = n - m
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]
def findMaxAverage ( arr , n , k ) : if k > n : return - 1 csum = [ 0 ] * n csum [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : csum [ i ] = csum [ i - 1 ] + arr [ i ] max_sum = csum [ k - 1 ] max_end = k - 1 for i in range ( k , n ) : curr_sum = csum [ i ] - csum [ i - k ] if curr_sum > max_sum : max_sum = curr_sum max_end = i return max_end - k + 1
def maxDiff ( arr , n ) : result = 0 arr.sort ( ) for i in range ( n - 1 ) : if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : result += abs ( arr [ i ] ) else : pass if ( arr [ n - 2 ] != arr [ n - 1 ] ) : result += abs ( arr [ n - 1 ] ) return result
def transpose ( A , B ) : for i in range ( N ) : for j in range ( N ) : B [ i ] [ j ] = A [ j ] [ i ]
def stoogesort ( arr , l , h ) : if l >= h : return if arr [ l ] > arr [ h ] : t = arr [ l ] arr [ l ] = arr [ h ] arr [ h ] = t if h - l + 1 > 2 : t = ( int ) ( ( h - l + 1 ) / 3 ) stoogesort ( arr , l , ( h - t ) ) stoogesort ( arr , l + t , ( h ) ) stoogesort ( arr , l , ( h - t ) )
def find3Numbers ( A , arr_size , sum ) : A.sort ( ) for i in range ( 0 , arr_size - 2 ) : l = i + 1 r = arr_size - 1 while ( l < r ) : if ( A [ i ] + A [ l ] + A [ r ] == sum ) : print ( "Tripletis" , A [ i ] , ',' , A [ l ] , ',' , A [ r ] ) return True elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : l += 1 else : r -= 1 return False
def solveQuery ( start , end , arr ) : frequency = dict ( ) for i in range ( start , end + 1 ) : if arr [ i ] in frequency.keys ( ) : frequency [ arr [ i ] ] += 1 else : frequency [ arr [ i ] ] = 1 count = 0 for x in frequency : if x == frequency [ x ] : count += 1 return count
def maxSum ( arr , n ) : res = - sys.maxsize for i in range ( 0 , n ) : curr_sum = 0 for j in range ( 0 , n ) : index = int ( ( i + j ) % n ) curr_sum += j * arr [ index ] res = max ( res , curr_sum ) return res
def modularSum ( arr , n , m ) : if ( n > m ) : return True DP = [ False for i in range ( m ) ] for i in range ( n ) : if ( DP [ 0 ] ) : return True temp = [ False for i in range ( m ) ] for j in range ( m ) : if ( DP [ j ] == True ) : if ( DP [ ( j + arr [ i ] ) % m ] == False ) : temp [ ( j + arr [ i ] ) % m ] = True for j in range ( m ) : if ( temp [ j ] ) : DP [ j ] = True DP [ arr [ i ] % m ] = True return DP [ 0 ]
def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24
def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count
def getInvCount ( arr ) : n = len ( arr ) invcount = 0 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if arr [ i ] > arr [ j ] : for k in range ( j + 1 , n ) : if arr [ j ] > arr [ k ] : invcount += 1 return invcount
def checkcircle ( r , R , r1 , x1 , y1 ) : dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) ) return ( dis - r1 >= R and dis + r1 <= r )
def noAdjacentDup ( s ) : n = len ( s ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = "a" while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 return s
def minCoins ( coins , m , V ) : if ( V == 0 ) : return 0 res = sys.maxsize for i in range ( 0 , m ) : if ( coins [ i ] <= V ) : sub_res = minCoins ( coins , m , V - coins [ i ] ) if ( sub_res != sys.maxsize and sub_res + 1 < res ) : res = sub_res + 1 return res
def reverseFibonacci ( n ) : a = [ 0 ] * n a [ 0 ] = 0 a [ 1 ] = 1 for i in range ( 2 , n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] for i in range ( n - 1 , - 1 , - 1 ) : print ( a [ i ] , end = "" )
def sumOfSubstrings ( num ) : n = len ( num ) sumofdigit = [ ] sumofdigit.append ( int ( num [ 0 ] ) ) res = sumofdigit [ 0 ] for i in range ( 1 , n ) : numi = int ( num [ i ] ) sumofdigit.append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) res += sumofdigit [ i ] return res
def generate ( st , s ) : if len ( s ) == 0 : return if s not in st : st.add ( s ) for i in range ( len ( s ) ) : t = list ( s ).copy ( ) t.remove ( s [ i ] ) t = ''.join ( t ) generate ( st , t ) return
def longDivision ( number , divisor ) : ans = "" idx = 0 temp = ord ( number [ idx ] ) - ord ( '0' ) while ( temp < divisor ) : temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) idx += 1 idx += 1 while ( ( len ( number ) ) > idx ) : ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) ) temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) idx += 1 ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) ) if ( len ( ans ) == 0 ) : return "0" return ans
def countSubsequence ( s , n ) : cntG = 0 cntF = 0 result = 0 C = 0 for i in range ( n ) : if ( s [ i ] == 'G' ) : cntG += 1 result += C continue if ( s [ i ] == 'F' ) : cntF += 1 C += cntG continue else : continue print ( result )
def areaOctagon ( side ) : return ( 2 * ( 1 + ( math.sqrt ( 2 ) ) ) * side * side )
def maxXOR ( mat , N ) : max_xor = 0 for i in range ( N ) : r_xor = 0 c_xor = 0 for j in range ( N ) : r_xor = r_xor ^ mat [ i ] [ j ] c_xor = c_xor ^ mat [ j ] [ i ] if ( max_xor < max ( r_xor , c_xor ) ) : max_xor = max ( r_xor , c_xor ) return max_xor
