def maxRemoval ( arr , n ) : count = 0 cummulative_sum = 0 arr.sort ( ) for i in range ( n ) : if arr [ i ] >= cummulative_sum : count += 1 cummulative_sum += arr [ i ] return count
def calculate ( N ) : length = len ( N ) l = int ( ( length ) / 2 ) count = 0 for i in range ( l + 1 ) : s = N [ 0 : 0 + i ] l1 = len ( s ) t = N [ i : l1 + i ] try : if s [ 0 ] == '0' or t [ 0 ] == '0' : continue except : continue if s == t : count += 1 return count
def worstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : wstIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if wstIdx == - 1 : wstIdx = j elif blockSize [ wstIdx ] < blockSize [ j ] : wstIdx = j if wstIdx != - 1 : allocation [ i ] = wstIdx blockSize [ wstIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )
def minJumps ( a , b , d ) : temp = a a = min ( a , b ) b = max ( temp , b ) if ( d >= b ) : return ( d + b - 1 ) / b if ( d == 0 ) : return 0 if ( d == a ) : return 1 return 2
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def calculate ( a , n ) : a.sort ( ) s = [ ] i = 0 j = n - 1 while ( i < j ) : s.append ( ( a [ i ] + a [ j ] ) ) i += 1 j -= 1 mini = min ( s ) maxi = max ( s ) return abs ( maxi - mini )
def find_difference ( arr , n , m ) : max = 0 min = 0 arr.sort ( ) j = n - 1 for i in range ( m ) : min += arr [ i ] max += arr [ j ] j = j - 1 return ( max - min )
def countDistictSubarray ( arr , n ) : vis = dict ( ) for i in range ( n ) : vis [ arr [ i ] ] = 1 k = len ( vis ) vid = dict ( ) ans = 0 right = 0 window = 0 for left in range ( n ) : while ( right < n and window < k ) : if arr [ right ] in vid.keys ( ) : vid [ arr [ right ] ] += 1 else : vid [ arr [ right ] ] = 1 if ( vid [ arr [ right ] ] == 1 ) : window += 1 right += 1 if ( window == k ) : ans += ( n - right + 1 ) vid [ arr [ left ] ] -= 1 if ( vid [ arr [ left ] ] == 0 ) : window -= 1 return ans
def minCost ( cost , m , n ) : tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , m + 1 ) : tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , n + 1 ) : tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return tc [ m ] [ n ]
def kthNonRepeating ( str , k ) : n = len ( str ) count = [ 0 ] * MAX_CHAR index = [ 0 ] * MAX_CHAR for i in range ( MAX_CHAR ) : count [ i ] = 0 index [ i ] = n for i in range ( n ) : x = str [ i ] count [ ord ( x ) ] += 1 if ( count [ ord ( x ) ] == 1 ) : index [ ord ( x ) ] = i if ( count [ ord ( x ) ] == 2 ) : index [ ord ( x ) ] = n index.sort ( ) return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1
def countDivisibles ( arr , n ) : res = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : res += 1 return res
def pairsInSortedRotated ( arr , n , x ) : for i in range ( n ) : if arr [ i ] > arr [ i + 1 ] : break l = ( i + 1 ) % n r = i cnt = 0 while ( l != r ) : if arr [ l ] + arr [ r ] == x : cnt += 1 if l == ( r - 1 + n ) % n : return cnt l = ( l + 1 ) % n r = ( r - 1 + n ) % n elif arr [ l ] + arr [ r ] < x : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return cnt
def FirstRepeated ( string ) : checker = 0 pos = 0 for i in string : val = ord ( i ) - ord ( 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) : return pos checker |= ( 1 << val ) pos += 1 return - 1
def isSubSequence ( string1 , string2 , m , n ) : if m == 0 : return True if n == 0 : return False if string1 [ m - 1 ] == string2 [ n - 1 ] : return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) return isSubSequence ( string1 , string2 , m , n - 1 )
def findElements ( arr , n ) : first = - sys.maxsize second = - sys.maxsize for i in range ( 0 , n ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] for i in range ( 0 , n ) : if ( arr [ i ] < second ) : print ( arr [ i ] , end = "" )
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]
def maximumPalinUsingKChanges ( strr , k ) : palin = strr l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( strr [ l ] != strr [ r ] ) : palin [ l ] = palin [ r ] = max ( strr [ l ] , strr [ r ] ) k -= 1 l += 1 r -= 1 if ( k < 0 ) : return "Notpossible" l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( l == r ) : if ( k > 0 ) : palin [ l ] = '9' if ( palin [ l ] < '9' ) : if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : k -= 1 palin [ l ] = palin [ r ] = '9' elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : k -= 1 palin [ l ] = palin [ r ] = '9' l += 1 r -= 1 return palin
def getMinDiff ( arr , n , k ) : if ( n == 1 ) : return 0 arr.sort ( ) ans = arr [ n - 1 ] - arr [ 0 ] small = arr [ 0 ] + k big = arr [ n - 1 ] - k if ( small > big ) : small , big = big , small for i in range ( 1 , n - 1 ) : subtract = arr [ i ] - k add = arr [ i ] + k if ( subtract >= small or add <= big ) : continue if ( big - subtract <= add - small ) : small = subtract else : big = add return min ( ans , big - small )
def breakSum ( n ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) return dp [ n ]
def search ( arr , n , x ) : i = 0 for i in range ( i , n ) : if ( arr [ i ] == x ) : return i return - 1
def PrintMinNumberForPattern ( arr ) : curr_max = 0 last_entry = 0 i = 0 while i < len ( arr ) : noOfNextD = 0 if arr [ i ] == "I" : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 if i == 0 : curr_max = noOfNextD + 2 last_entry += 1 print ( "" , last_entry , end = "" ) print ( "" , curr_max , end = "" ) last_entry = curr_max else : curr_max += noOfNextD + 1 last_entry = curr_max print ( "" , last_entry , end = "" ) for k in range ( noOfNextD ) : last_entry -= 1 print ( "" , last_entry , end = "" ) i += 1 elif arr [ i ] == "D" : if i == 0 : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 curr_max = noOfNextD + 2 print ( "" , curr_max , curr_max - 1 , end = "" ) last_entry = curr_max - 1 else : print ( "" , last_entry - 1 , end = "" ) last_entry -= 1 i += 1 print ( )
def singleNumber ( nums ) : return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2
def recSearch ( arr , l , r , x ) : if r < l : return - 1 if arr [ l ] == x : return l if arr [ r ] == x : return r return recSearch ( arr , l + 1 , r - 1 , x )
def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( y2 - y1 ) slope_error_new = m_new - ( x2 - x1 ) y = y1 for x in range ( x1 , x2 + 1 ) : print ( "(" , x , "," , y , ")\n" ) slope_error_new = slope_error_new + m_new if ( slope_error_new >= 0 ) : y = y + 1 slope_error_new = slope_error_new - 2 * ( x2 - x1 )
def countSeq ( n , diff ) : if ( abs ( diff ) > n ) : return 0 if ( n == 1 and diff == 0 ) : return 2 if ( n == 1 and abs ( diff ) == 1 ) : return 1 res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) return res
def slope ( x1 , y1 , x2 , y2 ) : return ( float ) ( y2 - y1 ) / ( x2 - x1 )
def findLastIndex ( str , x ) : for i in range ( len ( str ) - 1 , - 1 , - 1 ) : if ( str [ i ] == x ) : return i return - 1
def productArray ( arr , n ) : if n == 1 : print ( 0 ) return i , temp = 1 , 1 prod = [ 1 for i in range ( n ) ] for i in range ( n ) : prod [ i ] = temp temp *= arr [ i ] temp = 1 for i in range ( n - 1 , - 1 , - 1 ) : prod [ i ] *= temp temp *= arr [ i ] for i in range ( n ) : print ( prod [ i ] , end = "" ) return
def maxLength ( s , n ) : invalidOpenBraces = 0 invalidCloseBraces = 0 for i in range ( n ) : if ( s [ i ] == '(' ) : invalidOpenBraces += 1 else : if ( invalidOpenBraces == 0 ) : invalidCloseBraces += 1 else : invalidOpenBraces -= 1 return ( n - ( invalidOpenBraces + invalidCloseBraces ) )
def search ( arr , n , x , k ) : i = 0 while ( i < n ) : if ( arr [ i ] == x ) : return i i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) print ( "numberisnotpresent!" ) return - 1
def compute_average ( a , b ) : return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 )
def zigzag ( n , k ) : dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 1 , n + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) return dp [ n ] [ k ]
