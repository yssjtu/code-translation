static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " " ) ; }
static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) { j ++ ; i ++ ; } else if ( arr1 [ j ] > arr2 [ i ] ) return false ; } if ( i < n ) return false ; else return true ; }
static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
static void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " " ) ; }
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ; }
static int MinOperation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
static double nthRoot ( int A , int N ) { double xPre = Math . random ( ) % 10 ; double eps = 0.001 ; double delX = 2147483647 ; double xK = 0.0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
static int minTime ( int n , int k , int a [ ] ) { int temp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) { temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } } } int minTime = 0 ; for ( int i = 0 ; i < n ; i += k ) minTime += ( 2 * a [ i ] ) ; return minTime ; }
static int maximumSum ( int a [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a , i , n ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }
static long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; }
static boolean isPossible ( String str , int n ) { int len = str . length ( ) ; if ( len >= n ) return true ; return false ; }
static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = "" ; String anticlock_rot = "" ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ; return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ; }
static int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 }; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
static void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " -- " + next ) ; } }
static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = Integer . MAX_VALUE ; int x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }
static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + " " ) ; }
static int minXOR ( int arr [ ] , int n ) { Arrays . parallelSort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
public static int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
static boolean isMagicSquare ( int mat [ ] [ ] ) { int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( sum != colSum ) return false ; } return true ; }
static int countPS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( ( i - j == 1 ) || ( i - j == - 1 ) ) { if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = 3 ; else return dp [ i ] [ j ] = 2 ; } if ( i == j ) return dp [ 1 ] [ j ] = 1 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }
public static float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
static void KMP ( int m , int n , String str2 , String str1 ) { int pos = 0 , len = 0 ; int [ ] p = new int [ m + 1 ] ; int k = 0 ; char [ ] ch1 = str1 . toCharArray ( ) ; char [ ] ch2 = str2 . toCharArray ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] ; if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p [ j ] ; if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } System . out . println ( "Shift = " + pos ) ; System . out . println ( "Prefix = " + str1 . substring ( 0 , len ) ) ; }
static int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
static int evaluateBoolExpr ( StringBuffer s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s . charAt ( i + 1 ) == 'A' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == 'B' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . setCharAt ( i + 2 , '1' ) ; else s . setCharAt ( i + 2 , '0' ) ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } } } return s . charAt ( n - 1 ) - '0' ; }
static int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
static int maxLen ( int arr [ ] , int n ) { int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ; } } return max_len ; }
public static void kLargest ( Integer [ ] arr , int k ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
static int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( "Touch" ) ; else if ( radius > dist ) System . out . println ( "Intersect" ) ; else System . out . println ( "Outside" ) ; }
static boolean canFormPalindrome ( String str ) { int count [ ] = new int [ NO_OF_CHARS ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
static void swapUpperToLower ( int arr [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }
static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ; }
static void reverseStr ( String str ) { int n = str . length ( ) ; char [ ] ch = str . toCharArray ( ) ; char temp ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; } System . out . println ( ch ) ; }
static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
static long squareRoot ( int n ) { int x = n ; int y = 1 ; while ( x > y ) { x = ( x + y ) / 2 ; y = n / x ; } return ( long ) x ; }
public static void countCurrency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 }; int [ ] noteCounter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } System . out . println ( "Currency Count ->" ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { System . out . println ( notes [ i ] + " : " + noteCounter [ i ] ) ; } } }
static String longDivision ( String number , int divisor ) { String ans = "" ; int idx = 0 ; char [ ] num = number . toCharArray ( ) ; int temp = num [ idx ] - '0' ; while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ; idx += 1 ; while ( num . length > idx ) { ans += ( temp / divisor ) ; temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; }
public static int playGame ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i : arr ) set . add ( i ) ; return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ; }
static int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }
static int possibleWays ( int n , int m , int k ) { int [ ] [ ] dp = new int [ N ] [ N ] ; int [ ] [ ] presum = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; presum [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = 0 ; presum [ 0 ] [ i ] = 1 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ; if ( j > k ) { dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ; } } for ( int j = 1 ; j < n + 1 ; j ++ ) { presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
static void shiftMatrixByK ( int [ ] [ ] mat , int k ) { if ( k > N ) { System . out . print ( "Shifting is" + " not possible" ) ; return ; } int j = 0 ; while ( j < N ) { for ( int i = k ; i < N ; i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ; System . out . println ( ) ; j ++ ; } }
static long exponentiation ( long base , long exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return base % N ; long t = exponentiation ( base , exp / 2 ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( base % N ) * t ) % N ; }
static void bestApproximate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; System . out . println ( "m = " + m ) ; System . out . println ( "c = " + c ) ; }
public static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . length ( ) ; k ++ ) { String s1 = "" , s2 = "" , s3 = "" , s4 = "" ; try { s1 = s . substring ( 0 , i ) ; s2 = s . substring ( i , j - i ) ; s3 = s . substring ( j , k - j ) ; s4 = s . substring ( k , s . length ( ) - k ) ; } catch ( StringIndexOutOfBoundsException e ) { } if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) && strcheck ( s1 , s4 ) && strcheck ( s2 , s3 ) && strcheck ( s2 , s4 ) && strcheck ( s3 , s4 ) ) return true ; } } } return false ; }
static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
static int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }
static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }
static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
static int sumNodes ( int l ) { int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ; Vector < Vector < Integer >> vec = new Vector < Vector < Integer >> ( ) ; for ( int i = 1 ; i <= l ; i ++ ) vec . add ( new Vector < Integer > ( ) ) ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec . get ( l - 1 ) . add ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) { vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) + vec . get ( i + 1 ) . get ( k + 1 ) ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec . get ( i ) . size ( ) ; j ++ ) sum += vec . get ( i ) . get ( j ) ; } return sum ; }
static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
static boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
static Boolean subArrayExists ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 || sum == 0 || hM . get ( sum ) != null ) return true ; hM . put ( sum , i ) ; } return false ; }
static int largestSubset ( int [ ] a , int n ) { Arrays . sort ( a ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; }
static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
static int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int [ ] mark = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( mark [ i ] == 0 ) count ++ ; return count ; }
static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }
boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
static String decimalToBinary ( double num , int k_prec ) { String binary = "" ; int Integral = ( int ) num ; double fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += ( ( char ) ( rem + '0' ) ) ; Integral /= 2 ; } binary = reverse ( binary ) ; binary += ( '.' ) ; while ( k_prec -- > 0 ) { fractional *= 2 ; int fract_bit = ( int ) fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary += ( char ) ( 1 + '0' ) ; } else { binary += ( char ) ( 0 + '0' ) ; } } return binary ; }
static void shufleArray ( int a [ ] , int f , int l ) { if ( l > f ) return ; if ( l - f == 1 ) return ; int mid = ( f + l ) / 2 ; int temp = mid + 1 ; int mmid = ( f + mid ) / 2 ; for ( int i = mmid + 1 ; i <= mid ; i ++ ) { int temp1 = a [ i ] ; a [ i ] = a [ temp ] ; a [ temp ++ ] = temp1 ; } shufleArray ( a , f , mid ) ; shufleArray ( a , mid + 1 , l ) ; }
static int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
static int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k ) ; } System . out . println ( "number is " + "not present!" ) ; return - 1 ; }
static boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
static int findRepeatingNumber ( int [ ] arr , int n ) { int sq = ( int ) Math . sqrt ( n ) ; int range = ( n / sq ) + 1 ; int [ ] count = new int [ range ] ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m . put ( arr [ i ] , 1 ) ; if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; } } return - 1 ; }
static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
static void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { System . out . println ( "Overflow" ) ; } else { System . out . println ( "Not in overflow state" ) ; } }
static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
static long count_of_ways ( long n ) { long count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) count ++ ; return count ; }
static int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
static int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
static char findExtraCharcter ( String strA , String strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA . charAt ( i ) ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB . charAt ( i ) ; } return ( ( char ) ( res ) ) ; }
static long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int prod [ ] = new int [ n ] ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) prod [ i ] = left [ i ] * right [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " " ) ; return ; }
public static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
boolean canRepresentBST ( int pre [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; int root = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( pre [ i ] < root ) { return false ; } while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) { root = s . peek ( ) ; s . pop ( ) ; } s . push ( pre [ i ] ) ; } return true ; }
static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
public static void findFibSubset ( Integer [ ] x ) { Integer max = Collections . max ( Arrays . asList ( x ) ) ; List < Integer > fib = new ArrayList < Integer > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; Integer a = 0 ; Integer b = 1 ; while ( b < max ) { Integer c = a + b ; a = b ; b = c ; fib . add ( c ) ; } for ( Integer i = 0 ; i < x . length ; i ++ ) { if ( fib . contains ( x [ i ] ) ) { result . add ( x [ i ] ) ; } } System . out . println ( result ) ; }
static float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
public static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
static void modularEquation ( int a , int b ) { if ( a < b ) { System . out . println ( "No solution possible " ) ; return ; } if ( a == b ) { System . out . println ( "Infinite Solution possible " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; }
static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
static int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + " " ) ; if ( n >= 1 ) System . out . print ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { System . out . print ( a + b + " " ) ; b = a + b ; a = b - a ; } }
static boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
static int minCost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " Invalid Input " ) ; return ; } int first = arr [ 0 ] , second = Integer . MIN_VALUE , third = Integer . MIN_VALUE ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } System . out . printf ( "The third Largest element is %d\n" , third ) ; }
static boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
static int minTime ( int [ ] arr , int n , int m ) { int t = 0 ; while ( true ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }
static void printMaxOfMin ( int n ) { Stack < Integer > s = new Stack < > ( ) ; int left [ ] = new int [ n + 1 ] ; int right [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ; s . push ( i ) ; } int ans [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }
static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
static boolean isMajority ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; else mp . put ( a [ i ] , 1 ) ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ; return false ; }
static int maxProfit ( int price [ ] , int n , int k ) { int profit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }
static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( "Minimal Value = " + smallest ) ; System . out . println ( "Total Pairs = " + count ) ; }
public static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
static int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
static String firstLetterWord ( String str ) { String result = "" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ' ) { v = true ; } else if ( str . charAt ( i ) != ' ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; }
static int findMaxSegment ( String s , int k ) { int seg_len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_len ; i ++ ) res = res * 10 + ( s . charAt ( i ) - '0' ) ; int seg_len_pow = ( int ) Math . pow ( 10 , seg_len - 1 ) ; int curr_val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_len ) ; i ++ ) { curr_val = curr_val - ( s . charAt ( i - 1 ) - '0' ) * seg_len_pow ; curr_val = curr_val * 10 + ( s . charAt ( i + seg_len - 1 ) - '0' ) ; res = Math . max ( res , curr_val ) ; } return res ; }
static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) if ( arr2 [ i ] == arr1 [ j ] ) break ; if ( j == m ) return false ; } return true ; }
static int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }
static void deleteElements ( int arr [ ] , int n , int k ) { Stack < Integer > s = new Stack < > ( ) ; s . push ( arr [ 0 ] ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . push ( arr [ i ] ) ; } int m = s . size ( ) ; Integer [ ] v = new Integer [ m ] ; while ( ! s . empty ( ) ) { v [ -- m ] = s . peek ( ) ; s . pop ( ) ; } for ( Integer x : v ) { System . out . print ( x + "" ) ; }; System . out . println ( "" ) ; }
static void leafNode ( int preorder [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { boolean found = false ; if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ) ; else { while ( ! s . isEmpty ( ) ) { if ( preorder [ j ] > s . peek ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) System . out . print ( preorder [ i ] + " " ) ; } System . out . println ( preorder [ n - 1 ] ) ; }
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }
static void arrangeString ( String str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { System . out . print ( "0" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { System . out . print ( "1" ) ; count_1 -- ; } } } }
static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
static int compute_average ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }
static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; double r = 6371 ; return ( c * r ) ; }
static void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " " ) ; }
static boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 . charAt ( i ) - 'a' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 . charAt ( i ) - 'a' ] > 0 ) hash_str1 [ str2 . charAt ( i ) - 'a' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( f2 + " " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
public static int minSwaps ( int [ ] arr ) { int n = arr . length ; ArrayList < Pair < Integer , Integer >> arrpos = new ArrayList < Pair < Integer , Integer >> ( ) ; for ( int i = 0 ; i < n ; i ++ ) arrpos . add ( new Pair < Integer , Integer > ( arr [ i ] , i ) ) ; arrpos . sort ( new Comparator < Pair < Integer , Integer >> ( ) { @ Override public int compare ( Pair < Integer , Integer > o1 , Pair < Integer , Integer > o2 ) { if ( o1 . getKey ( ) > o2 . getKey ( ) ) return - 1 ; else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) ) ) return 0 ; else return 1 ; } } ) ; Boolean [ ] vis = new Boolean [ n ] ; Arrays . fill ( vis , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos . get ( i ) . getValue ( ) == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos . get ( j ) . getValue ( ) ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; }
static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
public static int checkValidity ( int a , int b , int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ; else return 1 ; }
static void PerformQueries ( int [ ] a , int [ ] [ ] vec ) { Vector < Integer > ans = new Vector < > ( ) ; int n = ( int ) a . length - 1 ; int q = ( int ) vec . length ; for ( int i = 0 ; i < q ; ++ i ) { long t = vec [ i ] [ 0 ] ; int m = vec [ i ] [ 1 ] ; if ( m > n ) { ans . add ( - 1 ) ; continue ; } int turn = ( int ) ( t / n ) ; int rem = ( int ) ( t % n ) ; if ( rem == 0 && turn % 2 == 1 ) { ans . add ( - 1 ) ; continue ; } if ( rem == 0 && turn % 2 == 0 ) { ans . add ( a [ m ] ) ; continue ; } if ( turn % 2 == 0 ) { int cursize = n - rem ; if ( cursize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m + rem ] ) ; } else { int cursize = rem ; if ( cursize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m ] ) ; } } for ( int i : ans ) System . out . print ( i + "\n" ) ; }
static int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) odd_count ++ ; if ( ( n & 2 ) != 0 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ; }
static double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
static int editDistDP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
static int countWays ( int n ) { int table [ ] = new int [ n + 1 ] ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; return table [ n ] ; }
static int minSum ( int [ ] A , int n ) { int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return ( min_val * ( n - 1 ) ) ; }
static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }
static int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - 'a' ] ++ ; } if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }
static void sortArray ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int index = - 1 ; int maximum = - 999999 ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int [ ] new_arr = new int [ n ] ; int k = 0 ; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ] ; else new_arr [ k ++ ] = arr [ j -- ] ; } while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ; while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ; new_arr [ n - 1 ] = maximum ; for ( int p = 0 ; p < n ; p ++ ) arr [ p ] = new_arr [ p ] ; }
public static long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( "Repeated elements are : " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }
int fib ( int n ) { if ( lookup [ n ] == NIL ) { if ( n <= 1 ) lookup [ n ] = n ; else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; } return lookup [ n ] ; }
static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
static float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }
static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; Stack < Integer > right_bnum = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == '(' ) { System . out . print ( left_bnum + " " ) ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ')' ) { System . out . print ( right_bnum . peek ( ) + " " ) ; right_bnum . pop ( ) ; } } }
private static int minJumps ( int [ ] arr , int n ) { int jumps [ ] = new int [ n ] ; int i , j ; if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE ; jumps [ 0 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) { jumps [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX_VALUE ) { jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } } return jumps [ n - 1 ] ; }
static void findDimen ( int H , int A ) { if ( H * H < 4 * A ) { System . out . println ( "Not Possible" ) ; return ; } double apb = Math . sqrt ( H * H + 4 * A ) ; double asb = Math . sqrt ( H * H - 4 * A ) ; System . out . println ( "P = " + Math . round ( ( ( apb - asb ) / 2.0 ) * 100.0 ) / 100.0 ) ; System . out . print ( "B = " + Math . round ( ( ( apb + asb ) / 2.0 ) * 100.0 ) / 100.0 ) ; }
static int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
static int countPairs ( String s ) { int cnt [ ] = new int [ MAX ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s . charAt ( i ) ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; }
static void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; int maxArr [ ] [ ] = new int [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }
static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }
static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }
public static void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = Integer . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
static int findDiff ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int max_count = 0 , min_count = n ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { max_count = Math . max ( max_count , x . getValue ( ) ) ; min_count = Math . min ( min_count , x . getValue ( ) ) ; } return ( max_count - min_count ) ; }
static int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; return res ; }
static int xorZero ( String s ) { int one_count = 0 , zero_count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
static void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case 'G' : cntG ++ ; result += C ; break ; case 'F' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; rightsum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
static void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( "" ) ; }
static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
static void alternateSubarray ( boolean arr [ ] , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { System . out . print ( count -- + " " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + " " ) ; } }
static void rearrange ( int [ ] arr , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } arr = temp . clone ( ) ; }
static void findTriplets ( int [ ] arr , int n ) { boolean found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { System . out . print ( arr [ i ] ) ; System . out . print ( " " ) ; System . out . print ( arr [ j ] ) ; System . out . print ( " " ) ; System . out . print ( arr [ k ] ) ; System . out . print ( "\n" ) ; found = true ; } } } } if ( found == false ) System . out . println ( " not exist " ) ; }
static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( "No pairs exists" ) ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } System . out . println ( "Max product pair is { " + a + ", " + b + "}" ) ; }
static void rearrange ( int arr [ ] , int n ) { int i = - 1 , temp = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) { i ++ ; temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { temp = arr [ neg ] ; arr [ neg ] = arr [ pos ] ; arr [ pos ] = temp ; pos ++ ; neg += 2 ; } }
static void reverse ( char str [ ] ) { int n = str . length , i ; for ( i = 0 ; i < n / 2 ; i ++ ) { swap ( str , i , n - i - 1 ) ; } }
static int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
public static void findPair ( int [ ] arr , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( Integer i : arr ) { s . add ( i ) ; } boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( s . contains ( sum ) ) { found = true ; System . out . println ( arr [ i ] + " " + arr [ j ] ) ; } } } if ( found == false ) System . out . println ( "Not Exist " ) ; }
static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
static int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
static boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit || 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != 'X' && ( last < '0' || last > '9' ) ) return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
static long findMinSum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
static void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }
static String compute ( String str , int n ) { String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ; int l = str . length ( ) ; String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str . charAt ( i ) ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - 'a' ) ; return answer ; }
static boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
static void alternateSort ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { System . out . print ( arr [ j -- ] + " " ) ; System . out . print ( arr [ i ++ ] + " " ) ; } if ( n % 2 != 0 ) System . out . print ( arr [ i ] ) ; }
static void printDistance ( int mat [ ] [ ] ) { int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }
static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
static void modularInverse ( int n , int prime ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }
static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
static long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; }
static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " " ) ; } }
static int findSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) ans += ( i / j ) ; return ans ; }
static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
static int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
static int countWays ( int N ) { int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; }
static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
static void minMaxLengthWords ( String input ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int min_length = len , min_start_index = 0 , max_length = 0 , max_start_index = 0 ; while ( ei <= len ) { if ( ei < len && input . charAt ( ei ) != ' ' ) { ei ++ ; } else { int curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } if ( curr_length > max_length ) { max_length = curr_length ; max_start_index = si ; } ei ++ ; si = ei ; } } minWord = input . substring ( min_start_index , min_start_index + min_length ) ; maxWord = input . substring ( max_start_index , max_length ) ; }
static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
static void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r , y = 0 ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; if ( r > 0 ) { System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . println ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; } int P = 1 - r ; while ( x > y ) { y ++ ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { x -- ; P = P + 2 * y - 2 * x + 1 ; } if ( x < y ) break ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; System . out . print ( "(" + ( - x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ; System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; System . out . println ( "(" + ( - x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ; if ( x != y ) { System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . print ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ; System . out . print ( "(" + ( y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ; System . out . println ( "(" + ( - y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ; } } }
static void firstNonRepeating ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; Queue < Character > q = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; q . add ( ch ) ; charCount [ ch - 'a' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( charCount [ q . peek ( ) - 'a' ] > 1 ) q . remove ( ) ; else { System . out . print ( q . peek ( ) + " " ) ; break ; } } if ( q . isEmpty ( ) ) System . out . print ( - 1 + " " ) ; } System . out . println ( ) ; }
public static double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
static void printRect ( Integer X [ ] , Integer Y [ ] , int n ) { int Xmax = Collections . max ( Arrays . asList ( X ) ) ; int Xmin = Collections . min ( Arrays . asList ( X ) ) ; int Ymax = Collections . max ( Arrays . asList ( Y ) ) ; int Ymin = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( "{" + Xmin + ", " + Ymin + "}" ) ; System . out . println ( "{" + Xmin + ", " + Ymax + "}" ) ; System . out . println ( "{" + Xmax + ", " + Ymax + "}" ) ; System . out . println ( "{" + Xmax + ", " + Ymin + "}" ) ; }
static void assign ( int a [ ] , int n ) { Arrays . sort ( a ) ; int ans [ ] = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ; else ans [ i ] = a [ p ++ ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }
public static boolean areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . length ; int m = arr2 . length ; if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
static boolean negCyclefloydWarshall ( int graph [ ] [ ] ) { int dist [ ] [ ] = new int [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( i = 0 ; i < V ; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; }
static int pageFaults ( int pages [ ] , int n , int capacity ) { HashSet < Integer > s = new HashSet < > ( capacity ) ; Queue < Integer > indexes = new LinkedList < > ( ) ; int page_faults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( ! s . contains ( pages [ i ] ) ) { s . add ( pages [ i ] ) ; page_faults ++ ; indexes . add ( pages [ i ] ) ; } } else { if ( ! s . contains ( pages [ i ] ) ) { int val = indexes . peek ( ) ; indexes . poll ( ) ; s . remove ( val ) ; s . add ( pages [ i ] ) ; indexes . add ( pages [ i ] ) ; page_faults ++ ; } } } return page_faults ; }
static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }
static int maxDP ( int n ) { int res [ ] = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
public static void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == - 1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != - 1 ) { allocation [ i ] = bestIdx ; blockSize [ bestIdx ] -= processSize [ i ] ; } } System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( "Not Allocated" ) ; System . out . println ( ) ; } }
static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
static int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }
static double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
static void countDistinct ( int arr [ ] , int k ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } } System . out . println ( dist_count ) ; for ( int i = k ; i < arr . length ; i ++ ) { if ( hM . get ( arr [ i - k ] ) == 1 ) { hM . remove ( arr [ i - k ] ) ; dist_count -- ; } else { int count = hM . get ( arr [ i - k ] ) ; hM . put ( arr [ i - k ] , count - 1 ) ; } if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } System . out . println ( dist_count ) ; } }
public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
static int waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; Vector < Integer > [ ] position = new Vector [ M ] ; for ( int i = 0 ; i < M ; i ++ ) position [ i ] = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) position [ str2 . charAt ( i - 1 ) - 'a' ] . add ( i ) ; int [ ] [ ] lcsl = new int [ m + 2 ] [ n + 2 ] ; int [ ] [ ] lcsr = new int [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = Math . max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = Math . max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( char d = 0 ; d < 26 ; d ++ ) { for ( int j = 0 ; j < position [ d ] . size ( ) ; j ++ ) { int p = position [ d ] . elementAt ( j ) ; if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) ways ++ ; } } } return ways ; }
static boolean isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }
int countSubStr ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
public static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
static int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
static void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + s / 2 ) ; System . out . println ( "Difference = " + 0 ) ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + ( ( s / 2 ) + 1 ) ) ; System . out . println ( "Difference = " + 1 ) ; } else { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + s / 2 ) ; System . out . println ( "Difference = " + 0 ) ; } } }
static void printFun ( int test ) { if ( test < 1 ) return ; else { System . out . printf ( "%d " , test ) ; printFun ( test - 1 ) ; System . out . printf ( "%d " , test ) ; return ; } }
static boolean isPrime ( int p ) { double checkNumber = Math . pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ++ ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }
static int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }
static int minXOR ( int arr [ ] , int n ) { int min_xor = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ; return min_xor ; }
public static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; }
static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
public static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) res ++ ; } return res ; }
static void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }
int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; int start_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_index = i ; } if ( hM . containsKey ( sum + n ) ) { if ( max_len < i - hM . get ( sum + n ) ) { max_len = i - hM . get ( sum + n ) ; ending_index = i ; } } else hM . put ( sum + n , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; } int end = ending_index - max_len + 1 ; System . out . println ( end + " to " + ending_index ) ; return max_len ; }
static char first ( String str , int i ) { if ( str . charAt ( i ) == '\0' ) return 0 ; if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }
static boolean isInorder ( int [ ] arr , int n ) { if ( n == 0 || n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }
static int getLevenstein ( StringBuilder input ) { StringBuilder revInput = new StringBuilder ( input ) ; revInput = revInput . reverse ( ) ; int n = input . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = Integer . MAX_VALUE ; for ( int i = n , j = 0 ; i >= 0 ; i -- , j ++ ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }
public static int minOperation ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; else hash . put ( arr [ i ] , 1 ) ; int max_count = 0 ; Set < Integer > s = hash . keySet ( ) ; for ( int i : s ) if ( max_count < hash . get ( i ) ) max_count = hash . get ( i ) ; return ( n - max_count ) ; }
static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " " ) ; System . out . println ( ) ; }
static boolean canFormPalindrome ( String str ) { List < Character > list = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( list . contains ( str . charAt ( i ) ) ) list . remove ( ( Character ) str . charAt ( i ) ) ; else list . add ( str . charAt ( i ) ) ; } if ( str . length ( ) % 2 == 0 && list . isEmpty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true ; else return false ; }
static float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . add ( x ) ; else { if ( Q . peek ( ) < x ) { Q . poll ( ) ; Q . add ( x ) ; } } } } return Q . poll ( ) ; }
public static long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
static int countFibs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) result ++ ; f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }
static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
static double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
static void findDivision ( String str , int a , int b ) { int len = str . length ( ) ; int [ ] lr = new int [ len + 1 ] ; lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a ; for ( int i = 1 ; i < len ; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str . charAt ( i ) - ( int ) '0' ) ) % a ; int [ ] rl = new int [ len + 1 ] ; rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int ) '0' ) % b ; int power10 = 10 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i ) - ( int ) '0' ) * power10 ) % b ; power10 = ( power10 * 10 ) % b ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { System . out . println ( "YES" ) ; for ( int k = 0 ; k <= i ; k ++ ) System . out . print ( str . charAt ( k ) ) ; System . out . print ( ", " ) ; for ( int k = i + 1 ; k < len ; k ++ ) System . out . print ( str . charAt ( k ) ) ; return ; } } System . out . println ( "NO" ) ; }
static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
public static int sumoflength ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }
static int maxSum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
static float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
static Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
static int maxcoefficientvalue ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }
static boolean isPossibleTriangle ( int [ ] arr , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }
static long maxPrimeFactors ( long n ) { long maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) maxPrime = n ; return maxPrime ; }
static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
static int maxProfit ( int price [ ] , int n ) { int profit [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) profit [ i ] = 0 ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; return result ; }
static int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
static int countNum ( int [ ] arr , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
static int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = Integer . MAX_VALUE ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) { min_diff = diff ; first = i ; last = i + m - 1 ; } } return ( arr [ last ] - arr [ first ] ) ; }
static void swapDiagonal ( int matrix [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { int temp = matrix [ i ] [ i ] ; matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ; matrix [ i ] [ N - i - 1 ] = temp ; } }
static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
static boolean checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( "Pair elements are %d and %d\n" , arr [ i ] , val ) ; return true ; } s . add ( arr [ i ] ) ; } return false ; }
static int findMinDiff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
static String lexsmallest ( String a [ ] , int n ) { sort ( a , n ) ; String answer = "" ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }
static int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 || cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
static void parabola ( float a , float b , float c ) { System . out . println ( "Vertex: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) + ")" ) ; System . out . println ( "Focus: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + ")" ) ; System . out . println ( "Directrix:" + " y=" + ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) ) ; }
static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }
public static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( arr1 [ i ] , 0 ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . containsKey ( x - arr2 [ j ] ) ) System . out . println ( x - arr2 [ j ] + " " + arr2 [ j ] ) ; }
static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
static int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
static void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( " Frequency of odd number =" + odd + " \n" ) ; System . out . print ( " Frequency of even number = " + even + " \n" ) ; }
static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( "No" ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( "Yes " + days ) ; } }
static int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
static int countSub ( String str ) { int [ ] last = new int [ MAX_CHAR ] ; Arrays . fill ( last , - 1 ) ; int n = str . length ( ) ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( int ) str . charAt ( i - 1 ) ] ] ; last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ; } return dp [ n ] ; }
static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
static float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { System . out . println ( "Not a valid triangle" ) ; System . exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }
static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start || longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; }
static void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < Integer > ( ) ; Vector < Integer > oddArr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } Collections . sort ( evenArr ) ; Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr . get ( j ) ; } }
static int find_extra_element_index ( int [ ] arrA , int [ ] arrB ) { int extra_element = sum ( arrA ) - sum ( arrB ) ; return indexOf ( arrA , extra_element ) ; }
static void generate ( int ones , int zeroes , String str , int len ) { if ( len == str . length ( ) ) { System . out . print ( str + " " ) ; return ; } generate ( ones + 1 , zeroes , str + "1" , len ) ; if ( ones > zeroes ) { generate ( ones , zeroes + 1 , str + "0" , len ) ; } }
static int solve ( int a [ ] , int b [ ] , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }
static void maximizecube ( int l , int b , int h ) { int side = gcd ( l , gcd ( b , h ) ) ; int num = l / side ; num = ( num * b / side ) ; num = ( num * h / side ) ; System . out . println ( side + " " + num ) ; }
static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
static int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
public static void dfs ( LinkedList < Integer > list [ ] , int node , int arrival ) { System . out . println ( node ) ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] . get ( i ) != arrival ) dfs ( list , list [ node ] . get ( i ) , node ) ; } }
static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( "Angle cannot" + " be formed" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
static String decodeMedianString ( String s ) { int l = s . length ( ) ; String s1 = "" ; boolean isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }
static int maxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cummulative_sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cummulative_sum ) { count ++ ; cummulative_sum += arr [ i ] ; } } return count ; }
static void findConsecutive ( int N ) { int start = 1 ; int end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= i ; j ++ ) System . out . print ( j + " " ) ; System . out . println ( ) ; break ; } if ( sum > N ) break ; } sum = 0 ; start ++ ; } }
static void removeDuplicates ( char [ ] S ) { int n = S . length ; if ( n < 2 ) { return ; } int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } System . out . println ( Arrays . copyOfRange ( S , 0 , j + 1 ) ) ; }
static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; }
static float findArea ( float a ) { float area ; area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4 ; return area ; }
static void printPrevSmaller ( int arr [ ] , int n ) { Stack < Integer > S = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . peek ( ) >= arr [ i ] ) { S . pop ( ) ; } if ( S . empty ( ) ) { System . out . print ( "_, " ) ; } else { System . out . print ( S . peek ( ) + ", " ) ; } S . push ( arr [ i ] ) ; } }
static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
static boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ; }
static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . min ( ans , bad ) ; } return ans ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; }
static int countWords ( String str [ ] , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( str [ i ] ) ) { int get = m . get ( str [ i ] ) ; m . put ( str [ i ] , get + 1 ) ; } else { m . put ( str [ i ] , 1 ) ; } } int res = 0 ; for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) { if ( it . getValue ( ) == 2 ) res ++ ; } return res ; }
static String constructPalin ( char [ ] str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) { str [ i ] = 'a' ; str [ j ] = 'a' ; continue ; } else if ( str [ i ] == '*' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == '*' ) { str [ j ] = str [ i ] ; continue ; } System . out . println ( "Not Possible" ) ; return "" ; } return String . valueOf ( str ) ; }
static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }
static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
public static int findPosition ( int k , int n ) { long f1 = 0 , f2 = 1 , f3 ; int i = 2 ; while ( i != 0 ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; }
static int assignValue ( int a , int b , int x ) { int arr [ ] = { a , b }; return ( arr [ x ] ) ; }
public static int jumpSearch ( int [ ] arr , int x ) { int n = arr . length ; int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ; int prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += ( int ) Math . floor ( Math . sqrt ( n ) ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }
static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
public static int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
static int SieveOfSundaram ( int n ) { int nNew = ( n - 2 ) / 2 ; boolean marked [ ] = new boolean [ nNew + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + " " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + " " ) ; return - 1 ; }
static int firstNonRepeating ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; return - 1 ; }
static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
static int sumAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == '(' ) { if ( tree . charAt ( i ) == ')' ) return 0 ; int sum = 0 ; if ( level == k ) sum = tree . charAt ( i ) - '0' ; ++ i ; int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return sum + leftsum + rightsum ; } return Integer . MIN_VALUE ; }
static int doublefactorial ( int n ) { int res = 1 ; for ( int i = n ; i >= 0 ; i = i - 2 ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }
public static void search ( int [ ] arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . println ( "The required element is " + arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else if ( mid % 2 == 1 ) { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }
static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
static void generateSquare ( int n ) { int [ ] [ ] magicSquare = new int [ n ] [ n ] ; int i = n / 2 ; int j = n - 1 ; for ( int num = 1 ; num <= n * n ; ) { if ( i == - 1 && j == n ) { j = n - 2 ; i = 0 ; } else { if ( j == n ) j = 0 ; if ( i < 0 ) i = n - 1 ; } if ( magicSquare [ i ] [ j ] != 0 ) { j -= 2 ; i ++ ; continue ; } else magicSquare [ i ] [ j ] = num ++ ; j ++ ; i -- ; } System . out . println ( "The Magic Square for " + n + ":" ) ; System . out . println ( "Sum of each row or column " + n * ( n * n + 1 ) / 2 + ":" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) System . out . print ( magicSquare [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }
static void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_last = 0 , size = 0 ; for ( char ch = 'z' ; ch >= 'a' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_last = i ; } } last = new_last ; } } t [ size ] = '\0' ; }
static void groupElements ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { System . out . print ( arr [ i ] + " " ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { System . out . print ( arr [ i ] + " " ) ; visited [ j ] = true ; } } } } }
static int maxTripletSum ( int arr [ ] , int n ) { int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }
static int countSubsets ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < > ( ) ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ; even_count = us . size ( ) ; return ( int ) ( Math . pow ( 2 , even_count ) - 1 ) ; }
int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { int sp [ ] [ ] [ ] = new int [ V ] [ V ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ; if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; if ( e > 1 ) { for ( int a = 0 ; a < V ; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } return sp [ u ] [ v ] [ k ] ; }
static int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
public static int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
static int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
static int countWays ( String s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( 0 ) - 'a' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
static void findMax ( int arr [ ] [ ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( j >= 0 && arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } System . out . print ( "Row number = " + ( row + 1 ) ) ; System . out . print ( ", MaxCount = " + ( N - 1 - j ) ) ; }
static void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) != ' ' ) count [ ( int ) str . charAt ( i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str . charAt ( i ) ] == 1 ) System . out . print ( str . charAt ( i ) ) ; }
public static boolean checkPangram ( String str ) { boolean [ ] mark = new boolean [ 26 ] ; int index = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) - 'A' ; else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) - 'a' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }
static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
static int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; int temp = 0 ; if ( small > big ) { temp = small ; small = big ; big = temp ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }
static double sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }
int getNthUglyNo ( int n ) { int ugly [ ] = new int [ n ] ; int i2 = 0 , i3 = 0 , i5 = 0 ; int next_multiple_of_2 = 2 ; int next_multiple_of_3 = 3 ; int next_multiple_of_5 = 5 ; int next_ugly_no = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { next_ugly_no = Math . min ( next_multiple_of_2 , Math . min ( next_multiple_of_3 , next_multiple_of_5 ) ) ; ugly [ i ] = next_ugly_no ; if ( next_ugly_no == next_multiple_of_2 ) { i2 = i2 + 1 ; next_multiple_of_2 = ugly [ i2 ] * 2 ; } if ( next_ugly_no == next_multiple_of_3 ) { i3 = i3 + 1 ; next_multiple_of_3 = ugly [ i3 ] * 3 ; } if ( next_ugly_no == next_multiple_of_5 ) { i5 = i5 + 1 ; next_multiple_of_5 = ugly [ i5 ] * 5 ; } } return next_ugly_no ; }
static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + " " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( "Fits" ) ; else System . out . println ( "Doesn't Fit" ) ; }
static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } } System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( "Not Allocated" ) ; System . out . println ( ) ; } }
static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }
static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; }
static void counterClockspiralPrint ( int m , int n , int arr [ ] [ ] ) { int i , k = 0 , l = 0 ; int cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) break ; for ( i = k ; i < m ; ++ i ) { System . out . print ( arr [ i ] [ l ] + " " ) ; cnt ++ ; } l ++ ; if ( cnt == total ) break ; for ( i = l ; i < n ; ++ i ) { System . out . print ( arr [ m - 1 ] [ i ] + " " ) ; cnt ++ ; } m -- ; if ( cnt == total ) break ; if ( k < m ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( arr [ i ] [ n - 1 ] + " " ) ; cnt ++ ; } n -- ; } if ( cnt == total ) break ; if ( l < n ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( arr [ k ] [ i ] + " " ) ; cnt ++ ; } k ++ ; } } }
static int minimumflip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
static int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }
static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
static void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } System . out . print ( maxOfMin + " " ) ; } }
static void findMin ( int V ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( " " + ans . elementAt ( i ) ) ; } }
static int countSubstr ( String s ) { int n = s . length ( ) ; int [ ] auxArr = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ] ; return count ; }
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ; SortedMap < Integer , Integer > st = new TreeMap < > ( ) ; for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) { st . put ( x . getKey ( ) , x . getValue ( ) ) ; } int cumul = 0 ; for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) { cumul += x . getValue ( ) ; System . out . println ( x . getKey ( ) + " " + cumul ) ; } }
static int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) ; return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( ) ; }
int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }
static int removeConsecutiveSame ( Vector < String > v ) { Stack < String > st = new Stack < > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v . get ( i ) ) ; else { String str = st . peek ( ) ; if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ; else st . push ( v . get ( i ) ) ; } } return st . size ( ) ; }
static int lis ( int arr [ ] , int n ) { max_ref = 1 ; _lis ( arr , n ) ; return max_ref ; }
static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
static long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
static int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }
static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
public static int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
static int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
static int getAbs ( int n ) { int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ; return ( ( n + mask ) ^ mask ) ; }
static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) pq . add ( A [ i ] + B [ j ] ) ; int count = 0 ; while ( count < K ) { System . out . println ( pq . peek ( ) ) ; pq . remove ( ) ; count ++ ; } }
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
static boolean distributingBalls ( long k , long n , String str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
static double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }
static int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; }
static String censor ( String text , String word ) { String [ ] word_list = text . split ( "\\s+" ) ; String result = "" ; String stars = "" ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) stars += '*' ; int index = 0 ; for ( String i : word_list ) { if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ; index ++ ; } for ( String i : word_list ) result += i + ' ' ; return result ; }
static void find ( Vector < String > list1 , Vector < String > list2 ) { Vector < String > res = new Vector < > ( ) ; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 . get ( i ) ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " " ) ; }
static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
static int findGreatest ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ; } } Arrays . sort ( arr ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m . get ( result ) == null || m . get ( result ) > 0 ) { return arr [ i ] ; } else if ( result == arr [ j ] && m . get ( result ) > 1 ) { return arr [ i ] ; } } } } return - 1 ; }
static int maxTripletSum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
public static void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + " " ) ; }
static int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }
static int countNum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }
static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == t . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }
static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n ; if ( sum == s ) return n ; } return - 1 ; }
void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( "The two reppeated elements are :" ) ; System . out . println ( x + " " + y ) ; }
static void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ; }
static double minHeight ( double base , double area ) { double d = ( 2 * area ) / base ; return Math . ceil ( d ) ; }
public static void shuffle ( int card [ ] , int n ) { Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + rand . nextInt ( 52 - i ) ; int temp = card [ r ] ; card [ r ] = card [ i ] ; card [ i ] = temp ; } }
static int shortestSeq ( char [ ] S , char [ ] T ) { int m = S . length , n = T . length ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; }
static char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }
static int minOperation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
static int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
int countTriangle ( int graph [ ] [ ] , boolean isDirected ) { int count_Triangle = 0 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 && graph [ k ] [ i ] == 1 ) count_Triangle ++ ; } } } if ( isDirected == true ) { count_Triangle /= 3 ; } else { count_Triangle /= 6 ; } return count_Triangle ; }
int lcs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 }; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) { int i = fromRow + ( toRow - fromRow ) / 2 ; int j = fromCol + ( toCol - fromCol ) / 2 ; if ( mat [ i ] [ j ] == key ) System . out . println ( "Found " + key + " at " + i + " " + j ) ; else { if ( i != toRow || j != fromCol ) search ( mat , fromRow , i , j , toCol , key ) ; if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) System . out . println ( "Found " + key + " at " + fromRow + " " + toCol ) ; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= toRow ) search ( mat , i + 1 , toRow , fromCol , toCol , key ) ; } else { if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ; } } }
static int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
static int countUnique ( int mat [ ] [ ] , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
public static void printArray ( int arr [ ] [ ] , int row , int col ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { String s = "" ; for ( int j = 0 ; j < col ; j ++ ) s += String . valueOf ( arr [ i ] [ j ] ) ; if ( ! set . contains ( s ) ) { set . add ( s ) ; System . out . println ( s ) ; } } }
static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
static int binomialCoeffSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
static int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
static int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
static boolean isPermutedMatrix ( int mat [ ] [ ] , int n ) { String str_cat = "" ; for ( int i = 0 ; i < n ; i ++ ) { str_cat = str_cat + "-" + String . valueOf ( mat [ 0 ] [ i ] ) ; } str_cat = str_cat + str_cat ; for ( int i = 1 ; i < n ; i ++ ) { String curr_str = "" ; for ( int j = 0 ; j < n ; j ++ ) { curr_str = curr_str + "-" + String . valueOf ( mat [ i ] [ j ] ) ; } if ( str_cat . contentEquals ( curr_str ) ) { return false ; } } return true ; }
static boolean isSparse ( int array [ ] [ ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; }
static int findMaxPath ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < M ; i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ; for ( int i = 1 ; i < N ; i ++ ) { res = - 1 ; for ( int j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; res = max ( mat [ i ] [ j ] , res ) ; } } return res ; }
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }
static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + " " ) ; } }
static int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
static int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
static int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; }
static void printPath ( String str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { int nextX = ( str . charAt ( i ) - 'A' ) / 5 ; int nextY = ( str . charAt ( i ) - 'B' + 1 ) % 5 ; while ( curX > nextX ) { System . out . println ( "Move Up" ) ; curX -- ; } while ( curY > nextY ) { System . out . println ( "Move Left" ) ; curY -- ; } while ( curX < nextX ) { System . out . println ( "Move Down" ) ; curX ++ ; } while ( curY < nextY ) { System . out . println ( "Move Right" ) ; curY ++ ; } System . out . println ( "Press OK" ) ; i ++ ; } }
static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
public static int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = "" ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } String reverse = "" ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) { reverse = reverse + res . charAt ( k ) ; } return reverse ; }
static int getMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }
static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; }
static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( "Maximum Number of Guests = " + max_guests + " at time " + time ) ; }
public static long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
static int minimumBox ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }
double countSquares ( int a , int b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }
static int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == '(' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ')' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ')' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) invcount ++ ; } } } } return invcount ; }
static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + " " ) ; flag = true ; break ; } } if ( ! flag ) System . out . print ( "0" + " " ) ; } }
public static int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; else hm . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) { int count = it . getValue ( ) ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( "No pairs exists" ) ; return ; } if ( n == 2 ) { System . out . println ( arr [ 0 ] + " " + arr [ 1 ] ) ; return ; } int posa = Integer . MIN_VALUE , posb = Integer . MIN_VALUE ; int nega = Integer . MIN_VALUE , negb = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) { posb = posa ; posa = arr [ i ] ; } else if ( arr [ i ] > posb ) posb = arr [ i ] ; if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( nega ) ) { negb = nega ; nega = arr [ i ] ; } else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( negb ) ) negb = arr [ i ] ; } if ( nega * negb > posa * posb ) System . out . println ( "Max product pair is { " + nega + ", " + negb + "}" ) ; else System . out . println ( "Max product pair is { " + posa + ", " + posb + "}" ) ; }
static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }
int getOddOccurrence ( int ar [ ] , int ar_size ) { int i ; int res = 0 ; for ( i = 0 ; i < ar_size ; i ++ ) { res = res ^ ar [ i ] ; } return res ; }
public static int minProduct ( int [ ] arr , int n , int k ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) pq . add ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( pq . isEmpty ( ) == false && count < k ) { ans = ans * pq . element ( ) ; pq . remove ( ) ; count ++ ; } return ans ; }
static int [ ] Restore_Tree ( int [ ] S , int [ ] End ) { int [ ] Identity = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Identity [ S [ i ] ] = i ; int [ ] parent = new int [ N ] ; Arrays . fill ( parent , - 1 ) ; int curr_parent = Identity [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) { int child = Identity [ j ] ; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_parent ; curr_parent = child ; } else { parent [ child ] = curr_parent ; while ( parent [ child ] > - 1 && End [ child ] == End [ parent [ child ] ] ) { child = parent [ child ] ; curr_parent = parent [ child ] ; if ( curr_parent == Identity [ 0 ] ) break ; } } } for ( int i = 0 ; i < N ; i ++ ) parent [ i ] += 1 ; return parent ; }
static boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
private static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) { int dp [ ] = new int [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; }
static int check_duck ( String num ) { int len = num . length ( ) ; int count_zero = 0 ; char ch ; for ( int i = 1 ; i < len ; i ++ ) { ch = num . charAt ( i ) ; if ( ch == '0' ) count_zero ++ ; } return count_zero ; }
static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 }; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
static int findLargestSumPair ( ) { int first , second ; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ] ; second = arr [ 1 ] ; } else { first = arr [ 1 ] ; second = arr [ 0 ] ; } for ( int i = 2 ; i < arr . length ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } return ( first + second ) ; }
static boolean check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { deg_sum += degree [ i ] ; } return ( 2 * ( n - 1 ) == deg_sum ) ; }
int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }
static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " " ) ; else System . out . print ( 0 + " " ) ; } System . out . println ( ) ; } return 0 ; }
static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i ; i += Math . abs ( arr [ i ] - x ) ; } return - 1 ; }
static void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 . charAt ( i ) - 'a' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - 'a' ] == 1 || present [ str2 . charAt ( i ) - 'a' ] == - 1 ) { present [ str2 . charAt ( i ) - 'a' ] = - 1 ; } else { present [ str2 . charAt ( i ) - 'a' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { System . out . print ( ( char ) ( i + 'a' ) + " " ) ; } } }
static int findRoot ( pair arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . first - arr [ i ] . second ) ; } return root ; }
static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " " ) ; else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " " ) ; else { System . out . print ( arr2 [ j ++ ] + " " ) ; i ++ ; } } while ( i < m ) System . out . print ( arr1 [ i ++ ] + " " ) ; while ( j < n ) System . out . print ( arr2 [ j ++ ] + " " ) ; return 0 ; }
static boolean flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
static int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
static int findPlatform ( int arr [ ] , int dep [ ] , int n ) { Arrays . sort ( arr ) ; Arrays . sort ( dep ) ; int plat_needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat_needed ++ ; i ++ ; if ( plat_needed > result ) result = plat_needed ; } else { plat_needed -- ; j ++ ; } } return result ; }
static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
static void pairSum ( int mat [ ] [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( mat [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { System . out . print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } } } }
static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
static int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == ' ' || str . charAt ( i ) == '\n' || str . charAt ( i ) == '\t' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
static int findLength ( String str , int n ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ; int ans = 0 ; for ( int len = 2 ; len <= n ; len += 2 ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ; } } return ans ; }
static int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; }
static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
static int findLastIndex ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }
static String minLexRotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }
static int findFlips ( String str , int n ) { char last = ' ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; }
static Boolean divisibleBy20 ( String num ) { int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
static int longestNull ( String str ) { ArrayList < Pair > arr = new ArrayList < > ( ) ; arr . add ( new Pair ( '@' , - 1 ) ) ; int maxlen = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { arr . add ( new Pair ( str . charAt ( i ) , i ) ) ; while ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) - 3 ) . first == '1' && arr . get ( arr . size ( ) - 2 ) . first == '0' && arr . get ( arr . size ( ) - 1 ) . first == '0' ) { arr . remove ( arr . size ( ) - 3 ) ; arr . remove ( arr . size ( ) - 2 ) ; arr . remove ( arr . size ( ) - 1 ) ; } int tmp = arr . get ( arr . size ( ) - 1 ) . second ; maxlen = Math . max ( maxlen , i - tmp ) ; } return maxlen ; }
static String printShortestSuperSeq ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = j ; } else if ( j == 0 ) { dp [ i ] [ j ] = i ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int index = dp [ m ] [ n ] ; String str = "" ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; j -- ; index -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; index -- ; } else { str += ( X . charAt ( i - 1 ) ) ; i -- ; index -- ; } } while ( i > 0 ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; index -- ; } while ( j > 0 ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; index -- ; } str = reverse ( str ) ; return str ; }
static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }
static void drawPattern ( int N ) { int n = N ; int row = 1 ; int nst = 1 ; int nsp1 = n - 1 ; int nsp2 = - 1 ; int val1 = row ; int val2 = 1 ; while ( row <= n ) { int csp1 = 1 ; while ( csp1 <= nsp1 ) { System . out . print ( " " ) ; csp1 = csp1 + 1 ; } int cst1 = 1 ; while ( cst1 <= nst ) { System . out . print ( val1 + " " ) ; val1 = val1 - 1 ; cst1 = cst1 + 1 ; } int csp2 = 1 ; while ( csp2 <= nsp2 ) { System . out . print ( " " ) ; csp2 = csp2 + 1 ; } if ( row != 1 && row != n ) { int cst2 = 1 ; while ( cst2 <= nst ) { System . out . print ( val2 + " " ) ; val2 = val2 + 1 ; cst2 = cst2 + 1 ; } } System . out . println ( ) ; if ( row <= n / 2 ) { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 + 2 ; val1 = row + 1 ; val2 = 1 ; } else { nst = nst - 1 ; nsp1 = nsp1 + 2 ; nsp2 = nsp2 - 2 ; val1 = n - row ; val2 = 1 ; } row = row + 1 ; } }
static int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
public static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
static int lis ( int arr [ ] , int n ) { max_ref = 1 ; _lis ( arr , n ) ; return max_ref ; }
static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " " + b + " " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . print ( "-1" ) ; }
static int minSumPath ( ) { int [ ] memo = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
static int MaximumPath ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }
static boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }
static boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) return false ; if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ; if ( first . length ( ) > 0 && first . charAt ( 0 ) == '*' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ; return false ; }
static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }
int Circumference ( int a ) { return 4 * a ; }
static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { int p = i - 1 ; System . out . println ( "Sum found between indexes " + start + " and " + p ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } System . out . println ( "No subarray found" ) ; return 0 ; }
static void generate_derangement ( int N ) { int S [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " " ) ; System . out . println ( ) ; }
static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { System . out . print ( "k pairs don't exist" ) ; return ; } int index2 [ ] = new int [ n1 ] ; while ( k > 0 ) { int min_sum = Integer . MAX_VALUE ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } System . out . print ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) ; index2 [ min_index ] ++ ; k -- ; } }
public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( "Pattern found at index " + i ) ; } }
static void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { arr = swap ( arr , i , j ) ; i += 2 ; j -= 2 ; } Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ; Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ; int low = ( n + 1 ) / 2 , high = n - 1 ; while ( low < high ) { Integer temp = arr [ low ] ; arr [ low ] = arr [ high ] ; arr [ high ] = temp ; low ++ ; high -- ; } }
static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
int minDist ( int arr [ ] , int n , int x , int y ) { int i = 0 ; int min_dist = Integer . MAX_VALUE ; int prev = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) { min_dist = i - prev ; prev = i ; } else prev = i ; } } return min_dist ; }
static int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
public static int MinimumCost ( int cost [ ] , int n , int W ) { Vector < Integer > val = new Vector < Integer > ( ) ; Vector < Integer > wt = new Vector < Integer > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt . get ( i - 1 ) ] + val . get ( i - 1 ) ) ; } } return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? - 1 : min_cost [ n ] [ W ] ; }
static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) S . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! S . contains ( arr [ i ] - 1 ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }
static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
static void rotatematrix ( int m , int n , int mat [ ] [ ] ) { int row = 0 , col = 0 ; int prev , curr ; while ( row < m && col < n ) { if ( row + 1 == m || col + 1 == n ) break ; prev = mat [ row + 1 ] [ col ] ; for ( int i = col ; i < n ; i ++ ) { curr = mat [ row ] [ i ] ; mat [ row ] [ i ] = prev ; prev = curr ; } row ++ ; for ( int i = row ; i < m ; i ++ ) { curr = mat [ i ] [ n - 1 ] ; mat [ i ] [ n - 1 ] = prev ; prev = curr ; } n -- ; if ( row < m ) { for ( int i = n - 1 ; i >= col ; i -- ) { curr = mat [ m - 1 ] [ i ] ; mat [ m - 1 ] [ i ] = prev ; prev = curr ; } } m -- ; if ( col < n ) { for ( int i = m - 1 ; i >= row ; i -- ) { curr = mat [ i ] [ col ] ; mat [ i ] [ col ] = prev ; prev = curr ; } } col ++ ; } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( mat [ i ] [ j ] + " " ) ; System . out . print ( "\n" ) ; } }
static int maxdiff ( int arr [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; }
static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = "" ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ; str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ; return str ; }
static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + ", " + ( float ) ( y1 + y2 ) / 2 ) ; }
public static int minRemove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; else countA . put ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; else countB . put ( b [ i ] , 1 ) ; } int res = 0 ; Set < Integer > s = countA . keySet ( ) ; for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ; return res ; }
static boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
public static int kthgroupsum ( int k ) { return k * k * k ; }
static int longLenStrictBitonicSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > inc = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > dcr = new HashMap < Integer , Integer > ( ) ; int len_inc [ ] = new int [ n ] ; int len_dcr [ ] = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ; len_inc [ i ] = len + 1 ; inc . put ( arr [ i ] , len_inc [ i ] ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . containsKey ( arr [ i ] - 1 ) ) len = dcr . get ( arr [ i ] - 1 ) ; len_dcr [ i ] = len + 1 ; dcr . put ( arr [ i ] , len_dcr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }
static long doublefactorial ( long n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; }
static boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
static void findString ( String str , int n , int k ) { if ( k == 0 ) { System . out . println ( str ) ; ; return ; } String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 . charAt ( i ) != 'a' ) { str2 = str2 . substring ( 0 , i ) + 'a' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == 'a' ) { str2 = str2 . substring ( 0 , i ) + 'b' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } System . out . println ( str2 ) ; }
static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " " ) ; } }
static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " " + arr2 [ j ] ) ; }
static int binaryMedian ( int m [ ] [ ] , int r , int c ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ; } int desired = ( r * c + 1 ) / 2 ; while ( min < max ) { int mid = min + ( max - min ) / 2 ; int place = 0 ; int get = 0 ; for ( int i = 0 ; i < r ; ++ i ) { get = Arrays . binarySearch ( m [ i ] , mid ) ; if ( get < 0 ) get = Math . abs ( get ) - 1 ; else { while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ; } place = place + get ; } if ( place < desired ) min = mid + 1 ; else max = mid ; } return min ; }
static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
static int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
public static void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( "Count of pairs is %d" , count ) ; }
static String reversingString ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . valueOf ( str ) ; }
static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
static int maximumNumberDistinctPrimeRange ( int m , int n ) { long factorCount [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; }
static void divisibilityCheck ( List < Integer > arr , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr . get ( i ) ) ; max_ele = Math . max ( max_ele , arr . get ( i ) ) ; } LinkedHashSet < Integer > res = new LinkedHashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) * 2 ; j <= max_ele ; j += arr . get ( i ) ) { if ( s . contains ( j ) ) res . add ( j ) ; } } List < Integer > list = new ArrayList < Integer > ( res ) ; Collections . reverse ( list ) ; for ( Integer temp : list ) System . out . print ( temp + " " ) ; }
static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " " ) ; }
static void strToBinary ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = Integer . valueOf ( s . charAt ( i ) ) ; String bin = "" ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; System . out . print ( bin + " " ) ; } }
static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
static int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
static void findpath ( int [ ] [ ] graph , int n ) { Vector < Integer > numofadj = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) numofadj . add ( accumulate ( graph [ i ] , 0 ) ) ; int startPoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj . elementAt ( i ) % 2 == 1 ) { numofodd ++ ; startPoint = i ; } } if ( numofodd > 2 ) { System . out . println ( "No Solution" ) ; return ; } Stack < Integer > stack = new Stack < > ( ) ; Vector < Integer > path = new Vector < > ( ) ; int cur = startPoint ; while ( ! stack . isEmpty ( ) || accumulate ( graph [ cur ] , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , 0 ) == 0 ) { path . add ( cur ) ; cur = stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . add ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( int ele : path ) System . out . print ( ele + " -> " ) ; System . out . println ( cur ) ; }
static int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
static boolean check ( int n ) { return 1162261467 % n == 0 ; }
static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
static int findArea ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }
static int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }
static boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
static void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + " " ) ; } System . out . println ( ) ; } }
public static void prefixSum2D ( int a [ ] [ ] ) { int R = a . length ; int C = a [ 0 ] . length ; int psa [ ] [ ] = new int [ R ] [ C ] ; psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ; for ( int i = 1 ; i < C ; i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ; for ( int i = 1 ; i < R ; i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( psa [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }
static int calcMaxValue ( String str ) { int res = str . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' ) ; else res *= ( str . charAt ( i ) - '0' ) ; } return res ; }
static int printKDistinct ( int arr [ ] , int n , int k ) { Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ; else h . put ( arr [ i ] , 1 ) ; } if ( h . size ( ) < k ) return - 1 ; int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . get ( arr [ i ] ) == 1 ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
static int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " " ) ; }
static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == 'a' ) c1 ++ ; if ( s . charAt ( i ) == 'b' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }
static long arrangeBraces ( int n , int pos [ ] , int k ) { boolean h [ ] = new boolean [ N ] ; int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } else if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
static boolean checkCount ( int [ ] arr , int n , int k ) { int count ; for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++ ; if ( count > 2 * k ) return false ; } } return true ; }
static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( "number is not" + " present!" ) ; return - 1 ; }
static int longLenSub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
static void printDistinct ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR && index [ i ] != n ; i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ; }
static int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str . charAt ( i + k ) - '0' ) ; rightsum += ( str . charAt ( i + k + length / 2 ) - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }
static int abFree ( char [ ] s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ s . length - i - 1 ] == 'a' ) { res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } else { b_count += 1 ; } } return res ; }
static int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
static float find_prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }
static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) s . add ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ; if ( j != n ) continue ; System . out . print ( i + ", " ) ; } }
public static String recursiveReverse ( char [ ] str ) { Stack < Character > st = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ; i ++ ) { str [ i ] = st . peek ( ) ; st . pop ( ) ; } return String . valueOf ( str ) ; }
static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }
public static int SumOfKsubArray ( int arr [ ] , int k ) { int sum = 0 ; Deque < Integer > S = new LinkedList < > ( ) , G = new LinkedList < > ( ) ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } for ( ; i < arr . length ; i ++ ) { sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ; while ( ! S . isEmpty ( ) && S . peekFirst ( ) <= i - k ) S . removeFirst ( ) ; while ( ! G . isEmpty ( ) && G . peekFirst ( ) <= i - k ) G . removeFirst ( ) ; while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ; return sum ; }
static long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int l = 1 ; l < k ; l ++ ) { for ( int i = l ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } } for ( int i = k - 1 ; i < n ; i ++ ) { sum += dp [ k - 1 ] [ i ] ; } return sum ; }
static int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == '} ' && ! s . empty ( ) ) { if ( s . peek ( ) == '{ ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == '{ ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } public static void main ( String [ ] args ) { String expr = " } }
static int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }
static int kthNonRepeating ( String str , int k ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }
static boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
static int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
static int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( myMap . containsKey ( sum ) ) count += myMap . get ( sum ) ; if ( ! myMap . containsKey ( sum ) ) myMap . put ( sum , 1 ) ; else myMap . put ( sum , myMap . get ( sum ) + 1 ) ; } return count ; }
static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
static boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
static int floorSearch ( int arr [ ] , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid - 1 , x ) ; return floorSearch ( arr , mid + 1 , high , x ) ; }
static int perfectSquare ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = "" ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { String str = "" ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str += s . charAt ( j ) ; } } if ( str . charAt ( 0 ) != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' ) ; int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . length ( ) ) { ans = ( int ) str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { System . out . print ( num + " " ) ; return n - ans ; } }
static float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
static void rotateMatrix ( int mat [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j >= 0 ; j -- ) System . out . print ( mat [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }
static boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
static int getMinSteps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ;
static int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
public static void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Arrays . sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
static void sortUsingHash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int min = Math . abs ( Arrays . stream ( a ) . min ( ) . getAsInt ( ) ) ; int hashpos [ ] = new int [ max + 1 ] ; int hashneg [ ] = new int [ min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ; else hashneg [ Math . abs ( a [ i ] ) ] += 1 ; } for ( int i = min ; i > 0 ; i -- ) { if ( hashneg [ i ] > 0 ) { for ( int j = 0 ; j < hashneg [ i ] ; j ++ ) { System . out . print ( ( - 1 ) * i + " " ) ; } } } for ( int i = 0 ; i <= max ; i ++ ) { if ( hashpos [ i ] > 0 ) { for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) { System . out . print ( i + " " ) ; } } } }
static boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ; isPairFound = true ; } } } return isPairFound ; }
static int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
static int maxDistance ( int [ ] arr , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }
static void tower ( int n , char sourcePole , char destinationPole , char auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; System . out . printf ( "Move the disk %d from %c to %c\n" , n , sourcePole , destinationPole ) ; tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ; }
static int getCount ( char keypad [ ] [ ] , int n ) { if ( keypad == null || n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
static int findElement ( int [ ] arr , int n ) { int [ ] leftMax = new int [ n ] ; leftMax [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ; int rightMin = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ; rightMin = Math . min ( rightMin , arr [ i ] ) ; } return - 1 ; }
static int minInsertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
static long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; int arr [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }
static int findCommon ( int mat [ ] [ ] ) { HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) { cnt . put ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ 0 ] , 1 ) ; } for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) if ( cnt . containsKey ( mat [ i ] [ j ] ) ) { cnt . put ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ j ] , 1 ) ; } } } for ( Map . Entry < Integer , Integer > ele : cnt . entrySet ( ) ) { if ( ele . getValue ( ) == M ) return ele . getKey ( ) ; } return - 1 ; }
static void search ( int arr [ ] , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . printf ( "The required element is %d " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }
static void printRotatedString ( String str ) { int len = str . length ( ) ; StringBuffer sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuffer ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . length ( ) ; k2 ++ ) { sb . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( sb ) ; } }
static void myCopy ( char s1 [ ] , char s2 [ ] , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1 . length - 1 ) { return ; } myCopy ( s1 , s2 , index + 1 ) ; }
static String findSubString ( String str ) { int n = str . length ( ) ; int dist_count = 0 ; boolean [ ] visited = new boolean [ MAX_CHARS ] ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str . charAt ( i ) ] == false ) { visited [ str . charAt ( i ) ] = true ; dist_count ++ ; } } int start = 0 , start_index = - 1 ; int min_len = Integer . MAX_VALUE ; int count = 0 ; int [ ] curr_count = new int [ MAX_CHARS ] ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str . charAt ( j ) ] ++ ; if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str . charAt ( start ) ] > 1 ) { if ( curr_count [ str . charAt ( start ) ] > 1 ) curr_count [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } return str . substring ( start_index , start_index + min_len ) ; }
static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
static int findInteger ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) - 1 ) ; else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] ; return - 1 ; }
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
static boolean isDDM ( int m [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ; sum -= Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }
static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) { if ( k == 0 ) { return 0 ; } if ( l < 0 | r < 0 ) { return ( int ) 1e9 ; } if ( dp [ l ] [ r ] [ k ] != - 1 ) { return dp [ l ] [ r ] [ k ] ; } int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ; return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ; }
public static int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
static String longestRepeatedSubstring ( String str ) { int n = str . length ( ) ; int LCSRe [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; String res = "" ; int res_length = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) { LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ; if ( LCSRe [ i ] [ j ] > res_length ) { res_length = LCSRe [ i ] [ j ] ; index = Math . max ( i , index ) ; } } else { LCSRe [ i ] [ j ] = 0 ; } } } if ( res_length > 0 ) { for ( i = index - res_length + 1 ; i <= index ; i ++ ) { res += str . charAt ( i - 1 ) ; } } return res ; }
static String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; String result = "" ; while ( i >= 0 ) { if ( str . charAt ( i ) == ' ' ) { start = i + 1 ; while ( start != end ) result += str . charAt ( start ++ ) ; result += ' ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str . charAt ( start ++ ) ; return result ; }
static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
static char getMaxOccuringChar ( String str ) { int count [ ] = new int [ ASCII_SIZE ] ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) count [ str . charAt ( i ) ] ++ ; int max = - 1 ; char result = ' ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str . charAt ( i ) ] ) { max = count [ str . charAt ( i ) ] ; result = str . charAt ( i ) ; } } return result ; }
static int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int mod_arr [ ] = new int [ n ] ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( um . containsKey ( mod_arr [ i ] ) == false ) um . put ( mod_arr [ i ] , i ) ; else if ( max < ( i - um . get ( mod_arr [ i ] ) ) ) max = i - um . get ( mod_arr [ i ] ) ; } return max ; }
static int SieveOfAtkin ( int limit ) { if ( limit > 2 ) System . out . print ( 2 + " " ) ; if ( limit > 3 ) System . out . print ( 3 + " " ) ; boolean sieve [ ] = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) System . out . print ( a + " " ) ; return 0 ; }
static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
public static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i < right ; ++ i ) if ( arr [ i ] == element ) ++ count ; return count ; }
static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s . charAt ( i ) == 'b' ) bCount = ( aCount + 2 * bCount ) ; else if ( s . charAt ( i ) == 'c' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
public static int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
static void greatest ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . charAt ( i ) - '0' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 != 0 ) { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) { System . out . println ( "-1" ) ; } else { System . out . println ( n ) ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) System . out . println ( - 1 ) ; else { System . out . println ( del + 1 ) ; } } }
static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( "x = " + i + ", y = " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( "No solution" ) ; }
static int policeThief ( char arr [ ] , int n , int k ) { int res = 0 ; ArrayList < Integer > thi = new ArrayList < Integer > ( ) ; ArrayList < Integer > pol = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 'P' ) pol . add ( i ) ; else if ( arr [ i ] == 'T' ) thi . add ( i ) ; } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi . get ( l ) < pol . get ( r ) ) l ++ ; else r ++ ; } return res ; }
static int maxProfit ( int [ ] price , int n , int k ) { int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_so_far = 0 ; for ( int m = 0 ; m < j ; m ++ ) max_so_far = Math . max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , max_so_far ) ; } } return profit [ k ] [ n - 1 ] ; }
static int fun ( int n ) { return n & ( n - 1 ) ; }
static int find_Area ( int r ) { return ( 2 * r * r ) ; }
static int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
static int intersection ( int n ) { return n * ( n - 1 ) ; }
static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
static int getSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; }
static double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
static int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }
static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }
static boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }
static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; }
static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
public static void amendSentence ( String sstr ) { char [ ] str = sstr . toCharArray ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) System . out . print ( " " ) ; System . out . print ( str [ i ] ) ; } else System . out . print ( str [ i ] ) ; } }
static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
static boolean pairWiseConsecutive ( Stack < Integer > s ) { Stack < Integer > aux = new Stack < Integer > ( ) ; while ( ! s . isEmpty ( ) ) { aux . push ( s . peek ( ) ) ; s . pop ( ) ; } boolean result = true ; while ( aux . size ( ) > 1 ) { int x = aux . peek ( ) ; aux . pop ( ) ; int y = aux . peek ( ) ; aux . pop ( ) ; if ( Math . abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . peek ( ) ) ; return result ; }
static void rotate ( ) { int x = arr [ arr . length - 1 ] , i ; for ( i = arr . length - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
static char getSecondMostFreq ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) ( count [ str . charAt ( i ) ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; }
static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 || unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
static void printPrevSmaller ( int [ ] arr , int n ) { System . out . print ( "_, " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { System . out . print ( arr [ j ] + ", " ) ; break ; } } if ( j == - 1 ) System . out . print ( "_, " ) ; } }
static int maxProd ( int n ) { if ( n == 0 || n == 1 ) return 0 ; int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ; return max_val ; }
static int areaSquare ( int side ) { int area = side * side ; return area ; }
static void findSmallest ( int m , int s ) { if ( s == 0 ) { System . out . print ( m == 1 ? "Smallest number is 0" : "Not possible" ) ; return ; } if ( s > 9 * m ) { System . out . println ( "Not possible" ) ; return ; } int [ ] res = new int [ m ] ; s -= 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( s > 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; System . out . print ( "Smallest number is " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; }
static void mergeTwoHalf ( int [ ] A , int n ) { Arrays . sort ( A ) ; }
static int numofArray ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > [ ] mu = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new Vector < > ( ) ; mu [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
static int findMinRooms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
public static int kthSmallest ( Integer [ ] arr , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }
static void solve ( int n , int t , char s [ ] ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } System . out . print ( s ) ; }
static int singleNumber ( int a [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i : a ) { s . add ( i ) ; } int arr_sum = 0 ; for ( int i : a ) { arr_sum += i ; } int set_sum = 0 ; for ( int i : s ) { set_sum += i ; } return ( 3 * set_sum - arr_sum ) / 2 ; }
static boolean checkSentence ( char [ ] str ) { int len = str . length ; if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false ; if ( str [ len - 1 ] != '.' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . length ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ; else if ( str [ index ] == ' ' ) curr_state = 1 ; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ; else if ( str [ index ] == '.' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ; index ++ ; prev_state = curr_state ; } return false ; }
static boolean isPossible ( int n , int index , int sum , int M , int arr [ ] , int dp [ ] [ ] ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } else if ( sum < 0 || sum >= MAX ) return false ; if ( dp [ index ] [ sum ] != - 1 ) { if ( dp [ index ] [ sum ] == 0 ) return false ; return true ; } boolean placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , M , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) ; boolean res = ( placeAdd || placeMinus ) ; dp [ index ] [ sum ] = ( res ) ? 1 : 0 ; return res ; }
static int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" ) ; }
static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
static int returnMaxSum ( int A [ ] , int B [ ] , int n ) { Set < Integer > mp = new HashSet < Integer > ( ) ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . contains ( A [ i ] ) ) { mp . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . add ( A [ i ] ) ; curr_sum += B [ i ] ; result = Integer . max ( result , curr_sum ) ; } return result ; }
static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; }
public static void cycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle_start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle_start ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } }
public static void checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; boolean flag = false ; int i = 0 ; while ( i * i <= ab ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { double l = Math . sqrt ( ab - ( i * i + j * j + k * k ) ) ; if ( Math . floor ( l ) == Math . ceil ( l ) && l >= k ) { flag = true ; System . out . print ( "i = " + i + "\n" ) ; System . out . print ( "j = " + j + "\n" ) ; System . out . print ( "k = " + k + "\n" ) ; System . out . print ( "l = " + ( int ) l + "\n" ) ; System . out . print ( "Product of " + a + " and " + b + " can be written as sum of squares" + " of i, j, k, l \n" ) ; System . out . print ( ab + " = " + i + "*" + i + " + " + j + "*" + j + " + " + k + "*" + k + " + " + ( int ) l + "*" + ( int ) l + "\n" ) ; } k += 1 ; } j += 1 ; } i += 1 ; } if ( flag == false ) { System . out . println ( "Solution doesn't exist!" ) ; return ; } }
static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } System . out . println ( "Principal Diagonal:" + principal ) ; System . out . println ( "Secondary Diagonal:" + secondary ) ; }
static void printHosoya ( int n ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( dp [ i ] [ j ] + "" ) ; System . out . println ( "" ) ; } }
static int findRepeatFirstN2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
int catalan ( int n ) { int res = 0 ; if ( n <= 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }
static int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
void computeLPSArray ( String pat , int M , int lps [ ] ) { int len = 0 ; int i = 1 ; lps [ 0 ] = 0 ; while ( i < M ) { if ( pat . charAt ( i ) == pat . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = len ; i ++ ; } } } }
static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
static int subsetGraph ( int C [ ] [ ] ) { HashSet < Integer > vertices = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { vertices . add ( i ) ; } while ( ! vertices . isEmpty ( ) ) { if ( vertices . size ( ) == 1 ) { return 1 ; } boolean someone_removed = false ; for ( int x : vertices ) { HashSet < Integer > values = new HashSet < > ( ) ; for ( int y : vertices ) { if ( y != x ) { values . add ( C [ x ] [ y ] ) ; } } if ( values . size ( ) == 1 ) { vertices . remove ( x ) ; someone_removed = true ; break ; } } if ( ! someone_removed ) { break ; } } return ( vertices . size ( ) ) ; }
static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
static long countStrs ( int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < 27 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i <= 25 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) { sum = ( sum + dp [ n ] [ i ] ) ; } return sum ; }
static void printMat ( int degseq [ ] , int n ) { int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -- ; degseq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } } System . out . print ( "\n" + setw ( 3 ) + " " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( setw ( 3 ) + "(" + i + ")" ) ; System . out . print ( "\n\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( setw ( 4 ) + "(" + i + ")" ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j ] ) ; System . out . print ( "\n" ) ; } }
static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( "Sum of middle row = " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( "Sum of middle column = " + col_sum ) ; }
static float slope ( float x1 , float y1 , float x2 , float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; }
static void printAllAPTriplets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }
static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
static int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
static int maximumZeros ( int arr [ ] , int n , int k ) { int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ; for ( int [ ] row : subset ) { Arrays . fill ( row , - 1 ) ; } subset [ 0 ] [ 0 ] = 0 ; for ( int p = 0 ; p < n ; p ++ ) { int pw2 = 0 , pw5 = 0 ; while ( arr [ p ] % 2 == 0 ) { pw2 ++ ; arr [ p ] /= 2 ; } while ( arr [ p ] % 5 == 0 ) { pw5 ++ ; arr [ p ] /= 5 ; } for ( int i = k - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) { subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) ; } } } } int ans = 0 ; for ( int i = 0 ; i < MAX5 ; i ++ ) { ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ; } return ans ; }
static void pythagoreanTriplets ( int limit ) { int a , b , c = 0 ; int m = 2 ; while ( c < limit ) { for ( int n = 1 ; n < m ; ++ n ) { a = m * m - n * n ; b = 2 * m * n ; c = m * m + n * n ; if ( c > limit ) break ; System . out . println ( a + " " + b + " " + c ) ; } m ++ ; } }
static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( "Diagonal one : " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ; } System . out . println ( ) ; System . out . print ( "Diagonal two : " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i + j == column - 1 ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ; } }
static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
static int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
private static void findMajority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length / 2 ) { System . out . println ( "Majority found :- " + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( " No Majority element" ) ; }
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; int result [ ] = new int [ len1 + len2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 . charAt ( i ) - '0' ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 . charAt ( j ) - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = "" ; while ( i >= 0 ) s += ( result [ i -- ] ) ; return s ; }
public static int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
public static int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
static void manipulated_seive ( int N ) { isprime . set ( 0 , false ) ; isprime . set ( 1 , false ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( isprime . get ( i ) ) { prime . add ( i ) ; SPF . set ( i , i ) ; } for ( int j = 0 ; j < prime . size ( ) && i * prime . get ( j ) < N && prime . get ( j ) <= SPF . get ( i ) ; j ++ ) { isprime . set ( i * prime . get ( j ) , false ) ; SPF . set ( i * prime . get ( j ) , prime . get ( j ) ) ; } } }
static int floorSearch ( int arr [ ] , int n , int x ) { if ( x >= arr [ n - 1 ] ) return n - 1 ; if ( x < arr [ 0 ] ) return - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ; return - 1 ; }
static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ ] = new int [ n ] ; int bw [ ] = new int [ n ] ; int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; fw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; }
static boolean isLucky ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ; } else { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } } return true ; }
static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
int countwalks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; return count ; }
static int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
static Boolean isOverflow ( long a , long b ) { if ( a == 0 || b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
static boolean isSubSeqDivisible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
static void recursiveReverse ( char [ ] str , int i ) { int n = str . length ; if ( i == n / 2 ) return ; swap ( str , i , n - i - 1 ) ; recursiveReverse ( str , i + 1 ) ; }
static String nextGreater ( String num ) { int l = num . length ( ) ; int i ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '0' ) { num = num . substring ( 0 , i ) + '1' + num . substring ( i + 1 ) ; break ; } else { num = num . substring ( 0 , i ) + '0' + num . substring ( i + 1 ) ; } } if ( i < 0 ) { num = "1" + num ; } return num ; }
static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }
static void reorder ( ) { for ( int i = 0 ; i < arr . length ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = ( char ) arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
static int findIndex ( int n ) { float fibo = 2.078087F * ( float ) Math . log ( n ) + 1.672276F ; return Math . round ( fibo ) ; }
static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
static int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
static int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) { int X [ ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 }; int Y [ ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 }; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }
static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
static void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
static int multiplyBySeven ( int n ) { return ( ( n << 3 ) - n ) ; }
static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 || last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }
static int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }
static void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ ] [ ] = new char [ m ] [ n ] ; char x = 'X' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? 'X' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) System . out . print ( a [ i ] [ j ] + " " ) ; System . out . println ( ) ; } }
int binarySearch ( int arr [ ] , int x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
static void NFG ( int a [ ] , int n , int freq [ ] ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; int res [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ] && s . size ( ) > 0 ) { res [ s . peek ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( s . size ( ) > 0 ) { res [ s . peek ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " " ) ; } }
static int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
static int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) { return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } }
static int countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ ] [ ] = new int [ n ] [ n ] ; int T [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '|' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '^' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }
static void printSumTricky ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int stripSum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + " " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " " ) ; } System . out . println ( ) ; } }
static int findRepeating ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) return arr [ i ] ; s . add ( arr [ i ] ) ; } return - 1 ; }
static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
static int countSub ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( "n Found at " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( "n Element not found" ) ; return ; }
public static int longOddEvenIncSeq ( int arr [ ] , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) System . out . print ( arr [ i ] + " " ) ; } }
static int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) == 0 ) result |= x ; } return result ; }
private static int minCost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int lps [ ] = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
static boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( "Sum found between indexes " + i + " and " + p ) ; return 1 ; } if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( "No subarray found" ) ; return 0 ; }
static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
static void bonacciseries ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = 0 ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
static void pointClip ( int XY [ ] [ ] , int n , int Xmin , int Ymin , int Xmax , int Ymax ) { System . out . printf ( "Point inside the viewing pane:\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) { if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } } System . out . printf ( "\nPoint outside the viewing pane:\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) System . out . printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } }
static int count ( String s , int len ) { int MAX = 1000 ; int cur = 0 , dig = 0 ; int [ ] sum = new int [ MAX ] ; int [ ] [ ] dp = new int [ MAX ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; if ( dig == 8 ) ans ++ ; if ( i - 2 >= 0 ) { dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ; } if ( i - 3 >= 0 ) { dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ; dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) continue ; ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; }
static void bin ( int n ) { if ( n > 1 ) bin ( n / 2 ) ; System . out . print ( n % 2 ) ; }
static long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
static int CountPS ( char str [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; boolean P [ ] [ ] = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }
static boolean checkCount ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , 0 ) ; hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; } for ( Map . Entry x : hash . entrySet ( ) ) if ( ( int ) x . getValue ( ) > 2 * k ) return false ; return true ; }
static int findSum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
static int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
static int countEndless ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] ; boolean col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " " ) ; } }
static int findSum ( String str ) { String temp = "" ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . isDigit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = "0" ; } } return sum + Integer . parseInt ( temp ) ; }
public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }
static int minStringValue ( String str , int k ) { int l = str . length ( ) ; if ( k >= l ) return 0 ; int [ ] frequency = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) frequency [ str . charAt ( i ) - 'a' ] ++ ; Comparator < Integer > c = new IntCompare ( ) ; PriorityQueue < Integer > q = new PriorityQueue < > ( c ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( frequency [ i ] != 0 ) q . add ( frequency [ i ] ) ; } while ( k != 0 ) { int temp = q . peek ( ) ; q . poll ( ) ; temp = temp - 1 ; q . add ( temp ) ; k -- ; } int result = 0 ; while ( ! q . isEmpty ( ) ) { int temp = q . peek ( ) ; result += temp * temp ; q . poll ( ) ; } return result ; }
static int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
static void CountTriangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } System . out . print ( "No of possible solutions: " + count ) ; }
static boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( "False" ) ; if ( n <= 3 ) System . out . println ( "False" ) ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
static int countStrings ( int n ) { int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
static void printCommonElements ( int mat [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( mat [ i ] [ j ] ) == i ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " " ) ; } } } }
public static int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
static void printString ( String str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { System . out . println ( str ) ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ; else System . out . println ( "Empty string" ) ; }
static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ; return result ; }
static int waysToArrange ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
static int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { System . out . print ( x + " " ) ; System . out . print ( arr [ l ] + " " ) ; System . out . println ( arr [ r ] + " " ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) System . out . println ( " No Triplet Found" ) ; }
static int computeLastDigit ( long A , long B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { for ( int i = 0 ; i < set1 . length ; i ++ ) { for ( int j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }
static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
static void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + " " ) ; if ( n >= 1 ) System . out . print ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + " " ) ; a = b ; b = c ; } }
static void printStringAlternate ( String str ) { int [ ] occ = new int [ 122 ] ; String s = str . toLowerCase ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = s . charAt ( i ) ; occ [ temp ] ++ ; if ( occ [ temp ] % 2 != 0 ) System . out . print ( str . charAt ( i ) ) ; } System . out . println ( ) ; }
public static int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum1 += stack1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum2 += stack2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum3 += stack3 [ i ] ; int top1 = 0 , top2 = 0 , top3 = 0 ; int ans = 0 ; while ( true ) { if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ; if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ] ; else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ] ; else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ] ; } }
static void printMaxSubSquare ( int M [ ] [ ] ) { int i , j ; int R = M . length ; int C = M [ 0 ] . length ; int S [ ] [ ] = new int [ R ] [ C ] ; int max_of_s , max_i , max_j ; for ( i = 0 ; i < R ; i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ] ; for ( j = 0 ; j < C ; j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ] ; for ( i = 1 ; i < R ; i ++ ) { for ( j = 1 ; j < C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 ; else S [ i ] [ j ] = 0 ; } } max_of_s = S [ 0 ] [ 0 ] ; max_i = 0 ; max_j = 0 ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( max_of_s < S [ i ] [ j ] ) { max_of_s = S [ i ] [ j ] ; max_i = i ; max_j = j ; } } } System . out . println ( "Maximum size sub-matrix is: " ) ; for ( i = max_i ; i > max_i - max_of_s ; i -- ) { for ( j = max_j ; j > max_j - max_of_s ; j -- ) { System . out . print ( M [ i ] [ j ] + " " ) ; } System . out . println ( ) ; } }
static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] , j = 0 ; Arrays . fill ( allocation , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } System . out . print ( "\nProcess No.\tProcess Size\tBlock no.\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + "\t\t" + processSize [ i ] + "\t\t" ) ; if ( allocation [ i ] != - 1 ) { System . out . print ( allocation [ i ] + 1 ) ; } else { System . out . print ( "Not Allocated" ) ; } System . out . println ( "" ) ; } }
public static void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Stack < Integer > stk = new Stack < Integer > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { System . out . print ( stk . peek ( ) + " " ) ; stk . pop ( ) ; } }
static int minJumps ( int a , int b , int d ) { int temp = a ; a = Math . min ( a , b ) ; b = Math . max ( temp , b ) ; if ( d >= b ) return ( d + b - 1 ) / b ; if ( d == 0 ) return 0 ; if ( d == a ) return 1 ; return 2 ; }
public static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; }
public static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " " ) ; } }
static int findRepeating ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum - ( ( ( n - 1 ) * n ) / 2 ) ; }
static int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
static int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
static double areaOfInscribedCircle ( float a ) { return ( PI / 4 ) * a * a ; }
public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int divisors [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; }
static int findSubarraySum ( int [ ] arr , int n ) { int res = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( m . containsKey ( sum ) ) { m . put ( sum , m . get ( sum ) + 1 ) ; } else { m . put ( sum , 1 ) ; } } } for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) if ( x . getValue ( ) == 1 ) res += x . getKey ( ) ; return res ; }
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; } else { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }
static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
static int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; }
static void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + " " ) ; } }
static void printInSortedOrder ( String arr [ ] , int n ) { int index [ ] = new int [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) { min = j ; } } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ index [ i ] ] + " " ) ; } }
static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
static boolean isRectangle ( int matrix [ ] [ ] ) { int rows = matrix . length ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . length ; HashMap < Integer , HashSet < Integer >> table = new HashMap < > ( ) ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns - 1 ; j ++ ) { for ( int k = j + 1 ; k < columns ; k ++ ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( table . containsKey ( j ) && table . get ( j ) . contains ( k ) ) { return true ; } if ( table . containsKey ( k ) && table . get ( k ) . contains ( j ) ) { return true ; } if ( ! table . containsKey ( j ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( k ) ; table . put ( j , x ) ; } else { table . get ( j ) . add ( k ) ; } if ( ! table . containsKey ( k ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( j ) ; table . put ( k , x ) ; } else { table . get ( k ) . add ( j ) ; } } } } } return false ; }
static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
