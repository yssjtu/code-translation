def fib ( n , a = 0 , b = 1 ) : if n == 0 : return a if n == 1 : return b return fib ( n - 1 , b , a + b ) ;
def rearrange ( a , size ) : positive = 0 negative = 1 while ( True ) : while ( positive < size and a [ positive ] >= 0 ) : positive = positive + 2 while ( negative < size and a [ negative ] <= 0 ) : negative = negative + 2 if ( positive < size and negative < size ) : temp = a [ positive ] a [ positive ] = a [ negative ] a [ negative ] = temp else : break
def printNos ( n ) : if n > 0 : printNos ( n - 1 ) print ( n , end = '' )
def findCount ( n , sum ) : start = math . pow ( 10 , n - 1 ) end = math . pow ( 10 , n ) - 1 count = 0 i = start while ( i <= end ) : cur = 0 temp = i while ( temp != 0 ) : cur += temp % 10 temp = temp // 10 if ( cur == sum ) : count = count + 1 i += 9 else : i = i + 1 print ( count )
def sumofFactors ( n ) : res = 1 for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : curr_sum = 1 curr_term = 1 while n % i == 0 : n = n / i curr_term = curr_term * i curr_sum += curr_term res = res * curr_sum if n > 2 : res = res * ( 1 + n ) return res
def MaximumHeight ( a , n ) : return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2
def insertSorted ( arr , n , key , capacity ) : if ( n >= capacity ) : return n i = n - 1 while i >= 0 and arr [ i ] > key : arr [ i + 1 ] = arr [ i ] i -= 1 arr [ i + 1 ] = key return ( n + 1 )
def find ( arr ) : n = len ( arr ) i = 0 j = n - 1 res = - 1 while i < n and j >= 0 : if arr [ i ] [ j ] == 0 : while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : j -= 1 if j == - 1 : res = i break else : i += 1 else : while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : i += 1 if i == n : res = j break else : j -= 1 if res == - 1 : return res for i in range ( 0 , n ) : if res != i and arr [ i ] [ res ] != 1 : return - 1 for j in range ( 0 , j ) : if res != j and arr [ res ] [ j ] != 0 : return - 1 ; return res ;
def pad ( n ) : pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 for i in range ( 3 , n + 1 ) : pNext = pPrevPrev + pPrev pPrevPrev = pPrev pPrev = pCurr pCurr = pNext return pNext ;
def countNonDecreasing ( n ) : dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] for i in range ( 10 ) : dp [ i ] [ 1 ] = 1 for digit in range ( 10 ) : for len in range ( 2 , n + 1 ) : for x in range ( digit + 1 ) : dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] count = 0 for i in range ( 10 ) : count += dp [ i ] [ n ] return count
def printSpiral ( mat , r , c ) : a = 0 b = 2 low_row = 0 if ( 0 > a ) else a low_column = 0 if ( 0 > b ) else b - 1 high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 while ( ( low_row > 0 - r and low_column > 0 - c ) ) : i = low_column + 1 while ( i <= high_column and i < c and low_row >= 0 ) : print ( mat [ low_row ] [ i ] , end = "" ) i += 1 low_row -= 1 i = low_row + 2 while ( i <= high_row and i < r and high_column < c ) : print ( mat [ i ] [ high_column ] , end = "" ) i += 1 high_column += 1 i = high_column - 2 while ( i >= low_column and i >= 0 and high_row < r ) : print ( mat [ high_row ] [ i ] , end = "" ) i -= 1 high_row += 1 i = high_row - 2 while ( i > low_row and i >= 0 and low_column >= 0 ) : print ( mat [ i ] [ low_column ] , end = "" ) i -= 1 low_column -= 1 print ( )
def segregateElements ( arr , n ) : temp = [ 0 for k in range ( n ) ] j = 0 for i in range ( n ) : if ( arr [ i ] >= 0 ) : temp [ j ] = arr [ i ] j += 1 if ( j == n or j == 0 ) : return for i in range ( n ) : if ( arr [ i ] < 0 ) : temp [ j ] = arr [ i ] j += 1 for k in range ( n ) : arr [ k ] = temp [ k ]
def KSwapMaximum ( n , k ) : global arr for i in range ( 0 , n - 1 ) : if ( k > 0 ) : indexPosition = i for j in range ( i + 1 , n ) : if ( k <= j - i ) : break if ( arr [ j ] > arr [ indexPosition ] ) : indexPosition = j for j in range ( indexPosition , i , - 1 ) : t = arr [ j ] arr [ j ] = arr [ j - 1 ] arr [ j - 1 ] = t k = k - indexPosition - i
def nearestSmallerEqFib ( n ) : if ( n == 0 or n == 1 ) : return n f1 , f2 , f3 = 0 , 1 , 1 while ( f3 <= n ) : f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; return f2 ;
def getMinNumberForPattern ( seq ) : n = len ( seq ) if ( n >= 9 ) : return "-1" result = [ None ] * ( n + 1 ) count = 1 for i in range ( n + 1 ) : if ( i == n or seq [ i ] == 'I' ) : for j in range ( i - 1 , - 2 , - 1 ) : result [ j + 1 ] = int ( '0' + str ( count ) ) count += 1 if ( j >= 0 and seq [ j ] == 'I' ) : break return result
def rearrangeArray ( arr , n ) : arr . sort ( ) tempArr = [ 0 ] * ( n + 1 ) ArrIndex = 0 i = 0 j = n - 1 while ( i <= n // 2 or j > n // 2 ) : tempArr [ ArrIndex ] = arr [ i ] ArrIndex = ArrIndex + 1 tempArr [ ArrIndex ] = arr [ j ] ArrIndex = ArrIndex + 1 i = i + 1 j = j - 1 for i in range ( 0 , n ) : arr [ i ] = tempArr [ i ]
def section ( x1 , x2 , y1 , y2 , m , n ) : x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) print ( x , y )
def isDvisibleBy12 ( num ) : if ( len ( num ) >= 3 ) : d1 = int ( num [ len ( num ) - 1 ] ) if ( d1 % 2 != 0 ) : return False d2 = int ( num [ len ( num ) - 2 ] ) sum = 0 for i in range ( 0 , len ( num ) ) : sum += int ( num [ i ] ) return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) else : number = int ( num ) return ( number % 12 == 0 )
def gcd ( a , b ) : if ( a == b ) : return a if ( a == 0 ) : return b if ( b == 0 ) : return a if ( ( ~ a & 1 ) == 1 ) : if ( ( b & 1 ) == 1 ) : return gcd ( a >> 1 , b ) else : return ( gcd ( a >> 1 , b >> 1 ) << 1 ) if ( ( ~ b & 1 ) == 1 ) : return gcd ( a , b >> 1 ) if ( a > b ) : return gcd ( ( a - b ) >> 1 , b ) return gcd ( ( b - a ) >> 1 , a )
def selectRandom ( x ) : res = 0 count = 0 count += 1 if ( count == 1 ) : res = x else : i = random . randrange ( count ) if ( i == count - 1 ) : res = x return res
def getMedian ( ar1 , ar2 , n ) : i = 0 j = 0 m1 = - 1 m2 = - 1 count = 0 while count < n + 1 : count += 1 if i == n : m1 = m2 m2 = ar2 [ 0 ] break elif j == n : m1 = m2 m2 = ar1 [ 0 ] break if ar1 [ i ] < ar2 [ j ] : m1 = m2 m2 = ar1 [ i ] i += 1 else : m1 = m2 m2 = ar2 [ j ] j += 1 return ( m1 + m2 ) / 2
def check ( st ) : n = len ( st ) oddDigSum = 0 evenDigSum = 0 for i in range ( 0 , n ) : if ( i % 2 == 0 ) : oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) else : evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) return ( ( oddDigSum - evenDigSum ) % 11 == 0 )
def findMinInsertions ( str , l , h ) : if ( l > h ) : return sys . maxsize if ( l == h ) : return 0 if ( l == h - 1 ) : return 0 if ( str [ l ] == str [ h ] ) else 1 if ( str [ l ] == str [ h ] ) : return findMinInsertions ( str , l + 1 , h - 1 ) else : return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )
def printTreeEdges ( prufer , m ) : vertices = m + 2 vertex_set = [ 0 ] * vertices for i in range ( vertices - 2 ) : vertex_set [ prufer [ i ] - 1 ] += 1 print ( "TheedgesetE(G)is:" ) j = 0 for i in range ( vertices - 2 ) : for j in range ( vertices ) : if ( vertex_set [ j ] == 0 ) : vertex_set [ j ] = - 1 print ( "(" , ( j + 1 ) , "," , prufer [ i ] , ")" , sep = "" , end = "" ) vertex_set [ prufer [ i ] - 1 ] -= 1 break j = 0 for i in range ( vertices ) : if ( vertex_set [ i ] == 0 and j == 0 ) : print ( "(" , ( i + 1 ) , "," , sep = "" , end = "" ) j += 1 elif ( vertex_set [ i ] == 0 and j == 1 ) : print ( ( i + 1 ) , ")" )
def findArea ( r ) : PI = 3.142 return PI * ( r * r )
def maxAverageOfPath ( cost , N ) : dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] for j in range ( 1 , N ) : dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] for i in range ( 1 , N ) : for j in range ( 1 , N ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )
def evenSum ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n + 1 ) ) : if j == 0 or j == i : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] sum = 0 ; for i in range ( 0 , n + 1 ) : if n % 2 == 0 : sum = sum + C [ n ] [ i ] return sum
def mostFrequent ( arr , n ) : Hash = dict ( ) for i in range ( n ) : if arr [ i ] in Hash . keys ( ) : Hash [ arr [ i ] ] += 1 else : Hash [ arr [ i ] ] = 1 max_count = 0 res = - 1 for i in Hash : if ( max_count < Hash [ i ] ) : res = i max_count = Hash [ i ] return res
def fib ( n ) : if n < 6 : return f [ n ] t = 5 fn = 5 while t < n : fn = round ( fn * PHI ) t += 1 return fn
def minAbsSumPair ( arr , arr_size ) : inv_count = 0 if arr_size < 2 : print ( "InvalidInput" ) return min_l = 0 min_r = 1 min_sum = arr [ 0 ] + arr [ 1 ] for l in range ( 0 , arr_size - 1 ) : for r in range ( l + 1 , arr_size ) : sum = arr [ l ] + arr [ r ] if abs ( min_sum ) > abs ( sum ) : min_sum = sum min_l = l min_r = r print ( "Thetwoelementswhosesumisminimumare" , arr [ min_l ] , "and" , arr [ min_r ] )
def find3largest ( arr , n ) : arr = sorted ( arr ) check = 0 count = 1 for i in range ( 1 , n + 1 ) : if ( count < 4 ) : if ( check != arr [ n - i ] ) : print ( arr [ n - i ] , end = "" ) check = arr [ n - i ] count += 1 else : break
def squareRoot ( n , p ) : n = n % p for x in range ( 2 , p ) : if ( ( x * x ) % p == n ) : print ( "Squarerootis" , x ) return print ( "Squarerootdoesn'texist" )
def maxDiff ( arr , n ) : SubsetSum_1 = 0 SubsetSum_2 = 0 for i in range ( 0 , n ) : isSingleOccurance = True for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : isSingleOccurance = False arr [ i ] = arr [ j ] = 0 break if ( isSingleOccurance == True ) : if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] return abs ( SubsetSum_1 - SubsetSum_2 )
def findElements ( arr , n ) : arr . sort ( ) for i in range ( 0 , n - 2 ) : print ( arr [ i ] , end = "" )
def findMaximum ( arr , low , high ) : max = arr [ low ] i = low for i in range ( high + 1 ) : if arr [ i ] > max : max = arr [ i ] return max
def binarySearch ( arr , low , high ) : if high >= low : mid = ( low + high ) // 2 if mid is arr [ mid ] : return mid if mid > arr [ mid ] : return binarySearch ( arr , ( mid + 1 ) , high ) else : return binarySearch ( arr , low , ( mid - 1 ) ) return - 1
def isEven ( n ) : return ( not ( n & 1 ) )
def findTwoscomplement ( str ) : n = len ( str ) i = n - 1 while ( i >= 0 ) : if ( str [ i ] == '1' ) : break i -= 1 if ( i == - 1 ) : return '1' + str k = i - 1 while ( k >= 0 ) : if ( str [ k ] == '1' ) : str = list ( str ) str [ k ] = '0' str = '' . join ( str ) else : str = list ( str ) str [ k ] = '1' str = '' . join ( str ) k -= 1 return str
def spiralDiaSum ( n ) : if n == 1 : return 1 return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )
def maxSum ( arr , N , k ) : MS = [ 0 for i in range ( N ) ] MS [ N - 1 ] = arr [ N - 1 ] for i in range ( N - 2 , - 1 , - 1 ) : if ( i + k + 1 >= N ) : MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) else : MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) return MS [ 0 ]
def printkthnode ( adj , wt , n , k ) : for i in range ( n ) : adj [ i ] . sort ( ) for i in range ( n ) : if ( len ( adj [ i ] ) >= k ) : print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = "" ) else : print ( "-1" , end = "" )
def findRepeatFirst ( s ) : p = - 1 hash = [ 0 for i in range ( MAX_CHAR ) ] pos = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( len ( s ) ) : k = ord ( s [ i ] ) if ( hash [ k ] == 0 ) : hash [ k ] += 1 pos [ k ] = i elif ( hash [ k ] == 1 ) : hash [ k ] += 1 for i in range ( MAX_CHAR ) : if ( hash [ i ] == 2 ) : if ( p == - 1 ) : p = pos [ i ] elif ( p > pos [ i ] ) : p = pos [ i ] return p
def translate ( st ) : l = len ( st ) if ( l < 2 ) : return i = 0 j = 0 while ( j < l - 1 ) : if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) : j += 2 st [ i ] = 'C' i += 1 continue st [ i ] = st [ j ] i += 1 j += 1 if ( j == l - 1 ) : st [ i ] = st [ j ] i += 1 st [ i ] = '' st [ l - 1 ] = ''
def findPair ( arr , n ) : found = False for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : for k in range ( 0 , n ) : if ( arr [ i ] + arr [ j ] == arr [ k ] ) : print ( arr [ i ] , arr [ j ] ) found = True if ( found == False ) : print ( "Notexist" )
def Print ( n , k ) : rem = 1 for i in range ( 0 , k ) : print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = "" ) rem = ( 10 * rem ) % n
def isDivisible999 ( num ) : n = len ( num ) ; if ( n == 0 or num [ 0 ] == '0' ) : return true if ( ( n % 3 ) == 1 ) : num = "00" + num if ( ( n % 3 ) == 2 ) : num = "0" + num gSum = 0 for i in range ( 0 , n , 3 ) : group = 0 group += ( ord ( num [ i ] ) - 48 ) * 100 group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 group += ( ord ( num [ i + 2 ] ) - 48 ) gSum += group if ( gSum > 1000 ) : num = str ( gSum ) n = len ( num ) gSum = isDivisible999 ( num ) return ( gSum == 999 )
def FirstRepeated ( string ) : checker = 0 pos = 0 for i in string : val = ord ( i ) - ord ( 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) : return pos checker |= ( 1 << val ) pos += 1 return - 1
def calculate ( A , B , C , M ) : res = pow ( B , C , M - 1 ) ans = pow ( A , res , M ) return ans
def findString ( n , k ) : res = "" for i in range ( k ) : res = res + chr ( ord ( 'a' ) + i ) count = 0 for i in range ( n - k ) : res = res + chr ( ord ( 'a' ) + count ) count += 1 if ( count == k ) : count = 0 ; return res
def minInitialPoints ( points ) : dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] m , n = R , C if points [ m - 1 ] [ n - 1 ] > 0 : dp [ m - 1 ] [ n - 1 ] = 1 else : dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 for i in range ( m - 2 , - 1 , - 1 ) : dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) for i in range ( 2 , - 1 , - 1 ) : dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) for i in range ( m - 2 , - 1 , - 1 ) : for j in range ( n - 2 , - 1 , - 1 ) : min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) return dp [ 0 ] [ 0 ]
def subArraySum ( arr , n , Sum ) : Map = { } curr_sum = 0 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if curr_sum == Sum : print ( "Sumfoundbetweenindexes0to" , i ) return if ( curr_sum - Sum ) in Map : print ( "Sumfoundbetweenindexes" , \ Map [ curr_sum - Sum ] + 1 , "to" , i ) return Map [ curr_sum ] = i print ( "Nosubarraywithgivensumexists" )
def countTransformation ( a , b ) : n = len ( a ) m = len ( b ) if m == 0 : return 1 dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] for i in range ( m ) : for j in range ( i , n ) : if i == 0 : if j == 0 : if a [ j ] == b [ i ] : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 0 elif a [ j ] == b [ i ] : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] else : if a [ j ] == b [ i ] : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) else : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] return dp [ m - 1 ] [ n - 1 ]
def findCommon ( mat ) : column = [ N - 1 ] * M min_row = 0 while ( column [ min_row ] >= 0 ) : for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : min_row = i eq_count = 0 for i in range ( M ) : if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) : if ( column [ i ] == 0 ) : return - 1 column [ i ] -= 1 else : eq_count += 1 if ( eq_count == M ) : return mat [ min_row ] [ column [ min_row ] ] return - 1
def sumOfSeries ( n ) : return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 )
def findMaxSum ( arr , n ) : res = - sys . maxsize - 1 for i in range ( n ) : prefix_sum = arr [ i ] for j in range ( i ) : prefix_sum += arr [ j ] suffix_sum = arr [ i ] j = n - 1 while ( j > i ) : suffix_sum += arr [ j ] j -= 1 if ( prefix_sum == suffix_sum ) : res = max ( res , prefix_sum ) return res
def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 for i in range ( 1 , n ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] return a [ n - 1 ] + b [ n - 1 ]
def getMinStepToReachEnd ( arr , N ) : visit = [ False for i in range ( N ) ] distance = [ 0 for i in range ( N ) ] digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ] for i in range ( 1 , N ) : digit [ arr [ i ] ] . append ( i ) distance [ 0 ] = 0 visit [ 0 ] = True q = [ ] q . append ( 0 ) while ( len ( q ) > 0 ) : idx = q [ 0 ] q . remove ( q [ 0 ] ) if ( idx == N - 1 ) : break d = arr [ idx ] for i in range ( len ( digit [ d ] ) ) : nextidx = digit [ d ] [ i ] if ( visit [ nextidx ] == False ) : visit [ nextidx ] = True q . append ( nextidx ) distance [ nextidx ] = distance [ idx ] + 1 if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : visit [ idx - 1 ] = True q . append ( idx - 1 ) distance [ idx - 1 ] = distance [ idx ] + 1 if ( idx + 1 < N and visit [ idx + 1 ] == False ) : visit [ idx + 1 ] = True q . append ( idx + 1 ) distance [ idx + 1 ] = distance [ idx ] + 1 return distance [ N - 1 ]
def minOps ( arr , n , k ) : max1 = max ( arr ) res = 0 for i in range ( 0 , n ) : if ( ( max1 - arr [ i ] ) % k != 0 ) : return - 1 else : res += ( max1 - arr [ i ] ) / k return int ( res )
def countIslands ( mat ) : count = 0 for i in range ( 0 , M ) : for j in range ( 0 , N ) : if ( mat [ i ] [ j ] == 'X' ) : if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) and ( j == 0 or mat [ i ] [ j - 1 ] == 'O' ) ) : count = count + 1 return count
def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( y2 - y1 ) slope_error_new = m_new - ( x2 - x1 ) y = y1 for x in range ( x1 , x2 + 1 ) : print ( "(" , x , "," , y , ")\n" ) slope_error_new = slope_error_new + m_new if ( slope_error_new >= 0 ) : y = y + 1 slope_error_new = slope_error_new - 2 * ( x2 - x1 )
def findMinZero ( p ) : first = 1 second = 1 number = 2 next = 1 while ( next ) : next = ( first + second ) % p first = second second = next number = number + 1 return number
def printDuo ( string ) : countChar = [ 0 for i in range ( MAX_CHAR ) ] n = len ( string ) for i in range ( n ) : countChar [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 str1 = "" str2 = "" for i in range ( MAX_CHAR ) : if ( countChar [ i ] > 1 ) : str2 = str2 + chr ( i + ord ( 'a' ) ) elif ( countChar [ i ] == 1 ) : str1 = str1 + chr ( i + ord ( 'a' ) ) print ( "Stringwithcharactersoccurringonce:" , "\n" , str1 ) print ( "Stringwithcharactersoccurring" , "multipletimes:" , "\n" , str2 )
def minDifferenceAmongMaxMin ( arr , N , K ) : arr . sort ( ) res = 2147483647 for i in range ( ( N - K ) + 1 ) : curSeqDiff = arr [ i + K - 1 ] - arr [ i ] res = min ( res , curSeqDiff ) return res
def sum ( a , n ) : cnt = dict ( ) ans = 0 pre_sum = 0 for i in range ( n ) : ans += ( i * a [ i ] ) - pre_sum pre_sum += a [ i ] if ( a [ i ] - 1 ) in cnt : ans -= cnt [ a [ i ] - 1 ] if ( a [ i ] + 1 ) in cnt : ans += cnt [ a [ i ] + 1 ] if a [ i ] not in cnt : cnt [ a [ i ] ] = 0 cnt [ a [ i ] ] += 1 return ans
def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : max = arr1 [ 0 ] min = arr2 [ 0 ] i = 1 while ( i < n1 and i < n2 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 while ( i < n1 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] i += 1 while ( i < n2 ) : if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 return max * min
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def isPowerOfK ( n , k ) : oneSeen = False while ( n > 0 ) : digit = n % k if ( digit > 1 ) : return False if ( digit == 1 ) : if ( oneSeen ) : return False oneSeen = True n //= k return True
def canMakeStr2 ( s1 , s2 ) : count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } for i in range ( len ( s1 ) ) : count [ s1 [ i ] ] += 1 for i in range ( len ( s2 ) ) : if count [ s2 [ i ] ] == 0 : return False count [ s2 [ i ] ] -= 1 return True
def countNumber ( n ) : result = 0 for i in range ( 1 , 10 ) : s = [ ] if ( i <= n ) : s . append ( i ) result += 1 while len ( s ) != 0 : tp = s [ - 1 ] s . pop ( ) for j in range ( tp % 10 , 10 ) : x = tp * 10 + j if ( x <= n ) : s . append ( x ) result += 1 return result
def print_sequence ( n , k ) : b = int ( n / ( k * ( k + 1 ) / 2 ) ) if b == 0 : print ( "-1" ) else : r = 1 x = 1 while x ** 2 <= n : if n % x != 0 : continue elif x <= b and x > r : r = x elif n / x <= b and n / x > r : r = n / x x = x + 1 i = 1 while i < k : print ( r * i , end = "" ) i = i + 1 last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) print ( last_term )
def printDistinct ( arr , n ) : arr . sort ( ) for i in range ( n ) : if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : i += 1 else : print ( arr [ i ] , end = "" )
def addOne ( x ) : return ( - ( ~ x ) )
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]
def largestKSubmatrix ( a ) : dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] result = 0 for i in range ( Row ) : for j in range ( Col ) : if ( i == 0 or j == 0 ) : dp [ i ] [ j ] = 1 else : if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 else : dp [ i ] [ j ] = 1 result = max ( result , dp [ i ] [ j ] ) return result
def getInvCount ( arr , n ) : invcount = 0 for i in range ( 1 , n - 1 ) : small = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : small += 1 great = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( arr [ i ] < arr [ j ] ) : great += 1 invcount += great * small return invcount
def mostFrequent ( arr , n ) : arr . sort ( ) max_count = 1 res = arr [ 0 ] curr_count = 1 for i in range ( 1 , n ) : if ( arr [ i ] == arr [ i - 1 ] ) : curr_count += 1 else : if ( curr_count > max_count ) : max_count = curr_count res = arr [ i - 1 ] curr_count = 1 if ( curr_count > max_count ) : max_count = curr_count res = arr [ n - 1 ] return res
def lcs ( X , Y , m , n ) : if m == 0 or n == 0 : return 0 ; elif X [ m - 1 ] == Y [ n - 1 ] : return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else : return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;
def find ( p ) : return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) )
def sortUsingHash ( a , n ) : Max = max ( a ) Hash = [ 0 ] * ( Max + 1 ) for i in range ( 0 , n ) : Hash [ a [ i ] ] += 1 for i in range ( 0 , Max + 1 ) : if Hash [ i ] != 0 : for j in range ( 0 , Hash [ i ] ) : print ( i , end = "" )
def minmaxProduct ( arr1 , arr2 , n1 , n2 ) : arr1 . sort ( ) arr2 . sort ( ) return arr1 [ n1 - 1 ] * arr2 [ 0 ]
def nthTerm ( n ) : return ( n * n ) + ( n * n * n )
def countSeq ( n , diff ) : if ( abs ( diff ) > n ) : return 0 if ( n == 1 and diff == 0 ) : return 2 if ( n == 1 and abs ( diff ) == 1 ) : return 1 res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) return res
def smallestKFreq ( arr , n , k ) : mp = defaultdict ( lambda : 0 ) for i in range ( n ) : mp [ arr [ i ] ] += 1 res = sys . maxsize res1 = sys . maxsize for key , values in mp . items ( ) : if values == k : res = min ( res , key ) return res if res != res1 else - 1
def printSquares ( n ) : square = 0 odd = 1 for x in range ( 0 , n ) : print ( square , end = "" ) square = square + odd odd = odd + 2
def countPairs ( str1 ) : result = 0 ; n = len ( str1 ) for i in range ( 0 , n ) : for j in range ( 1 , MAX_CHAR + 1 ) : if ( ( i + j ) < n ) : if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : result += 1 ; return result
def isPrime ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return True if ( n % 2 == 0 or n % 3 == 0 ) : return False i = 5 while ( i * i <= n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return False i = i + 6 return True
def findthepath ( S , v ) : result [ 0 ] = v for i in range ( 1 , len ( S ) ) : if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) ] [ v ] ) : v = ord ( S [ i ] ) - ord ( 'A' ) elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) : v = ord ( S [ i ] ) - ord ( 'A' ) + 5 else : return False result . append ( v ) return True
def minTimeForWritingChars ( N , insrt , remov , cpy ) : if N == 0 : return 0 if N == 1 : return insrt dp = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : if i % 2 == 0 : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + cpy ) else : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) // 2 ] + cpy + remov ) return dp [ N ]
def isDiagonalMatrix ( mat ) : for i in range ( 0 , N ) : for j in range ( 0 , N ) : if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : return False return True
def binomialCoeffSum ( n ) : return ( 1 << n )
def carveCross ( str ) : n = len ( str ) if ( n % 2 == 0 ) : print ( "Notpossible.Pleaseenter" , "oddlengthstring.\n" ) else : arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] m = n // 2 for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = 'X' for i in range ( n ) : arr [ i ] [ m ] = str [ i ] for i in range ( n ) : arr [ m ] [ i ] = str [ i ] for i in range ( n ) : for j in range ( n ) : print ( arr [ i ] [ j ] , end = "" ) print ( )
def minRange ( arr , n , k ) : l = 0 r = n for i in range ( n ) : s = [ ] for j in range ( i , n ) : s . append ( arr [ j ] ) if ( len ( s ) == k ) : if ( ( j - i ) < ( r - l ) ) : r = j l = i break if ( j == n ) : break if ( l == 0 and r == n ) : print ( "Invalidk" ) else : print ( l , r )
def findRoots ( a , b , c ) : if a == 0 : print ( "Invalid" ) return - 1 d = b * b - 4 * a * c sqrt_val = math . sqrt ( abs ( d ) ) if d > 0 : print ( "Rootsarerealanddifferent" ) print ( ( - b + sqrt_val ) / ( 2 * a ) ) print ( ( - b - sqrt_val ) / ( 2 * a ) ) elif d == 0 : print ( "Rootsarerealandsame" ) print ( - b / ( 2 * a ) ) else : print ( "Rootsarecomplex" ) print ( - b / ( 2 * a ) , "+i" , sqrt_val ) print ( - b / ( 2 * a ) , "-i" , sqrt_val )
def maxSubArraySum ( a , size ) : max_so_far = - maxsize - 1 max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( 0 , size ) : max_ending_here += a [ i ] if max_so_far < max_ending_here : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 return ( end - start + 1 )
def findWays ( m , n , x ) : table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] for j in range ( 1 , min ( m + 1 , x + 1 ) ) : table [ 1 ] [ j ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 1 , x + 1 ) : for k in range ( 1 , min ( m + 1 , j ) ) : table [ i ] [ j ] += table [ i - 1 ] [ j - k ] return table [ - 1 ] [ - 1 ]
def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : if ( curr_sum <= 0 and x > 0 ) : start = end curr_sum = 0 curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len
def encrypt ( text , s ) : result = "" for i in range ( len ( text ) ) : char = text [ i ] if ( char . isupper ( ) ) : result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) else : result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) return result
def getNumStrictMonotone ( ln ) : DP = [ [ 0 ] * DP_s for _ in range ( ln ) ] for i in range ( DP_s ) : DP [ 0 ] [ i ] = i + 1 for i in range ( 1 , ln ) : for j in range ( 1 , DP_s ) : DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] return DP [ ln - 1 ] [ DP_s - 1 ]
def getRemainder ( num , divisor ) : while ( num >= divisor ) : num -= divisor return num
def longestSubseqWithK ( str , k ) : n = len ( str ) freq = [ 0 ] * MAX_CHARS for i in range ( n ) : freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) : print ( str [ i ] , end = "" )
def minTime ( arr , n ) : if ( n <= 0 ) : return 0 incl = arr [ 0 ] excl = 0 for i in range ( 1 , n ) : incl_new = arr [ i ] + min ( excl , incl ) excl_new = incl incl = incl_new excl = excl_new return min ( incl , excl )
def minMaxValues ( arr , n , m ) : sum = 0 INF = 1000000000 MAX = 50 for i in range ( 0 , ( n + m ) ) : sum += arr [ i ] arr [ i ] += 50 dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] dp [ 0 ] [ 0 ] = 1 for i in range ( 0 , ( n + m ) ) : for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : for j in range ( 0 , MAX * MAX + 1 ) : if ( dp [ k - 1 ] [ j ] ) : dp [ k ] [ j + arr [ i ] ] = 1 max_value = - 1 * INF min_value = INF for i in range ( 0 , MAX * MAX + 1 ) : if ( dp [ n ] [ i ] ) : temp = i - 50 * n max_value = max ( max_value , temp * ( sum - temp ) ) min_value = min ( min_value , temp * ( sum - temp ) ) print ( "MaximumValue:{}\nMinimumValue:{}" . format ( max_value , min_value ) )
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : arr . sort ( ) dp = [ 0 ] * N dp [ 0 ] = 0 for i in range ( 1 , N ) : dp [ i ] = dp [ i - 1 ] if ( arr [ i ] - arr [ i - 1 ] < K ) : if ( i >= 2 ) : dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) else : dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) return dp [ N - 1 ]
def middleOfThree ( a , b , c ) : if ( ( a < b and b < c ) or ( c < b and b < a ) ) : return b if ( ( b < a and a < c ) or ( c < a and a < b ) ) : return a else : return c
def getOddOccurrence ( arr , size ) : Hash = dict ( ) for i in range ( size ) : Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 for i in Hash : if ( Hash [ i ] % 2 != 0 ) : return i return - 1
def minSpacePreferLarge ( w , m , n ) : num_m = 0 num_n = 0 rem = w p = 0 q = 0 r = 0 while ( w >= n ) : p = w / m r = w % m if ( r <= rem ) : num_m = p num_n = q rem = r q += 1 w -= n print ( str ( int ( num_m ) ) + "" + str ( num_n ) + "" + str ( rem ) )
def isReversible ( str ) : i = 0 j = len ( str ) - 1 while ( i < j ) : if ( str [ i ] != str [ j ] ) : return False i += 1 j -= 1 return True
def isOneFlip ( str ) : sum = 0 n = len ( str ) for i in range ( 0 , n ) : sum += int ( str [ i ] ) - int ( '0' ) return ( sum == n - 1 or sum == 1 )
def decToOctal ( n ) : octalNum = [ 0 ] * 100 i = 0 while ( n != 0 ) : octalNum [ i ] = n % 8 n = int ( n / 8 ) i += 1 for j in range ( i - 1 , - 1 , - 1 ) : print ( octalNum [ j ] , end = "" )
def isPalindrome ( string ) : l = 0 h = len ( string ) - 1 while h > l : l += 1 h -= 1 if string [ l - 1 ] != string [ h + 1 ] : return False return True
def sumOfSubstrings ( num ) : n = len ( num ) sumofdigit = [ ] sumofdigit . append ( int ( num [ 0 ] ) ) res = sumofdigit [ 0 ] for i in range ( 1 , n ) : numi = int ( num [ i ] ) sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) res += sumofdigit [ i ] return res
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : s = set ( ) for i in range ( n1 ) : s . add ( a1 [ i ] ) for i in range ( n2 ) : for j in range ( n3 ) : if sum - a2 [ i ] - a3 [ j ] in s : return True return False
def sortString ( str ) : charCount = [ 0 ] * MAX_CHAR for i in range ( len ( str ) ) : charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : for j in range ( charCount [ i ] ) : print ( chr ( 97 + i ) , end = "" )
def maxLength ( s , n ) : invalidOpenBraces = 0 invalidCloseBraces = 0 for i in range ( n ) : if ( s [ i ] == '(' ) : invalidOpenBraces += 1 else : if ( invalidOpenBraces == 0 ) : invalidCloseBraces += 1 else : invalidOpenBraces -= 1 return ( n - ( invalidOpenBraces + invalidCloseBraces ) )
def printRepeating ( arr , size ) : print ( "Therepeatingelementsare" , end = "" ) for i in range ( 0 , size ) : if ( arr [ abs ( arr [ i ] ) ] > 0 ) : arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] else : print ( abs ( arr [ i ] ) , end = "" )
def MinOperation ( a , n , k ) : result = 0 for i in range ( n ) : if ( a [ i ] != 1 and a [ i ] > k ) : result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) else : result = result + k - a [ i ] return result
def printSorted ( arr , start , end ) : if start > end : return printSorted ( arr , start * 2 + 1 , end ) print ( arr [ start ] , end = "" ) printSorted ( arr , start * 2 + 2 , end )
def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 res = 0 sum = 0 for i in range ( position , length ) : sum = sum + int ( num [ i ] ) if ( sum >= previous_sum ) : res = res + countGroups ( i + 1 , sum , length , num ) return res
def getMissingNo ( a , n ) : i , total = 0 , 1 for i in range ( 2 , n + 2 ) : total += i total -= a [ i - 2 ] return total
def findMaxGCD ( arr , n ) : high = 0 for i in range ( 0 , n ) : high = max ( high , arr [ i ] ) count = [ 0 ] * ( high + 1 ) for i in range ( 0 , n ) : count [ arr [ i ] ] += 1 counter = 0 for i in range ( high , 0 , - 1 ) : j = i while ( j <= high ) : if ( count [ j ] > 0 ) : counter += count [ j ] j += i if ( counter == 2 ) : return i counter = 0
def getSum ( n ) : sum = 0 while ( n != 0 ) : sum = sum + int ( n % 10 ) n = int ( n / 10 ) return sum
def count9s ( number ) : n = len ( number ) d = [ 0 for i in range ( 9 ) ] d [ 0 ] = 1 result = 0 mod_sum = 0 continuous_zero = 0 for i in range ( n ) : if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : continuous_zero += 1 else : continuous_zero = 0 mod_sum += ord ( number [ i ] ) - ord ( '0' ) mod_sum %= 9 result += d [ mod_sum ] d [ mod_sum ] += 1 result -= continuous_zero return result
def minAdjustmentCost ( A , n , target ) : dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] for j in range ( M + 1 ) : dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) for i in range ( 1 , n ) : for j in range ( M + 1 ) : dp [ i ] [ j ] = 100000000 for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) res = 10000000 for j in range ( M + 1 ) : res = min ( res , dp [ n - 1 ] [ j ] ) return res
def solveWordWrap ( arr , n , k ) : dp = [ 0 ] * n ans = [ 0 ] * n dp [ n - 1 ] = 0 ans [ n - 1 ] = n - 1 for i in range ( n - 2 , - 1 , - 1 ) : currlen = - 1 dp [ i ] = sys . maxsize for j in range ( i , n ) : currlen += ( arr [ j ] + 1 ) if ( currlen > k ) : break if ( j == n - 1 ) : cost = 0 else : cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) if ( cost < dp [ i ] ) : dp [ i ] = cost ans [ i ] = j i = 0 while ( i < n ) : print ( i + 1 , ans [ i ] + 1 , end = "" ) i = ans [ i ] + 1
def mirrorImage ( a , b , c , x1 , y1 ) : temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) x = temp * a + x1 y = temp * b + y1 return ( x , y )
def count ( n ) : dp = [ 0 for _ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if i <= 3 : dp [ i ] = 1 elif i == 4 : dp [ i ] = 2 else : dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] return dp [ n ]
def maxTripletSum ( arr , n ) : arr . sort ( ) return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )
def printEqualSumSets ( arr , n ) : sum_array = sum ( arr ) if ( sum_array & 1 ) : print ( "-1" ) return k = sum_array >> 1 dp = np . zeros ( ( n + 1 , k + 1 ) ) for i in range ( 1 , k + 1 ) : dp [ 0 ] [ i ] = False for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : for currSum in range ( 1 , k + 1 ) : dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] if ( arr [ i - 1 ] <= currSum ) : dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) set1 , set2 = [ ] , [ ] if ( not dp [ n ] [ k ] ) : print ( "-1" ) return i = n currSum = k while ( i > 0 and currSum >= 0 ) : if ( dp [ i - 1 ] [ currSum ] ) : i -= 1 set2 . append ( arr [ i ] ) elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) : i -= 1 currSum -= arr [ i ] set1 . append ( arr [ i ] ) print ( "Set1elements:" , end = "" ) for i in range ( len ( set1 ) ) : print ( set1 [ i ] , end = "" ) print ( "\nSet2elements:" , end = "" ) for i in range ( len ( set2 ) ) : print ( set2 [ i ] , end = "" )
def sequence ( n ) : f = array . array ( 'i' , [ 0 , 1 , 1 ] ) for i in range ( 3 , n + 1 ) : r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] f . append ( r ) ; return r
def discreteLogarithm ( a , b , m ) : n = int ( math . sqrt ( m ) + 1 ) an = 1 for i in range ( n ) : an = ( an * a ) % m value = [ 0 ] * m cur = an for i in range ( 1 , n + 1 ) : if ( value [ cur ] == 0 ) : value [ cur ] = i cur = ( cur * an ) % m cur = b for i in range ( n + 1 ) : if ( value [ cur ] > 0 ) : ans = value [ cur ] * n - i if ( ans < m ) : return ans cur = ( cur * a ) % m return - 1
def printRoman ( number ) : num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] sym = [ "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" , "C" , "CD" , "D" , "CM" , "M" ] i = 12 while number : div = number // num [ i ] number %= num [ i ] while div : print ( sym [ i ] , end = "" ) div -= 1 i -= 1
def isEven ( n ) : return ( n % 2 == 0 )
def diagonalsquare ( mat , row , column ) : print ( "Diagonalone:" , end = "" ) for i in range ( 0 , row ) : print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = "" ) print ( "\n\nDiagonaltwo:" , end = "" ) for i in range ( 0 , row ) : print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = "" )
def replaceOriginal ( s , n ) : r = [ '' ] * n for i in range ( n ) : r [ i ] = s [ n - 1 - i ] if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) : print ( r [ i ] , end = "" ) print ( )
def findSmallestRange ( arr , n , k ) : i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 for i in range ( k + 1 ) : ptr [ i ] = 0 minrange = 10 ** 9 while ( 1 ) : minind = - 1 minval = 10 ** 9 maxval = - 10 ** 9 flag = 0 for i in range ( k ) : if ( ptr [ i ] == n ) : flag = 1 break if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : minind = i minval = arr [ i ] [ ptr [ i ] ] if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : maxval = arr [ i ] [ ptr [ i ] ] if ( flag ) : break ptr [ minind ] += 1 if ( ( maxval - minval ) < minrange ) : minel = minval maxel = maxval minrange = maxel - minel print ( "Thesmallestrangeis[" , minel , maxel , "]" )
def findRotations ( str ) : tmp = str + str n = len ( str ) for i in range ( 1 , n + 1 ) : substring = tmp [ i : n ] if ( str == substring ) : return i return n
def checkplusperfect ( x ) : temp = x n = 0 while ( x != 0 ) : x = x // 10 n = n + 1 x = temp sm = 0 while ( x != 0 ) : sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) x = x // 10 return ( sm == temp )
def maxLevel ( boxes , n ) : boxes . sort ( ) ans = 1 prev_width = boxes [ 0 ] prev_count = 1 curr_count = 0 curr_width = 0 for i in range ( 1 , n ) : curr_width += boxes [ i ] curr_count += 1 if ( curr_width > prev_width and curr_count > prev_count ) : prev_width = curr_width prev_count = curr_count curr_count = 0 curr_width = 0 ans += 1 return ans
def summingSeries ( n ) : return math . pow ( n , 2 )
def nthPalindrome ( n , k ) : if ( k & 1 ) : temp = k // 2 else : temp = k // 2 - 1 palindrome = 10 ** temp palindrome = palindrome + n - 1 print ( palindrome , end = "" ) if ( k & 1 ) : palindrome = palindrome // 10 while ( palindrome ) : print ( palindrome % 10 , end = "" ) palindrome = palindrome // 10
def minPalPartion ( str1 ) : n = len ( str1 ) C = [ 0 ] * ( n + 1 ) P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n ) : P [ i ] [ i ] = True for L in range ( 2 , n + 1 ) : for i in range ( n - L + 1 ) : j = i + L - 1 if ( L == 2 ) : P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) else : P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) for i in range ( n ) : if ( P [ 0 ] [ i ] == True ) : C [ i ] = 0 else : C [ i ] = sys . maxsize for j in range ( i ) : if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) : C [ i ] = 1 + C [ j ] return C [ n - 1 ]
def firstElement ( arr , n , k ) : count_map = { } for i in range ( 0 , n ) : if ( arr [ i ] in count_map . keys ( ) ) : count_map [ arr [ i ] ] += 1 else : count_map [ arr [ i ] ] = 1 i += 1 for i in range ( 0 , n ) : if ( count_map [ arr [ i ] ] == k ) : return arr [ i ] i += 1 return - 1
def countSubSeq ( A , N , M ) : ans = 0 h = [ 0 ] * M for i in range ( 0 , N ) : A [ i ] = A [ i ] % M h [ A [ i ] ] = h [ A [ i ] ] + 1 for i in range ( 0 , M ) : for j in range ( i , M ) : rem = ( M - ( i + j ) % M ) % M if ( rem < j ) : continue if ( i == j and rem == j ) : ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 elif ( i == j ) : ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) elif ( i == rem ) : ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 elif ( rem == j ) : ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 else : ans = ans + h [ i ] * h [ j ] * h [ rem ] return ans
def find ( n , k ) : if ( n + 1 >= k ) : return ( k - 1 ) else : return ( 2 * n + 1 - k )
def countOps ( A , B , m , n ) : for i in range ( n ) : for j in range ( m ) : A [ i ] [ j ] -= B [ i ] [ j ] for i in range ( 1 , n ) : for j in range ( 1 , n ) : if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : return - 1 result = 0 for i in range ( n ) : result += abs ( A [ i ] [ 0 ] ) for j in range ( m ) : result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) return ( result )
def minSum ( a , n ) : a = sorted ( a ) num1 , num2 = 0 , 0 for i in range ( n ) : if i % 2 == 0 : num1 = num1 * 10 + a [ i ] else : num2 = num2 * 10 + a [ i ] return num2 + num1
def compute ( graph , N ) : count = 0 for i in range ( 1 , N + 1 ) : if ( len ( graph [ i ] ) == 0 ) : count += 1 return count
def arekAnagrams ( str1 , str2 , k ) : n = len ( str1 ) if ( len ( str2 ) != n ) : return False count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR for i in range ( n ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 count = 0 for i in range ( MAX_CHAR ) : if ( count1 [ i ] > count2 [ i ] ) : count = count + abs ( count1 [ i ] - count2 [ i ] ) return ( count <= k )
def sumOfSeries ( n ) : sum = 0 for i in range ( 1 , n + 1 ) : sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) return sum
def lps ( s ) : n = len ( s ) a = [ 0 ] * n for i in range ( n - 1 , - 1 , - 1 ) : back_up = 0 for j in range ( i , n ) : if j == i : a [ j ] = 1 elif s [ i ] == s [ j ] : temp = a [ j ] a [ j ] = back_up + 2 back_up = temp else : back_up = a [ j ] a [ j ] = max ( a [ j - 1 ] , a [ j ] ) return a [ n - 1 ]
def findMaxPoints ( A ) : P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] for i in range ( 1 , N + 1 ) : for j in range ( 1 , M + 1 ) : P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( N , 0 , - 1 ) : for j in range ( M , 0 , - 1 ) : P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( N , 0 , - 1 ) : for j in range ( 1 , M + 1 ) : P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] for i in range ( 1 , N + 1 ) : for j in range ( M , 0 , - 1 ) : P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ans = 0 for i in range ( 2 , N ) : for j in range ( 2 , M ) : op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + \ P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + \ P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ans = max ( ans , max ( op1 , op2 ) ) return ans
def countSetBits ( n ) : if ( n == 0 ) : return 0 else : return 1 + countSetBits ( n & ( n - 1 ) )
def minheapify ( a , index ) : small = index l = 2 * index + 1 r = 2 * index + 2 if ( l < n and a [ l ] < a [ small ] ) : small = l if ( r < n and a [ r ] < a [ small ] ) : small = r if ( small != index ) : ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) minheapify ( a , small )
def printNumbers ( numbers ) : numbers = map ( str , numbers ) result = [ ] for num in numbers : if ( '1' in num and '2' in num and '3' in num ) : result . append ( num ) if not result : result = [ '-1' ] return sorted ( result ) ;
def smallest ( x , y , z ) : if ( not ( y / x ) ) : return y if ( not ( y / z ) ) else z return x if ( not ( x / z ) ) else z
def swap ( xp , yp ) : if ( xp [ 0 ] == yp [ 0 ] ) : return xp [ 0 ] = xp [ 0 ] + yp [ 0 ] yp [ 0 ] = xp [ 0 ] - yp [ 0 ] xp [ 0 ] = xp [ 0 ] - yp [ 0 ]
def knapSack ( W , wt , val , n ) : K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] for i in range ( n + 1 ) : for w in range ( W + 1 ) : if i == 0 or w == 0 : K [ i ] [ w ] = 0 elif wt [ i - 1 ] <= w : K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) else : K [ i ] [ w ] = K [ i - 1 ] [ w ] return K [ n ] [ W ]
def isDivisibleBy10 ( bin ) : n = len ( bin ) if ( bin [ n - 1 ] == '1' ) : return False sum = 0 i = n - 2 while i >= 0 : if ( bin [ i ] == '1' ) : posFromRight = n - i - 1 if ( posFromRight % 4 == 1 ) : sum = sum + 2 elif ( posFromRight % 4 == 2 ) : sum = sum + 4 elif ( posFromRight % 4 == 3 ) : sum = sum + 8 elif ( posFromRight % 4 == 0 ) : sum = sum + 6 i = i - 1 if ( sum % 10 == 0 ) : return True return False
def subset ( arr , n ) : mp = { i : 0 for i in range ( 10 ) } for i in range ( n ) : mp [ arr [ i ] ] += 1 res = 0 for key , value in mp . items ( ) : res = max ( res , value ) return res
def lenOfLongestGP ( sett , n ) : if n < 2 : return n if n == 2 : return ( sett [ 1 ] % sett [ 0 ] == 0 ) sett . sort ( ) L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] llgp = 1 for i in range ( 0 , n ) : if sett [ n - 1 ] % sett [ i ] == 0 : L [ i ] [ n - 1 ] = 2 else : L [ i ] [ n - 1 ] = 1 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while i >= 0 and k <= n - 1 : if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : k += 1 elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 if L [ i ] [ j ] > llgp : llgp = L [ i ] [ j ] i -= 1 k + 1 while i >= 0 : if sett [ j ] % sett [ i ] == 0 : L [ i ] [ j ] = 2 else : L [ i ] [ j ] = 1 i -= 1 return llgp
def printPairs ( arr , n ) : v = [ ] for i in range ( n ) : for j in range ( i + 1 , n ) : if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : v . append ( abs ( arr [ i ] ) ) if ( len ( v ) == 0 ) : return ; v . sort ( ) for i in range ( len ( v ) ) : print ( - v [ i ] , "" , v [ i ] , end = "" )
def MaxTotalRectangleArea ( a , n ) : a . sort ( reverse = True ) sum = 0 flag = False len = 0 i = 0 while ( i < n - 1 ) : if ( i != 0 ) : i = i + 1 if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : flag = True len = a [ i + 1 ] i = i + 1 elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : sum = sum + a [ i + 1 ] * len flag = False i = i + 1 return sum
def subarrayDivisibleByK ( arr , n , k ) : mp = [ 0 ] * 1000 s = 0 e = 0 maxs = 0 maxe = 0 mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 for i in range ( 1 , n ) : mod = arr [ i ] % k while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 s = s + 1 mp [ mod ] = mp [ mod ] + 1 e = e + 1 if ( ( e - s ) > ( maxe - maxs ) ) : maxe = e maxs = s print ( "Themaximumsizeis{}andthe" . format ( ( maxe - maxs + 1 ) ) ) for i in range ( maxs , maxe + 1 ) : print ( "{}" . format ( arr [ i ] ) , end = "" )
def leonardo ( n ) : dp = [ ] dp . append ( 1 ) dp . append ( 1 ) for i in range ( 2 , n + 1 ) : dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) return dp [ n ]
def maxNumOfChocolates ( arr , n , k ) : um , curr_rem , maxSum = { } , 0 , 0 sm = [ 0 ] * n sm [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : sm [ i ] = sm [ i - 1 ] + arr [ i ] for i in range ( n ) : curr_rem = sm [ i ] % k if ( not curr_rem and maxSum < sm [ i ] ) : maxSum = sm [ i ] elif ( not curr_rem in um ) : um [ curr_rem ] = i elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) : maxSum = sm [ i ] - sm [ um [ curr_rem ] ] return maxSum // k
def numofsubset ( arr , n ) : x = sorted ( arr ) count = 1 for i in range ( 0 , n - 1 ) : if ( x [ i ] + 1 != x [ i + 1 ] ) : count = count + 1 return count
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def reorder ( arr , index , n ) : temp = [ 0 ] * n for i in range ( 0 , n ) : temp [ index [ i ] ] = arr [ i ] for i in range ( 0 , n ) : arr [ i ] = temp [ i ] index [ i ] = i
def maxHamming ( arr , n ) : brr = [ 0 ] * ( 2 * n + 1 ) for i in range ( n ) : brr [ i ] = arr [ i ] for i in range ( n ) : brr [ n + i ] = arr [ i ] maxHam = 0 for i in range ( 1 , n ) : currHam = 0 k = 0 for j in range ( i , i + n ) : if brr [ j ] != arr [ k ] : currHam += 1 k = k + 1 if currHam == n : return n maxHam = max ( maxHam , currHam ) return maxHam
def simplify ( Str ) : Len = len ( Str ) res = [ None ] * Len index = 0 i = 0 s = [ ] s . append ( 0 ) while ( i < Len ) : if ( Str [ i ] == '+' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '-' index += 1 if ( s [ - 1 ] == 0 ) : res [ index ] = '+' index += 1 elif ( Str [ i ] == '-' ) : if ( s [ - 1 ] == 1 ) : res [ index ] = '+' index += 1 elif ( s [ - 1 ] == 0 ) : res [ index ] = '-' index += 1 elif ( Str [ i ] == '(' and i > 0 ) : if ( Str [ i - 1 ] == '-' ) : x = 0 if ( s [ - 1 ] == 1 ) else 1 s . append ( x ) elif ( Str [ i - 1 ] == '+' ) : s . append ( s [ - 1 ] ) elif ( Str [ i ] == ')' ) : s . pop ( ) else : res [ index ] = Str [ i ] index += 1 i += 1 return res
def circumference ( r ) : return ( 2 * PI * r )
def luDecomposition ( mat , n ) : lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : for k in range ( i , n ) : sum = 0 for j in range ( i ) : sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) upper [ i ] [ k ] = mat [ i ] [ k ] - sum for k in range ( i , n ) : if ( i == k ) : lower [ i ] [ i ] = 1 else : sum = 0 for j in range ( i ) : sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) print ( "LowerTriangular\t\tUpperTriangular" ) for i in range ( n ) : for j in range ( n ) : print ( lower [ i ] [ j ] , end = "\t" ) print ( "" , end = "\t" ) for j in range ( n ) : print ( upper [ i ] [ j ] , end = "\t" ) print ( "" )
def search ( arr , n , x ) : i = 0 for i in range ( i , n ) : if ( arr [ i ] == x ) : return i return - 1
def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count += 1 return 1 << count
def LCSubStr ( X , Y ) : m = len ( X ) n = len ( Y ) result = 0 len_mat = np . zeros ( ( 2 , n ) ) currRow = 0 for i in range ( m ) : for j in range ( n ) : if ( i == 0 | j == 0 ) : len_mat [ currRow ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 result = max ( result , len_mat [ currRow ] [ j ] ) else : len_mat [ currRow ] [ j ] = 0 currRow = 1 - currRow return result
def countPairs ( arr , n ) : result = 0 Hash = set ( ) for i in range ( n ) : Hash . add ( arr [ i ] ) for i in range ( n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] if product in ( Hash ) : result += 1 return result
def randomize ( arr , n ) : for i in range ( n - 1 , 0 , - 1 ) : j = random . randint ( 0 , i + 1 ) arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] return arr
def getOddOccurrence ( arr , arr_size ) : for i in range ( 0 , arr_size ) : count = 0 for j in range ( 0 , arr_size ) : if arr [ i ] == arr [ j ] : count += 1 if ( count % 2 != 0 ) : return arr [ i ] return - 1
def findSum ( A , B , n ) : Hash = defaultdict ( lambda : 0 ) for i in range ( 0 , n ) : Hash [ A [ i ] ] += 1 Hash [ B [ i ] ] += 1 Sum = 0 for x in Hash : if Hash [ x ] == 1 : Sum += x return Sum
def getPairsCount ( arr , n , sum ) : m = [ 0 ] * 1000 for i in range ( 0 , n ) : m [ arr [ i ] ] m [ arr [ i ] ] += 1 twice_count = 0 for i in range ( 0 , n ) : twice_count += m [ sum - arr [ i ] ] if ( sum - arr [ i ] == arr [ i ] ) : twice_count -= 1 return int ( twice_count / 2 )
def findExtra ( arr1 , arr2 , n ) : for i in range ( 0 , n ) : if ( arr1 [ i ] != arr2 [ i ] ) : return i return n
def getTotalNumberOfSequences ( m , n ) : if m < n : return 0 if n == 0 : return 1 res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) return res
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) if ( dis1 != dis2 ) : print ( "No" ) elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : print ( "No" ) else : print ( "Yes" )
def removeConsecutiveSame ( v ) : n = len ( v ) i = 0 while ( i < n - 1 ) : if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) : v = v [ : i ] v = v [ : i ] if ( i > 0 ) : i -= 1 n = n - 2 else : i += 1 return len ( v [ : i - 1 ] )
def countSetBitsRec ( num ) : nibble = 0 if ( 0 == num ) : return num_to_bits [ 0 ] nibble = num & 0xf return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 )
def findRepeating ( arr , n ) : res = 0 for i in range ( 0 , n - 1 ) : res = res ^ ( i + 1 ) ^ arr [ i ] res = res ^ arr [ n - 1 ] return res
def Resources ( process , need ) : minResources = 0 minResources = process * ( need - 1 ) + 1 return minResources
def MAXMIN ( arr , n ) : MIN = 10 ** 9 MAX = - 10 ** 9 for i in range ( n ) : for j in range ( n // 2 + 1 ) : if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : if ( MIN > arr [ i ] [ n - j - 1 ] ) : MIN = arr [ i ] [ n - j - 1 ] if ( MAX < arr [ i ] [ j ] ) : MAX = arr [ i ] [ j ] else : if ( MIN > arr [ i ] [ j ] ) : MIN = arr [ i ] [ j ] if ( MAX < arr [ i ] [ n - j - 1 ] ) : MAX = arr [ i ] [ n - j - 1 ] print ( "MAXimum=" , MAX , ",MINimum=" , MIN )
def countCommon ( mat , n ) : res = 0 for i in range ( n ) : if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : res = res + 1 return res
def countInRange ( arr , n , x , y ) : count = 0 ; for i in range ( n ) : if ( arr [ i ] >= x and arr [ i ] <= y ) : count += 1 return count
def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : d1 = d1 + arr [ i ] [ i ] d2 = d2 + arr [ i ] [ n - i - 1 ] return abs ( d1 - d2 )
def ZigZag ( rows , columns , numbers ) : k = 0 arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] for i in range ( rows ) : if ( i % 2 == 0 ) : j = 0 while j < columns and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j += 1 else : j = columns - 1 while j >= 0 and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j -= 1 for i in arr : for j in i : print ( j , end = "" ) print ( )
def checkCorrectOrNot ( s ) : global MAX_CHAR count1 = [ 0 ] * MAX_CHAR count2 = [ 0 ] * MAX_CHAR n = len ( s ) if n == 1 : return true i = 0 j = n - 1 while ( i < j ) : count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 i += 1 j -= 1 for i in range ( MAX_CHAR ) : if count1 [ i ] != count2 [ i ] : return False return True
def minimumflip ( mat , n ) : flip = 0 for i in range ( n ) : for j in range ( i ) : if mat [ i ] [ j ] != mat [ j ] [ i ] : flip += 1 return flip
def recSearch ( arr , l , r , x ) : if r < l : return - 1 if arr [ l ] == x : return l if arr [ r ] == x : return r return recSearch ( arr , l + 1 , r - 1 , x )
def getFirstSetBitPos ( n ) : return math . log2 ( n & - n ) + 1
def LexicographicalMaxString ( str ) : mx = "" for i in range ( len ( str ) ) : mx = max ( mx , str [ i : ] ) return mx
def longestSubsequence ( a , n ) : mp = { i : 0 for i in range ( 13 ) } dp = [ 0 for i in range ( n ) ] maximum = - sys . maxsize - 1 index = - 1 for i in range ( n ) : if ( ( a [ i ] - 1 ) in mp ) : lastIndex = mp [ a [ i ] - 1 ] - 1 dp [ i ] = 1 + dp [ lastIndex ] else : dp [ i ] = 1 mp [ a [ i ] ] = i + 1 if ( maximum < dp [ i ] ) : maximum = dp [ i ] index = i for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) : print ( curr , end = "" )
def count ( n ) : table = [ 0 for i in range ( n + 1 ) ] table [ 0 ] = 1 for i in range ( 3 , n + 1 ) : table [ i ] += table [ i - 3 ] for i in range ( 5 , n + 1 ) : table [ i ] += table [ i - 5 ] for i in range ( 10 , n + 1 ) : table [ i ] += table [ i - 10 ] return table [ n ]
def psuedoBinary ( n ) : while ( n > 0 ) : temp = n m = 0 p = 1 while ( temp ) : rem = temp % 10 temp = int ( temp / 10 ) if ( rem != 0 ) : m += p p *= 10 print ( m , end = "" ) n = n - m
def countRotations ( n ) : l = len ( n ) if ( l == 1 ) : oneDigit = ( int ) ( n [ 0 ] ) if ( oneDigit % 4 == 0 ) : return 1 return 0 count = 0 for i in range ( 0 , l - 1 ) : twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 return count
def minimumSquare ( m , n ) : vertical_min = 10000000000 horizontal_min = 10000000000 if m == n : return 1 if dp [ m ] [ n ] != 0 : return dp [ m ] [ n ] for i in range ( 1 , m // 2 + 1 ) : horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) for j in range ( 1 , n // 2 + 1 ) : vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) return dp [ m ] [ n ]
def answerQuery ( a , n , l , r ) : count = 0 l = l - 1 for i in range ( l , r , 1 ) : element = a [ i ] divisors = 0 for j in range ( l , r , 1 ) : if ( a [ j ] % a [ i ] == 0 ) : divisors += 1 else : break if ( divisors == ( r - l ) ) : count += 1 return count
def rearrange ( arr , n ) : max_idx = n - 1 min_idx = 0 max_elem = arr [ n - 1 ] + 1 for i in range ( 0 , n ) : if i % 2 == 0 : arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem max_idx -= 1 else : arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem min_idx += 1 for i in range ( 0 , n ) : arr [ i ] = arr [ i ] / max_elem
def countNumberOfTriangles ( n ) : return ( n * ( n - 1 ) * ( n - 2 ) // 6 )
def makePermutation ( a , n ) : count = dict ( ) for i in range ( n ) : if count . get ( a [ i ] ) : count [ a [ i ] ] += 1 else : count [ a [ i ] ] = 1 next_missing = 1 for i in range ( n ) : if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : count [ a [ i ] ] -= 1 while count . get ( next_missing ) : next_missing += 1 a [ i ] = next_missing count [ next_missing ] = 1
def maxelement ( arr ) : no_of_rows = len ( arr ) no_of_column = len ( arr [ 0 ] ) for i in range ( no_of_rows ) : max1 = 0 for j in range ( no_of_column ) : if arr [ i ] [ j ] > max1 : max1 = arr [ i ] [ j ] print ( max1 )
def first ( str ) : for i in range ( 0 , len ( str ) ) : if ( str [ i ] . istitle ( ) ) : return str [ i ] return 0
def maximumPalinUsingKChanges ( strr , k ) : palin = strr l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( strr [ l ] != strr [ r ] ) : palin [ l ] = palin [ r ] = max ( strr [ l ] , strr [ r ] ) k -= 1 l += 1 r -= 1 if ( k < 0 ) : return "Notpossible" l = 0 r = len ( strr ) - 1 while ( l <= r ) : if ( l == r ) : if ( k > 0 ) : palin [ l ] = '9' if ( palin [ l ] < '9' ) : if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : k -= 1 palin [ l ] = palin [ r ] = '9' elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : k -= 1 palin [ l ] = palin [ r ] = '9' l += 1 r -= 1 return palin
def generate ( st , s ) : if len ( s ) == 0 : return if s not in st : st . add ( s ) for i in range ( len ( s ) ) : t = list ( s ) . copy ( ) t . remove ( s [ i ] ) t = '' . join ( t ) generate ( st , t ) return
def lps ( str ) : n = len ( str ) L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] for i in range ( n ) : L [ i ] [ i ] = 1 for cl in range ( 2 , n + 1 ) : for i in range ( n - cl + 1 ) : j = i + cl - 1 if str [ i ] == str [ j ] and cl == 2 : L [ i ] [ j ] = 2 elif str [ i ] == str [ j ] : L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 else : L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; return L [ 0 ] [ n - 1 ]
def superSeq ( X , Y , m , n ) : dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] for i in range ( m + 1 ) : for j in range ( n + 1 ) : if ( not i ) : dp [ i ] [ j ] = j elif ( not j ) : dp [ i ] [ j ] = i elif ( X [ i - 1 ] == Y [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) return dp [ m ] [ n ]
def linearSearch ( arr , n ) : for i in range ( n ) : if arr [ i ] is i : return i return - 1
def maxProductSubset ( a , n ) : if n == 1 : return a [ 0 ] max_neg = - 999999999999 count_neg = 0 count_zero = 0 prod = 1 for i in range ( n ) : if a [ i ] == 0 : count_zero += 1 continue if a [ i ] < 0 : count_neg += 1 max_neg = max ( max_neg , a [ i ] ) prod = prod * a [ i ] if count_zero == n : return 0 if count_neg & 1 : if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : return 0 prod = int ( prod / max_neg ) return prod
def countRotations ( arr , n ) : min = arr [ 0 ] for i in range ( 0 , n ) : if ( min > arr [ i ] ) : min = arr [ i ] min_index = i return min_index
def prevPermutation ( str ) : n = len ( str ) - 1 i = n while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : i -= 1 if ( i <= 0 ) : return False j = i - 1 while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : j += 1 str = list ( str ) temp = str [ i - 1 ] str [ i - 1 ] = str [ j ] str [ j ] = temp str = '' . join ( str ) str [ : : - 1 ] return True , str
def countOfSubstringWithKOnes ( s , K ) : N = len ( s ) res = 0 countOfOne = 0 freq = [ 0 for i in range ( N + 1 ) ] freq [ 0 ] = 1 for i in range ( 0 , N , 1 ) : countOfOne += ord ( s [ i ] ) - ord ( '0' ) if ( countOfOne >= K ) : res += freq [ countOfOne - K ] freq [ countOfOne ] += 1 return res
def power ( x , y , p ) : res = 1 x = x % p while ( y > 0 ) : if ( ( y & 1 ) == 1 ) : res = ( res * x ) % p y = y >> 1 x = ( x * x ) % p return res
def moveSpaceInFront ( s ) : i = len ( s ) - 1 for j in range ( i , - 1 , - 1 ) : if ( s [ j ] != '' ) : s = s [ : i ] + s [ j ] + s [ i + 1 : ] i -= 1 while ( i >= 0 ) : s = s [ : i ] + '' + s [ i + 1 : ] i -= 1 return s
def countSetBits ( n ) : count = 0 while ( n ) : n &= ( n - 1 ) count += 1 return count
def checkPoint ( radius , x , y , percent , startAngle ) : endAngle = 360 / percent + startAngle polarradius = math . sqrt ( x * x + y * y ) Angle = math . atan ( y / x ) if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : print ( "Point(" , x , "," , y , ")" "existinthecirclesector" ) else : print ( "Point(" , x , "," , y , ")" "doesnotexistinthecirclesector" )
def smallest ( x , y , z ) : c = 0 while ( x and y and z ) : x = x - 1 y = y - 1 z = z - 1 c = c + 1 return c
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def arrangeString ( string ) : char_count = [ 0 ] * MAX_CHAR s = 0 for i in range ( len ( string ) ) : if string [ i ] >= "A" and string [ i ] <= "Z" : char_count [ ord ( string [ i ] ) - ord ( "A" ) ] += 1 else : s += ord ( string [ i ] ) - ord ( "0" ) res = "" for i in range ( MAX_CHAR ) : ch = chr ( ord ( "A" ) + i ) while char_count [ i ] : res += ch char_count [ i ] -= 1 if s > 0 : res += str ( s ) return res
def Circumference ( l , w ) : return ( 2 * ( l + w ) )
def lcs ( i , j , count ) : if ( i == 0 or j == 0 ) : return count if ( X [ i - 1 ] == Y [ j - 1 ] ) : count = lcs ( i - 1 , j - 1 , count + 1 ) count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) return count
def check ( st ) : n = len ( st ) digitSum = 0 for i in range ( 0 , n ) : digitSum = digitSum + ( int ) ( st [ i ] ) return ( digitSum % 9 == 0 )
def lexicographicSubConcat ( s ) : n = len ( s ) sub_count = ( n * ( n + 1 ) ) // 2 arr = [ 0 ] * sub_count index = 0 for i in range ( n ) : for j in range ( 1 , n - i + 1 ) : arr [ index ] = s [ i : i + j ] index += 1 arr . sort ( ) res = "" for i in range ( sub_count ) : res += arr [ i ] return res
def numberOfPaths ( m , n ) : for i in range ( n , ( m + n - 1 ) ) : path *= i path //= ( i - n + 1 ) return path
def noAdjacentDup ( s ) : n = len ( s ) for i in range ( 1 , n ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = "a" while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 return s
def numberOfPaths ( m , n ) : count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] for i in range ( m ) : count [ i ] [ 0 ] = 1 ; for j in range ( n ) : count [ 0 ] [ j ] = 1 ; for i in range ( 1 , m ) : for j in range ( n ) : count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] return count [ m - 1 ] [ n - 1 ]
def sequence ( n ) : if n == 1 or n == 2 : return 1 else : return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;
def scalarProductMat ( mat , k ) : for i in range ( N ) : for j in range ( N ) : mat [ i ] [ j ] = mat [ i ] [ j ] * k
def minDist ( arr , n , x , y ) : min_dist = 99999999 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) : min_dist = abs ( i - j ) return min_dist
def countManipulations ( s1 , s2 ) : count = 0 char_count = [ 0 ] * 26 for i in range ( 26 ) : char_count [ i ] = 0 for i in range ( len ( s1 ) ) : char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( s2 ) ) : char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1 if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] < 0 ) : count += 1 return count
def carAssembly ( a , t , e , x ) : NUM_STATION = len ( a [ 0 ] ) T1 = [ 0 for i in range ( NUM_STATION ) ] T2 = [ 0 for i in range ( NUM_STATION ) ] T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] for i in range ( 1 , NUM_STATION ) : T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] )
def solve ( dp , a , low , high , turn ) : if ( low == high ) : return a [ low ] * turn if ( dp [ low ] [ high ] != 0 ) : return dp [ low ] [ high ] dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ]
def sort012 ( a , arr_size ) : lo = 0 hi = arr_size - 1 mid = 0 while mid <= hi : if a [ mid ] == 0 : a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] lo = lo + 1 mid = mid + 1 elif a [ mid ] == 1 : mid = mid + 1 else : a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] hi = hi - 1
def isTriangular ( num ) : if ( num < 0 ) : return False c = ( - 2 * num ) b , a = 1 , 1 d = ( b * b ) - ( 4 * a * c ) if ( d < 0 ) : return False root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) if ( root1 > 0 and math . floor ( root1 ) == root1 ) : return True if ( root2 > 0 and math . floor ( root2 ) == root2 ) : return True return False
def findLength ( st , n ) : total = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ans = 0 l = 2 while ( l <= n ) : for i in range ( n - l + 1 ) : j = i + l - 1 if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : ans = max ( ans , l ) l = l + 2 return ans
def lcs ( X , Y ) : m = len ( X ) n = len ( Y ) L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] bi = bool for i in range ( m ) : bi = i & 1 for j in range ( n + 1 ) : if ( i == 0 or j == 0 ) : L [ bi ] [ j ] = 0 elif ( X [ i ] == Y [ j - 1 ] ) : L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 else : L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) return L [ bi ] [ n ]
def solve ( A , n ) : cnt = 0 parent = [ None ] * ( n + 1 ) vis = [ None ] * ( n + 1 ) for i in range ( 0 , n + 1 ) : parent [ i ] = - 1 vis [ i ] = 0 for i in range ( 0 , n ) : j = i if ( parent [ j ] == - 1 ) : while ( parent [ j ] == - 1 ) : parent [ j ] = i j = ( j + A [ j ] + 1 ) % n if ( parent [ j ] == i ) : while ( vis [ j ] == 0 ) : vis [ j ] = 1 cnt = cnt + 1 j = ( j + A [ j ] + 1 ) % n return cnt
def calculateEnergy ( mat , n ) : tot_energy = 0 for i in range ( n ) : for j in range ( n ) : q = mat [ i ] [ j ] // n i_des = q j_des = mat [ i ] [ j ] - ( n * q ) tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) return tot_energy
def maxRepeating ( str ) : l = len ( str ) count = 0 res = str [ 0 ] for i in range ( l ) : cur_count = 1 for j in range ( i + 1 , l ) : if ( str [ i ] != str [ j ] ) : break cur_count += 1 if cur_count > count : count = cur_count res = str [ i ] return res
def kPrimeFactor ( n , k ) : while ( n % 2 == 0 ) : k = k - 1 n = n / 2 if ( k == 0 ) : return 2 i = 3 while i <= math . sqrt ( n ) : while ( n % i == 0 ) : if ( k == 1 ) : return i k = k - 1 n = n / i i = i + 2 if ( n > 2 and k == 1 ) : return n return - 1
def unique ( mat , n , m ) : maximum = 0 flag = 0 for i in range ( 0 , n ) : for j in range ( 0 , m ) : if ( maximum < mat [ i ] [ j ] ) : maximum = mat [ i ] [ j ] uniqueElementDict = [ 0 ] * ( maximum + 1 ) for i in range ( 0 , n ) : for j in range ( 0 , m ) : uniqueElementDict [ mat [ i ] [ j ] ] += 1 for key in range ( maximum + 1 ) : if uniqueElementDict [ key ] == 1 : print ( key , end = "" ) flag = 1 if ( flag == 0 ) : print ( "Nouniqueelementinthematrix" )
def printSubStr ( st , low , high ) : sys . stdout . write ( st [ low : high + 1 ] ) sys . stdout . flush ( ) return ''
def maxArea ( mat ) : hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] for i in range ( 0 , C , 1 ) : hist [ 0 ] [ i ] = mat [ 0 ] [ i ] for j in range ( 1 , R , 1 ) : if ( ( mat [ j ] [ i ] == 0 ) ) : hist [ j ] [ i ] = 0 else : hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 for i in range ( 0 , R , 1 ) : count = [ 0 for i in range ( R + 1 ) ] for j in range ( 0 , C , 1 ) : count [ hist [ i ] [ j ] ] += 1 col_no = 0 j = R while ( j >= 0 ) : if ( count [ j ] > 0 ) : for k in range ( 0 , count [ j ] , 1 ) : hist [ i ] [ col_no ] = j col_no += 1 j -= 1 max_area = 0 for i in range ( 0 , R , 1 ) : for j in range ( 0 , C , 1 ) : curr_area = ( j + 1 ) * hist [ i ] [ j ] if ( curr_area > max_area ) : max_area = curr_area return max_area
def lastNon0Digit ( n ) : if ( n < 10 ) : return dig [ n ] if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 else : return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 return 0
def compute_average ( a , b ) : return floor ( ( a + b ) / 2 )
def longestCommonSum ( arr1 , arr2 , n ) : maxLen = 0 presum1 = presum2 = 0 diff = { } for i in range ( n ) : presum1 += arr1 [ i ] presum2 += arr2 [ i ] curr_diff = presum1 - presum2 if curr_diff == 0 : maxLen = i + 1 elif curr_diff not in diff : diff [ curr_diff ] = i else : length = i - diff [ curr_diff ] maxLen = max ( maxLen , length ) return maxLen
def answer_query ( a , n , l , r ) : count = 0 for i in range ( l , r ) : if ( a [ i ] == a [ i + 1 ] ) : count += 1 return count
def nonDecNums ( n ) : a = np . zeros ( ( n + 1 , 10 ) ) for i in range ( 10 ) : a [ 0 ] [ i ] = 1 for i in range ( 1 , n + 1 ) : a [ i ] [ 9 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( 8 , - 1 , - 1 ) : a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] return int ( a [ n ] [ 0 ] )
def printFactorialNums ( n ) : fact = 1 x = 2 while fact <= n : print ( fact , end = "" ) fact = fact * x x += 1
def to_upper ( string ) : for i in range ( len ( string ) ) : if ( 'a' <= string [ i ] <= 'z' ) : string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] ) return string
def sortString ( str ) : str = '' . join ( sorted ( str ) ) print ( str )
def solve ( i , par , a , n , k , current_ans ) : if ( par > k ) : return 0 global ans if ( par == k and i == n - 1 ) : ans = min ( ans , current_ans ) return 0 for j in range ( i + 1 , n ) : solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) )
def stirlingFactorial ( n ) : if ( n == 1 ) : return 1 e = 2.71 z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) return math . floor ( z )
def ksmallest ( arr , n , k ) : b = [ 0 ] * MAX for i in range ( n ) : b [ arr [ i ] ] = 1 for j in range ( 1 , MAX ) : if ( b [ j ] != 1 ) : k -= 1 if ( k is not 1 ) : return j
def countWays ( n ) : dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] dp [ 0 ] [ 1 ] = 1 dp [ 1 ] [ 1 ] = 2 for i in range ( 2 , n + 1 ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]
def countTrees ( n ) : BT = [ 0 ] * ( n + 1 ) BT [ 0 ] = BT [ 1 ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( i ) : BT [ i ] += BT [ j ] * BT [ i - j - 1 ] return BT [ n ]
def modFact ( n , p ) : if n >= p : return 0 result = 1 for i in range ( 1 , n + 1 ) : result = ( result * i ) % p return result
def findnumberofTriangles ( arr ) : n = len ( arr ) arr . sort ( ) count = 0 for i in range ( 0 , n - 2 ) : k = i + 2 for j in range ( i + 1 , n ) : while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : k += 1 if ( k > j ) : count += k - j - 1 return count
def isDivisible ( n ) : while ( int ( n / 100 ) ) : last_digit = int ( n % 10 ) n = int ( n / 10 ) n += last_digit * 3 return ( n % 29 == 0 )
def relativeComplement ( arr1 , arr2 , n , m ) : i = 0 j = 0 while ( i < n and j < m ) : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ] , "" , end = "" ) i += 1 elif ( arr1 [ i ] > arr2 [ j ] ) : j += 1 elif ( arr1 [ i ] == arr2 [ j ] ) : i += 1 j += 1 while ( i < n ) : print ( arr1 [ i ] , "" , end = "" )
def mulmod ( a , b , mod ) : res = 0 a = a % mod while ( b > 0 ) : if ( b % 2 == 1 ) : res = ( res + a ) % mod a = ( a * 2 ) % mod b //= 2 return res % mod
def insertionSortRecursive ( arr , n ) : if n <= 1 : return insertionSortRecursive ( arr , n - 1 ) last = arr [ n - 1 ] j = n - 2 while ( j >= 0 and arr [ j ] > last ) : arr [ j + 1 ] = arr [ j ] j = j - 1 arr [ j + 1 ] = last
def findMin ( arr , low , high ) : if high < low : return arr [ 0 ] if high == low : return arr [ low ] mid = int ( ( low + high ) / 2 ) if mid < high and arr [ mid + 1 ] < arr [ mid ] : return arr [ mid + 1 ] if mid > low and arr [ mid ] < arr [ mid - 1 ] : return arr [ mid ] if arr [ high ] > arr [ mid ] : return findMin ( arr , low , mid - 1 ) return findMin ( arr , mid + 1 , high )
def findInteger ( arr , n ) : neg = 0 pos = 0 sum = 0 for i in range ( 0 , n ) : sum += arr [ i ] if ( arr [ i ] < 0 ) : neg += 1 else : pos += 1 return ( sum / abs ( neg - pos ) )
def smallestSubsegment ( a , n ) : left = dict ( ) count = dict ( ) mx = 0 mn , strindex = 0 , 0 for i in range ( n ) : x = a [ i ] if ( x not in count . keys ( ) ) : left [ x ] = i count [ x ] = 1 else : count [ x ] += 1 if ( count [ x ] > mx ) : mx = count [ x ] mn = i - left [ x ] + 1 strindex = left [ x ] elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) : mn = i - left [ x ] + 1 strindex = left [ x ] for i in range ( strindex , strindex + mn ) : print ( a [ i ] , end = "" )
def countPattern ( s ) : length = len ( s ) oneSeen = False count = 0 for i in range ( length ) : if ( s [ i ] == '1' and oneSeen ) : if ( s [ i - 1 ] == '0' ) : count += 1 if ( s [ i ] == '1' and oneSeen == 0 ) : oneSeen = True if ( s [ i ] != '0' and s [ i ] != '1' ) : oneSeen = False return count
def countDivisibleSubseq ( str , n ) : l = len ( str ) dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 for i in range ( 1 , l ) : dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 for j in range ( n ) : dp [ i ] [ j ] += dp [ i - 1 ] [ j ] dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] return dp [ l - 1 ] [ 0 ]
def findDuplicateparenthesis ( string ) : Stack = [ ] for ch in string : if ch == ')' : top = Stack . pop ( ) elementsInside = 0 while top != '(' : elementsInside += 1 top = Stack . pop ( ) if elementsInside < 1 : return True else : Stack . append ( ch ) return False
def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 2 ) : for j in range ( i + 1 , arr_size - 1 ) : for k in range ( j + 1 , arr_size ) : if A [ i ] + A [ j ] + A [ k ] == sum : print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , A [ k ] ) return True return False
def sortString ( str , n ) : new_str = "" for i in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : for j in range ( n ) : if ( str [ j ] == chr ( i ) ) : new_str += str [ j ] return new_str
def ispalindrome ( s ) : l = len ( s ) i = 0 j = l - 1 while i <= j : if ( s [ i ] != s [ j ] ) : return False i += 1 j -= 1 return True
def nobleInteger ( arr , size ) : for i in range ( 0 , size ) : count = 0 for j in range ( 0 , size ) : if ( arr [ i ] < arr [ j ] ) : count += 1 if ( count == arr [ i ] ) : return arr [ i ] return - 1
def circumferenceparallelogram ( a , b ) : return ( ( 2 * a ) + ( 2 * b ) )
def direction ( R , C ) : if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if R == C and R % 2 != 0 and C % 2 != 0 : print ( "Right" ) return if R == C and R % 2 == 0 and C % 2 == 0 : print ( "Left" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : print ( "Left" ) return if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : print ( "Up" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : print ( "Down" ) return if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : print ( "Right" ) return
def getIndexInSortedArray ( arr , n , idx ) : result = 0 for i in range ( n ) : if ( arr [ i ] < arr [ idx ] ) : result += 1 if ( arr [ i ] == arr [ idx ] and i < idx ) : result += 1 return result ;
def squareRootExists ( n , p ) : n = n % p for x in range ( 2 , p , 1 ) : if ( ( x * x ) % p == n ) : return True return False
def maxXOR ( mat , N ) : max_xor = 0 for i in range ( N ) : r_xor = 0 c_xor = 0 for j in range ( N ) : r_xor = r_xor ^ mat [ i ] [ j ] c_xor = c_xor ^ mat [ j ] [ i ] if ( max_xor < max ( r_xor , c_xor ) ) : max_xor = max ( r_xor , c_xor ) return max_xor
def numberOfTriangles ( n ) : answer = [ None ] * ( n + 1 ) answer [ 0 ] = 1 i = 1 while i <= n : answer [ i ] = answer [ i - 1 ] * 3 + 2 i = i + 1 return answer [ n ]
def countkDist ( str1 , k ) : n = len ( str1 ) res = 0 cnt = [ 0 ] * 27 for i in range ( 0 , n ) : dist_count = 0 cnt = [ 0 ] * 27 for j in range ( i , n ) : if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : dist_count += 1 cnt [ ord ( str1 [ j ] ) - 97 ] += 1 if ( dist_count == k ) : res += 1 if ( dist_count > k ) : break return res
def maxLower ( str ) : n = len ( str ) i = 0 for i in range ( n ) : if str [ i ] >= 'A' and str [ i ] <= 'Z' : i += 1 break maxCount = 0 count = [ ] for j in range ( MAX_CHAR ) : count . append ( 0 ) for j in range ( i , n ) : if str [ j ] >= 'A' and str [ j ] <= 'Z' : currCount = 0 for k in range ( MAX_CHAR ) : if count [ k ] > 0 : currCount += 1 maxCount = max ( maxCount , currCount ) for y in count : y = 0 if str [ j ] >= 'a' and str [ j ] <= 'z' : count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1 return maxCount
def getRemainder ( num , divisor ) : if ( divisor == 0 ) : return False if ( divisor < 0 ) : divisor = - divisor if ( num < 0 ) : num = - num i = 1 product = 0 while ( product <= num ) : product = divisor * i i += 1 return num - ( product - divisor )
def isPossible ( n , index , modulo , M , arr , dp ) : modulo = ( ( modulo % M ) + M ) % M if ( index == n ) : if ( modulo == 0 ) : return 1 return 0 if ( dp [ index ] [ modulo ] != - 1 ) : return dp [ index ] [ modulo ] placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) res = bool ( placeAdd or placeMinus ) dp [ index ] [ modulo ] = res return res
def timeToMeet ( s , v ) : V = 3 * v / 2 time = s / V print ( time )
def chordCnt ( A ) : n = 2 * A dpArray = [ 0 ] * ( n + 1 ) dpArray [ 0 ] = 1 dpArray [ 2 ] = 1 for i in range ( 4 , n + 1 , 2 ) : for j in range ( 0 , i - 1 , 2 ) : dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) return int ( dpArray [ n ] )
def findRepeating ( arr , n ) : missingElement = 0 for i in range ( 0 , n ) : element = arr [ abs ( arr [ i ] ) ] if ( element < 0 ) : missingElement = arr [ i ] break arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] return abs ( missingElement )
def find_difference ( arr , n , m ) : max = 0 min = 0 arr . sort ( ) j = n - 1 for i in range ( m ) : min += arr [ i ] max += arr [ j ] j = j - 1 return ( max - min )
def substringConversions ( str1 , k , b ) : for i in range ( 0 , len ( str1 ) - k + 1 ) : sub = str1 [ i : k + i ] Sum = 0 counter = 0 for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) counter += 1 print ( Sum , end = "" )
def find3Numbers ( A , arr_size , sum ) : A . sort ( ) for i in range ( 0 , arr_size - 2 ) : l = i + 1 r = arr_size - 1 while ( l < r ) : if ( A [ i ] + A [ l ] + A [ r ] == sum ) : print ( "Tripletis" , A [ i ] , ',' , A [ l ] , ',' , A [ r ] ) return True elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : l += 1 else : r -= 1 return False
def countFriendsPairings ( n ) : dp = [ - 1 ] * 100 if ( dp [ n ] != - 1 ) : return dp [ n ] if ( n > 2 ) : dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) return dp [ n ] else : dp [ n ] = n return dp [ n ]
def sortString ( str ) : charCount = [ 0 for i in range ( MAX_CHAR ) ] for i in range ( 0 , len ( str ) , 1 ) : charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( 0 , MAX_CHAR , 1 ) : for j in range ( 0 , charCount [ i ] , 1 ) : print ( chr ( ord ( 'a' ) + i ) , end = "" )
def isLucky ( n ) : next_position = n if isLucky . counter > n : return 1 if n % isLucky . counter == 0 : return 0 next_position = next_position - next_position / isLucky . counter isLucky . counter = isLucky . counter + 1 return isLucky ( next_position )
def printGrouped ( string ) : n = len ( string ) count = [ 0 ] * MAX_CHAR for i in range ( n ) : count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1 for i in range ( n ) : while count [ ord ( string [ i ] ) - ord ( "a" ) ] : print ( string [ i ] , end = "" ) count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1 count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0
def mod ( num , a ) : res = 0 for i in range ( 0 , len ( num ) ) : res = ( res * 10 + int ( num [ i ] ) ) % a return res
def findRandomIndexOfMax ( arr , n ) : mp = dict ( ) for i in range ( n ) : if ( arr [ i ] in mp ) : mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 else : mp [ arr [ i ] ] = 1 max_element = - 323567 max_so_far = - 323567 for p in mp : if ( mp [ p ] > max_so_far ) : max_so_far = mp [ p ] max_element = p r = int ( ( ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) ) i = 0 count = 0 while ( i < n ) : if ( arr [ i ] == max_element ) : count = count + 1 if ( count == r ) : print ( "Elementwithmaximumfrequencypresentatindex" , i ) break i = i + 1
def splitString ( str ) : alpha = "" num = "" special = "" for i in range ( len ( str ) ) : if ( str [ i ] . isdigit ( ) ) : num = num + str [ i ] elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( str [ i ] >= 'a' and str [ i ] <= 'z' ) ) : alpha += str [ i ] else : special += str [ i ] print ( alpha ) print ( num ) print ( special )
def MaxSumDifference ( a , n ) : np . sort ( a ) j = 0 finalSequence = [ 0 for x in range ( n ) ] for i in range ( 0 , int ( n / 2 ) ) : finalSequence [ j ] = a [ i ] finalSequence [ j + 1 ] = a [ n - i - 1 ] j = j + 2 MaximumSum = 0 for i in range ( 0 , n - 1 ) : MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) print ( MaximumSum )
def countSubarrays ( arr , n ) : difference = 0 ans = 0 hash_positive = [ 0 ] * ( n + 1 ) hash_negative = [ 0 ] * ( n + 1 ) hash_positive [ 0 ] = 1 for i in range ( n ) : if ( arr [ i ] & 1 == 1 ) : difference = difference + 1 else : difference = difference - 1 if ( difference < 0 ) : ans += hash_negative [ - difference ] hash_negative [ - difference ] = hash_negative [ - difference ] + 1 else : ans += hash_positive [ difference ] hash_positive [ difference ] = hash_positive [ difference ] + 1 return ans
def rectCount ( n , m ) : return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4
def isPerfectSquare ( n ) : i = 1 the_sum = 0 while the_sum < n : the_sum += i if the_sum == n : return True i += 2 return False
def findMaximum ( arr , low , high ) : if low == high : return arr [ low ] if high == low + 1 and arr [ low ] >= arr [ high ] : return arr [ low ] if high == low + 1 and arr [ low ] < arr [ high ] : return arr [ high ] mid = ( low + high ) // 2 if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : return arr [ mid ] if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : return findMaximum ( arr , low , mid - 1 ) else : return findMaximum ( arr , mid + 1 , high )
def KnapSack ( val , wt , n , W ) : dp = [ 0 ] * ( W + 1 ) for i in range ( n ) : for j in range ( W , wt [ i ] , - 1 ) : dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) return dp [ W ]
def totalNodes ( adjac , n , x , y ) : visited = [ 0 ] * ( n + 1 ) p = [ None ] * n q = queue . Queue ( ) q . put ( x ) visited [ x ] = True m = None while ( not q . empty ( ) ) : m = q . get ( ) for i in range ( len ( adjac [ m ] ) ) : h = adjac [ m ] [ i ] if ( not visited [ h ] ) : visited [ h ] = True p [ h ] = m q . put ( h ) count = 0 i = p [ y ] while ( i != x ) : count += 1 i = p [ i ] return count
def findWinner ( x , y , n ) : dp = [ 0 for i in range ( n + 1 ) ] dp [ 0 ] = False dp [ 1 ] = True for i in range ( 2 , n + 1 ) : if ( i - 1 >= 0 and not dp [ i - 1 ] ) : dp [ i ] = True elif ( i - x >= 0 and not dp [ i - x ] ) : dp [ i ] = True elif ( i - y >= 0 and not dp [ i - y ] ) : dp [ i ] = True else : dp [ i ] = False return dp [ n ]
def splitArr ( arr , n , k ) : for i in range ( 0 , k ) : x = arr [ 0 ] for j in range ( 0 , n - 1 ) : arr [ j ] = arr [ j + 1 ] arr [ n - 1 ] = x
def query ( s , i , j ) : n = len ( s ) i %= n j %= n print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" )
def SectorArea ( radius , angle ) : pi = 22 / 7 if angle >= 360 : print ( "Anglenotpossible" ) return else : sector = ( pi * radius ** 2 ) * ( angle / 360 ) print ( sector ) return
def cosXSertiesSum ( x , n ) : x = x * ( PI / 180.0 ) res = 1 sign = 1 fact = 1 pow = 1 for i in range ( 1 , 5 ) : sign = sign * - 1 fact = fact * ( 2 * i - 1 ) * ( 2 * i ) pow = pow * x * x res = res + sign * pow / fact return res
def isDivisible ( str , k ) : n = len ( str ) c = 0 for i in range ( 0 , k ) : if ( str [ n - i - 1 ] == '0' ) : c += 1 return ( c == k )
def check ( st ) : n = len ( st ) if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : return False digitSum = 0 for i in range ( 0 , n ) : digitSum = digitSum + ( int ) ( st [ i ] ) return ( digitSum % 3 == 0 )
def findLargestd ( S , n ) : found = False S . sort ( ) for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( 0 , n ) : if ( i == j ) : continue for k in range ( j + 1 , n ) : if ( i == k ) : continue for l in range ( k + 1 , n ) : if ( i == l ) : continue if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = True return S [ i ] if ( found == False ) : return - 1
def findSubarraySum ( arr , n , Sum ) : prevSum = defaultdict ( lambda : 0 ) res = 0 currsum = 0 for i in range ( 0 , n ) : currsum += arr [ i ] if currsum == Sum : res += 1 if ( currsum - Sum ) in prevSum : res += prevSum [ currsum - Sum ] prevSum [ currsum ] += 1 return res
def minimumSquare ( a , b ) : result = 0 rem = 0 if ( a < b ) : a , b = b , a while ( b > 0 ) : result += int ( a / b ) rem = int ( a % b ) a = b b = rem return result
def CountSquares ( a , b ) : cnt = 0 for i in range ( a , b + 1 ) : j = 1 ; while j * j <= i : if j * j == i : cnt = cnt + 1 j = j + 1 i = i + 1 return cnt
def countPaths ( n , m ) : if ( n == 0 or m == 0 ) : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )
def subArray ( arr , n ) : for i in range ( 0 , n ) : for j in range ( i , n ) : for k in range ( i , j + 1 ) : print ( arr [ k ] , end = "" ) print ( "\n" , end = "" )
def printDivisors ( n ) : list = [ ] for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : if ( n % i == 0 ) : if ( n / i == i ) : print ( i , end = "" ) else : print ( i , end = "" ) list . append ( int ( n / i ) ) for i in list [ : : - 1 ] : print ( i , end = "" )
def findNth ( n ) : count = 0 for curr in itertools . count ( ) : sum = 0 x = curr while ( x ) : sum = sum + x % 10 x = x // 10 if ( sum == 10 ) : count = count + 1 if ( count == n ) : return curr return - 1
def findMaxValue ( arr , n ) : if n < 4 : print ( "Thearrayshouldhaveatlest4elements" ) return MIN table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) for i in range ( n - 1 , - 1 , - 1 ) : table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) for i in range ( n - 2 , - 1 , - 1 ) : table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) for i in range ( n - 3 , - 1 , - 1 ) : table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) for i in range ( n - 4 , - 1 , - 1 ) : table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) return table4 [ 0 ]
def isHeap ( arr , n ) : for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : if arr [ 2 * i + 1 ] > arr [ i ] : return False if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : return False return True
def countPaths ( maze ) : if ( maze [ 0 ] [ 0 ] == - 1 ) : return 0 for i in range ( R ) : if ( maze [ i ] [ 0 ] == 0 ) : maze [ i ] [ 0 ] = 1 else : break for i in range ( 1 , C , 1 ) : if ( maze [ 0 ] [ i ] == 0 ) : maze [ 0 ] [ i ] = 1 else : break for i in range ( 1 , R , 1 ) : for j in range ( 1 , C , 1 ) : if ( maze [ i ] [ j ] == - 1 ) : continue if ( maze [ i - 1 ] [ j ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) if ( maze [ i ] [ j - 1 ] > 0 ) : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : return maze [ R - 1 ] [ C - 1 ] else : return 0
def mergeIntervals ( arr ) : arr . sort ( key = lambda x : x [ 0 ] ) m = [ ] s = - 10000 max = - 100000 for i in range ( len ( arr ) ) : a = arr [ i ] if a [ 0 ] > max : if i != 0 : m . append ( [ s , max ] ) max = a [ 1 ] s = a [ 0 ] else : if a [ 1 ] >= max : max = a [ 1 ] if max != - 100000 and [ s , max ] not in m : m . append ( [ s , max ] ) print ( "TheMergedIntervalsare:" , end = "" ) for i in range ( len ( m ) ) : print ( m [ i ] , end = "" )
def productArray ( arr , n ) : if n == 1 : print ( 0 ) return i , temp = 1 , 1 prod = [ 1 for i in range ( n ) ] for i in range ( n ) : prod [ i ] = temp temp *= arr [ i ] temp = 1 for i in range ( n - 1 , - 1 , - 1 ) : prod [ i ] *= temp temp *= arr [ i ] for i in range ( n ) : print ( prod [ i ] , end = "" ) return
def countPairsWithDiffK ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : count += 1 return count
def calculateSum ( arr , n ) : if ( n == 0 ) : return 0 s = arr [ 0 ] value = int ( s ) sum = value for i in range ( 2 , n , 2 ) : s = arr [ i ] value = int ( s ) operation = arr [ i - 1 ] [ 0 ] if ( operation == '+' ) : sum += value else : sum -= value return sum
def countStr ( n ) : return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) )
def shortestDist ( graph ) : global INF dist = [ 0 ] * N dist [ N - 1 ] = 0 for i in range ( N - 2 , - 1 , - 1 ) : dist [ i ] = INF for j in range ( N ) : if graph [ i ] [ j ] == INF : continue dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) return dist [ 0 ]
def lexNext ( s , n ) : for i in range ( n - 1 , - 1 , - 1 ) : if s [ i ] != 'z' : k = ord ( s [ i ] ) s [ i ] = chr ( k + 1 ) return '' . join ( s ) s [ i ] = 'a'
def interLeaveQueue ( q ) : if ( q . qsize ( ) % 2 != 0 ) : print ( "Inputevennumberofintegers." ) s = [ ] halfSize = int ( q . qsize ( ) / 2 ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) for i in range ( halfSize ) : q . put ( q . queue [ 0 ] ) q . get ( ) for i in range ( halfSize ) : s . append ( q . queue [ 0 ] ) q . get ( ) while len ( s ) != 0 : q . put ( s [ - 1 ] ) s . pop ( ) q . put ( q . queue [ 0 ] ) q . get ( )
def checkIfAllTogether ( s , c ) : oneSeen = False i = 0 n = len ( s ) while ( i < n ) : if ( s [ i ] == c ) : if ( oneSeen == True ) : return False while ( i < n and s [ i ] == c ) : i = i + 1 oneSeen = True else : i = i + 1 return True
def printSequence ( arr , input ) : n = len ( input ) output = "" for i in range ( n ) : if ( input [ i ] == '' ) : output = output + "0" else : position = ord ( input [ i ] ) - ord ( 'A' ) output = output + arr [ position ] return output
def calcAngle ( h , m ) : if ( h < 0 or m < 0 or h > 12 or m > 60 ) : print ( 'Wronginput' ) if ( h == 12 ) : h = 0 if ( m == 60 ) : m = 0 hour_angle = 0.5 * ( h * 60 + m ) minute_angle = 6 * m angle = abs ( hour_angle - minute_angle ) angle = min ( 360 - angle , angle ) return angle
def lenghtOfLongestAP ( set , n ) : if ( n <= 2 ) : return n L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] llap = 2 for i in range ( n ) : L [ i ] [ n - 1 ] = 2 for j in range ( n - 2 , 0 , - 1 ) : i = j - 1 k = j + 1 while ( i >= 0 and k <= n - 1 ) : if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : k += 1 elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : L [ i ] [ j ] = 2 i -= 1 else : L [ i ] [ j ] = L [ j ] [ k ] + 1 llap = max ( llap , L [ i ] [ j ] ) i -= 1 k += 1 while ( i >= 0 ) : L [ i ] [ j ] = 2 i -= 1 return llap
def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( "InvalidInput" ) return first = arr [ 0 ] for i in range ( 1 , arr_size ) : if ( arr [ i ] > first ) : first = arr [ i ] second = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > second and arr [ i ] < first ) : second = arr [ i ] third = - sys . maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > third and arr [ i ] < second ) : third = arr [ i ] print ( "TheThirdLargest" , "elementis" , third )
def findSymPairs ( arr , row ) : hM = dict ( ) for i in range ( row ) : first = arr [ i ] [ 0 ] sec = arr [ i ] [ 1 ] if ( sec in hM . keys ( ) and hM [ sec ] == first ) : print ( "(" , sec , "," , first , ")" ) else : hM [ first ] = sec
def printRoots ( n ) : theta = math . pi * 2 / n for k in range ( 0 , n ) : real = math . cos ( k * theta ) img = math . sin ( k * theta ) print ( real , end = "" ) if ( img >= 0 ) : print ( "+i" , end = "" ) else : print ( "-i" , end = "" ) print ( abs ( img ) )
def minStepToDeleteString ( str ) : N = len ( str ) dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] for l in range ( 1 , N + 1 ) : i = 0 j = l - 1 while j < N : if ( l == 1 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] if ( str [ i ] == str [ i + 1 ] ) : dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) for K in range ( i + 2 , j + 1 ) : if ( str [ i ] == str [ K ] ) : dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) i += 1 j += 1 return dp [ 0 ] [ N - 1 ]
def findLongestRepeatingSubSeq ( X , m , n ) : if ( dp [ m ] [ n ] != - 1 ) : return dp [ m ] [ n ] if ( m == 0 or n == 0 ) : dp [ m ] [ n ] = 0 return dp [ m ] [ n ] if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 return dp [ m ] [ n ] dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) return dp [ m ] [ n ]
def SternSequenceFunc ( BrocotSequence , n ) : for i in range ( 1 , n ) : considered_element = BrocotSequence [ i ] precedent = BrocotSequence [ i - 1 ] BrocotSequence . append ( considered_element + precedent ) BrocotSequence . append ( considered_element ) for i in range ( 0 , 15 ) : print ( BrocotSequence [ i ] , end = "" )
def areDisjoint ( set1 , set2 , m , n ) : set1 . sort ( ) set2 . sort ( ) i = 0 ; j = 0 while ( i < m and j < n ) : if ( set1 [ i ] < set2 [ j ] ) : i += 1 elif ( set2 [ j ] < set1 [ i ] ) : j += 1 else : return False return True
def findpos ( n ) : i = 0 j = len ( n ) pos = 0 while ( i < j ) : if ( n [ i ] == '4' ) : pos = pos * 2 + 1 if ( n [ i ] == '7' ) : pos = pos * 2 + 2 i = i + 1 return pos
def recaman ( n ) : if ( n <= 0 ) : return print ( 0 , "," , end = '' ) s = set ( [ ] ) s . add ( 0 ) prev = 0 for i in range ( 1 , n ) : curr = prev - i if ( curr < 0 or curr in s ) : curr = prev + i s . add ( curr ) print ( curr , "," , end = '' ) prev = curr
def dealnnoy ( n , m ) : if ( m == 0 or n == 0 ) : return 1 return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 )
def printDistSum ( arr , n ) : Sum = sum ( arr ) dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True for i in range ( 1 , n + 1 ) : dp [ i ] [ arr [ i - 1 ] ] = True for j in range ( 1 , Sum + 1 ) : if ( dp [ i - 1 ] [ j ] == True ) : dp [ i ] [ j ] = True dp [ i ] [ j + arr [ i - 1 ] ] = True for j in range ( Sum + 1 ) : if ( dp [ n ] [ j ] == True ) : print ( j , end = "" )
def printSeries ( n ) : for i in range ( 1 , n + 1 ) : num = i * ( i + 1 ) * ( i + 2 ) // 6 print ( num , end = '' )
def spiralFill ( m , n , a ) : val = 1 k , l = 0 , 0 while ( k < m and l < n ) : for i in range ( l , n ) : a [ k ] [ i ] = val val += 1 k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = val val += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : a [ m - 1 ] [ i ] = val val += 1 m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : a [ i ] [ l ] = val val += 1 l += 1
def cassini ( n ) : return - 1 if ( n & 1 ) else 1
def checkStar ( mat ) : global size vertexD1 = 0 vertexDn_1 = 0 if ( size == 1 ) : return ( mat [ 0 ] [ 0 ] == 0 ) if ( size == 2 ) : return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) for i in range ( 0 , size ) : degreeI = 0 for j in range ( 0 , size ) : if ( mat [ i ] [ j ] ) : degreeI = degreeI + 1 if ( degreeI == 1 ) : vertexD1 = vertexD1 + 1 elif ( degreeI == size - 1 ) : vertexDn_1 = vertexDn_1 + 1 return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 )
def findRepeatingElement ( arr , low , high ) : if low > high : return - 1 mid = ( low + high ) / 2 if ( arr [ mid ] != mid + 1 ) : if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : return mid return findRepeatingElement ( arr , low , mid - 1 ) return findRepeatingElement ( arr , mid + 1 , high )
def checkSorted ( n , q ) : st = [ ] expected = 1 fnt = None while ( not q . empty ( ) ) : fnt = q . queue [ 0 ] q . get ( ) if ( fnt == expected ) : expected += 1 else : if ( len ( st ) == 0 ) : st . append ( fnt ) elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) : return False else : st . append ( fnt ) while ( len ( st ) != 0 and st [ - 1 ] == expected ) : st . pop ( ) expected += 1 if ( expected - 1 == n and len ( st ) == 0 ) : return True return False
def printDuplicates ( arr ) : dict = { } for ele in arr : try : dict [ ele ] += 1 except : dict [ ele ] = 1 for item in dict : if ( dict [ item ] > 1 ) : print ( item , end = "" ) print ( "\n" )
def oppositeSigns ( x , y ) : return ( ( x ^ y ) < 0 )
def decode ( Str ) : integerstack = [ ] stringstack = [ ] temp = "" result = "" for i in range ( len ( Str ) ) : count = 0 if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) i += 1 i -= 1 integerstack . append ( count ) elif ( Str [ i ] == ']' ) : temp = "" count = 0 if ( len ( integerstack ) != 0 ) : count = integerstack [ - 1 ] integerstack . pop ( ) while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) : temp = stringstack [ - 1 ] + temp stringstack . pop ( ) if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) : stringstack . pop ( ) for j in range ( count ) : result = result + temp for j in range ( len ( result ) ) : stringstack . append ( result [ j ] ) result = "" elif ( Str [ i ] == '[' ) : if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : stringstack . append ( Str [ i ] ) else : stringstack . append ( Str [ i ] ) integerstack . append ( 1 ) else : stringstack . append ( Str [ i ] ) while len ( stringstack ) != 0 : result = stringstack [ - 1 ] + result stringstack . pop ( ) return result
def recaman ( n ) : arr = [ 0 ] * n arr [ 0 ] = 0 print ( arr [ 0 ] , end = "," ) for i in range ( 1 , n ) : curr = arr [ i - 1 ] - i for j in range ( 0 , i ) : if ( ( arr [ j ] == curr ) or curr < 0 ) : curr = arr [ i - 1 ] + i break arr [ i ] = curr print ( arr [ i ] , end = "," )
def isSymmetric ( mat , N ) : for i in range ( N ) : for j in range ( N ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : return False return True
def factorize ( n ) : count = 0 while ( ( n % 2 > 0 ) == False ) : n >>= 1 count += 1 if ( count > 0 ) : print ( 2 , count ) for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : count = 0 while ( n % i == 0 ) : count += 1 n = int ( n / i ) if ( count > 0 ) : print ( i , count ) i += 2 if ( n > 2 ) : print ( n , 1 )
def evenlength ( n ) : res = n for j in range ( len ( n ) - 1 , - 1 , - 1 ) : res += n [ j ] return res
def findMinimumAngle ( arr , n ) : l = 0 _sum = 0 ans = 360 for i in range ( n ) : _sum += arr [ i ] while _sum >= 180 : ans = min ( ans , 2 * abs ( 180 - _sum ) ) _sum -= arr [ l ] l += 1 ans = min ( ans , 2 * abs ( 180 - _sum ) ) return ans
def convertOpposite ( str ) : ln = len ( str ) for i in range ( ln ) : if str [ i ] >= 'a' and str [ i ] <= 'z' : str [ i ] = chr ( ord ( str [ i ] ) - 32 ) elif str [ i ] >= 'A' and str [ i ] <= 'Z' : str [ i ] = chr ( ord ( str [ i ] ) + 32 )
def search ( arr , n , x ) : for i in range ( 0 , n ) : if ( arr [ i ] == x ) : return i return - 1
def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : principal += mat [ i ] [ i ] secondary += mat [ i ] [ n - i - 1 ] print ( "PrincipalDiagonal:" , principal ) print ( "SecondaryDiagonal:" , secondary )
def largest ( arr , n ) : max = arr [ 0 ] for i in range ( 1 , n ) : if arr [ i ] > max : max = arr [ i ] return max
def fib ( n ) : if ( n <= 1 ) : return n return fib ( n - 1 ) + fib ( n - 2 )
def isPrime ( n ) : if n <= 1 : return False for i in range ( 2 , n ) : if n % i == 0 : return False return True
def sumDigits ( no ) : return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) )
def printbinomial ( max ) : for m in range ( max + 1 ) : print ( '%2d' % m , end = '' ) binom = 1 for x in range ( m + 1 ) : if m != 0 and x != 0 : binom = binom * ( m - x + 1 ) / x print ( '%4d' % binom , end = '' ) print ( "\n" , end = '' )
def transpose ( A , B ) : for i in range ( N ) : for j in range ( M ) : B [ i ] [ j ] = A [ j ] [ i ]
def countSol ( coeff , start , end , rhs ) : if ( rhs == 0 ) : return 1 result = 0 for i in range ( start , end + 1 ) : if ( coeff [ i ] <= rhs ) : result += countSol ( coeff , i , end , rhs - coeff [ i ] ) return result
def binarySearch ( arr , left , right ) : if ( left <= right ) : mid = ( left + right ) // 2 if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : return mid if ( arr [ mid ] < arr [ mid + 1 ] ) : return binarySearch ( arr , mid + 1 , right ) else : return binarySearch ( arr , left , mid - 1 ) return - 1
def commonCharacters ( strings , n ) : prim = [ True ] * MAX_CHAR for i in range ( n ) : sec = [ False ] * MAX_CHAR for j in range ( len ( strings [ i ] ) ) : if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) : sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = True for i in range ( MAX_CHAR ) : prim [ i ] = sec [ i ] for i in range ( 26 ) : if ( prim [ i ] ) : print ( "%c" % ( i + ord ( 'a' ) ) , end = "" )
def smallestNumber ( num ) : num = list ( num ) n = len ( num ) rightMin = [ 0 ] * n right = 0 rightMin [ n - 1 ] = - 1 ; right = n - 1 ; for i in range ( n - 2 , 0 , - 1 ) : if num [ i ] > num [ right ] : rightMin [ i ] = right else : rightMin [ i ] = - 1 right = i small = - 1 for i in range ( 1 , n ) : if num [ i ] != '0' : if small == - 1 : if num [ i ] < num [ 0 ] : small = i elif num [ i ] < num [ small ] : small = i if small != - 1 : num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ] else : for i in range ( 1 , n ) : if rightMin [ i ] != - 1 : num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] break return '' . join ( num )
def printSpiral ( n ) : for i in range ( 0 , n ) : for j in range ( 0 , n ) : x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) if ( i <= j ) : print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = "\t" ) else : print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = "\t" ) print ( )
def cocktailSort ( a ) : n = len ( a ) swapped = True start = 0 end = n - 1 while ( swapped == True ) : swapped = False for i in range ( start , end ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True if ( swapped == False ) : break swapped = False end = end - 1 for i in range ( end - 1 , start - 1 , - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True start = start + 1
def coutSubSeq ( A , N , M ) : sum = 0 ans = 0 for i in range ( 0 , N ) : for j in range ( i + 1 , N ) : for k in range ( j + 1 , N ) : sum = A [ i ] + A [ j ] + A [ k ] if ( sum % M == 0 ) : ans = ans + 1 return ans
def findLongestConseqSubseq ( arr , n ) : S = set ( ) for i in range ( n ) : S . add ( arr [ i ] ) ans = 0 for i in range ( n ) : if S . __contains__ ( arr [ i ] ) : j = arr [ i ] while ( S . __contains__ ( j ) ) : j += 1 ans = max ( ans , j - arr [ i ] ) return ans
def turnOffK ( n , k ) : if ( k <= 0 ) : return n return ( n & ~ ( 1 << ( k - 1 ) ) )
def lineFromPoints ( P , Q ) : a = Q [ 1 ] - P [ 1 ] b = P [ 0 ] - Q [ 0 ] c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) if ( b < 0 ) : print ( "ThelinepassingthroughpointsPandQis:" , a , "x" , b , "y=" , c , "\n" ) else : print ( "ThelinepassingthroughpointsPandQis:" , a , "x+" , b , "y=" , c , "\n" )
def calculate ( s ) : ans = 6 for i in range ( 10 ) : for j in range ( 10 ) : for k in range ( 10 ) : for l in range ( 10 ) : for m in range ( 10 ) : for n in range ( 10 ) : if ( i + j + k == l + m + n ) : c = 0 if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : c += 1 if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : c += 1 if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : c += 1 if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : c += 1 if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : c += 1 if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : c += 1 if ( c < ans ) : ans = c return ans
def sortInWave ( arr , n ) : for i in range ( 0 , n , 2 ) : if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) : arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]
def maxDecimalValue ( mat , i , j , p ) : if i >= N or j >= N : return 0 result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) if mat [ i ] [ j ] == 1 : return pow ( 2 , p ) + result else : return result
def printSquares ( n ) : square = 0 ; prev_x = 0 ; for x in range ( 0 , n ) : square = ( square + x + prev_x ) print ( square , end = "" ) prev_x = x
def countFact ( low , high ) : fact = 1 x = 1 while ( fact < low ) : fact = fact * x x += 1 res = 0 while ( fact <= high ) : res += 1 fact = fact * x x += 1 return res
def maxLength ( s , n ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n - 1 ) : if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) : dp [ i ] [ i + 1 ] = 2 for l in range ( 2 , n ) : i = - 1 for j in range ( l , n ) : i += 1 if ( s [ i ] == '(' and s [ j ] == ')' ) : dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] for k in range ( i , j ) : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) return dp [ 0 ] [ n - 1 ]
def checkDuplicatesWithinK ( arr , n , k ) : myset = [ ] for i in range ( n ) : if arr [ i ] in myset : return True myset . append ( arr [ i ] ) if ( i >= k ) : myset . remove ( arr [ i - k ] ) return False
def findElement ( arr , ranges , rotations , index ) : for i in range ( rotations - 1 , - 1 , - 1 ) : left = ranges [ i ] [ 0 ] right = ranges [ i ] [ 1 ] if ( left <= index and right >= index ) : if ( index == left ) : index = right else : index = index - 1 return arr [ index ]
def findCount ( str ) : result = 0 for i in range ( len ( str ) ) : if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : result += 1 return result
def printIntersection ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and j < n : if arr1 [ i ] < arr2 [ j ] : i += 1 elif arr2 [ j ] < arr1 [ i ] : j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1
def check ( num ) : digitSum = 0 while num > 0 : rem = num % 10 digitSum = digitSum + rem num = num // 10 return ( digitSum % 3 == 0 )
def Round_off ( N , n ) : b = N c = floor ( N ) i = 0 while ( b >= 1 ) : b = b / 10 i = i + 1 d = n - i b = N b = b * pow ( 10 , d ) e = b + 0.5 if ( float ( e ) == float ( ceil ( b ) ) ) : f = ( ceil ( b ) ) h = f - 2 if ( h % 2 != 0 ) : e = e - 1 j = floor ( e ) m = pow ( 10 , d ) j = j / m print ( "Thenumberafterrounding-offis" , j )
def printRepeating ( arr , size ) : print ( "Repeatingelementsare" , end = '' ) for i in range ( 0 , size ) : for j in range ( i + 1 , size ) : if arr [ i ] == arr [ j ] : print ( arr [ i ] , end = '' )
def findSmallest ( arr , n ) : res = 1 for i in range ( 0 , n ) : if arr [ i ] <= res : res = res + arr [ i ] else : break return res
def countZeroes ( mat ) : N = 5 ; row = N - 1 ; col = 0 ; count = 0 ; while ( col < N ) : while ( mat [ row ] [ col ] ) : if ( row < 0 ) : return count ; row = row - 1 ; count = count + ( row + 1 ) ; col = col + 1 ; return count ;
def minCoins ( coins , m , V ) : if ( V == 0 ) : return 0 res = sys . maxsize for i in range ( 0 , m ) : if ( coins [ i ] <= V ) : sub_res = minCoins ( coins , m , V - coins [ i ] ) if ( sub_res != sys . maxsize and sub_res + 1 < res ) : res = sub_res + 1 return res
def checkCorrectOrNot ( s ) : global MAX_CHAR count = [ 0 ] * MAX_CHAR n = len ( s ) if n == 1 : return true i = 0 j = n - 1 while i < j : count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1 i += 1 j -= 1 for i in range ( MAX_CHAR ) : if count [ i ] != 0 : return False return True
def height ( N ) : return math . ceil ( math . log2 ( N + 1 ) ) - 1
def kthdigit ( a , b , k ) : p = a ** b count = 0 while ( p > 0 and count < k ) : rem = p % 10 count = count + 1 if ( count == k ) : return rem p = p / 10
def countWays ( n ) : A = [ 0 ] * ( n + 1 ) B = [ 0 ] * ( n + 1 ) A [ 0 ] = 1 A [ 1 ] = 0 B [ 0 ] = 0 B [ 1 ] = 1 for i in range ( 2 , n + 1 ) : A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] B [ i ] = A [ i - 1 ] + B [ i - 2 ] return A [ n ]
def canMakeAllSame ( str ) : zeros = 0 ones = 0 for i in range ( 0 , len ( str ) ) : ch = str [ i ] if ( ch == '0' ) : zeros = zeros + 1 else : ones = ones + 1 return ( zeros == 1 or ones == 1 )
def findMajority ( arr , n ) : maxCount = 0 ; index = - 1 for i in range ( n ) : count = 0 for j in range ( n ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count > maxCount ) : maxCount = count index = i if ( maxCount > n // 2 ) : print ( arr [ index ] ) else : print ( "NoMajorityElement" )
def count ( n , x ) : cnt = 0 for i in range ( 1 , n + 1 ) : if i <= x : if x // i <= n and x % i == 0 : cnt += 1 return cnt
def isNumber ( s ) : for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) != True : return False return True
def interpolationSearch ( arr , n , x ) : lo = 0 hi = ( n - 1 ) while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : if lo == hi : if arr [ lo ] == x : return lo ; return - 1 ; pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ) if arr [ pos ] == x : return pos if arr [ pos ] < x : lo = pos + 1 ; else : hi = pos - 1 ; return - 1
def minCost ( cost ) : dist = [ 0 for i in range ( N ) ] for i in range ( N ) : dist [ i ] = INF dist [ 0 ] = 0 for i in range ( N ) : for j in range ( i + 1 , N ) : if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : dist [ j ] = dist [ i ] + cost [ i ] [ j ] return dist [ N - 1 ]
def numberOfTriangles ( n ) : ans = 2 * ( pow ( 3 , n ) ) - 1 return ans
def myCopy ( s1 , s2 ) : for i in range ( len ( s1 ) ) : s2 [ i ] = s1 [ i ]
def printMinIndexChar ( Str , patt ) : minIndex = 10 ** 9 m = len ( Str ) n = len ( patt ) for i in range ( n ) : for j in range ( m ) : if ( patt [ i ] == Str [ j ] and j < minIndex ) : minIndex = j break if ( minIndex != 10 ** 9 ) : print ( "MinimumIndexCharacter=" , Str [ minIndex ] ) else : print ( "Nocharacterpresent" )
def subset ( ar , n ) : res = 0 ar . sort ( ) for i in range ( 0 , n ) : count = 1 for i in range ( n - 1 ) : if ar [ i ] == ar [ i + 1 ] : count += 1 else : break res = max ( res , count ) return res
def isMinHeap ( level , n ) : for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : if level [ i ] > level [ 2 * i + 1 ] : return False if 2 * i + 2 < n : if level [ i ] > level [ 2 * i + 2 ] : return False return True
def constructTree ( n , d , h ) : if d == 1 : if n == 2 and h == 1 : print ( "12" ) return 0 print ( "-1" ) return 0 if d > 2 * h : print ( "-1" ) return 0 for i in range ( 1 , h + 1 ) : print ( i , "" , i + 1 ) if d > h : print ( 1 , "" , h + 2 ) for i in range ( h + 2 , d + 1 ) : print ( i , "" , i + 1 ) for i in range ( d + 1 , n ) : k = 1 if d == h : k = 2 print ( k , "" , i + 1 )
def nCrModp ( n , r , p ) : C = [ 0 for i in range ( r + 1 ) ] C [ 0 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( min ( i , r ) , 0 , - 1 ) : C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p return C [ r ]
def replaceSpaces ( string ) : string = string . strip ( ) i = len ( string ) space_count = string . count ( '' ) new_length = i + space_count * 2 if new_length > MAX : return - 1 index = new_length - 1 string = list ( string ) for f in range ( i - 2 , new_length - 2 ) : string . append ( '0' ) for j in range ( i - 1 , 0 , - 1 ) : if string [ j ] == '' : string [ index ] = '0' string [ index - 1 ] = '2' string [ index - 2 ] = '%' index = index - 3 else : string [ index ] = string [ j ] index -= 1 return '' . join ( string )
def findMinAvgSubarray ( arr , n , k ) : if ( n < k ) : return 0 res_index = 0 curr_sum = 0 for i in range ( k ) : curr_sum += arr [ i ] min_sum = curr_sum for i in range ( k , n ) : curr_sum += arr [ i ] - arr [ i - k ] if ( curr_sum < min_sum ) : min_sum = curr_sum res_index = ( i - k + 1 ) print ( "Subarraybetween[" , res_index , "," , ( res_index + k - 1 ) , "]hasminimumaverage" )
def isChangeable ( notes , n ) : fiveCount = 0 tenCount = 0 for i in range ( n ) : if ( notes [ i ] == 5 ) : fiveCount += 1 elif ( notes [ i ] == 10 ) : if ( fiveCount > 0 ) : fiveCount -= 1 tenCount += 1 else : return 0 else : if ( fiveCount > 0 and tenCount > 0 ) : fiveCount -= 1 tenCount -= 1 elif ( fiveCount >= 3 ) : fiveCount -= 3 else : return 0 return 1
def maxvolume ( s ) : maxvalue = 0 i = 1 for i in range ( s - 1 ) : j = 1 for j in range ( s ) : k = s - i - j maxvalue = max ( maxvalue , i * j * k ) return maxvalue
def exponential ( n , x ) : sum = 1.0 for i in range ( n , 0 , - 1 ) : sum = 1 + x * sum / i print ( "e^x=" , sum )
def nextPowerOf2 ( n ) : n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n
def decToBinary ( n ) : for i in range ( 31 , - 1 , - 1 ) : k = n >> i if ( k & 1 ) : print ( "1" , end = "" ) else : print ( "0" , end = "" )
def unitnumber ( x , y ) : x = x % 10 if y != 0 : y = y % 4 + 4 return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 )
def findSum ( str1 , str2 ) : if len ( str1 ) > len ( str2 ) : temp = str1 str1 = str2 str2 = temp str3 = "" n1 = len ( str1 ) n2 = len ( str2 ) diff = n2 - n1 carry = 0 for i in range ( n1 - 1 , - 1 , - 1 ) : sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 if ( carry ) : str3 + str ( carry + '0' ) str3 = str3 [ : : - 1 ] return str3
def maxOverlap ( start , end ) : n = len ( start ) maxa = max ( start ) maxb = max ( end ) maxc = max ( maxa , maxb ) x = ( maxc + 2 ) * [ 0 ] cur = 0 idx = 0 for i in range ( 0 , n ) : x [ start [ i ] ] += 1 x [ end [ i ] + 1 ] -= 1 maxy = - 1 for i in range ( 0 , maxc + 1 ) : cur += x [ i ] if maxy < cur : maxy = cur idx = i print ( "Maximumvalueis:{0:d}" . format ( maxy ) , "atposition:{0:d}" . format ( idx ) )
def unitDigitXRaisedY ( x , y ) : res = 1 for i in range ( y ) : res = ( res * x ) % 10 return res
def maximumSumSubarray ( arr , n ) : min_prefix_sum = 0 res = - math . inf prefix_sum = [ ] prefix_sum . append ( arr [ 0 ] ) for i in range ( 1 , n ) : prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) for i in range ( n ) : res = max ( res , prefix_sum [ i ] - min_prefix_sum ) min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) return res
def gnomeSort ( arr , n ) : index = 0 while index < n : if index == 0 : index = index + 1 if arr [ index ] >= arr [ index - 1 ] : index = index + 1 else : arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] index = index - 1 return arr
def bonacciseries ( n , m ) : a = [ 0 ] * m a [ n - 1 ] = 1 for i in range ( n , m ) : for j in range ( i - n , i ) : a [ i ] = a [ i ] + a [ j ] for i in range ( 0 , m ) : print ( a [ i ] , end = "" )
def maxSumWO3Consec ( arr , n ) : sum = [ 0 for k in range ( n ) ] if n >= 1 : sum [ 0 ] = arr [ 0 ] if n >= 2 : sum [ 1 ] = arr [ 0 ] + arr [ 1 ] if n > 2 : sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) for i in range ( 3 , n ) : sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) return sum [ n - 1 ]
def printLevels ( graph , V , x ) : level = [ None ] * V marked = [ False ] * V que = queue . Queue ( ) que . put ( x ) level [ x ] = 0 marked [ x ] = True while ( not que . empty ( ) ) : x = que . get ( ) for i in range ( len ( graph [ x ] ) ) : b = graph [ x ] [ i ] if ( not marked [ b ] ) : que . put ( b ) level [ b ] = level [ x ] + 1 marked [ b ] = True print ( "Nodes" , "" , "Level" ) for i in range ( V ) : print ( "" , i , "-->" , level [ i ] )
def findHeight ( parent , n ) : res = 0 for i in range ( n ) : p = i current = 1 while ( parent [ p ] != - 1 ) : current += 1 p = parent [ p ] res = max ( res , current ) return res
def solve ( arr , n ) : arr . sort ( ) a = 0 b = 0 for i in range ( n ) : if ( i % 2 != 0 ) : a = a * 10 + arr [ i ] else : b = b * 10 + arr [ i ] return a + b
def sortedCount ( mat , r , c ) : result = 0 for i in range ( r ) : j = 0 for j in range ( c - 1 ) : if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : break if j == c - 2 : result += 1 for i in range ( 0 , r ) : j = 0 for j in range ( c - 1 , 0 , - 1 ) : if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : break if c > 1 and j == 1 : result += 1 return result
def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) return math . floor ( x ) + 1
def countSubarrWithEqualZeroAndOne ( arr , n ) : um = dict ( ) curr_sum = 0 for i in range ( n ) : curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) if um . get ( curr_sum ) : um [ curr_sum ] += 1 else : um [ curr_sum ] = 1 count = 0 for itr in um : if um [ itr ] > 1 : count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) if um . get ( 0 ) : count += um [ 0 ] return int ( count )
def LeibnizHarmonicTriangle ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , i + 1 ) : print ( "1/" , end = "" ) print ( i * C [ i - 1 ] [ j - 1 ] , end = "" ) print ( )
def printOtherSides ( n ) : if ( n & 1 ) : if ( n == 1 ) : print ( - 1 ) else : b = ( n * n - 1 ) // 2 c = ( n * n + 1 ) // 2 print ( "b=" , b , ",c=" , c ) else : if ( n == 2 ) : print ( - 1 ) else : b = n * n // 4 - 1 c = n * n // 4 + 1 print ( "b=" , b ",c=" , c )
def PowerOFPINnfactorial ( n , p ) : ans = 0 temp = p while ( temp <= n ) : ans += n / temp temp = temp * p return ans
def checkStackPermutation ( ip , op , n ) : Input = Queue ( ) for i in range ( n ) : Input . put ( ip [ i ] ) output = Queue ( ) for i in range ( n ) : output . put ( op [ i ] ) tempStack = [ ] while ( not Input . empty ( ) ) : ele = Input . queue [ 0 ] Input . get ( ) if ( ele == output . queue [ 0 ] ) : output . get ( ) while ( len ( tempStack ) != 0 ) : if ( tempStack [ - 1 ] == output . queue [ 0 ] ) : tempStack . pop ( ) output . get ( ) else : break else : tempStack . append ( ele ) return ( Input . empty ( ) and len ( tempStack ) == 0 )
def isSubsetSum ( set , n , sum ) : subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) for i in range ( n + 1 ) : subset [ i ] [ 0 ] = True for i in range ( 1 , sum + 1 ) : subset [ 0 ] [ i ] = False for i in range ( 1 , n + 1 ) : for j in range ( 1 , sum + 1 ) : if j < set [ i - 1 ] : subset [ i ] [ j ] = subset [ i - 1 ] [ j ] if j >= set [ i - 1 ] : subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) return subset [ n ] [ sum ]
def swapNibbles ( x ) : return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )
def arraySortedOrNot ( arr ) : n = len ( arr ) if n == 1 or n == 0 : return True return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] )
def sumOfSeries ( n ) : return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) )
def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : for j in range ( 0 , n - i - 1 ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ]
def printTwoElements ( arr , size ) : for i in range ( size ) : if arr [ abs ( arr [ i ] ) - 1 ] > 0 : arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] else : print ( "Therepeatingelementis" , abs ( arr [ i ] ) ) for i in range ( size ) : if arr [ i ] > 0 : print ( "andthemissingelementis" , i + 1 )
def decToBin ( n ) : if ( n == 0 ) : return "0" bin = "" while ( n > 0 ) : if ( n & 1 == 0 ) : bin = '0' + bin else : bin = '1' + bin n = n >> 1 return bin
def isProduct ( arr , n , x ) : if n < 2 : return False s = set ( ) for i in range ( 0 , n ) : if arr [ i ] == 0 : if x == 0 : return True else : continue if x % arr [ i ] == 0 : if x // arr [ i ] in s : return True s . add ( arr [ i ] ) return False
def checkMarkov ( m ) : for i in range ( 0 , len ( m ) ) : sm = 0 for j in range ( 0 , len ( m [ i ] ) ) : sm = sm + m [ i ] [ j ] if ( sm != 1 ) : return False return True
def isPowerOfFour ( n ) : count = 0 if ( n and ( not ( n & ( n - 1 ) ) ) ) : while ( n > 1 ) : n >>= 1 count += 1 if ( count % 2 == 0 ) : return True else : return False
def find_maximum ( a , n , k ) : b = dict ( ) for i in range ( n ) : x = a [ i ] d = min ( 1 + i , n - i ) if x not in b . keys ( ) : b [ x ] = d else : b [ x ] = min ( d , b [ x ] ) ans = 10 ** 9 for i in range ( n ) : x = a [ i ] if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) return ans
def printSuperSeq ( a , b ) : m = len ( a ) n = len ( b ) dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( 0 , m + 1 ) : for j in range ( 0 , n + 1 ) : if not i : dp [ i ] [ j ] = j elif not j : dp [ i ] [ j ] = i elif ( a [ i - 1 ] == b [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) index = dp [ m ] [ n ] res = [ "" ] * ( index ) i = m j = n while ( i > 0 and j > 0 ) : if ( a [ i - 1 ] == b [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 j -= 1 index -= 1 elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 else : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 while ( i > 0 ) : res [ index - 1 ] = a [ i - 1 ] i -= 1 index -= 1 while ( j > 0 ) : res [ index - 1 ] = b [ j - 1 ] j -= 1 index -= 1 print ( "" . join ( res ) )
def countIntegralSolutions ( n ) : result = 0 for i in range ( n + 1 ) : for j in range ( n + 1 ) : for k in range ( n + 1 ) : if i + j + k == n : result += 1 return result
def CountSubString ( Str , n ) : ans = ( n * ( n + 1 ) ) // 2 a_index = 0 b_index = 0 c_index = 0 for i in range ( n ) : if ( Str [ i ] == 'a' ) : a_index = i + 1 ans -= min ( b_index , c_index ) elif ( Str [ i ] == 'b' ) : b_index = i + 1 ans -= min ( a_index , c_index ) else : c_index = i + 1 ans -= min ( a_index , b_index ) return ans
def productSubSeqCount ( arr , k ) : n = len ( arr ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] for i in range ( 1 , k + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 return dp [ k ] [ n ]
def minRemove ( arr , n ) : LIS = [ 0 for i in range ( n ) ] len = 0 for i in range ( n ) : LIS [ i ] = 1 for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) len = max ( len , LIS [ i ] ) return ( n - len )
def oddEvenSort ( arr , n ) : isSorted = 0 while isSorted == 0 : isSorted = 1 temp = 0 for i in range ( 1 , n - 1 , 2 ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 for i in range ( 0 , n - 1 , 2 ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 return
def countOccurrences ( arr , n , x ) : res = 0 for i in range ( n ) : if x == arr [ i ] : res += 1 return res
def countDivisbleby4 ( s ) : n = len ( s ) count = 0 for i in range ( 0 , n , 1 ) : if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : count += 1 for i in range ( 0 , n - 1 , 1 ) : h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) if ( h % 4 == 0 ) : count = count + i + 1 return count
def maxSubArraySum ( a , size ) : max_so_far = - maxint - 1 max_ending_here = 0 for i in range ( 0 , size ) : max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if max_ending_here < 0 : max_ending_here = 0 return max_so_far
def findLIS ( A , n ) : hash = dict ( ) LIS_size , LIS_index = 1 , 0 hash [ A [ 0 ] ] = 1 for i in range ( 1 , n ) : if A [ i ] - 1 not in hash : hash [ A [ i ] - 1 ] = 0 hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 if LIS_size < hash [ A [ i ] ] : LIS_size = hash [ A [ i ] ] LIS_index = A [ i ] print ( "LIS_size=" , LIS_size ) print ( "LIS:" , end = "" ) start = LIS_index - LIS_size + 1 while start <= LIS_index : print ( start , end = "" ) start += 1
def minCoins ( coins , m , V ) : table = [ 0 for i in range ( V + 1 ) ] table [ 0 ] = 0 for i in range ( 1 , V + 1 ) : table [ i ] = sys . maxsize for i in range ( 1 , V + 1 ) : for j in range ( m ) : if ( coins [ j ] <= i ) : sub_res = table [ i - coins [ j ] ] if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : table [ i ] = sub_res + 1 return table [ V ]
def evaluate ( n ) : if ( n == 1 or n == 2 ) : print ( "NoPythagoras" + "Tripletexists" ) elif ( n % 2 == 0 ) : var = n * n / 4 print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var - 1 ) , "" , int ( var + 1 ) ) elif ( n % 2 != 0 ) : var = n * n + 1 print ( "PythagorasTriplets" + "existi.e." , end = "" ) print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , int ( var / 2 ) )
def rangeGCD ( n , m ) : return n if ( n == m ) else 1
def sortit ( arr , n ) : for i in range ( n ) : arr [ i ] = i + 1
def transpose ( A , B ) : for i in range ( N ) : for j in range ( N ) : B [ i ] [ j ] = A [ j ] [ i ]
def worstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : wstIdx = - 1 for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : if wstIdx == - 1 : wstIdx = j elif blockSize [ wstIdx ] < blockSize [ j ] : wstIdx = j if wstIdx != - 1 : allocation [ i ] = wstIdx blockSize [ wstIdx ] -= processSize [ i ] print ( "ProcessNo.ProcessSizeBlockno." ) for i in range ( n ) : print ( i + 1 , "" , processSize [ i ] , end = "" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( "NotAllocated" )
def nextWord ( s ) : if ( s == "" ) : return "a" i = len ( s ) - 1 while ( s [ i ] == 'z' and i >= 0 ) : i -= 1 if ( i == - 1 ) : s = s + 'a' else : s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) return s
def convert ( s ) : n = len ( s ) s1 = "" s1 = s1 + s [ 0 ] . lower ( ) i = 1 while i < n : if ( s [ i ] == '' and i <= n ) : s1 = s1 + "" + ( s [ i + 1 ] ) . lower ( ) i = i + 1 else : s1 = s1 + ( s [ i ] ) . upper ( ) i = i + 1 return s1
def countP ( n , k ) : dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = 0 for i in range ( k + 1 ) : dp [ 0 ] [ k ] = 0 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : if ( j == 1 or i == j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) return dp [ n ] [ k ]
def arrayEvenAndOdd ( arr , n ) : i = - 1 j = 0 while ( j != n ) : if ( arr [ j ] % 2 == 0 ) : i = i + 1 arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] j = j + 1 for i in arr : print ( str ( i ) + "" , end = '' )
def findSum ( n ) : return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24
def nextfit ( weight , c ) : res = 0 rem = c for _ in range ( len ( weight ) ) : if rem >= weight [ _ ] : rem = rem - weight [ _ ] else : res += 1 rem = c - weight [ _ ] return res
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def sumAtKthLevel ( tree , k ) : level = - 1 sum = 0 n = len ( tree ) for i in range ( n ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 else : if ( level == k ) : sum += ( ord ( tree [ i ] ) - ord ( '0' ) ) return sum
def Add ( x , y ) : while ( y != 0 ) : carry = x & y x = x ^ y y = carry << 1 return x
def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 for i in range ( 0 , n ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return int ( abs ( area / 2.0 ) )
def find ( a , b , k , n1 , n2 ) : s = set ( ) for i in range ( n2 ) : s . add ( b [ i ] ) missing = 0 for i in range ( n1 ) : if a [ i ] not in s : missing += 1 if missing == k : return a [ i ] return - 1
def isSubSequence ( str1 , str2 , m , n ) : j = 0 i = 0 while j < m and i < n : if str1 [ j ] == str2 [ i ] : j = j + 1 i = i + 1 return j == m
def findNth ( n ) : count = 0 curr = 19 while ( True ) : sum = 0 x = curr while ( x > 0 ) : sum = sum + x % 10 x = int ( x / 10 ) if ( sum == 10 ) : count += 1 if ( count == n ) : return curr curr += 9 return - 1
def countFreq ( a , n ) : hm = dict ( ) for i in range ( n ) : hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 cumul = 0 for i in range ( n ) : cumul += hm [ a [ i ] ] if ( hm [ a [ i ] ] > 0 ) : print ( a [ i ] , "->" , cumul ) hm [ a [ i ] ] = 0
def midPoint ( X1 , Y1 , X2 , Y2 ) : dx = X2 - X1 dy = Y2 - Y1 d = dy - ( dx / 2 ) x = X1 y = Y1 print ( x , "," , y , "\n" ) while ( x < X2 ) : x = x + 1 if ( d < 0 ) : d = d + dy else : d = d + ( dy - dx ) y = y + 1 print ( x , "," , y , "\n" )
def findPairs ( arr , n ) : Hash = { } for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum = arr [ i ] + arr [ j ] if sum in Hash . keys ( ) : prev = Hash . get ( sum ) print ( str ( prev ) + "and(%d,%d)" % ( arr [ i ] , arr [ j ] ) ) return True else : Hash [ sum ] = ( arr [ i ] , arr [ j ] )
def allCharactersSame ( s ) : n = len ( s ) for i in range ( 1 , n ) : if s [ i ] != s [ 0 ] : return False return True
def PrintMinNumberForPattern ( arr ) : curr_max = 0 last_entry = 0 i = 0 while i < len ( arr ) : noOfNextD = 0 if arr [ i ] == "I" : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 if i == 0 : curr_max = noOfNextD + 2 last_entry += 1 print ( "" , last_entry , end = "" ) print ( "" , curr_max , end = "" ) last_entry = curr_max else : curr_max += noOfNextD + 1 last_entry = curr_max print ( "" , last_entry , end = "" ) for k in range ( noOfNextD ) : last_entry -= 1 print ( "" , last_entry , end = "" ) i += 1 elif arr [ i ] == "D" : if i == 0 : j = i + 1 while j < len ( arr ) and arr [ j ] == "D" : noOfNextD += 1 j += 1 curr_max = noOfNextD + 2 print ( "" , curr_max , curr_max - 1 , end = "" ) last_entry = curr_max - 1 else : print ( "" , last_entry - 1 , end = "" ) last_entry -= 1 i += 1 print ( )
def zodiac_sign ( day , month ) : if month == 'december' : astro_sign = 'Sagittarius' if ( day < 22 ) else 'capricorn' elif month == 'january' : astro_sign = 'Capricorn' if ( day < 20 ) else 'aquarius' elif month == 'february' : astro_sign = 'Aquarius' if ( day < 19 ) else 'pisces' elif month == 'march' : astro_sign = 'Pisces' if ( day < 21 ) else 'aries' elif month == 'april' : astro_sign = 'Aries' if ( day < 20 ) else 'taurus' elif month == 'may' : astro_sign = 'Taurus' if ( day < 21 ) else 'gemini' elif month == 'june' : astro_sign = 'Gemini' if ( day < 21 ) else 'cancer' elif month == 'july' : astro_sign = 'Cancer' if ( day < 23 ) else 'leo' elif month == 'august' : astro_sign = 'Leo' if ( day < 23 ) else 'virgo' elif month == 'september' : astro_sign = 'Virgo' if ( day < 23 ) else 'libra' elif month == 'october' : astro_sign = 'Libra' if ( day < 23 ) else 'scorpio' elif month == 'november' : astro_sign = 'scorpio' if ( day < 22 ) else 'sagittarius' print ( astro_sign )
def isdivisible7 ( num ) : n = len ( num ) if ( n == 0 and num [ 0 ] == '\n' ) : return 1 if ( n % 3 == 1 ) : num = str ( num ) + "00" n += 2 elif ( n % 3 == 2 ) : num = str ( num ) + "0" n += 1 GSum = 0 p = 1 for i in range ( n - 1 , - 1 , - 1 ) : group = 0 group += ord ( num [ i ] ) - ord ( '0' ) i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 GSum = GSum + group * p p *= ( - 1 ) return ( GSum % 7 == 0 )
def minOperations ( str , n ) : lastUpper = - 1 firstLower = - 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( str [ i ] . isupper ( ) ) : lastUpper = i break for i in range ( n ) : if ( str [ i ] . islower ( ) ) : firstLower = i break if ( lastUpper == - 1 or firstLower == - 1 ) : return 0 countUpper = 0 for i in range ( firstLower , n ) : if ( str [ i ] . isupper ( ) ) : countUpper += 1 countLower = 0 for i in range ( lastUpper ) : if ( str [ i ] . islower ( ) ) : countLower += 1 return min ( countLower , countUpper )
def find_max ( A , N , K ) : Count = dict ( ) for i in range ( K - 1 ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 Myset = dict ( ) for x in Count : if ( Count [ x ] == 1 ) : Myset [ x ] = 1 for i in range ( K - 1 , N ) : Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 if ( Count [ A [ i ] ] == 1 ) : Myset [ A [ i ] ] = 1 else : del Myset [ A [ i ] ] if ( len ( Myset ) == 0 ) : print ( "Nothing" ) else : maxm = - 10 ** 9 for i in Myset : maxm = max ( i , maxm ) print ( maxm ) x = A [ i - K + 1 ] if x in Count . keys ( ) : Count [ x ] -= 1 if ( Count [ x ] == 1 ) : Myset [ x ] = 1 if ( Count [ x ] == 0 ) : del Myset [ x ]
def findSubString ( string , pat ) : len1 = len ( string ) len2 = len ( pat ) if len1 < len2 : print ( "Nosuchwindowexists" ) return "" hash_pat = [ 0 ] * no_of_chars hash_str = [ 0 ] * no_of_chars for i in range ( 0 , len2 ) : hash_pat [ ord ( pat [ i ] ) ] += 1 start , start_index , min_len = 0 , - 1 , float ( 'inf' ) count = 0 for j in range ( 0 , len1 ) : hash_str [ ord ( string [ j ] ) ] += 1 if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : count += 1 if count == len2 : while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : hash_str [ ord ( string [ start ] ) ] -= 1 start += 1 len_window = j - start + 1 if min_len > len_window : min_len = len_window start_index = start if start_index == - 1 : print ( "Nosuchwindowexists" ) return "" return string [ start_index : start_index + min_len ]
def printFirstRepeating ( arr , n ) : Min = - 1 myset = dict ( ) for i in range ( n - 1 , - 1 , - 1 ) : if arr [ i ] in myset . keys ( ) : Min = i else : myset [ arr [ i ] ] = 1 if ( Min != - 1 ) : print ( "Thefirstrepeatingelementis" , arr [ Min ] ) else : print ( "Therearenorepeatingelements" )
def longestString ( str1 , str2 ) : count1 = [ 0 ] * 26 count2 = [ 0 ] * 26 for i in range ( len ( str1 ) ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( str2 ) ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 result = "" for i in range ( 26 ) : for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : result = result + chr ( ord ( 'a' ) + i ) print ( result )
def findStep ( n ) : if ( n == 1 or n == 0 ) : return 1 elif ( n == 2 ) : return 2 else : return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 )
def countPS ( str ) : N = len ( str ) cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] for i in range ( N ) : cps [ i ] [ i ] = 1 for L in range ( 2 , N + 1 ) : for i in range ( N ) : k = L + i - 1 if ( k < N ) : if ( str [ i ] == str [ k ] ) : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) else : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) return cps [ 0 ] [ N - 1 ]
def maxSum ( arr ) : arrSum = 0 currVal = 0 n = len ( arr ) for i in range ( 0 , n ) : arrSum = arrSum + arr [ i ] currVal = currVal + ( i * arr [ i ] ) maxVal = currVal for j in range ( 1 , n ) : currVal = currVal + arrSum - n * arr [ n - j ] if currVal > maxVal : maxVal = currVal return maxVal
def generateGrayarr ( n ) : if ( n <= 0 ) : return arr = list ( ) arr . append ( "0" ) arr . append ( "1" ) i = 2 j = 0 while ( True ) : if i >= 1 << n : break for j in range ( i - 1 , - 1 , - 1 ) : arr . append ( arr [ j ] ) for j in range ( i ) : arr [ j ] = "0" + arr [ j ] for j in range ( i , 2 * i ) : arr [ j ] = "1" + arr [ j ] i = i << 1 for i in range ( len ( arr ) ) : print ( arr [ i ] )
def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 for i in range ( 0 , n ) : area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i return abs ( area // 2.0 )
def encodedChar ( str , k ) : expand = "" freq = 0 i = 0 while ( i < len ( str ) ) : temp = "" freq = 0 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) : temp += str [ i ] i += 1 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) i += 1 for j in range ( 1 , freq + 1 , 1 ) : expand += temp if ( freq == 0 ) : expand += temp return expand [ k - 1 ]
def findLength ( string ) : n = len ( string ) maxlen = 0 Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( 0 , n ) : Sum [ i ] [ i ] = int ( string [ i ] ) for length in range ( 2 , n + 1 ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 k = length // 2 Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : maxlen = length return maxlen
def countDer ( n ) : if ( n == 1 ) : return 0 if ( n == 0 ) : return 1 if ( n == 2 ) : return 1 return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )
def findMod ( a , b ) : if ( a < 0 ) : a = - a if ( b < 0 ) : b = - b mod = a while ( mod >= b ) : mod = mod - b if ( a < 0 ) : return - mod return mod
