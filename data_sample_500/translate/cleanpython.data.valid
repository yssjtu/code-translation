def sparseSearch ( arr , key , low , high ) : left = 0 right = 0 while low <= high : mid = ( low + high ) // 2 if arr [ mid ] == '' : left = mid - 1 right = mid + 1 if left < low and right > high : return - 1 elif right <= high and arr [ right ] != '' : mid = right elif left >= low and arr [ left ] != '' : mid = left if arr [ mid ] == key : print ( 'Foundstring{}atindex{}' . format ( arr [ mid ] , mid ) ) return elif arr [ mid ] > key : high = mid - 1 elif arr [ mid ] < key : low = mid + 1 left -= 1 right += 1 return - 1
def numofAP ( a , n ) : minarr = + 2147483647 maxarr = - 2147483648 for i in range ( n ) : minarr = min ( minarr , a [ i ] ) maxarr = max ( maxarr , a [ i ] ) dp = [ 0 for i in range ( n + 1 ) ] ans = n + 1 for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : sum = [ 0 for i in range ( MAX + 1 ) ] for i in range ( n ) : dp [ i ] = 1 if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : dp [ i ] += sum [ a [ i ] - d ] ans += dp [ i ] - 1 sum [ a [ i ] ] += dp [ i ] return ans
def russianPeasant ( a , b ) : res = 0 while ( b > 0 ) : if ( b & 1 ) : res = res + a a = a << 1 b = b >> 1 return res
def findSum ( arr , n ) : s = set ( ) sum = 0 for i in range ( n ) : if arr [ i ] not in s : s . add ( arr [ i ] ) for i in s : sum = sum + i return sum
def areaOctagon ( side ) : return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side )
def numoffbt ( arr , n ) : maxvalue = - 2147483647 minvalue = 2147483647 for i in range ( n ) : maxvalue = max ( maxvalue , arr [ i ] ) minvalue = min ( minvalue , arr [ i ] ) mark = [ 0 for i in range ( maxvalue + 2 ) ] value = [ 0 for i in range ( maxvalue + 2 ) ] for i in range ( n ) : mark [ arr [ i ] ] = 1 value [ arr [ i ] ] = 1 ans = 0 for i in range ( minvalue , maxvalue + 1 ) : if ( mark [ i ] != 0 ) : j = i + i while ( j <= maxvalue and j // i <= i ) : if ( mark [ j ] == 0 ) : continue value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) if ( i != j // i ) : value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) j += i ans += value [ i ] return ans
def areElementsContiguous ( arr ) : us = set ( ) for i in arr : us . add ( i ) count = 1 curr_ele = arr [ 0 ] - 1 while curr_ele in us : count += 1 curr_ele -= 1 curr_ele = arr [ 0 ] + 1 while curr_ele in us : count += 1 curr_ele += 1 return ( count == len ( us ) )
def gcd ( a , b ) : if a == 0 : return b return gcd ( b % a , a )
def printUnsorted ( arr , n ) : e = n - 1 for s in range ( 0 , n - 1 ) : if arr [ s ] > arr [ s + 1 ] : break if s == n - 1 : print ( "Thecompletearrayissorted" ) exit ( ) e = n - 1 while e > 0 : if arr [ e ] < arr [ e - 1 ] : break e -= 1 max = arr [ s ] min = arr [ s ] for i in range ( s + 1 , e + 1 ) : if arr [ i ] > max : max = arr [ i ] if arr [ i ] < min : min = arr [ i ] for i in range ( s ) : if arr [ i ] > min : s = i break i = n - 1 while i >= e + 1 : if arr [ i ] < max : e = i break i -= 1 print ( "Theunsortedsubarraywhichmakesthegivenarray" ) print ( "sortedliesbetweentheindexes%dand%d" % ( s , e ) )
def printSubsequences ( arr , n ) : opsize = math . pow ( 2 , n ) for counter in range ( 1 , ( int ) ( opsize ) ) : for j in range ( 0 , n ) : if ( counter & ( 1 << j ) ) : print ( arr [ j ] , end = "" ) print ( )
def countDigits ( a , b ) : if ( a == 0 or b == 0 ) : return 1 return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1
def isDivisibleBy7 ( num ) : if num < 0 : return isDivisibleBy7 ( - num ) if ( num == 0 or num == 7 ) : return True if ( num < 10 ) : return False return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) )
def kmax ( arr , k , n ) : for c in range ( k ) : max_so_far = - float ( "inf" ) max_here = 0 start = 0 end = 0 s = 0 for i in range ( n ) : max_here += arr [ i ] if ( max_so_far < max_here ) : max_so_far = max_here start = s end = i if ( max_here < 0 ) : max_here = 0 s = i + 1 print ( "Maximumnon-overlappingsub-arraysum" , c + 1 , ":" , max_so_far , ",startingindex:" , start , ",endingindex:" , end , "." , sep = "" ) for l in range ( start , end + 1 ) : arr [ l ] = - float ( "inf" ) print ( )
def printPowerSet ( set , set_size ) : pow_set_size = ( int ) ( math . pow ( 2 , set_size ) ) counter = 0 j = 0 for counter in range ( 0 , pow_set_size ) : for j in range ( 0 , set_size ) : if ( ( counter & ( 1 << j ) ) > 0 ) : print ( set [ j ] , end = "" ) print ( "" )
def costToBalance ( s ) : if ( len ( s ) == 0 ) : print ( 0 ) ans = 0 o = 0 c = 0 for i in range ( len ( s ) ) : if ( s [ i ] == '(' ) : o += 1 if ( s [ i ] == ')' ) : c += 1 if ( o != c ) : return - 1 a = [ 0 for i in range ( len ( s ) ) ] if ( s [ 0 ] == '(' ) : a [ 0 ] = 1 else : a [ 0 ] = - 1 if ( a [ 0 ] < 0 ) : ans += abs ( a [ 0 ] ) for i in range ( 1 , len ( s ) ) : if ( s [ i ] == '(' ) : a [ i ] = a [ i - 1 ] + 1 else : a [ i ] = a [ i - 1 ] - 1 if ( a [ i ] < 0 ) : ans += abs ( a [ i ] ) return ans
def largestSumOfAverages ( A , K ) : n = len ( A ) pre_sum = [ 0 ] * ( n + 1 ) pre_sum [ 0 ] = 0 for i in range ( n ) : pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] dp = [ 0 ] * n sum = 0 for i in range ( n ) : dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) for k in range ( K - 1 ) : for i in range ( n ) : for j in range ( i + 1 , n ) : dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) return int ( dp [ 0 ] )
def divSum ( num ) : result = 0 i = 2 while i <= ( math . sqrt ( num ) ) : if ( num % i == 0 ) : if ( i == ( num / i ) ) : result = result + i ; else : result = result + ( i + num / i ) ; i = i + 1 return ( result + 1 ) ;
def MaximumHeight ( a , n ) : result = 1 for i in range ( 1 , n ) : y = ( i * ( i + 1 ) ) / 2 if ( y < n ) : result = i else : break return result
def HalfDiagonalSums ( mat , n ) : diag1_left = 0 diag1_right = 0 diag2_left = 0 diag2_right = 0 i = 0 j = n - 1 while i < n : if ( i < n // 2 ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ j ] [ i ] elif ( i > n // 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] i += 1 j -= 1 return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )
def sortInWave ( arr , n ) : arr . sort ( ) for i in range ( 0 , n - 1 , 2 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]
def countWays ( n ) : DP = [ 0 for i in range ( 0 , n + 1 ) ] DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 DP [ 3 ] = 2 for i in range ( 4 , n + 1 ) : DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] return DP [ n ]
def yMod ( y , x ) : return ( y % pow ( 2 , x ) )
def maxLen ( arr ) : hash_map = { } max_len = 0 curr_sum = 0 for i in range ( len ( arr ) ) : curr_sum += arr [ i ] if arr [ i ] is 0 and max_len is 0 : max_len = 1 if curr_sum is 0 : max_len = i + 1 if curr_sum in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum ] ) else : hash_map [ curr_sum ] = i return max_len
def maxProd ( n ) : if ( n == 2 or n == 3 ) : return ( n - 1 ) res = 1 while ( n > 4 ) : n -= 3 res *= 3 return ( n * res )
def maxDifference ( arr , N , k ) : S = 0 S1 = 0 max_difference = 0 for i in range ( N ) : S += arr [ i ] arr . sort ( reverse = True ) M = max ( k , N - k ) for i in range ( M ) : S1 += arr [ i ] max_difference = S1 - ( S - S1 ) return max_difference
def printDistinct ( arr , n ) : s = dict ( ) for i in range ( n ) : if ( arr [ i ] not in s . keys ( ) ) : s [ arr [ i ] ] = arr [ i ] print ( arr [ i ] , end = "" )
def lis ( arr , n ) : mpis = [ 0 ] * ( n ) for i in range ( n ) : mpis [ i ] = arr [ i ] for i in range ( 1 , n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] return max ( mpis )
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) return math . ceil ( d // ( 2 * r ) )
def minimum_cost ( a , n ) : mn = sys . maxsize sum = 0 for i in range ( n ) : mn = min ( a [ i ] , mn ) sum += a [ i ] return mn * ( sum - mn )
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , m + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 if ( cnt [ i ] [ j ] >= k ) : for a in range ( k , cnt [ i ] [ j ] + 1 ) : lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) return lcs [ n ] [ m ]
def countSetBits ( n ) : count = 0 while ( n ) : count += n & 1 n >>= 1 return count
def remainderWith7 ( num ) : series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] series_index = 0 result = 0 for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : digit = ord ( num [ i ] ) - 48 result += digit * series [ series_index ] series_index = ( series_index + 1 ) % 6 result %= 7 if ( result < 0 ) : result = ( result + 7 ) % 7 return result
def maxOnesIndex ( arr , n ) : max_count = 0 max_index = 0 prev_zero = - 1 prev_prev_zero = - 1 for curr in range ( n ) : if ( arr [ curr ] == 0 ) : if ( curr - prev_prev_zero > max_count ) : max_count = curr - prev_prev_zero max_index = prev_zero prev_prev_zero = prev_zero prev_zero = curr if ( n - prev_prev_zero > max_count ) : max_index = prev_zero return max_index
def maxArea ( a , b , c , d ) : semiperimeter = ( a + b + c + d ) / 2 return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )
def gcd ( a , b ) : if ( a < b ) : return gcd ( b , a ) if ( abs ( b ) < 0.001 ) : return a else : return ( gcd ( b , a - math . floor ( a / b ) * b ) )
def replace ( s , c1 , c2 ) : l = len ( s ) for i in range ( l ) : if ( s [ i ] == c1 ) : s = s [ 0 : i ] + c2 + s [ i + 1 : ] elif ( s [ i ] == c2 ) : s = s [ 0 : i ] + c1 + s [ i + 1 : ] return s
def sortSquares ( arr , n ) : K = 0 for K in range ( n ) : if ( arr [ K ] >= 0 ) : break i = K - 1 j = K ind = 0 temp = [ 0 ] * n while ( i >= 0 and j < n ) : if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 else : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 while ( i >= 0 ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 ind += 1 while ( j < n ) : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 for i in range ( n ) : arr [ i ] = temp [ i ]
def round ( n ) : a = ( n // 10 ) * 10 b = a + 10 return ( b if n - a > b - n else a )
def FindMaxProduct ( arr , n ) : max = 0 for i in range ( n ) : for j in range ( n ) : if ( ( j - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) if ( max < result ) : max = result if ( ( i - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) if ( max < result ) : max = result if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) if ( max < result ) : max = result return max
def isRectangle ( m ) : rows = len ( m ) if ( rows == 0 ) : return False columns = len ( m [ 0 ] ) for y1 in range ( rows ) : for x1 in range ( columns ) : if ( m [ y1 ] [ x1 ] == 1 ) : for y2 in range ( y1 + 1 , rows ) : for x2 in range ( x1 + 1 , columns ) : if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : return True return False
def countMinOperations ( target , n ) : result = 0 while ( True ) : zero_count = 0 i = 0 while ( i < n ) : if ( ( target [ i ] & 1 ) > 0 ) : break elif ( target [ i ] == 0 ) : zero_count += 1 i += 1 if ( zero_count == n ) : return result if ( i == n ) : for j in range ( n ) : target [ j ] = target [ j ] // 2 result += 1 for j in range ( i , n ) : if ( target [ j ] & 1 ) : target [ j ] -= 1 result += 1
def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 us = set ( ) for i in range ( m ) : us . add ( arr1 [ i ] ) for j in range ( n ) : if x - arr2 [ j ] in us : count += 1 return count
def numberofways ( A , B , N , M ) : pos = [ [ ] for _ in range ( MAX ) ] for i in range ( M ) : pos [ ord ( B [ i ] ) ] . append ( i + 1 ) dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( 1 , N + 1 ) : for j in range ( 1 , M + 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 else : dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) LCS = dpl [ N ] [ M ] dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] for i in range ( N , 0 , - 1 ) : for j in range ( M , 0 , - 1 ) : if A [ i - 1 ] == B [ j - 1 ] : dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 else : dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ans = 0 for i in range ( N + 1 ) : for j in range ( MAX ) : for x in pos [ j ] : if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : ans += 1 break return ans
def ReversespiralPrint ( m , n , a ) : b = [ 0 for i in range ( 100 ) ] i , k , l = 0 , 0 , 0 z = 0 size = m * n while ( k < m and l < n ) : val = 0 for i in range ( l , n ) : val = a [ k ] [ i ] b [ z ] = val z += 1 k += 1 for i in range ( k , m ) : val = a [ i ] [ n - 1 ] b [ z ] = val z += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : val = a [ m - 1 ] [ i ] b [ z ] = val z += 1 m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : val = a [ i ] [ l ] b [ z ] = val z += 1 l += 1 for i in range ( size - 1 , - 1 , - 1 ) : print ( b [ i ] , end = "" )
def maxSubArraySum ( a , size ) : max_so_far = - maxsize - 1 max_ending_here = 0 start = 0 end = 0 s = 0 for i in range ( 0 , size ) : max_ending_here += a [ i ] if max_so_far < max_ending_here : max_so_far = max_ending_here start = s end = i if max_ending_here < 0 : max_ending_here = 0 s = i + 1 print ( "Maximumcontiguoussumis%d" % ( max_so_far ) ) print ( "StartingIndex%d" % ( start ) ) print ( "EndingIndex%d" % ( end ) )
def optimalStrategyOfGame ( arr , n ) : table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for gap in range ( n ) : for j in range ( gap , n ) : i = j - gap x = 0 if ( ( i + 2 ) <= j ) : x = table [ i + 2 ] [ j ] y = 0 if ( ( i + 1 ) <= ( j - 1 ) ) : y = table [ i + 1 ] [ j - 1 ] z = 0 if ( i <= ( j - 2 ) ) : z = table [ i ] [ j - 2 ] table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) return table [ 0 ] [ n - 1 ]
def minDaysToEmpty ( C , l ) : if ( l >= C ) : return C eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 return math . ceil ( eq_root ) + l
def squareRoot ( n ) : return pow ( 2 , 0.5 * math . log2 ( n ) )
def summingSeries ( n ) : S = 0 for i in range ( 1 , n + 1 ) : S += i * i - ( i - 1 ) * ( i - 1 ) return S
def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : for j in range ( 0 , n ) : if ( i == j ) : d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) : d2 += arr [ i ] [ j ] return abs ( d1 - d2 )
def countDecodingDP ( digits , n ) : count = [ 0 ] * ( n + 1 ) count [ 0 ] = 1 count [ 1 ] = 1 for i in range ( 2 , n + 1 ) : count [ i ] = 0 if ( digits [ i - 1 ] > '0' ) : count [ i ] = count [ i - 1 ] if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : count [ i ] += count [ i - 2 ] return count [ n ]
def containsOdd ( G , src ) : global V colorArr = [ - 1 ] * V colorArr [ src ] = 1 q = queue . Queue ( ) q . put ( src ) while ( not q . empty ( ) ) : u = q . get ( ) if ( G [ u ] [ u ] == 1 ) : return True for v in range ( V ) : if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) : colorArr [ v ] = 1 - colorArr [ u ] q . put ( v ) elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) : return True return False
def PositionRightmostSetbit ( n ) : position = 1 m = 1 while ( not ( n & m ) ) : m = m << 1 position += 1 return position
def spiralPrint ( m , n , a ) : k = 0 l = 0 while ( k < m and l < n ) : for i in range ( l , n ) : print ( a [ k ] [ i ] , end = "" ) k += 1 for i in range ( k , m ) : print ( a [ i ] [ n - 1 ] , end = "" ) n -= 1 if ( k < m ) : for i in range ( n - 1 , ( l - 1 ) , - 1 ) : print ( a [ m - 1 ] [ i ] , end = "" ) m -= 1 if ( l < n ) : for i in range ( m - 1 , k - 1 , - 1 ) : print ( a [ i ] [ l ] , end = "" ) l += 1
def isAnBn ( str ) : n = len ( str ) for i in range ( n ) : if ( str [ i ] != 'a' ) : break if ( i * 2 != n ) : return False for j in range ( i , n ) : if ( str [ j ] != 'b' ) : return False return True
def sortByPattern ( str , pat ) : global MAX_CHAR count = [ 0 ] * MAX_CHAR for i in range ( 0 , len ( str ) ) : count [ ord ( str [ i ] ) - 97 ] += 1 index = 0 str = "" for i in range ( 0 , len ( pat ) ) : j = 0 while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] ) : str += pat [ i ] j = j + 1 index += 1 return str
def countDigits ( a , b ) : count = 0 p = abs ( a * b ) if ( p == 0 ) : return 1 while ( p > 0 ) : count = count + 1 p = p // 10 return count
def findMinSum ( num ) : sum = 0 i = 2 while ( i * i <= num ) : while ( num % i == 0 ) : sum += i num /= i i += 1 sum += num return sum
def maxRevenue ( m , x , revenue , n , t ) : maxRev = [ 0 ] * ( m + 1 ) nxtbb = 0 for i in range ( 1 , m + 1 ) : if ( nxtbb < n ) : if ( x [ nxtbb ] != i ) : maxRev [ i ] = maxRev [ i - 1 ] else : if ( i <= t ) : maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) else : maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) nxtbb += 1 else : maxRev [ i ] = maxRev [ i - 1 ] return maxRev [ m ]
def bin ( n ) : if ( n > 1 ) : bin ( n >> 1 ) print ( n & 1 , end = "" )
def isPresent ( s , q ) : freq = [ 0 ] * MAX_CHAR for i in range ( 0 , len ( s ) ) : freq [ ord ( s [ i ] ) ] += 1 for i in range ( 0 , len ( q ) ) : freq [ ord ( q [ i ] ) ] -= 1 if ( freq [ ord ( q [ i ] ) ] < 0 ) : return False return True
def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : swapped = False for j in range ( 0 , n - i - 1 ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] swapped = True if swapped == False : break
def factorial ( n ) : return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
def areAnagram ( str1 , str2 ) : n1 = len ( str1 ) n2 = len ( str2 ) if n1 != n2 : return 0 str1 = sorted ( str1 ) str2 = sorted ( str2 ) for i in range ( 0 , n1 ) : if str1 [ i ] != str2 [ i ] : return 0 return 1
def gcdExtended ( a , b , x , y ) : if a == 0 : x = 0 y = 1 return b x1 = 1 y1 = 1 gcd = gcdExtended ( b % a , a , x1 , y1 ) x = y1 - ( b / a ) * x1 y = x1 return gcd
def solveQuery ( start , end , arr ) : frequency = dict ( ) for i in range ( start , end + 1 ) : if arr [ i ] in frequency . keys ( ) : frequency [ arr [ i ] ] += 1 else : frequency [ arr [ i ] ] = 1 count = 0 for x in frequency : if x == frequency [ x ] : count += 1 return count
def printPascal ( n : int ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for line in range ( 0 , n ) : for i in range ( 0 , line + 1 ) : if ( i is 0 or i is line ) : arr [ line ] [ i ] = 1 print ( arr [ line ] [ i ] , end = "" ) else : arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) print ( arr [ line ] [ i ] , end = "" ) print ( "\n" , end = "" )
def printFirstNegativeInteger ( arr , n , k ) : Di = deque ( ) for i in range ( k ) : if ( arr [ i ] < 0 ) : Di . append ( i ) for i in range ( k , n ) : if ( not Di ) : print ( 0 , end = '' ) else : print ( arr [ Di [ 0 ] ] , end = '' ) while Di and Di [ 0 ] <= ( i - k ) : Di . popleft ( ) if ( arr [ i ] < 0 ) : Di . append ( i ) if not Di : print ( 0 ) else : print ( arr [ Di [ 0 ] ] , end = "" )
def findTriplets ( arr , n ) : found = False for i in range ( n - 1 ) : s = set ( ) for j in range ( i + 1 , n ) : x = - ( arr [ i ] + arr [ j ] ) if x in s : print ( x , arr [ i ] , arr [ j ] ) found = True else : s . add ( arr [ j ] ) if found == False : print ( "NoTripletFound" )
def getModulo ( n , d ) : return ( n & ( d - 1 ) )
def minimumCostOfBreaking ( X , Y , m , n ) : res = 0 X . sort ( reverse = True ) Y . sort ( reverse = True ) hzntl = 1 vert = 1 i = 0 j = 0 while ( i < m and j < n ) : if ( X [ i ] > Y [ j ] ) : res += X [ i ] * vert hzntl += 1 i += 1 else : res += Y [ j ] * hzntl vert += 1 j += 1 total = 0 while ( i < m ) : total += X [ i ] i += 1 res += total * vert total = 0 while ( j < n ) : total += Y [ j ] j += 1 res += total * hzntl return res
def isPossible ( a , b , n , k ) : a . sort ( reverse = True ) b . sort ( ) for i in range ( n ) : if ( a [ i ] + b [ i ] < k ) : return False return True
def calculate ( a ) : maximum = max ( a ) frequency = [ 0 for x in range ( maximum + 1 ) ] for i in a : frequency [ i ] += 1 answer = 0 for i in frequency : answer = answer + i * ( i - 1 ) // 2 return answer
def minimalSteps ( s , n ) : dp = [ INT_MAX for i in range ( n ) ] s1 = "" s2 = "" dp [ 0 ] = 1 s1 += s [ 0 ] for i in range ( 1 , n ) : s1 += s [ i ] s2 = s [ i + 1 : i + 1 + i + 1 ] dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) if ( s1 == s2 ) : dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) return dp [ n - 1 ]
def countLattice ( r ) : if ( r <= 0 ) : return 0 result = 4 for x in range ( 1 , r ) : ySquare = r * r - x * x y = int ( math . sqrt ( ySquare ) ) if ( y * y == ySquare ) : result += 4 return result
def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x start = 1 end = x while ( start <= end ) : mid = ( start + end ) // 2 if ( mid * mid == x ) : return mid if ( mid * mid < x ) : start = mid + 1 ans = mid else : end = mid - 1 return ans
def swapBits ( x ) : even_bits = x & 0xAAAAAAAA odd_bits = x & 0x55555555 even_bits >>= 1 odd_bits <<= 1 return ( even_bits | odd_bits )
def findmin ( p , n ) : a , b , c , d = 0 , 0 , 0 , 0 for i in range ( n ) : if ( p [ i ] [ 0 ] <= 0 ) : a += 1 elif ( p [ i ] [ 0 ] >= 0 ) : b += 1 if ( p [ i ] [ 1 ] >= 0 ) : c += 1 elif ( p [ i ] [ 1 ] <= 0 ) : d += 1 return min ( [ a , b , c , d ] )
def findMinX ( num , rem , k ) : x = 1 while ( True ) : j = 0 while ( j < k ) : if ( x % num [ j ] != rem [ j ] ) : break j += 1 if ( j == k ) : return x x += 1
def knapSack ( W , wt , val , n ) : if n == 0 or W == 0 : return 0 if ( wt [ n - 1 ] > W ) : return knapSack ( W , wt , val , n - 1 ) else : return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )
def breakSum ( n ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) return dp [ n ]
def countWords ( str , l ) : count = 1 ; if ( l == 1 ) : return count if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : count *= 2 for j in range ( 1 , l - 1 ) : if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : count *= 1 elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : count *= 2 else : count *= 3 if ( str [ l - 1 ] == str [ l - 2 ] ) : count *= 1 else : count *= 2 return count
def findSDSFunc ( n ) : DP = [ 0 ] * ( n + 1 ) DP [ 0 ] = 0 DP [ 1 ] = 1 for i in range ( 2 , n + 1 ) : if ( int ( i % 2 ) == 0 ) : DP [ i ] = DP [ int ( i / 2 ) ] else : DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) return DP [ n ]
def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 for i in range ( 0 , n - 1 ) : sum = - 1 if ( arr [ i ] == 0 ) else 1 for j in range ( i + 1 , n ) : sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 if ( sum == 0 and maxsize < j - i + 1 ) : maxsize = j - i + 1 startindex = i if ( maxsize == - 1 ) : print ( "Nosuchsubarray" ) else : print ( startindex , "to" , startindex + maxsize - 1 ) return maxsize
def fix ( A , len ) : for i in range ( 0 , len ) : if ( A [ i ] != - 1 and A [ i ] != i ) : x = A [ i ] while ( A [ x ] != - 1 and A [ x ] != x ) : y = A [ x ] A [ x ] = x x = y A [ x ] = x if ( A [ i ] != i ) : A [ i ] = - 1
def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 digits = 0 for i in range ( 2 , n + 1 ) : digits += math . log10 ( i ) return math . floor ( digits ) + 1
def computeTotient ( n ) : phi = [ ] for i in range ( n + 2 ) : phi . append ( 0 ) for i in range ( 1 , n + 1 ) : phi [ i ] = i for p in range ( 2 , n + 1 ) : if ( phi [ p ] == p ) : phi [ p ] = p - 1 for i in range ( 2 * p , n + 1 , p ) : phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) for i in range ( 1 , n + 1 ) : print ( "Totientof" , i , "is" , phi [ i ] )
def printSorted ( a , b , c ) : get_max = max ( a , max ( b , c ) ) get_min = - max ( - a , max ( - b , - c ) ) get_mid = ( a + b + c ) - ( get_max + get_min ) print ( get_min , "" , get_mid , "" , get_max )
def findCombinations ( string , index , out ) : if index == len ( string ) : print ( out ) for i in range ( index , len ( string ) , 1 ) : findCombinations ( string , i + 1 , out + "(" + string [ index : i + 1 ] + ")" )
def minProductSubset ( a , n ) : if ( n == 1 ) : return a [ 0 ] max_neg = float ( '-inf' ) min_pos = float ( 'inf' ) count_neg = 0 count_zero = 0 prod = 1 for i in range ( 0 , n ) : if ( a [ i ] == 0 ) : count_zero = count_zero + 1 continue if ( a [ i ] < 0 ) : count_neg = count_neg + 1 max_neg = max ( max_neg , a [ i ] ) if ( a [ i ] > 0 ) : min_pos = min ( min_pos , a [ i ] ) prod = prod * a [ i ] if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : return 0 if ( count_neg == 0 ) : return min_pos if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) : prod = int ( prod / max_neg ) return prod
def findMaxVal ( arr , n , num , maxLimit ) : ind = - 1 val = - 1 dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] for ind in range ( n ) : for val in range ( maxLimit + 1 ) : if ( ind == 0 ) : if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : dp [ ind ] [ val ] = 1 else : dp [ ind ] [ val ] = 0 else : if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : dp [ ind ] [ val ] = 1 elif ( val - arr [ ind ] >= 0 ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] elif ( val + arr [ ind ] <= maxLimit ) : dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] else : dp [ ind ] [ val ] = 0 for val in range ( maxLimit , - 1 , - 1 ) : if ( dp [ n - 1 ] [ val ] == 1 ) : return val return - 1
def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 1 ) : s = set ( ) curr_sum = sum - A [ i ] for j in range ( i + 1 , arr_size ) : if ( curr_sum - A [ j ] ) in s : print ( "Tripletis" , A [ i ] , "," , A [ j ] , "," , curr_sum - A [ j ] ) return True s . add ( A [ j ] ) return False
def countDistictSubarray ( arr , n ) : vis = dict ( ) for i in range ( n ) : vis [ arr [ i ] ] = 1 k = len ( vis ) vid = dict ( ) ans = 0 right = 0 window = 0 for left in range ( n ) : while ( right < n and window < k ) : if arr [ right ] in vid . keys ( ) : vid [ arr [ right ] ] += 1 else : vid [ arr [ right ] ] = 1 if ( vid [ arr [ right ] ] == 1 ) : window += 1 right += 1 if ( window == k ) : ans += ( n - right + 1 ) vid [ arr [ left ] ] -= 1 if ( vid [ arr [ left ] ] == 0 ) : window -= 1 return ans
def stoogesort ( arr , l , h ) : if l >= h : return if arr [ l ] > arr [ h ] : t = arr [ l ] arr [ l ] = arr [ h ] arr [ h ] = t if h - l + 1 > 2 : t = ( int ) ( ( h - l + 1 ) / 3 ) stoogesort ( arr , l , ( h - t ) ) stoogesort ( arr , l + t , ( h ) ) stoogesort ( arr , l , ( h - t ) )
def sumofsquare ( n ) : C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) sum = 0 for i in range ( 0 , n + 1 ) : sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) return sum
def areacircumscribed ( a ) : return ( a * a * ( PI / 2 ) )
def printSubsequences ( str ) : n = len ( str ) opsize = int ( pow ( 2 , n - 1 ) ) for counter in range ( opsize ) : for j in range ( n ) : print ( str [ j ] , end = "" ) if ( counter & ( 1 << j ) ) : print ( "" , end = "" ) print ( "\n" , end = "" )
def findLeft ( str ) : n = len ( str ) - 1 while ( n > 0 ) : if ( str [ n ] == 'd' ) : str = str [ 0 : n ] + 'c' + str [ n + 1 : ] break if ( str [ n ] == 'b' ) : str = str [ 0 : n ] + 'a' + str [ n + 1 : ] break if ( str [ n ] == 'a' ) : str = str [ 0 : n ] + 'b' + str [ n + 1 : ] elif ( str [ n ] == 'c' ) : str = str [ 0 : n ] + 'd' + str [ n + 1 : ] n -= 1 return str
def countPairs ( a , n ) : count = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : if ( a [ i ] & a [ j ] ) == 0 : count += 2 return count
def findMaxProduct ( arr , n ) : ans = - float ( 'inf' ) maxval = 1 minval = 1 for i in range ( 0 , n ) : if arr [ i ] > 0 : maxval = maxval * arr [ i ] minval = min ( 1 , minval * arr [ i ] ) elif arr [ i ] == 0 : minval = 1 maxval = 0 elif arr [ i ] < 0 : prevMax = maxval maxval = minval * arr [ i ] minval = prevMax * arr [ i ] ans = max ( ans , maxval ) if maxval <= 0 : maxval = 1 return ans
