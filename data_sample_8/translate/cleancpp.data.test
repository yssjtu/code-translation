void countSubsequence ( char s [ ], int n ) { int cntG = 0, cntF = 0, result = 0, C = 0; for ( int i = 0; i < n; i ++ ) { switch ( s [ i ] ) { case 'G' : cntG ++; result += C; break; case 'F' : cntF ++; C += cntG; break; default : continue; } } cout << result << endl; }
int minProduct ( int arr [ ], int n, int k ) { priority_queue < int, vector < int >, greater < int > > pq; for ( int i = 0; i < n; i ++ ) pq . push ( arr [ i ] ); int count = 0, ans = 1; while ( pq . empty ( ) == false && count < k ) { ans = ans * pq . top ( ); pq . pop ( ); count ++; } return ans; }
int countStrings ( int n ) { int a [ n ], b [ n ]; a [ 0 ] = b [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ]; b [ i ] = a [ i - 1 ]; } return a [ n - 1 ] + b [ n - 1 ]; }
void findElements ( int arr [ ], int n ) { int first = INT_MIN, second = INT_MIN; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] > first ) { second = first; first = arr [ i ]; } else if ( arr [ i ] > second ) second = arr [ i ]; } for ( int i = 0; i < n; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " "; }
int minJumps ( int arr [ ], int n ) { if ( n == 1 ) return 0; int res = INT_MAX; for ( int i = n - 2; i >= 0; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_res = minJumps ( arr, i + 1 ); if ( sub_res != INT_MAX ) res = min ( res, sub_res + 1 ); } } return res; }
void printInSortedOrder ( string arr [ ], int n ) { int index [ n ]; int i, j, min; for ( i = 0; i < n; i ++ ) index [ i ] = i; for ( i = 0; i < n - 1; i ++ ) { min = i; for ( j = i + 1; j < n; j ++ ) { if ( arr [ index [ min ] ] . compare ( arr [ index [ j ] ] ) > 0 ) min = j; } if ( min != i ) { int temp = index [ min ]; index [ min ] = index [ i ]; index [ i ] = temp; } } for ( i = 0; i < n; i ++ ) cout << arr [ index [ i ] ] << " "; }
int minDiff ( int arr [ ], int n, int k ) { int result = INT_MAX; sort ( arr, arr + n ); for ( int i = 0; i <= n - k; i ++ ) result = min ( result, arr [ i + k - 1 ] - arr [ i ] ); return result; }
double arcLength ( double diameter, double angle ) { double pi = 22.0 / 7.0; double arc; if ( angle >= 360 ) { cout << "Angle cannot", " be formed"; return 0; } else { arc = ( pi * diameter ) * ( angle / 360.0 ); return arc; } }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ); }
int minDifferenceAmongMaxMin ( int arr [ ], int N, int K ) { sort ( arr, arr + N ); int res = INT_MAX; for ( int i = 0; i <= ( N - K ); i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ]; res = min ( res, curSeqDiff ); } return res; }
int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x; int i = 1, result = 1; while ( result <= x ) { i ++; result = i * i; } return i - 1; }
int countDivisbleby4 ( char s [ ] ) { int n = strlen ( s ); int count = 0; for ( int i = 0; i < n; ++ i ) if ( s [ i ] == '4' || s [ i ] == '8' || s [ i ] == '0' ) count ++; for ( int i = 0; i < n - 1; ++ i ) { int h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ); if ( h % 4 == 0 ) count = count + i + 1; } return count; }
int countPairs ( int arr [ ], int n ) { int ans = 0; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++; return ans; }
int isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ); if ( num == 0 || num == 7 ) return 1; if ( num < 10 ) return 0; return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ); }
int minDaysToEmpty ( int C, int l ) { if ( l >= C ) return C; double eq_root = ( std :: sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2; return std :: ceil ( eq_root ) + l; }
int cutRod ( int price [ ], int n ) { int val [ n + 1 ]; val [ 0 ] = 0; int i, j; for ( i = 1; i <= n; i ++ ) { int max_val = INT_MIN; for ( j = 0; j < i; j ++ ) max_val = max ( max_val, price [ j ] + val [ i - j - 1 ] ); val [ i ] = max_val; } return val [ n ]; }
int getTotalNumberOfSequences ( int m, int n ) { if ( m < n ) return 0; if ( n == 0 ) return 1; return getTotalNumberOfSequences ( m - 1, n ) + getTotalNumberOfSequences ( m / 2, n - 1 ); }
int maxSum ( int arr [ ], int n ) { int cum_sum = 0; for ( int i = 0; i < n; i ++ ) cum_sum += arr [ i ]; int curr_val = 0; for ( int i = 0; i < n; i ++ ) curr_val += i * arr [ i ]; int res = curr_val; for ( int i = 1; i < n; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ); curr_val = next_val; res = max ( res, next_val ); } return res; }
char first ( string str, int i = 0 ) { if ( str [ i ] == '\0' ) return 0; if ( isupper ( str [ i ] ) ) return str [ i ]; return first ( str, i + 1 ); }
void findSmallest ( int m, int s ) { if ( s == 0 ) { ( m == 1 ) ? cout << "Smallest number is " << 0 : cout << "Not possible"; return; } if ( s > 9 * m ) { cout << "Not possible"; return; } int res [ m ]; s -= 1; for ( int i = m - 1; i > 0; i -- ) { if ( s > 9 ) { res [ i ] = 9; s -= 9; } else { res [ i ] = s; s = 0; } } res [ 0 ] = s + 1; cout << "Smallest number is "; for ( int i = 0; i < m; i ++ ) cout << res [ i ]; }
bool areEqual ( int arr1 [ ], int arr2 [ ], int n, int m ) { if ( n != m ) return false; sort ( arr1, arr1 + n ); sort ( arr2, arr2 + m ); for ( int i = 0; i < n; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false; return true; }
int countNums ( int n, int x, int y ) { vector < bool > arr ( n + 1, false ); if ( x <= n ) arr [ x ] = true; if ( y <= n ) arr [ y ] = true; int result = 0; for ( int i = min ( x, y ); i <= n; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true; if ( i + y <= n ) arr [ i + y ] = true; result ++; } } return result; }
void bonacciseries ( long n, int m ) { int a [ m ] = { 0 }; a [ n - 1 ] = 1; a [ n ] = 1; for ( int i = n + 1; i < m; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]; for ( int i = 0; i < m; i ++ ) cout << a [ i ] << " "; }
bool isSubSequence ( char str1 [ ], char str2 [ ], int m, int n ) { if ( m == 0 ) return true; if ( n == 0 ) return false; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1, str2, m - 1, n - 1 ); return isSubSequence ( str1, str2, m, n - 1 ); }
int findNth ( int n ) { int count = 0; for ( int curr = 1; ; curr ++ ) { int sum = 0; for ( int x = curr; x > 0; x = x / 10 ) sum = sum + x % 10; if ( sum == 10 ) count ++; if ( count == n ) return curr; } return - 1; }
int rangeGCD ( int n, int m ) { return ( n == m ) ? n : 1; }
int lbs ( int arr [ ], int n ) { int i, j; int * lis = new int [ n ]; for ( i = 0; i < n; i ++ ) lis [ i ] = 1; for ( i = 1; i < n; i ++ ) for ( j = 0; j < i; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1; int * lds = new int [ n ]; for ( i = 0; i < n; i ++ ) lds [ i ] = 1; for ( i = n - 2; i >= 0; i -- ) for ( j = n - 1; j > i; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1; int max = lis [ 0 ] + lds [ 0 ] - 1; for ( i = 1; i < n; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1; return max; }
int answerQuery ( int a [ ], int n, int l, int r ) { int count = 0; l = l - 1; for ( int i = l; i < r; i ++ ) { int element = a [ i ]; int divisors = 0; for ( int j = l; j < r; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++; else break; } if ( divisors == ( r - l ) ) count ++; } return count; }
string printShortestSuperSeq ( string X, string Y ) { int m = X . length ( ); int n = Y . length ( ); int dp [ m + 1 ] [ n + 1 ]; for ( int i = 0; i <= m; i ++ ) { for ( int j = 0; j <= n; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j; else if ( j == 0 ) dp [ i ] [ j ] = i; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ); } } int index = dp [ m ] [ n ]; string str; int i = m, j = n; while ( i > 0 && j > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { str . push_back ( X [ i - 1 ] ); i --, j --, index --; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str . push_back ( Y [ j - 1 ] ); j --, index --; } else { str . push_back ( X [ i - 1 ] ); i --, index --; } } while ( i > 0 ) { str . push_back ( X [ i - 1 ] ); i --, index --; } while ( j > 0 ) { str . push_back ( Y [ j - 1 ] ); j --, index --; } reverse ( str . begin ( ), str . end ( ) ); return str; }
int findSum ( string str ) { string temp = ""; int sum = 0; for ( char ch : str ) { if ( isdigit ( ch ) ) temp += ch; else { sum += atoi ( temp . c_str ( ) ); temp = ""; } } return sum + atoi ( temp . c_str ( ) ); }
int countRotationsDivBy8 ( string n ) { int len = n . length ( ); int count = 0; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0'; if ( oneDigit % 8 == 0 ) return 1; return 0; } if ( len == 2 ) { int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ); int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ); if ( first % 8 == 0 ) count ++; if ( second % 8 == 0 ) count ++; return count; } int threeDigit; for ( int i = 0; i < ( len - 2 ); i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ); if ( threeDigit % 8 == 0 ) count ++; } threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ); if ( threeDigit % 8 == 0 ) count ++; threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ); if ( threeDigit % 8 == 0 ) count ++; return count; }
bool check ( string s ) { if ( s . size ( ) >= 10 ) return true; for ( int i = 1; i < s . size ( ); i ++ ) { for ( int j = i + 1; j < s . size ( ); j ++ ) { for ( int k = j + 1; k < s . size ( ); k ++ ) { string s1 = s . substr ( 0, i ); string s2 = s . substr ( i, j - i ); string s3 = s . substr ( j, k - j ); string s4 = s . substr ( k, s . size ( ) - k ); if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true; } } } return false; }
int eggDrop ( int n, int k ) { if ( k == 1 || k == 0 ) return k; if ( n == 1 ) return k; int min = INT_MAX, x, res; for ( x = 1; x <= k; x ++ ) { res = max ( eggDrop ( n - 1, x - 1 ), eggDrop ( n, k - x ) ); if ( res < min ) min = res; } return min + 1; }
void decToBinary ( int n ) { int binaryNum [ 32 ]; int i = 0; while ( n > 0 ) { binaryNum [ i ] = n % 2; n = n / 2; i ++; } for ( int j = i - 1; j >= 0; j -- ) cout << binaryNum [ j ]; }
bool isSubsetSum ( int set [ ], int n, int sum ) { bool subset [ n + 1 ] [ sum + 1 ]; for ( int i = 0; i <= n; i ++ ) subset [ i ] [ 0 ] = true; for ( int i = 1; i <= sum; i ++ ) subset [ 0 ] [ i ] = false; for ( int i = 1; i <= n; i ++ ) { for ( int j = 1; j <= sum; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ]; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ]; } } return subset [ n ] [ sum ]; }
bool checkStar ( int mat [ ] [ size ] ) { int vertexD1 = 0, vertexDn_1 = 0; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ); if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ); for ( int i = 0; i < size; i ++ ) { int degreeI = 0; for ( int j = 0; j < size; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++; if ( degreeI == 1 ) vertexD1 ++; else if ( degreeI == size - 1 ) vertexDn_1 ++; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ); }
void sortUsingHash ( int a [ ], int n ) { int max = * std :: max_element ( a, a + n ); int hash [ max + 1 ] = { 0 }; for ( int i = 0; i < n; i ++ ) hash [ a [ i ] ] += 1; for ( int i = 0; i <= max; i ++ ) { if ( hash [ i ] ) { for ( int j = 0; j < hash [ i ]; j ++ ) { cout << i << " "; } } } }
float findArea ( float a, float b, float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { cout << "Not a valid trianglen"; exit ( 0 ); } float s = ( a + b + c ) / 2; return sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ); }
int maxDistance ( int arr [ ], int n ) { unordered_map < int, int > mp; int max_dist = 0; for ( int i = 0; i < n; i ++ ) { if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = i; else max_dist = max ( max_dist, i - mp [ arr [ i ] ] ); } return max_dist; }
INT_MAX int minCost ( int cost [ ] [ N ] ) { int dist [ N ]; for ( int i = 0; i < N; i ++ ) dist [ i ] = INF; dist [ 0 ] = 0; for ( int i = 0; i < N; i ++ ) for ( int j = i + 1; j < N; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ]; return dist [ N - 1 ]; }
int countSub ( int arr [ ], int n ) { int count [ 10 ] = { 0 }; for ( int i = 0; i < n; i ++ ) { for ( int j = arr [ i ] - 1; j >= 0; j -- ) count [ arr [ i ] ] += count [ j ]; count [ arr [ i ] ] ++; } int result = 0; for ( int i = 0; i < 10; i ++ ) result += count [ i ]; return result; }
void printPascal ( int n ) { for ( int line = 1; line <= n; line ++ ) { int C = 1; for ( int i = 1; i <= line; i ++ ) { cout << C << " "; C = C * ( line - i ) / i; } cout << "\n"; } }
int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ); }
void checkCollision ( int a, int b, int c, int x, int y, int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ); if ( radius == dist ) cout << "Touch" << endl; else if ( radius > dist ) cout << "Intersect" << endl; else cout << "Outside" << endl; }
int numofAP ( int a [ ], int n ) { int minarr = INT_MAX, maxarr = INT_MIN; for ( int i = 0; i < n; i ++ ) { minarr = min ( minarr, a [ i ] ); maxarr = max ( maxarr, a [ i ] ); } int dp [ n ], sum [ MAX ]; int ans = n + 1; for ( int d = ( minarr - maxarr ); d <= ( maxarr - minarr ); d ++ ) { memset ( sum, 0, sizeof sum ); for ( int i = 0; i < n; i ++ ) { dp [ i ] = 1; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ]; ans += dp [ i ] - 1; sum [ a [ i ] ] += dp [ i ]; } } return ans; }
int MinOperation ( int a [ ], int b [ ], int n ) { sort ( a, a + n ); sort ( b, b + n ); int result = 0; for ( int i = 0; i < n; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ); } return result; }
int sumOfSeries ( int n ) { return 0.6172 * ( pow ( 10, n ) - 1 ) - 0.55 * n; }
void recursiveReverse ( string & str, int i = 0 ) { int n = str . length ( ); if ( i == n / 2 ) return; swap ( str [ i ], str [ n - i - 1 ] ); recursiveReverse ( str, i + 1 ); }
int countOccurrences ( int arr [ ], int n, int x ) { int res = 0; for ( int i = 0; i < n; i ++ ) if ( x == arr [ i ] ) res ++; return res; }
int kthNonRepeating ( string str, int k ) { int n = str . length ( ); int count [ MAX_CHAR ]; int index [ MAX_CHAR ]; for ( int i = 0; i < MAX_CHAR; i ++ ) { count [ i ] = 0; index [ i ] = n; } for ( int i = 0; i < n; i ++ ) { char x = str [ i ]; ++ count [ x ]; if ( count [ x ] == 1 ) index [ x ] = i; if ( count [ x ] == 2 ) index [ x ] = n; } sort ( index, index + MAX_CHAR ); return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1; }
bool check ( int degree [ ], int n ) { int deg_sum = 0; for ( int i = 0; i < n; i ++ ) deg_sum += degree [ i ]; return ( 2 * ( n - 1 ) == deg_sum ); }
int bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ); }
int superSeq ( char * X, char * Y, int m, int n ) { if ( ! m ) return n; if ( ! n ) return m; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X, Y, m - 1, n - 1 ); return 1 + min ( superSeq ( X, Y, m - 1, n ), superSeq ( X, Y, m, n - 1 ) ); }
int lis ( int arr [ ], int n ) { int max = 1; _lis ( arr, n, & max ); return max; }
bool findTriplet ( int a1 [ ], int a2 [ ], int a3 [ ], int n1, int n2, int n3, int sum ) { unordered_set < int > s; for ( int i = 0; i < n1; i ++ ) s . insert ( a1 [ i ] ); for ( int i = 0; i < n2; i ++ ) { for ( int j = 0; j < n3; j ++ ) { if ( s . find ( sum - a2 [ i ] - a3 [ j ] ) != s . end ( ) ) return true; } } return false; }
int maxLen ( int arr [ ], int n ) { unordered_map < int, int > hM; int sum = 0; int max_len = 0; int ending_index = - 1; for ( int i = 0; i < n; i ++ ) arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1; for ( int i = 0; i < n; i ++ ) { sum += arr [ i ]; if ( sum == 0 ) { max_len = i + 1; ending_index = i; } if ( hM . find ( sum + n ) != hM . end ( ) ) { if ( max_len < i - hM [ sum + n ] ) { max_len = i - hM [ sum + n ]; ending_index = i; } } else hM [ sum + n ] = i; } for ( int i = 0; i < n; i ++ ) arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1; printf ( "%d to %d\n", ending_index - max_len + 1, ending_index ); return max_len; }
int SumOfKsubArray ( int arr [ ], int n, int k ) { int sum = 0; deque < int > S ( k ), G ( k ); int i = 0; for ( i = 0; i < k; i ++ ) { while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ); while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ); G . push_back ( i ); S . push_back ( i ); } for (; i < n; i ++ ) { sum += arr [ S . front ( ) ] + arr [ G . front ( ) ]; while ( ! S . empty ( ) && S . front ( ) <= i - k ) S . pop_front ( ); while ( ! G . empty ( ) && G . front ( ) <= i - k ) G . pop_front ( ); while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ); while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ); G . push_back ( i ); S . push_back ( i ); } sum += arr [ S . front ( ) ] + arr [ G . front ( ) ]; return sum; }
void sortString ( string & str ) { sort ( str . begin ( ), str . end ( ) ); cout << str; }
void ReversespiralPrint ( int m, int n, int a [ R ] [ C ] ) { long int b [ 100 ]; int i, k = 0, l = 0; int z = 0; int size = m * n; while ( k < m && l < n ) { int val; for ( i = l; i < n; ++ i ) { val = a [ k ] [ i ]; b [ z ] = val; ++ z; } k ++; for ( i = k; i < m; ++ i ) { val = a [ i ] [ n - 1 ]; b [ z ] = val; ++ z; } n --; if ( k < m ) { for ( i = n - 1; i >= l; -- i ) { val = a [ m - 1 ] [ i ]; b [ z ] = val; ++ z; } m --; } if ( l < n ) { for ( i = m - 1; i >= k; -- i ) { val = a [ i ] [ l ]; b [ z ] = val; ++ z; } l ++; } } for ( int i = size - 1; i >= 0; -- i ) { cout << b [ i ] << " "; } }
int maxSumSubarrayRemovingOneEle ( int arr [ ], int n ) { int fw [ n ], bw [ n ]; int cur_max = arr [ 0 ], max_so_far = arr [ 0 ]; fw [ 0 ] = arr [ 0 ]; for ( int i = 1; i < n; i ++ ) { cur_max = max ( arr [ i ], cur_max + arr [ i ] ); max_so_far = max ( max_so_far, cur_max ); fw [ i ] = cur_max; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2; i >= 0; i -- ) { cur_max = max ( arr [ i ], cur_max + arr [ i ] ); max_so_far = max ( max_so_far, cur_max ); bw [ i ] = cur_max; } int fans = max_so_far; for ( int i = 1; i < n - 1; i ++ ) fans = max ( fans, fw [ i - 1 ] + bw [ i + 1 ] ); return fans; }
int linearSearch ( int arr [ ], int n ) { int i; for ( i = 0; i < n; i ++ ) { if ( arr [ i ] == i ) return i; } return - 1; }
bool isSubset ( int arr1 [ ], int arr2 [ ], int m, int n ) { int i = 0; int j = 0; for ( i = 0; i < n; i ++ ) { for ( j = 0; j < m; j ++ ) { if ( arr2 [ i ] == arr1 [ j ] ) break; } if ( j == m ) return 0; } return 1; }
int findSmallestDifference ( int A [ ], int B [ ], int m, int n ) { sort ( A, A + m ); sort ( B, B + n ); int a = 0, b = 0; int result = INT_MAX; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ); if ( A [ a ] < B [ b ] ) a ++; else b ++; } return result; }
int equilibrium ( int arr [ ], int n ) { int sum = 0; int leftsum = 0; for ( int i = 0; i < n; ++ i ) sum += arr [ i ]; for ( int i = 0; i < n; ++ i ) { sum -= arr [ i ]; if ( leftsum == sum ) return i; leftsum += arr [ i ]; } return - 1; }
void sequence ( int n ) { int f [ n + 1 ]; f [ 0 ] = 0; f [ 1 ] = 1; f [ 2 ] = 1; cout << f [ 1 ] << " " << f [ 2 ] << " "; for ( int i = 3; i <= n; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]; cout << f [ i ] << " "; } }
int eggDrop ( int n, int k ) { int eggFloor [ n + 1 ] [ k + 1 ]; int res; int i, j, x; for ( i = 1; i <= n; i ++ ) { eggFloor [ i ] [ 1 ] = 1; eggFloor [ i ] [ 0 ] = 0; } for ( j = 1; j <= k; j ++ ) eggFloor [ 1 ] [ j ] = j; for ( i = 2; i <= n; i ++ ) { for ( j = 2; j <= k; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX; for ( x = 1; x <= j; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ], eggFloor [ i ] [ j - x ] ); if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res; } } } return eggFloor [ n ] [ k ]; }
int findgroups ( int arr [ ], int n ) { int c [ 3 ] = { 0 }, i; int res = 0; for ( i = 0; i < n; i ++ ) c [ arr [ i ] % 3 ] ++; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ); res += c [ 1 ] * c [ 2 ]; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ); res += c [ 0 ] * c [ 1 ] * c [ 2 ]; return res; }
int minRevolutions ( double r, int x1, int y1, int x2, int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ); return ceil ( d / ( 2 * r ) ); }
int findLargestd ( int S [ ], int n ) { bool found = false; sort ( S, S + n ); for ( int i = n - 1; i >= 0; i -- ) { for ( int j = 0; j < n; j ++ ) { if ( i == j ) continue; for ( int k = j + 1; k < n; k ++ ) { if ( i == k ) continue; for ( int l = k + 1; l < n; l ++ ) { if ( i == l ) continue; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true; return S [ i ]; } } } } } if ( found == false ) return INT_MIN; }
long long int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24; }
int subArraySum ( int arr [ ], int n, int sum ) { int curr_sum = arr [ 0 ], start = 0, i; for ( i = 1; i <= n; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ]; start ++; } if ( curr_sum == sum ) { cout << "Sum found between indexes " << start << " and " << i - 1; return 1; } if ( i < n ) curr_sum = curr_sum + arr [ i ]; } cout << "No subarray found"; return 0; }
bool isNumber ( string s ) { for ( int i = 0; i < s . length ( ); i ++ ) if ( isdigit ( s [ i ] ) == false ) return false; return true; }
int minStringValue ( string str, int k ) { int l = str . length ( ); if ( k >= l ) return 0; int frequency [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < l; i ++ ) frequency [ str [ i ] - 'a' ] ++; priority_queue < int > q; for ( int i = 0; i < MAX_CHAR; i ++ ) q . push ( frequency [ i ] ); while ( k -- ) { int temp = q . top ( ); q . pop ( ); temp = temp - 1; q . push ( temp ); } int result = 0; while ( ! q . empty ( ) ) { int temp = q . top ( ); result += temp * temp; q . pop ( ); } return result; }
int productSubSeqCount ( vector < int > & arr, int k ) { int n = arr . size ( ); int dp [ k + 1 ] [ n + 1 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 1; i <= k; i ++ ) { for ( int j = 1; j <= n; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) dp [ i ] [ j ] += dp [ i / arr [ j - 1 ] ] [ j - 1 ] + 1; } } return dp [ k ] [ n ]; }
bool isDiagonalMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0; i < N; i ++ ) for ( int j = 0; j < N; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false; return true; }
int nobleInteger ( int arr [ ], int n ) { sort ( arr, arr + n ); for ( int i = 0; i < n - 1; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue; if ( arr [ i ] == n - i - 1 ) return arr [ i ]; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ]; return - 1; }
int findElement ( int arr [ ], int n, int key ) { int i; for ( i = 0; i < n; i ++ ) if ( arr [ i ] == key ) return i; return - 1; }
ll lis ( ll arr [ ], ll n ) { ll mpis [ n ]; for ( int i = 0; i < n; i ++ ) mpis [ i ] = arr [ i ]; for ( int i = 1; i < n; i ++ ) for ( int j = 0; j < i; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ]; return * max_element ( mpis, mpis + n ); }
int sumEqualProduct ( int a [ ], int n ) { int zero = 0, two = 0; for ( int i = 0; i < n; i ++ ) { if ( a [ i ] == 0 ) { zero ++; } if ( a [ i ] == 2 ) { two ++; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2; return cnt; }
unsigned int fact ( unsigned int n ) { if ( n == 0 ) return 1; return n * fact ( n - 1 ); }
string decimalToBinary ( double num, int k_prec ) { string binary = ""; int Integral = num; double fractional = num - Integral; while ( Integral ) { int rem = Integral % 2; binary . push_back ( rem + '0' ); Integral /= 2; } reverse ( binary . begin ( ), binary . end ( ) ); binary . push_back ( '.' ); while ( k_prec -- ) { fractional *= 2; int fract_bit = fractional; if ( fract_bit == 1 ) { fractional -= fract_bit; binary . push_back ( 1 + '0' ); } else binary . push_back ( 0 + '0' ); } return binary; }
int getLevenstein ( string const & input ) { string revInput ( input . rbegin ( ), input . rend ( ) ); int n = input . size ( ); vector < vector < int > > dp ( n + 1, vector < int > ( n + 1, - 1 ) ); for ( int i = 0; i <= n; ++ i ) { dp [ 0 ] [ i ] = i; dp [ i ] [ 0 ] = i; } for ( int i = 1; i <= n; ++ i ) { for ( int j = 1; j <= n; ++ j ) { if ( input [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = 1 + min ( { dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] } ); } } int res = numeric_limits < int > :: max ( ); for ( int i = n, j = 0; i >= 0; -- i, ++ j ) { res = min ( res, dp [ i ] [ j ] ); if ( i < n ) res = min ( res, dp [ i + 1 ] [ j ] ); if ( i > 0 ) res = min ( res, dp [ i - 1 ] [ j ] ); } return res; }
unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1; return n * factorial ( n - 1 ); }
void bresenham ( int x1, int y1, int x2, int y2 ) { int m_new = 2 * ( y2 - y1 ); int slope_error_new = m_new - ( x2 - x1 ); for ( int x = x1, y = y1; x <= x2; x ++ ) { cout << "(" << x << "," << y << ")\n"; slope_error_new += m_new; if ( slope_error_new >= 0 ) { y ++; slope_error_new -= 2 * ( x2 - x1 ); } } }
void printUnsorted ( int arr [ ], int n ) { int s = 0, e = n - 1, i, max, min; for ( s = 0; s < n - 1; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break; } if ( s == n - 1 ) { cout << "The complete array is sorted"; return; } for ( e = n - 1; e > 0; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break; } max = arr [ s ]; min = arr [ s ]; for ( i = s + 1; i <= e; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ]; if ( arr [ i ] < min ) min = arr [ i ]; } for ( i = 0; i < s; i ++ ) { if ( arr [ i ] > min ) { s = i; break; } } for ( i = n - 1; i >= e + 1; i -- ) { if ( arr [ i ] < max ) { e = i; break; } } cout << "The unsorted subarray which" << " makes the given array" << endl << "sorted lies between the indees " << s << " and " << e; return; }
void find_max ( int A [ ], int N, int K ) { map < int, int > Count; for ( int i = 0; i < K - 1; i ++ ) Count [ A [ i ] ] ++; set < int > Myset; for ( auto x : Count ) if ( x . second == 1 ) Myset . insert ( x . first ); for ( int i = K - 1; i < N; i ++ ) { Count [ A [ i ] ] ++; if ( Count [ A [ i ] ] == 1 ) Myset . insert ( A [ i ] ); else Myset . erase ( A [ i ] ); if ( Myset . size ( ) == 0 ) printf ( "Nothing\n" ); else printf ( "%d\n", * Myset . rbegin ( ) ); int x = A [ i - K + 1 ]; Count [ x ] --; if ( Count [ x ] == 1 ) Myset . insert ( x ); if ( Count [ x ] == 0 ) Myset . erase ( x ); } }
void segregateElements ( int arr [ ], int n ) { int temp [ n ]; int j = 0; for ( int i = 0; i < n; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ]; if ( j == n || j == 0 ) return; for ( int i = 0; i < n; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ]; memcpy ( arr, temp, sizeof ( temp ) ); }
void KMaxCombinations ( int A [ ], int B [ ], int N, int K ) { priority_queue < int > pq; for ( int i = 0; i < N; i ++ ) for ( int j = 0; j < N; j ++ ) pq . push ( A [ i ] + B [ j ] ); int count = 0; while ( count < K ) { cout << pq . top ( ) << endl; pq . pop ( ); count ++; } }
int lenghtOfLongestAP ( int set [ ], int n ) { if ( n <= 2 ) return n; int L [ n ] [ n ]; int llap = 2; for ( int i = 0; i < n; i ++ ) L [ i ] [ n - 1 ] = 2; for ( int j = n - 2; j >= 1; j -- ) { int i = j - 1, k = j + 1; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2, i --; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1; llap = max ( llap, L [ i ] [ j ] ); i --; k ++; } } while ( i >= 0 ) { L [ i ] [ j ] = 2; i --; } } return llap; }
void prefixSum2D ( int a [ ] [ C ] ) { int psa [ R ] [ C ]; psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ]; for ( int i = 1; i < C; i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ]; for ( int i = 0; i < R; i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ]; for ( int i = 1; i < R; i ++ ) { for ( int j = 1; j < C; j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ]; } for ( int i = 0; i < R; i ++ ) { for ( int j = 0; j < C; j ++ ) cout << psa [ i ] [ j ] << " "; cout << "\n"; } }
int round ( int n ) { int a = ( n / 10 ) * 10; int b = a + 10; return ( n - a > b - n ) ? b : a; }
int getMinSquares ( int n ) { int * dp = new int [ n + 1 ]; dp [ 0 ] = 0; dp [ 1 ] = 1; dp [ 2 ] = 2; dp [ 3 ] = 3; for ( int i = 4; i <= n; i ++ ) { dp [ i ] = i; for ( int x = 1; x <= ceil ( sqrt ( i ) ); x ++ ) { int temp = x * x; if ( temp > i ) break; else dp [ i ] = min ( dp [ i ], 1 + dp [ i - temp ] ); } } int res = dp [ n ]; delete [ ] dp; return res; }
string noAdjacentDup ( string s ) { int n = s . length ( ); for ( int i = 1; i < n; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = 'a'; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++; i ++; } } return s; }
void printDistinct ( int arr [ ], int n ) { for ( int i = 0; i < n; i ++ ) { int j; for ( j = 0; j < i; j ++ ) if ( arr [ i ] == arr [ j ] ) break; if ( i == j ) cout << arr [ i ] << " "; } }
int rectCount ( int n, int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4; }
void greatest ( string s ) { int n = s . length ( ); int a [ n ]; int sum = 0; for ( int i = 0; i < n; i ++ ) { a [ i ] = s [ i ] - '0'; sum += a [ i ]; } if ( a [ n - 1 ] % 2 ) { if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) { cout << "-1" << endl; } else { cout << n << endl; } } else { int re = sum % 3; int del = - 1; int flag = 0; for ( int i = 0; i < n - 1; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i; flag = 1; break; } else { del = i; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) del = n - 1; } if ( del == - 1 ) cout << - 1 << endl; else { cout << del + 1 << endl; } } }
int maximumSum ( int arr [ ], int n, int k ) { for ( int i = 1; i <= k; i ++ ) { int min = INT_MAX; int index = - 1; for ( int j = 0; j < n; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ]; index = j; } } if ( min == 0 ) break; arr [ index ] = - arr [ index ]; } int sum = 0; for ( int i = 0; i < n; i ++ ) sum += arr [ i ]; return sum; }
pair < double, double > mirrorImage ( double a, double b, double c, double x1, double y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ); double x = temp * a + x1; double y = temp * b + y1; return make_pair ( x, y ); }
void firstFit ( int blockSize [ ], int m, int processSize [ ], int n ) { int allocation [ n ]; memset ( allocation, - 1, sizeof ( allocation ) ); for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < m; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j; blockSize [ j ] -= processSize [ i ]; break; } } } cout << "\nProcess No.\tProcess Size\tBlock no.\n"; for ( int i = 0; i < n; i ++ ) { cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\t\t"; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1; else cout << "Not Allocated"; cout << endl; } }
char * simplify ( string str ) { int len = str . length ( ); char * res = new char ( len ); int index = 0, i = 0; stack < int > s; s . push ( 0 ); while ( i < len ) { if ( str [ i ] == '+' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = '-'; if ( s . top ( ) == 0 ) res [ index ++ ] = '+'; } else if ( str [ i ] == '-' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = '+'; else if ( s . top ( ) == 0 ) res [ index ++ ] = '-'; } else if ( str [ i ] == '(' && i > 0 ) { if ( str [ i - 1 ] == '-' ) { int x = ( s . top ( ) == 1 ) ? 0 : 1; s . push ( x ); } else if ( str [ i - 1 ] == '+' ) s . push ( s . top ( ) ); } else if ( str [ i ] == ')' ) s . pop ( ); else res [ index ++ ] = str [ i ]; i ++; } return res; }
int maximumZeros ( int * arr, int n, int k ) { int subset [ k + 1 ] [ MAX5 + 5 ]; memset ( subset, - 1, sizeof ( subset ) ); subset [ 0 ] [ 0 ] = 0; for ( int p = 0; p < n; p ++ ) { int pw2 = 0, pw5 = 0; while ( arr [ p ] % 2 == 0 ) { pw2 ++; arr [ p ] /= 2; } while ( arr [ p ] % 5 == 0 ) { pw5 ++; arr [ p ] /= 5; } for ( int i = k - 1; i >= 0; i -- ) for ( int j = 0; j < MAX5; j ++ ) if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ], subset [ i ] [ j ] + pw2 ); } int ans = 0; for ( int i = 0; i < MAX5; i ++ ) ans = max ( ans, min ( i, subset [ k ] [ i ] ) ); return ans; }
int minDist ( int arr [ ], int n, int x, int y ) { int i, j; int min_dist = INT_MAX; for ( i = 0; i < n; i ++ ) { for ( j = i + 1; j < n; j ++ ) { if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > abs ( i - j ) ) { min_dist = abs ( i - j ); } } } return min_dist; }
make_pair push_back int solve ( int A [ ], int n ) { int i, cnt = 0, j; int parent [ n + 1 ]; int vis [ n + 1 ]; memset ( parent, - 1, sizeof ( parent ) ); memset ( vis, 0, sizeof ( vis ) ); for ( i = 0; i < n; i ++ ) { j = i; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i; j = ( j + A [ j ] + 1 ) % n; } if ( parent [ j ] == i ) { while ( ! vis [ j ] ) { vis [ j ] = 1; cnt ++; j = ( j + A [ j ] + 1 ) % n; } } } } return cnt; }
int leonardo ( int n ) { int dp [ n + 1 ]; dp [ 0 ] = dp [ 1 ] = 1; for ( int i = 2; i <= n; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1; return dp [ n ]; }
int Circumference ( int a ) { return 4 * a; }
int policeThief ( char arr [ ], int n, int k ) { int res = 0; vector < int > thi; vector < int > pol; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] == 'P' ) pol . push_back ( i ); else if ( arr [ i ] == 'T' ) thi . push_back ( i ); } int l = 0, r = 0; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( abs ( thi [ l ] - pol [ r ] ) <= k ) { res ++; l ++; r ++; } else if ( thi [ l ] < pol [ r ] ) l ++; else r ++; } return res; }
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side, 3 ) ) ); }
int count9s ( char number [ ] ) { int n = strlen ( number ); int d [ 9 ]; memset ( d, 0, sizeof ( d ) ); d [ 0 ] = 1; int result = 0; int mod_sum = 0, continuous_zero = 0; for ( int i = 0; i < n; i ++ ) { if ( ! int ( number [ i ] - '0' ) ) continuous_zero ++; else continuous_zero = 0; mod_sum += int ( number [ i ] - '0' ); mod_sum %= 9; result += d [ mod_sum ]; d [ mod_sum ] ++; result -= continuous_zero; } return result; }
int countDigits ( int a, int b ) { int count = 0; int p = abs ( a * b ); if ( p == 0 ) return 1; while ( p > 0 ) { count ++; p = p / 10; } return count; }
double maxArea ( double a, double b, double c, double d ) { double semiperimeter = ( a + b + c + d ) / 2; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ); }
bool prevPermutation ( string & str ) { int n = str . length ( ) - 1; int i = n; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) i --; if ( i <= 0 ) return false; int j = i - 1; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++; swap ( str [ i - 1 ], str [ j ] ); reverse ( str . begin ( ) + i, str . end ( ) ); return true; }
int longOddEvenIncSeq ( int arr [ ], int n ) { int lioes [ n ]; int maxLen = 0; for ( int i = 0; i < n; i ++ ) lioes [ i ] = 1; for ( int i = 1; i < n; i ++ ) for ( int j = 0; j < i; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1; for ( int i = 0; i < n; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ]; return maxLen; }
int countPaths ( int maze [ ] [ C ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0; for ( int i = 0; i < R; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1; else break; } for ( int i = 1; i < C; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1; else break; } for ( int i = 1; i < R; i ++ ) { for ( int j = 1; j < C; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ); if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ); } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0; }
int kthLargestSum ( int arr [ ], int n, int k ) { int sum [ n + 1 ]; sum [ 0 ] = 0; sum [ 1 ] = arr [ 0 ]; for ( int i = 2; i <= n; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ]; priority_queue < int, vector < int >, greater < int > > Q; for ( int i = 1; i <= n; i ++ ) { for ( int j = i; j <= n; j ++ ) { int x = sum [ j ] - sum [ i - 1 ]; if ( Q . size ( ) < k ) Q . push ( x ); else { if ( Q . top ( ) < x ) { Q . pop ( ); Q . push ( x ); } } } } return Q . top ( ); }
int findFirstMissing ( int array [ ], int start, int end ) { if ( start > end ) return end + 1; if ( start != array [ start ] ) return start; int mid = ( start + end ) / 2; if ( array [ mid ] == mid ) return findFirstMissing ( array, mid + 1, end ); return findFirstMissing ( array, start, mid ); }
int calcAngle ( double h, double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) printf ( "Wrong input" ); if ( h == 12 ) h = 0; if ( m == 60 ) m = 0; int hour_angle = 0.5 * ( h * 60 + m ); int minute_angle = 6 * m; int angle = abs ( hour_angle - minute_angle ); angle = min ( 360 - angle, angle ); return angle; }
int findLength ( char * str ) { int n = strlen ( str ); int maxlen = 0; int sum [ n ] [ n ]; for ( int i = 0; i < n; i ++ ) sum [ i ] [ i ] = str [ i ] - '0'; for ( int len = 2; len <= n; len ++ ) { for ( int i = 0; i < n - len + 1; i ++ ) { int j = i + len - 1; int k = len / 2; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ]; if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len; } } return maxlen; }
bool isEven ( int n ) { return ( ! ( n & 1 ) ); }
int findDigits ( int n ) { if ( n < 0 ) return 0; if ( n <= 1 ) return 1; double digits = 0; for ( int i = 2; i <= n; i ++ ) digits += log10 ( i ); return floor ( digits ) + 1; }
bool isHeap ( int arr [ ], int i, int n ) { if ( i > ( n - 2 ) / 2 ) return true; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr, 2 * i + 1, n ) && isHeap ( arr, 2 * i + 2, n ) ) return true; return false; }
unsigned int doublefactorial ( unsigned int n ) { int res = 1; for ( int i = n; i >= 0; i = i - 2 ) { if ( i == 0 || i == 1 ) return res; else res *= i; } }
bool isValidISBN ( string & isbn ) { int n = isbn . length ( ); if ( n != 10 ) return false; int sum = 0; for ( int i = 0; i < 9; i ++ ) { int digit = isbn [ i ] - '0'; if ( 0 > digit || 9 < digit ) return false; sum += ( digit * ( 10 - i ) ); } char last = isbn [ 9 ]; if ( last != 'X' && ( last < '0' || last > '9' ) ) return false; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ); return ( sum % 11 == 0 ); }
uint_t snoob ( uint_t x ) { uint_t rightOne; uint_t nextHigherOneBit; uint_t rightOnesPattern; uint_t next = 0; if ( x ) { rightOne = x & - ( signed ) x; nextHigherOneBit = x + rightOne; rightOnesPattern = x ^ nextHigherOneBit; rightOnesPattern = ( rightOnesPattern ) / rightOne; rightOnesPattern >>= 2; next = nextHigherOneBit | rightOnesPattern; } return next; }
int maxDiff ( int arr [ ], int n ) { int SubsetSum_1 = 0, SubsetSum_2 = 0; for ( int i = 0; i <= n - 1; i ++ ) { bool isSingleOccurance = true; for ( int j = i + 1; j <= n - 1; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false; arr [ i ] = arr [ j ] = 0; break; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ]; else SubsetSum_2 += arr [ i ]; } } return abs ( SubsetSum_1 - SubsetSum_2 ); }
char getMaxOccuringChar ( char * str ) { int count [ ASCII_SIZE ] = { 0 }; int len = strlen ( str ); int max = 0; char result; for ( int i = 0; i < len; i ++ ) { count [ str [ i ] ] ++; if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ]; result = str [ i ]; } } return result; }
void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) cout << - 1 << endl; else { int b = ( n * n - 1 ) / 2; int c = ( n * n + 1 ) / 2; cout << "b = " << b << ", c = " << c << endl; } } else { if ( n == 2 ) cout << - 1 << endl; else { int b = n * n / 4 - 1; int c = n * n / 4 + 1; cout << "b = " << b << ", c = " << c << endl; } } }
bool isPowerOfK ( unsigned int n, unsigned int k ) { bool oneSeen = false; while ( n > 0 ) { int digit = n % k; if ( digit > 1 ) return false; if ( digit == 1 ) { if ( oneSeen ) return false; oneSeen = true; } n /= k; } return true; }
int printUnion ( int arr1 [ ], int arr2 [ ], int m, int n ) { int i = 0, j = 0; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) cout << arr1 [ i ++ ] << " "; else if ( arr2 [ j ] < arr1 [ i ] ) cout << arr2 [ j ++ ] << " "; else { cout << arr2 [ j ++ ] << " "; i ++; } } while ( i < m ) cout << arr1 [ i ++ ] << " "; while ( j < n ) cout << arr2 [ j ++ ] << " "; }
void spiralFill ( int m, int n, int a [ ] [ MAX ] ) { int val = 1; int k = 0, l = 0; while ( k < m && l < n ) { for ( int i = l; i < n; ++ i ) a [ k ] [ i ] = val ++; k ++; for ( int i = k; i < m; ++ i ) a [ i ] [ n - 1 ] = val ++; n --; if ( k < m ) { for ( int i = n - 1; i >= l; -- i ) a [ m - 1 ] [ i ] = val ++; m --; } if ( l < n ) { for ( int i = m - 1; i >= k; -- i ) a [ i ] [ l ] = val ++; l ++; } } }
float exponential ( int n, float x ) { float sum = 1.0f; for ( int i = n - 1; i > 0; -- i ) sum = 1 + x * sum / i; return sum; }
void diagonalsquare ( int mat [ ] [ MAX ], int row, int column ) { cout << " \nDiagonal one : "; for ( int i = 0; i < row; i ++ ) { cout << mat [ i ] [ i ] * mat [ i ] [ i ] << " "; } cout << " \n\nDiagonal two : "; for ( int i = 0; i < row; i ++ ) { cout << mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] << " "; } }
void reorder ( int arr [ ], int index [ ], int n ) { for ( int i = 0; i < n; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ]; char oldTargetE = arr [ index [ i ] ]; arr [ index [ i ] ] = arr [ i ]; index [ index [ i ] ] = index [ i ]; index [ i ] = oldTargetI; arr [ i ] = oldTargetE; } } }
bool isSubSeqDivisible ( string str ) { int n = str . length ( ); int dp [ n + 1 ] [ 10 ]; memset ( dp, 0, sizeof ( dp ) ); int arr [ n + 1 ]; for ( int i = 1; i <= n; i ++ ) arr [ i ] = str [ i - 1 ] - '0'; for ( int i = 1; i <= n; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1; for ( int j = 0; j < 8; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ]; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ]; } } for ( int i = 1; i <= n; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true; } return false; }
bool isRotated ( string str1, string str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false; string clock_rot = ""; string anticlock_rot = ""; int len = str2 . length ( ); anticlock_rot = anticlock_rot + str2 . substr ( len - 2, 2 ) + str2 . substr ( 0, len - 2 ); clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr ( 0, 2 ); return ( str1 . compare ( clock_rot ) == 0 || str1 . compare ( anticlock_rot ) == 0 ); }
void translate ( char * str ) { if ( str [ 0 ] == '' ) return; for ( int i = 1; str [ i ] != ''; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C'; for ( int j = i; str [ j ] != ''; j ++ ) str [ j ] = str [ j + 1 ]; } } return; }
int optimalStrategyOfGame ( int * arr, int n ) { int table [ n ] [ n ]; for ( int gap = 0; gap < n; ++ gap ) { for ( int i = 0, j = gap; j < n; ++ i, ++ j ) { int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0; table [ i ] [ j ] = max ( arr [ i ] + min ( x, y ), arr [ j ] + min ( y, z ) ); } } return table [ 0 ] [ n - 1 ]; }
void printSeries ( int n ) { for ( int i = 1; i <= n; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6; cout << num << " "; } }
int getIndexInSortedArray ( int arr [ ], int n, int idx ) { int result = 0; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++; } return result; }
int findTrailingZeros ( int n ) { int count = 0; for ( int i = 5; n / i >= 1; i *= 5 ) count += n / i; return count; }
bool areDisjoint ( int set1 [ ], int set2 [ ], int m, int n ) { for ( int i = 0; i < m; i ++ ) for ( int j = 0; j < n; j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false; return true; }
void rearrange ( int arr [ ], int n ) { int max_idx = n - 1, min_idx = 0; int max_elem = arr [ n - 1 ] + 1; for ( int i = 0; i < n; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem; max_idx --; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem; min_idx ++; } } for ( int i = 0; i < n; i ++ ) arr [ i ] = arr [ i ] / max_elem; }
int Right_most_setbit ( int num ) { int pos = 1; for ( int i = 0; i < INT_SIZE; i ++ ) { if ( ! ( num & ( 1 << i ) ) ) pos ++; else break; } return pos; }
int maxRemoval ( int arr [ ], int n ) { int count = 0; int cummulative_sum = 0; sort ( arr, arr + n ); for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] >= cummulative_sum ) { count ++; cummulative_sum += arr [ i ]; } } return count; }
int sumBetweenTwoKth ( int arr [ ], int n, int k1, int k2 ) { sort ( arr, arr + n ); return accumulate ( arr + k1, arr + k2 - 1, 0 ); }
int maximumNumberDistinctPrimeRange ( int m, int n ) { long long factorCount [ n + 1 ]; bool prime [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) { factorCount [ i ] = 0; prime [ i ] = true; } for ( int i = 2; i <= n; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1; for ( int j = i * 2; j <= n; j += i ) { factorCount [ j ] ++; prime [ j ] = false; } } } int max = factorCount [ m ]; int num = m; for ( int i = m; i <= n; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ]; num = i; } } return num; }
int count ( char s [ ], int len ) { int cur = 0, dig = 0; int sum [ MAX ], dp [ MAX ] [ 3 ]; memset ( sum, 0, sizeof ( sum ) ); memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] [ 0 ] = 1; for ( int i = 1; i <= len; i ++ ) { dig = int ( s [ i - 1 ] ) - 48; cur += dig; cur %= 3; sum [ i ] = cur; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ]; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ]; dp [ i ] [ sum [ i ] ] ++; } int ans = 0, dprev = 0, value = 0, dprev2 = 0; for ( int i = 1; i <= len; i ++ ) { dig = int ( s [ i - 1 ] ) - 48; if ( dig == 8 ) ans ++; if ( i - 2 >= 0 ) { dprev = int ( s [ i - 2 ] ) - 48; value = dprev * 10 + dig; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++; } if ( i - 3 >= 0 ) { dprev2 = int ( s [ i - 3 ] ) - 48; dprev = int ( s [ i - 2 ] ) - 48; value = dprev2 * 100 + dprev * 10 + dig; if ( value % 8 != 0 ) continue; ans += ( i - 2 ); ans -= ( dp [ i - 3 ] [ sum [ i ] ] ); } } return ans; }
void relativeComplement ( int arr1 [ ], int arr2 [ ], int n, int m ) { int i = 0, j = 0; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ] << " "; i ++; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++; j ++; } } while ( i < n ) cout << arr1 [ i ] << " "; }
int MaxSumDifference ( int a [ ], int n ) { vector < int > finalSequence; sort ( a, a + n ); for ( int i = 0; i < n / 2; ++ i ) { finalSequence . push_back ( a [ i ] ); finalSequence . push_back ( a [ n - i - 1 ] ); } int MaximumSum = 0; for ( int i = 0; i < n - 1; ++ i ) { MaximumSum = MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ); } MaximumSum = MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ); return MaximumSum; }
unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0; if ( 0 == num ) return num_to_bits [ 0 ]; nibble = num & 0xf; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ); }
int minCells ( int mat [ SIZE ] [ SIZE ], int m, int n ) { int dp [ m ] [ n ]; for ( int i = 0; i < m; i ++ ) for ( int j = 0; j < n; j ++ ) dp [ i ] [ j ] = INT_MAX; dp [ 0 ] [ 0 ] = 1; for ( int i = 0; i < m; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1; if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1; } } if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1 ] [ n - 1 ]; return - 1; }
int maxSubArraySumRepeated ( int a [ ], int n, int k ) { int max_so_far = INT_MIN, max_ending_here = 0; for ( int i = 0; i < n * k; i ++ ) { max_ending_here = max_ending_here + a [ i % n ]; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here; if ( max_ending_here < 0 ) max_ending_here = 0; } return max_so_far; }
void printkthnode ( vector < pair < int, int > > adj [ ], int wt [ ], int n, int k ) { for ( int i = 0; i < n; i ++ ) sort ( adj [ i ] . begin ( ), adj [ i ] . end ( ) ); for ( int i = 0; i < n; i ++ ) { if ( adj [ i ] . size ( ) >= k ) cout << adj [ i ] [ adj [ i ] . size ( ) - k ] . second; else cout << "-1"; } }
int maxLength ( char s [ ], int n ) { int dp [ n ] [ n ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 0; i < n - 1; i ++ ) if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i ] [ i + 1 ] = 2; for ( int l = 2; l < n; l ++ ) { for ( int i = 0, j = l; j < n; i ++, j ++ ) { if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]; for ( int k = i; k < j; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ], dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ); } } return dp [ 0 ] [ n - 1 ]; }
int minXOR ( int arr [ ], int n ) { int min_xor = INT_MAX; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) min_xor = min ( min_xor, arr [ i ] ^ arr [ j ] ); return min_xor; }
void add ( int A [ ] [ N ], int B [ ] [ N ], int C [ ] [ N ] ) { int i, j; for ( i = 0; i < N; i ++ ) for ( j = 0; j < N; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]; }
void solve ( int n, int t, string s ) { for ( int i = 0; i < t; i ++ ) for ( int j = 0; j < n - 1; j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) { char temp = s [ j ]; s [ j ] = s [ j + 1 ]; s [ j + 1 ] = temp; j ++; } cout << s; }
int PositionRightmostSetbit ( int n ) { int position = 1; int m = 1; while ( ! ( n & m ) ) { m = m << 1; position ++; } return position; }
int countSolutions ( int n ) { int x = 0, yCount, res = 0; for ( yCount = 0; yCount * yCount < n; yCount ++ ); while ( yCount != 0 ) { res += yCount; x ++; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount --; } return res; }
int largest ( int arr [ ], int n ) { int i; int max = arr [ 0 ]; for ( i = 1; i < n; i ++ ) if ( arr [ i ] > max ) max = arr [ i ]; return max; }
int findMinDiff ( int arr [ ], int n ) { sort ( arr, arr + n ); int diff = INT_MAX; for ( int i = 0; i < n - 1; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ]; return diff; }
void amendSentence ( string str ) { for ( int i = 0; i < str . length ( ); i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { str [ i ] = str [ i ] + 32; if ( i != 0 ) cout << " "; cout << str [ i ]; } else cout << str [ i ]; } }
float volumeOfEllipsoid ( float r1, float r2, float r3 ) { float pi = 3.14; return 1.33 * pi * r1 * r2 * r3; }
int abFree ( string s ) { int n = s . length ( ); char char_array [ n + 1 ]; strcpy ( char_array, s . c_str ( ) ); int b_count = 0; int res = 0; for ( int i = 0; i < n; i ++ ) { if ( char_array [ n - i - 1 ] == 'a' ) { res = ( res + b_count ); b_count = ( b_count * 2 ); } else { b_count += 1; } } return res; }
int findLastIndex ( string & str, char x ) { for ( int i = str . length ( ) - 1; i >= 0; i -- ) if ( str [ i ] == x ) return i; return - 1; }
int lcs ( char * X, char * Y, int m, int n ) { if ( m == 0 || n == 0 ) return 0; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X, Y, m - 1, n - 1 ); else return max ( lcs ( X, Y, m, n - 1 ), lcs ( X, Y, m - 1, n ) ); }
int minSwaps ( int arr [ ], int n ) { pair < int, int > arrPos [ n ]; for ( int i = 0; i < n; i ++ ) { arrPos [ i ] . first = arr [ i ]; arrPos [ i ] . second = i; } sort ( arrPos, arrPos + n ); vector < bool > vis ( n, false ); int ans = 0; for ( int i = 0; i < n; i ++ ) { if ( vis [ i ] || arrPos [ i ] . second == i ) continue; int cycle_size = 0; int j = i; while ( ! vis [ j ] ) { vis [ j ] = 1; j = arrPos [ j ] . second; cycle_size ++; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ); } } return ans; }
int countSetBits ( int n ) { if ( n == 0 ) return 0; else return 1 + countSetBits ( n & ( n - 1 ) ); }
int findLastIndex ( string & str, char x ) { int index = - 1; for ( int i = 0; i < str . length ( ); i ++ ) if ( str [ i ] == x ) index = i; return index; }
int count ( string s, char c ) { int res = 0; for ( int i = 0; i < s . length ( ); i ++ ) if ( s [ i ] == c ) res ++; return res; }
void minRange ( int arr [ ], int n, int k ) { int l = 0, r = n; for ( int i = 0; i < n; i ++ ) { unordered_set < int > s; int j; for ( j = i; j < n; j ++ ) { s . insert ( arr [ j ] ); if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j; l = i; } break; } } if ( j == n ) break; } if ( l == 0 && r == n ) cout << "Invalid k"; else cout << l << " " << r; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1; if ( n && ! ( n & ( n - 1 ) ) ) return n; while ( p < n ) p <<= 1; return p; }
bool isIdentity ( int mat [ ] [ MAX ], int N ) { for ( int row = 0; row < N; row ++ ) { for ( int col = 0; col < N; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false; else if ( row != col && mat [ row ] [ col ] != 0 ) return false; } } return true; }
double cosXSertiesSum ( double x, int n ) { x = x * ( PI / 180.0 ); double res = 1; double sign = 1, fact = 1, pow = 1; for ( int i = 1; i < 5; i ++ ) { sign = sign * - 1; fact = fact * ( 2 * i - 1 ) * ( 2 * i ); pow = pow * x * x; res = res + sign * pow / fact; } return res; }
int getNumStrictMonotone ( int len ) { int DP [ len ] [ DP_s ]; memset ( DP, 0, sizeof ( DP ) ); for ( int i = 0; i < DP_s; ++ i ) DP [ 0 ] [ i ] = i + 1; for ( int i = 1; i < len; ++ i ) for ( int j = 1; j < DP_s; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ]; return DP [ len - 1 ] [ DP_s - 1 ]; }
int countPairs ( int arr [ ], int n ) { int result = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { int product = arr [ i ] * arr [ j ]; for ( int k = 0; k < n; k ++ ) { if ( arr [ k ] == product ) { result ++; break; } } } } return result; }
int countRotations ( int arr [ ], int n ) { int min = arr [ 0 ], min_index; for ( int i = 0; i < n; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ]; min_index = i; } } return min_index; }
int fib ( int n, int a = 0, int b = 1 ) { if ( n == 0 ) return a; if ( n == 1 ) return b; return fib ( n - 1, b, a + b ); }
bool SieveOfEratosthenes ( int n, bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false; for ( int i = 2; i <= n; i ++ ) isPrime [ i ] = true; for ( int p = 2; p * p <= n; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2; i <= n; i += p ) isPrime [ i ] = false; } } }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ); printf ( "%d", n & 1 ); }
e9 int minMaxValues ( int arr [ ], int n, int m ) { int sum = 0; for ( int i = 0; i < ( n + m ); i ++ ) { sum += arr [ i ]; arr [ i ] += 50; } bool dp [ MAX + 1 ] [ MAX * MAX + 1 ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] [ 0 ] = 1; for ( int i = 0; i < ( n + m ); i ++ ) { for ( int k = min ( n, i + 1 ); k >= 1; k -- ) { for ( int j = 0; j < MAX * MAX + 1; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = 1; } } } int max_value = - INF, min_value = INF; for ( int i = 0; i < MAX * MAX + 1; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n; max_value = max ( max_value, temp * ( sum - temp ) ); min_value = min ( min_value, temp * ( sum - temp ) ); } } cout << "Maximum Value: " << max_value << "\n" << "Minimum Value: " << min_value << endl; }
void GFG :: rearrange ( int arr [ ], int n ) { int i = - 1; for ( int j = 0; j < n; j ++ ) { if ( arr [ j ] < 0 ) { i ++; swap ( & arr [ i ], & arr [ j ] ); } } int pos = i + 1, neg = 0; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { swap ( & arr [ neg ], & arr [ pos ] ); pos ++; neg += 2; } }
public : void printNos ( unsigned int n ) { if ( n > 0 ) { printNos ( n - 1 ); cout << n << " "; } return; }
void printDistance ( int mat [ N ] [ M ] ) { int ans [ N ] [ M ]; for ( int i = 0; i < N; i ++ ) for ( int j = 0; j < M; j ++ ) ans [ i ] [ j ] = INT_MAX; for ( int i = 0; i < N; i ++ ) for ( int j = 0; j < M; j ++ ) { for ( int k = 0; k < N; k ++ ) for ( int l = 0; l < M; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans [ i ] [ j ], abs ( i - k ) + abs ( j - l ) ); } } for ( int i = 0; i < N; i ++ ) { for ( int j = 0; j < M; j ++ ) cout << ans [ i ] [ j ] << " "; cout << endl; } }
void printPairs ( int arr [ ], int n ) { vector < int > v; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ); if ( v . size ( ) == 0 ) return; sort ( v . begin ( ), v . end ( ) ); for ( int i = 0; i < v . size ( ); i ++ ) cout << - v [ i ] << " " << v [ i ]; }
int findSum ( int arr [ ], int n ) { int sum = 0; unordered_set < int > s; for ( int i = 0; i < n; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { sum += arr [ i ]; s . insert ( arr [ i ] ); } } return sum; }
void alternateSubarray ( bool arr [ ], int n ) { int len [ n ]; len [ n - 1 ] = 1; for ( int i = n - 2; i >= 0; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1; else len [ i ] = 1; } for ( int i = 0; i < n; ++ i ) cout << len [ i ] << " "; }
void printSquares ( int n ) { int square = 0, prev_x = 0; for ( int x = 0; x < n; x ++ ) { square = ( square + x + prev_x ); cout << square << " "; prev_x = x; } }
int countNegative ( int M [ ] [ 4 ], int n, int m ) { int count = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < m; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1; else break; } } return count; }
int maxSubArraySum ( int a [ ], int size ) { int max_so_far = a [ 0 ]; int curr_max = a [ 0 ]; for ( int i = 1; i < size; i ++ ) { curr_max = max ( a [ i ], curr_max + a [ i ] ); max_so_far = max ( max_so_far, curr_max ); } return max_so_far; }
void maximizecube ( int l, int b, int h ) { int side = __gcd ( l, __gcd ( b, h ) ); int num = l / side; num = ( num * b / side ); num = ( num * h / side ); cout << side << " " << num << endl; }
int maxSubArraySum ( int a [ ], int size ) { int max_so_far = INT_MIN, max_ending_here = 0; for ( int i = 0; i < size; i ++ ) { max_ending_here = max_ending_here + a [ i ]; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here; if ( max_ending_here < 0 ) max_ending_here = 0; } return max_so_far; }
int calculateSum ( int n ) { if ( n <= 0 ) return 0; int fibo [ n + 1 ]; fibo [ 0 ] = 0, fibo [ 1 ] = 1; int sum = fibo [ 0 ] + fibo [ 1 ]; for ( int i = 2; i <= n; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]; sum += fibo [ i ]; } return sum; }
int findMaxAverage ( int arr [ ], int n, int k ) { if ( k > n ) return - 1; int sum = arr [ 0 ]; for ( int i = 1; i < k; i ++ ) sum += arr [ i ]; int max_sum = sum, max_end = k - 1; for ( int i = k; i < n; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ]; if ( sum > max_sum ) { max_sum = sum; max_end = i; } } return max_end - k + 1; }
void printMaxSum ( int arr [ ], int n ) { int dp [ n ]; memset ( dp, 0, sizeof dp ); for ( int i = 0; i < n; i ++ ) { dp [ i ] = arr [ i ]; int maxi = 0; for ( int j = 1; j <= sqrt ( i + 1 ); j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ]; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ]; } } dp [ i ] += maxi; } for ( int i = 0; i < n; i ++ ) cout << dp [ i ] << " "; }
int countRotations ( int arr [ ], int low, int high ) { if ( high < low ) return 0; if ( high == low ) return low; int mid = low + ( high - low ) / 2; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ); if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr, low, mid - 1 ); return countRotations ( arr, mid + 1, high ); }
int isdivisible7 ( char num [ ] ) { int n = strlen ( num ), gSum; if ( n == 0 && num [ 0 ] == '\n' ) return 1; if ( n % 3 == 1 ) { strcat ( num, "00" ); n += 2; } else if ( n % 3 == 2 ) { strcat ( num, "0" ); n ++; } int i, GSum = 0, p = 1; for ( i = n - 1; i >= 0; i -- ) { int group = 0; group += num [ i -- ] - '0'; group += ( num [ i -- ] - '0' ) * 10; group += ( num [ i ] - '0' ) * 100; gSum = gSum + group * p; p *= ( - 1 ); } return ( gSum % 7 == 0 ); }
void printStringAlternate ( string str ) { unordered_map < char, int > occ; for ( int i = 0; i < str . length ( ); i ++ ) { char temp = tolower ( str [ i ] ); occ [ temp ] ++; if ( occ [ temp ] & 1 ) cout << str [ i ]; } cout << endl; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return n * ( n + 1 ) / 2; int d = log10 ( n ); int * a = new int [ d + 1 ]; a [ 0 ] = 0, a [ 1 ] = 45; for ( int i = 2; i <= d; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10, i - 1 ) ); int p = ceil ( pow ( 10, d ) ); int msd = n / p; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ); }
unsigned long int catalan ( unsigned int n ) { if ( n <= 1 ) return 1; unsigned long int res = 0; for ( int i = 0; i < n; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ); return res; }
int evenSum ( int n ) { int C [ n + 1 ] [ n + 1 ]; int i, j; for ( i = 0; i <= n; i ++ ) { for ( j = 0; j <= min ( i, n ); j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]; } } int sum = 0; for ( int i = 0; i <= n; i += 2 ) sum += C [ n ] [ i ]; return sum; }
int getMedian ( int ar1 [ ], int ar2 [ ], int n ) { int i = 0; int j = 0; int count; int m1 = - 1, m2 = - 1; for ( count = 0; count <= n; count ++ ) { if ( i == n ) { m1 = m2; m2 = ar2 [ 0 ]; break; } else if ( j == n ) { m1 = m2; m2 = ar1 [ 0 ]; break; } if ( ar1 [ i ] < ar2 [ j ] ) { m1 = m2; m2 = ar1 [ i ]; i ++; } else { m1 = m2; m2 = ar2 [ j ]; j ++; } } return ( m1 + m2 ) / 2; }
public : int getSum ( int n ) { int sum; for ( sum = 0; n > 0; sum += n % 10, n /= 10 ); return sum; }
bool isMajority ( int a [ ], int n ) { unordered_map < int, int > mp; for ( int i = 0; i < n; i ++ ) mp [ a [ i ] ] ++; for ( auto x : mp ) if ( x . second >= n / 2 ) return true; return false; }
int minInsertion ( string str ) { int n = str . length ( ); int res = 0; int count [ 26 ] = { 0 }; for ( int i = 0; i < n; i ++ ) count [ str [ i ] - 'a' ] ++; for ( int i = 0; i < 26; i ++ ) if ( count [ i ] % 2 == 1 ) res ++; return ( res == 0 ) ? 0 : res - 1; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2; }
bool checkPangram ( string & str ) { vector < bool > mark ( 26, false ); int index; for ( int i = 0; i < str . length ( ); i ++ ) { if ( 'A' <= str [ i ] && str [ i ] <= 'Z' ) index = str [ i ] - 'A'; else if ( 'a' <= str [ i ] && str [ i ] <= 'z' ) index = str [ i ] - 'a'; mark [ index ] = true; } for ( int i = 0; i <= 25; i ++ ) if ( mark [ i ] == false ) return ( false ); return ( true ); }
long long int findSubarraySum ( int arr [ ], int n ) { int res = 0; unordered_map < int, int > m; for ( int i = 0; i < n; i ++ ) { int sum = 0; for ( int j = i; j < n; j ++ ) { sum += arr [ j ]; m [ sum ] ++; } } for ( auto x : m ) if ( x . second == 1 ) res += x . first; return res; }
int numofArray ( int n, int m ) { int dp [ MAX ] [ MAX ]; vector < int > di [ MAX ]; vector < int > mu [ MAX ]; memset ( dp, 0, sizeof dp ); memset ( di, 0, sizeof di ); memset ( mu, 0, sizeof mu ); for ( int i = 1; i <= m; i ++ ) { for ( int j = 2 * i; j <= m; j += i ) { di [ j ] . push_back ( i ); mu [ i ] . push_back ( j ); } di [ i ] . push_back ( i ); } for ( int i = 1; i <= m; i ++ ) dp [ 1 ] [ i ] = 1; for ( int i = 2; i <= n; i ++ ) { for ( int j = 1; j <= m; j ++ ) { dp [ i ] [ j ] = 0; for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ]; for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ]; } } int ans = 0; for ( int i = 1; i <= m; i ++ ) { ans += dp [ n ] [ i ]; di [ i ] . clear ( ); mu [ i ] . clear ( ); } return ans; }
int getMissingNo ( int a [ ], int n ) { int i, total = 1; for ( i = 2; i <= ( n + 1 ); i ++ ) { total += i; total -= a [ i - 2 ]; } return total; }
int getTotalNumberOfSequences ( int m, int n ) { int T [ m + 1 ] [ n + 1 ]; for ( int i = 0; i < m + 1; i ++ ) { for ( int j = 0; j < n + 1; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0; else if ( i < j ) T [ i ] [ j ] = 0; else if ( j == 1 ) T [ i ] [ j ] = i; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ]; } } return T [ m ] [ n ]; }
int kthgroupsum ( int k ) { return k * k * k; }
int middleOfThree ( int a, int b, int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a; else return c; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ); }
int countOfSubstringWithKOnes ( string s, int K ) { int N = s . length ( ); int res = 0; int countOfOne = 0; int freq [ N + 1 ] = { 0 }; freq [ 0 ] = 1; for ( int i = 0; i < N; i ++ ) { countOfOne += ( s [ i ] - '0' ); if ( countOfOne >= K ) { res += freq [ countOfOne - K ]; } freq [ countOfOne ] ++; } return res; }
long double distance ( long double lat1, long double long1, long double lat2, long double long2 ) { lat1 = toRadians ( lat1 ); long1 = toRadians ( long1 ); lat2 = toRadians ( lat2 ); long2 = toRadians ( long2 ); long double dlong = long2 - long1; long double dlat = lat2 - lat1; long double ans = pow ( sin ( dlat / 2 ), 2 ) + cos ( lat1 ) * cos ( lat2 ) * pow ( sin ( dlong / 2 ), 2 ); ans = 2 * asin ( sqrt ( ans ) ); long double R = 6371; ans = ans * R; return ans; }
int numberofways ( string A, string B, int N, int M ) { vector < int > pos [ MAX ]; for ( int i = 0; i < M; i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ); int dpl [ N + 2 ] [ M + 2 ]; memset ( dpl, 0, sizeof ( dpl ) ); for ( int i = 1; i <= N; i ++ ) { for ( int j = 1; j <= M; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1; else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ], dpl [ i ] [ j - 1 ] ); } } int LCS = dpl [ N ] [ M ]; int dpr [ N + 2 ] [ M + 2 ]; memset ( dpr, 0, sizeof ( dpr ) ); for ( int i = N; i >= 1; i -- ) { for ( int j = M; j >= 1; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1; else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ], dpr [ i ] [ j + 1 ] ); } } int ans = 0; for ( int i = 0; i <= N; i ++ ) { for ( int j = 0; j < MAX; j ++ ) { for ( auto x : pos [ j ] ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++; break; } } } } return ans; }
int maxSubArraySum ( int a [ ], int size ) { int max_so_far = INT_MIN, max_ending_here = 0, start = 0, end = 0, s = 0; for ( int i = 0; i < size; i ++ ) { max_ending_here += a [ i ]; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here; start = s; end = i; } if ( max_ending_here < 0 ) { max_ending_here = 0; s = i + 1; } } cout << "Maximum contiguous sum is " << max_so_far << endl; cout << "Starting index " << start << endl << "Ending index " << end << endl; }
int countIntegralSolutions ( int n ) { int result = 0; for ( int i = 0; i <= n; i ++ ) for ( int j = 0; j <= n - i; j ++ ) for ( int k = 0; k <= ( n - i - j ); k ++ ) if ( i + j + k == n ) result ++; return result; }
int findCount ( string str ) { int result = 0; for ( int i = 0; i < str . size ( ); i ++ ) if ( i == ( str [ i ] - 'a' ) || i == ( str [ i ] - 'A' ) ) result ++; return result; }
int remainderWith7 ( string num ) { int series [ ] = { 1, 3, 2, - 1, - 3, - 2 }; int series_index = 0; int result = 0; for ( int i = num . size ( ) - 1; i >= 0; i -- ) { int digit = num [ i ] - '0'; result += digit * series [ series_index ]; series_index = ( series_index + 1 ) % 6; result %= 7; } if ( result < 0 ) result = ( result + 7 ) % 7; return result; }
bool pairInSortedRotated ( int arr [ ], int n, int x ) { int i; for ( i = 0; i < n - 1; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break; int l = ( i + 1 ) % n; int r = i; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n; else r = ( n + r - 1 ) % n; } return false; }
void printDistinct ( string str ) { int n = str . length ( ); int count [ MAX_CHAR ]; int index [ MAX_CHAR ]; for ( int i = 0; i < MAX_CHAR; i ++ ) { count [ i ] = 0; index [ i ] = n; } for ( int i = 0; i < n; i ++ ) { char x = str [ i ]; ++ count [ x ]; if ( count [ x ] == 1 && x != ' ' ) index [ x ] = i; if ( count [ x ] == 2 ) index [ x ] = n; } sort ( index, index + MAX_CHAR ); for ( int i = 0; i < MAX_CHAR && index [ i ] != n; i ++ ) cout << str [ index [ i ] ]; }
void groupElements ( int arr [ ], int n ) { bool * visited = new bool [ n ]; for ( int i = 0; i < n; i ++ ) visited [ i ] = false; for ( int i = 0; i < n; i ++ ) { if ( ! visited [ i ] ) { cout << arr [ i ] << " "; for ( int j = i + 1; j < n; j ++ ) { if ( arr [ i ] == arr [ j ] ) { cout << arr [ i ] << " "; visited [ j ] = true; } } } } delete [ ] visited; }
int countDistictSubarray ( int arr [ ], int n ) { unordered_map < int, int > vis; for ( int i = 0; i < n; ++ i ) vis [ arr [ i ] ] = 1; int k = vis . size ( ); vis . clear ( ); int ans = 0, right = 0, window = 0; for ( int left = 0; left < n; ++ left ) { while ( right < n && window < k ) { ++ vis [ arr [ right ] ]; if ( vis [ arr [ right ] ] == 1 ) ++ window; ++ right; } if ( window == k ) ans += ( n - right + 1 ); -- vis [ arr [ left ] ]; if ( vis [ arr [ left ] ] == 0 ) -- window; } return ans; }
bool checkIfAllTogether ( string s, char c ) { bool oneSeen = false; int i = 0, n = s . length ( ); while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false; while ( i < n && s [ i ] == c ) i ++; oneSeen = true; } else i ++; } return true; }
int kPrimeFactor ( int n, int k ) { while ( n % 2 == 0 ) { k --; n = n / 2; if ( k == 0 ) return 2; } for ( int i = 3; i <= sqrt ( n ); i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i; k --; n = n / i; } } if ( n > 2 && k == 1 ) return n; return - 1; }
void findTriplets ( int arr [ ], int n ) { bool found = false; sort ( arr, arr + n ); for ( int i = 0; i < n - 1; i ++ ) { int l = i + 1; int r = n - 1; int x = arr [ i ]; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { printf ( "%d %d %d\n", x, arr [ l ], arr [ r ] ); l ++; r --; found = true; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++; else r --; } } if ( found == false ) cout << " No Triplet Found" << endl; }
bool sortedAfterSwap ( int A [ ], bool B [ ], int n ) { for ( int i = 0; i < n - 1; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) swap ( A [ i ], A [ i + 1 ] ); } } for ( int i = 0; i < n; i ++ ) { if ( A [ i ] != i + 1 ) return false; } return true; }
int countCommon ( int mat [ ] [ MAX ], int n ) { int res = 0; for ( int i = 0; i < n; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++; return res; }
void permutatedRows ( int mat [ ] [ MAX ], int m, int n, int r ) { unordered_set < int > s; for ( int j = 0; j < n; j ++ ) s . insert ( mat [ r ] [ j ] ); for ( int i = 0; i < m; i ++ ) { if ( i == r ) continue; int j; for ( j = 0; j < n; j ++ ) if ( s . find ( mat [ i ] [ j ] ) == s . end ( ) ) break; if ( j != n ) continue; cout << i << ", "; } }
ll pre_compute ( ll a [ ], ll n, ll index, ll k ) { ll dp [ n ] [ n ] = { 0 }; for ( int i = 0; i < n; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ]; else dp [ 0 ] [ i ] = a [ i ]; } for ( int i = 1; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ]; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ]; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ]; } } return dp [ index ] [ k ]; }
void sortInWave ( int arr [ ], int n ) { for ( int i = 0; i < n; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [ i ], & arr [ i - 1 ] ); if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & arr [ i ], & arr [ i + 1 ] ); } }
void printPascal ( int n ) { int arr [ n ] [ n ]; for ( int line = 0; line < n; line ++ ) { for ( int i = 0; i <= line; i ++ ) { if ( line == i || i == 0 ) arr [ line ] [ i ] = 1; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ]; cout << arr [ line ] [ i ] << " "; } cout << "\n"; } }
int waysToIncreaseLCSBy1 ( string str1, string str2 ) { int m = str1 . length ( ), n = str2 . length ( ); vector < int > position [ M ]; for ( int i = 1; i <= n; i ++ ) position [ toInt ( str2 [ i - 1 ] ) ] . push_back ( i ); int lcsl [ m + 2 ] [ n + 2 ]; int lcsr [ m + 2 ] [ n + 2 ]; for ( int i = 0; i <= m + 1; i ++ ) for ( int j = 0; j <= n + 1; j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0; for ( int i = 1; i <= m; i ++ ) { for ( int j = 1; j <= n; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ]; else lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ], lcsl [ i ] [ j - 1 ] ); } } for ( int i = m; i >= 1; i -- ) { for ( int j = n; j >= 1; j -- ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ]; else lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ], lcsr [ i ] [ j + 1 ] ); } } int ways = 0; for ( int i = 0; i <= m; i ++ ) { for ( char c = 'a'; c <= 'z'; c ++ ) { for ( int j = 0; j < position [ toInt ( c ) ] . size ( ); j ++ ) { int p = position [ toInt ( c ) ] [ j ]; if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) ways ++; } } } return ways; }
bool squareRootExists ( int n, int p ) { n = n % p; for ( int x = 2; x < p; x ++ ) if ( ( x * x ) % p == n ) return true; return false; }
public : float squareRoot ( float n ) { float x = n; float y = 1; float e = 0.000001; while ( x - y > e ) { x = ( x + y ) / 2; y = n / x; } return x; }
int fib ( int n ) { if ( lookup [ n ] == NIL ) { if ( n <= 1 ) lookup [ n ] = n; else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ); } return lookup [ n ]; }
int isChangeable ( int notes [ ], int n ) { int fiveCount = 0; int tenCount = 0; for ( int i = 0; i < n; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount --; tenCount ++; } else return 0; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount --; tenCount --; } else if ( fiveCount >= 3 ) { fiveCount -= 3; } else return 0; } } return 1; }
int numberOfPaths ( int m, int n ) { int count [ m ] [ n ]; for ( int i = 0; i < m; i ++ ) count [ i ] [ 0 ] = 1; for ( int j = 0; j < n; j ++ ) count [ 0 ] [ j ] = 1; for ( int i = 1; i < m; i ++ ) { for ( int j = 1; j < n; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ]; } return count [ m - 1 ] [ n - 1 ]; }
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1; int sum = 0; while ( k -- ) { sum += cur; cur += 2; } return sum; }
void longestSubseqWithK ( string str, int k ) { int n = str . size ( ); int freq [ MAX_CHARS ] = { 0 }; for ( int i = 0; i < n; i ++ ) freq [ str [ i ] - 'a' ] ++; for ( int i = 0; i < n; i ++ ) if ( freq [ str [ i ] - 'a' ] >= k ) cout << str [ i ]; }
int countPairs ( int arr1 [ ], int arr2 [ ], int m, int n, int x ) { int count = 0; unordered_set < int > us; for ( int i = 0; i < m; i ++ ) us . insert ( arr1 [ i ] ); for ( int j = 0; j < n; j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) count ++; return count; }
void checkPoint ( int radius, int x, int y, float percent, float startAngle ) { float endAngle = 360 / percent + startAngle; float polarradius = sqrt ( x * x + y * y ); float Angle = atan ( y / x ); if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) printf ( "Point (%d, %d) exist in the circle sector\n", x, y ); else printf ( "Point (%d, %d) does not exist in the circle sector\n", x, y ); }
void CocktailSort ( int a [ ], int n ) { bool swapped = true; int start = 0; int end = n - 1; while ( swapped ) { swapped = false; for ( int i = start; i < end; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ], a [ i + 1 ] ); swapped = true; } } if ( ! swapped ) break; swapped = false; -- end; for ( int i = end - 1; i >= start; -- i ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ], a [ i + 1 ] ); swapped = true; } } ++ start; } }
int divisorSum ( int n ) { int sum = 0; for ( int i = 1; i <= n; ++ i ) sum += ( n / i ) * i; return sum; }
int getInvCount ( int arr [ ], int n ) { int invcount = 0; for ( int i = 1; i < n - 1; i ++ ) { int small = 0; for ( int j = i + 1; j < n; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++; int great = 0; for ( int j = i - 1; j >= 0; j -- ) if ( arr [ i ] < arr [ j ] ) great ++; invcount += great * small; } return invcount; }
int countNonEmptySubstr ( string str ) { int n = str . length ( ); return n * ( n + 1 ) / 2; }
int knapSack ( int W, int wt [ ], int val [ ], int n ) { int i, w; int K [ n + 1 ] [ W + 1 ]; for ( i = 0; i <= n; i ++ ) { for ( w = 0; w <= W; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] ); else K [ i ] [ w ] = K [ i - 1 ] [ w ]; } } return K [ n ] [ W ]; }
int firstElement ( int arr [ ], int n, int k ) { unordered_map < int, int > count_map; for ( int i = 0; i < n; i ++ ) count_map [ arr [ i ] ] ++; for ( int i = 0; i < n; i ++ ) if ( count_map [ arr [ i ] ] == k ) return arr [ i ]; return - 1; }
void subArray ( int arr [ ], int n ) { for ( int i = 0; i < n; i ++ ) { for ( int j = i; j < n; j ++ ) { for ( int k = i; k <= j; k ++ ) cout << arr [ k ] << " "; cout << endl; } } }
int countRect ( int n ) { int ans = 0; for ( int length = 1; length <= sqrt ( n ); ++ length ) for ( int height = length; height * length <= n; ++ height ) ans ++; return ans; }
int maxDiff ( int arr [ ], int n ) { int result = 0; sort ( arr, arr + n ); for ( int i = 0; i < n - 1; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ); else i ++; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] ); return result; }
void midPoint ( int X1, int Y1, int X2, int Y2 ) { int dx = X2 - X1; int dy = Y2 - Y1; int d = dy - ( dx / 2 ); int x = X1, y = Y1; cout << x << "," << y << "\n"; while ( x < X2 ) { x ++; if ( d < 0 ) d = d + dy; else { d += ( dy - dx ); y ++; } cout << x << "," << y << "\n"; } }
int unitDigitXRaisedY ( int x, int y ) { int res = 1; for ( int i = 0; i < y; i ++ ) res = ( res * x ) % 10; return res; }
int findSum ( int n ) { n --; int sum = 0; sum += ( n * ( n + 1 ) ) / 2; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6; return sum; }
void printEqualModNumbers ( int arr [ ], int n ) { sort ( arr, arr + n ); int d = arr [ n - 1 ] - arr [ 0 ]; vector < int > v; for ( int i = 1; i * i <= d; i ++ ) { if ( d % i == 0 ) { v . push_back ( i ); if ( i != d / i ) v . push_back ( d / i ); } } for ( int i = 0; i < v . size ( ); i ++ ) { int temp = arr [ 0 ] % v [ i ]; int j; for ( j = 1; j < n; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break; if ( j == n ) cout << v [ i ] << " "; } }
void search ( char * pat, char * txt ) { int M = strlen ( pat ); int N = strlen ( txt ); for ( int i = 0; i <= N - M; i ++ ) { int j; for ( j = 0; j < M; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break; if ( j == M ) cout << "Pattern found at index " << i << endl; } }
void printClosest ( int ar1 [ ], int ar2 [ ], int m, int n, int x ) { int diff = INT_MAX; int res_l, res_r; int l = 0, r = n - 1; while ( l < m && r >= 0 ) { if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l; res_r = r; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ); } if ( ar1 [ l ] + ar2 [ r ] > x ) r --; else l ++; } cout << "The closest pair is [" << ar1 [ res_l ] << ", " << ar2 [ res_r ] << "] \n"; }
string findSubString ( string str ) { int n = str . length ( ); int dist_count = 0; bool visited [ MAX_CHARS ] = { false }; for ( int i = 0; i < n; i ++ ) { if ( visited [ str [ i ] ] == false ) { visited [ str [ i ] ] = true; dist_count ++; } } int start = 0, start_index = - 1, min_len = INT_MAX; int count = 0; int curr_count [ MAX_CHARS ] = { 0 }; for ( int j = 0; j < n; j ++ ) { curr_count [ str [ j ] ] ++; if ( curr_count [ str [ j ] ] == 1 ) count ++; if ( count == dist_count ) { while ( curr_count [ str [ start ] ] > 1 ) { if ( curr_count [ str [ start ] ] > 1 ) curr_count [ str [ start ] ] --; start ++; } int len_window = j - start + 1; if ( min_len > len_window ) { min_len = len_window; start_index = start; } } } return str . substr ( start_index, min_len ); }
char first ( string str ) { for ( int i = 0; i < str . length ( ); i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ]; return 0; }
int knapSack ( int W, int wt [ ], int val [ ], int n ) { if ( n == 0 || W == 0 ) return 0; if ( wt [ n - 1 ] > W ) return knapSack ( W, wt, val, n - 1 ); else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) ); }
int minMaxProduct ( int arr1 [ ], int arr2 [ ], int n1, int n2 ) { sort ( arr1, arr1 + n1 ); sort ( arr2, arr2 + n2 ); return arr1 [ n1 - 1 ] * arr2 [ 0 ]; }
long long int findMinSum ( int a [ ], int b [ ], int n ) { sort ( a, a + n ); sort ( b, b + n ); long long int sum = 0; for ( int i = 0; i < n; i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ); return sum; }
int largestPower ( int n, int p ) { int x = 0; while ( n ) { n /= p; x += n; } return x; }
int maxDifference ( int arr [ ], int N, int k ) { int M, S = 0, S1 = 0, max_difference = 0; for ( int i = 0; i < N; i ++ ) S += arr [ i ]; sort ( arr, arr + N, greater < int > ( ) ); M = max ( k, N - k ); for ( int i = 0; i < M; i ++ ) S1 += arr [ i ]; max_difference = S1 - ( S - S1 ); return max_difference; }
long long arrangeBraces ( int n, int pos [ ], int k ) { bool h [ N ]; int dp [ N ] [ N ]; memset ( h, 0, sizeof h ); memset ( dp, 0, sizeof dp ); for ( int i = 0; i < k; i ++ ) h [ pos [ i ] ] = 1; dp [ 0 ] [ 0 ] = 1; for ( int i = 1; i <= 2 * n; i ++ ) { for ( int j = 0; j <= 2 * n; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = 0; } else { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ]; else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]; } } } return dp [ 2 * n ] [ 0 ]; }
int countGroups ( int position, int previous_sum, int length, char * num ) { if ( position == length ) return 1; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ]; dp [ position ] [ previous_sum ] = 0; int res = 0; int sum = 0; for ( int i = position; i < length; i ++ ) { sum += ( num [ i ] - '0' ); if ( sum >= previous_sum ) res += countGroups ( i + 1, sum, length, num ); } dp [ position ] [ previous_sum ] = res; return res; }
float getArea ( int a ) { float area = ( M_PI * a * a ) / 4.0; return area; }
void rearrangeArr ( int arr [ ], int n ) { int evenPos = n / 2; int oddPos = n - evenPos; int tempArr [ n ]; for ( int i = 0; i < n; i ++ ) tempArr [ i ] = arr [ i ]; sort ( tempArr, tempArr + n ); int j = oddPos - 1; for ( int i = 0; i < n; i += 2 ) { arr [ i ] = tempArr [ j ]; j --; } j = oddPos; for ( int i = 1; i < n; i += 2 ) { arr [ i ] = tempArr [ j ]; j ++; } for ( int i = 0; i < n; i ++ ) cout << arr [ i ] << " "; }
int coutSubSeq ( int A [ ], int N, int M ) { int sum = 0; int ans = 0; for ( int i = 0; i < N; i ++ ) { for ( int j = i + 1; j < N; j ++ ) { for ( int k = j + 1; k < N; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ]; if ( sum % M == 0 ) ans ++; } } } return ans; }
int findMaxGCD ( int arr [ ], int n ) { int high = 0; for ( int i = 0; i < n; i ++ ) high = max ( high, arr [ i ] ); int count [ high + 1 ] = { 0 }; for ( int i = 0; i < n; i ++ ) count [ arr [ i ] ] ++; int counter = 0; for ( int i = high; i >= 1; i -- ) { int j = i; counter = 0; while ( j <= high ) { if ( count [ j ] >= 2 ) return j; else if ( count [ j ] == 1 ) counter ++; j += i; if ( counter == 2 ) return i; } } }
int countarray ( int n, int k, int x ) { int dp [ MAXN ] = { 0 }; dp [ 0 ] = 0; dp [ 1 ] = 1; for ( int i = 2; i < n; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ]; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ); }
int countDer ( int n ) { int der [ n + 1 ]; der [ 0 ] = 1; der [ 1 ] = 0; der [ 2 ] = 1; for ( int i = 3; i <= n; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ); return der [ n ]; }
bool isRectangle ( const vector < vector < int > > & m ) { int rows = m . size ( ); if ( rows == 0 ) return false; int columns = m [ 0 ] . size ( ); for ( int y1 = 0; y1 < rows; y1 ++ ) for ( int x1 = 0; x1 < columns; x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1; y2 < rows; y2 ++ ) for ( int x2 = x1 + 1; x2 < columns; x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true; return false; }
string getMinNumberForPattern ( string seq ) { int n = seq . length ( ); if ( n >= 9 ) return "-1"; string result ( n + 1, ' ' ); int count = 1; for ( int i = 0; i <= n; i ++ ) { if ( i == n || seq [ i ] == 'I' ) { for ( int j = i - 1; j >= - 1; j -- ) { result [ j + 1 ] = '0' + count ++; if ( j >= 0 && seq [ j ] == 'I' ) break; } } } return result; }
int maxTripletSum ( int arr [ ], int n ) { int sum = INT_MIN; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) for ( int k = j + 1; k < n; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ]; return sum; }
int minRadius ( int k, int x [ ], int y [ ], int n ) { int dis [ n ]; for ( int i = 0; i < n; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ]; sort ( dis, dis + n ); return dis [ k - 1 ]; }
void printPrevSmaller ( int arr [ ], int n ) { stack < int > S; for ( int i = 0; i < n; i ++ ) { while ( ! S . empty ( ) && S . top ( ) >= arr [ i ] ) S . pop ( ); if ( S . empty ( ) ) cout << "_, "; else cout << S . top ( ) << ", "; S . push ( arr [ i ] ); } }
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ]; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10; }
void computeLPSArray ( char * pat, int M, int * lps ) { int len = 0; lps [ 0 ] = 0; int i = 1; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++; lps [ i ] = len; i ++; } else { if ( len != 0 ) { len = lps [ len - 1 ]; } else { lps [ i ] = 0; i ++; } } } }
int numberOfPaths ( int m, int n ) { int path = 1; for ( int i = n; i < ( m + n - 1 ); i ++ ) { path *= i; path /= ( i - n + 1 ); } return path; }
int maxOnesIndex ( bool arr [ ], int n ) { int max_count = 0; int max_index; int prev_zero = - 1; int prev_prev_zero = - 1; for ( int curr = 0; curr < n; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero; max_index = prev_zero; } prev_prev_zero = prev_zero; prev_zero = curr; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero; return max_index; }
void ZigZag ( int rows, int columns, int numbers [ ] ) { int k = 0; int arr [ rows ] [ columns ]; for ( int i = 0; i < rows; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0; j < columns and numbers [ k ] > 0; j ++ ) { arr [ i ] [ j ] = k + 1; numbers [ k ] --; if ( numbers [ k ] == 0 ) k ++; } } else { for ( int j = columns - 1; j >= 0 and numbers [ k ] > 0; j -- ) { arr [ i ] [ j ] = k + 1; numbers [ k ] --; if ( numbers [ k ] == 0 ) k ++; } } } for ( int i = 0; i < rows; i ++ ) { for ( int j = 0; j < columns; j ++ ) cout << arr [ i ] [ j ] << " "; cout << endl; } }
int fib ( int n ) { if ( n == 0 ) return 0; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ); if ( f [ n ] ) return f [ n ]; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2; f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ); return f [ n ]; }
void printDistinct ( char * str ) { int count [ NO_OF_CHARS ]; int i; for ( i = 0; * ( str + i ); i ++ ) if ( * ( str + i ) != ' ' ) count [ * ( str + i ) ] ++; int n = i; for ( i = 0; i < n; i ++ ) if ( count [ * ( str + i ) ] == 1 ) cout << str [ i ]; }
void printMaxOfMin ( int arr [ ], int n ) { stack < int > s; int left [ n + 1 ]; int right [ n + 1 ]; for ( int i = 0; i < n; i ++ ) { left [ i ] = - 1; right [ i ] = n; } for ( int i = 0; i < n; i ++ ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ); if ( ! s . empty ( ) ) left [ i ] = s . top ( ); s . push ( i ); } while ( ! s . empty ( ) ) s . pop ( ); for ( int i = n - 1; i >= 0; i -- ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ); if ( ! s . empty ( ) ) right [ i ] = s . top ( ); s . push ( i ); } int ans [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) ans [ i ] = 0; for ( int i = 0; i < n; i ++ ) { int len = right [ i ] - left [ i ] - 1; ans [ len ] = max ( ans [ len ], arr [ i ] ); } for ( int i = n - 1; i >= 1; i -- ) ans [ i ] = max ( ans [ i ], ans [ i + 1 ] ); for ( int i = 1; i <= n; i ++ ) cout << ans [ i ] << " "; }
void findLarger ( int arr [ ], int n ) { sort ( arr, arr + n ); for ( int i = n - 1; i >= n / 2; i -- ) cout << arr [ i ] << " "; }
string findSum ( string str1, string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1, str2 ); string str = ""; int n1 = str1 . length ( ), n2 = str2 . length ( ); reverse ( str1 . begin ( ), str1 . end ( ) ); reverse ( str2 . begin ( ), str2 . end ( ) ); int carry = 0; for ( int i = 0; i < n1; i ++ ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) + carry ); str . push_back ( sum % 10 + '0' ); carry = sum / 10; } for ( int i = n1; i < n2; i ++ ) { int sum = ( ( str2 [ i ] - '0' ) + carry ); str . push_back ( sum % 10 + '0' ); carry = sum / 10; } if ( carry ) str . push_back ( carry + '0' ); reverse ( str . begin ( ), str . end ( ) ); return str; }
int intersection ( int n ) { return n * ( n - 1 ); }
void kmax ( int arr [ ], int k, int n ) { for ( int c = 0; c < k; c ++ ) { int max_so_far = numeric_limits < int > :: min ( ); int max_here = 0; int start = 0, end = 0, s = 0; for ( int i = 0; i < n; i ++ ) { max_here += arr [ i ]; if ( max_so_far < max_here ) { max_so_far = max_here; start = s; end = i; } if ( max_here < 0 ) { max_here = 0; s = i + 1; } } cout << "Maximum non-overlapping sub-array sum" << ( c + 1 ) << ": " << max_so_far << ", starting index: " << start << ", ending index: " << end << "." << endl; for ( int l = start; l <= end; l ++ ) arr [ l ] = numeric_limits < int > :: min ( ); } cout << endl; }
int maxSum ( int arr [ ], int n ) { sort ( arr, arr + n ); int sum = 0; for ( int i = 0; i < n; i ++ ) sum += ( arr [ i ] * i ); return sum; }
int ceilSearch ( int arr [ ], int low, int high, int x ) { int i; if ( x <= arr [ low ] ) return low; for ( i = low; i < high; i ++ ) { if ( arr [ i ] == x ) return i; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1; } return - 1; }
int countDecodingDP ( char * digits, int n ) { int count [ n + 1 ]; count [ 0 ] = 1; count [ 1 ] = 1; if ( digits [ 0 ] == '0' ) return 0; for ( int i = 2; i <= n; i ++ ) { count [ i ] = 0; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ]; if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ]; } return count [ n ]; }
long long maxPrimeFactors ( long long n ) { long long maxPrime = - 1; while ( n % 2 == 0 ) { maxPrime = 2; n >>= 1; } for ( int i = 3; i <= sqrt ( n ); i += 2 ) { while ( n % i == 0 ) { maxPrime = i; n = n / i; } } if ( n > 2 ) maxPrime = n; return maxPrime; }
int maxLenSub ( int arr [ ], int n ) { int mls [ n ], max = 0; for ( int i = 0; i < n; i ++ ) mls [ i ] = 1; for ( int i = 1; i < n; i ++ ) for ( int j = 0; j < i; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1; for ( int i = 0; i < n; i ++ ) if ( max < mls [ i ] ) max = mls [ i ]; return max; }
void printRepeating ( int arr [ ], int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ]; int i; cout << " Repeating elements are "; for ( i = 0; i < size; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " "; else count [ arr [ i ] ] ++; } }
void insertionSortRecursive ( int arr [ ], int n ) { if ( n <= 1 ) return; insertionSortRecursive ( arr, n - 1 ); int last = arr [ n - 1 ]; int j = n - 2; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ]; j --; } arr [ j + 1 ] = last; }
void bubbleSort ( int arr [ ], int n ) { int i, j; for ( i = 0; i < n - 1; i ++ ) for ( j = 0; j < n - i - 1; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( & arr [ j ], & arr [ j + 1 ] ); }
ll count_of_ways ( ll n ) { ll count; count = ( n + 1 ) * ( n + 2 ) / 2; return count; }
int count ( int S [ ], int m, int n ) { if ( n == 0 ) return 1; if ( n < 0 ) return 0; if ( m <= 0 && n >= 1 ) return 0; return count ( S, m - 1, n ) + count ( S, m, n - S [ m - 1 ] ); }
int minProductSubset ( int a [ ], int n ) { if ( n == 1 ) return a [ 0 ]; int max_neg = INT_MIN; int min_pos = INT_MAX; int count_neg = 0, count_zero = 0; int prod = 1; for ( int i = 0; i < n; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++; continue; } if ( a [ i ] < 0 ) { count_neg ++; max_neg = max ( max_neg, a [ i ] ); } if ( a [ i ] > 0 ) min_pos = min ( min_pos, a [ i ] ); prod = prod * a [ i ]; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0; if ( count_neg == 0 ) return min_pos; if ( ! ( count_neg & 1 ) && count_neg != 0 ) { prod = prod / max_neg; } return prod; }
int recSearch ( int arr [ ], int l, int r, int x ) { if ( r < l ) return - 1; if ( arr [ l ] == x ) return l; if ( arr [ r ] == x ) return r; return recSearch ( arr, l + 1, r - 1, x ); }
void survival ( int S, int N, int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) cout << "No\n"; else { int days = ( M * S ) / N; if ( ( ( M * S ) % N ) != 0 ) days ++; cout << "Yes " << days << endl; } }
bool printPairs ( int arr [ ], int n, int k ) { bool isPairFound = true; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << "(" << arr [ i ] << ", " << arr [ j ] << ")" << " "; isPairFound = true; } } } return isPairFound; }
double vol_tetra ( int side ) { double volume = ( pow ( side, 3 ) / ( 6 * sqrt ( 2 ) ) ); return volume; }
int kthdigit ( int a, int b, int k ) { int p = pow ( a, b ); int count = 0; while ( p > 0 && count < k ) { int rem = p % 10; count ++; if ( count == k ) return rem; p = p / 10; } return 0; }
unsigned int doublefactorial ( unsigned int n ) { if ( n == 0 || n == 1 ) return 1; return n * doublefactorial ( n - 2 ); }
void maxProduct ( int arr [ ], int n ) { if ( n < 2 ) { cout << "No pairs exists\n"; return; } int a = arr [ 0 ], b = arr [ 1 ]; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) a = arr [ i ], b = arr [ j ]; cout << "Max product pair is {" << a << ", " << b << "}"; }
int countOccurrences ( string s, int K ) { int n = s . length ( ); int C, c1 = 0, c2 = 0; for ( int i = 0; i < n; i ++ ) { if ( s [ i ] == 'a' ) c1 ++; if ( s [ i ] == 'b' ) { c2 ++; C += c1; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2; }
int firstNonRepeating ( int arr [ ], int n ) { unordered_map < int, int > mp; for ( int i = 0; i < n; i ++ ) mp [ arr [ i ] ] ++; for ( int i = 0; i < n; i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ]; return - 1; }
int findRepeating ( int arr [ ], int n ) { int res = 0; for ( int i = 0; i < n - 1; i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ]; res = res ^ arr [ n - 1 ]; return res; }
void transpose ( int A [ ] [ N ] ) { for ( int i = 0; i < N; i ++ ) for ( int j = i + 1; j < N; j ++ ) swap ( A [ i ] [ j ], A [ j ] [ i ] ); }
int swapBits ( unsigned int x, unsigned int p1, unsigned int p2, unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ); unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ); unsigned int Xor = ( set1 ^ set2 ); Xor = ( Xor << p1 ) | ( Xor << p2 ); unsigned int result = x ^ Xor; return result; }
bool isProduct ( int arr [ ], int n, int x ) { for ( int i = 0; i < n - 1; i ++ ) for ( int j = i + 1; i < n; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true; return false; }
int maxSubarrayXOR ( int arr [ ], int n ) { int ans = INT_MIN; for ( int i = 0; i < n; i ++ ) { int curr_xor = 0; for ( int j = i; j < n; j ++ ) { curr_xor = curr_xor ^ arr [ j ]; ans = max ( ans, curr_xor ); } } return ans; }
bool isPower ( int x, int y ) { int res1 = log ( y ) / log ( x ); double res2 = log ( y ) / log ( x ); return ( res1 == res2 ); }
int countPair ( int a, int b ) { string s = to_string ( b ); int i; for ( i = 0; i < s . length ( ); i ++ ) { if ( s [ i ] != '9' ) break; } int result; if ( i == s . length ( ) ) result = a * s . length ( ); else result = a * ( s . length ( ) - 1 ); return result; }
int findLongestConseqSubseq ( int arr [ ], int n ) { unordered_set < int > S; for ( int i = 0; i < n; i ++ ) S . insert ( arr [ i ] ); int ans = 0; for ( int i = 0; i < n; i ++ ) { if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) { int j = arr [ i ]; while ( S . find ( j ) != S . end ( ) ) j ++; ans = max ( ans, j - arr [ i ] ); } } return ans; }
int findMinInsertions ( char str [ ], int l, int h ) { if ( l > h ) return INT_MAX; if ( l == h ) return 0; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str, l + 1, h - 1 ) : ( min ( findMinInsertions ( str, l, h - 1 ), findMinInsertions ( str, l + 1, h ) ) + 1 ); }
int find ( int a [ ], int b [ ], int k, int n1, int n2 ) { unordered_set < int > s; for ( int i = 0; i < n2; i ++ ) s . insert ( b [ i ] ); int missing = 0; for ( int i = 0; i < n1; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++; if ( missing == k ) return a [ i ]; } return - 1; }
int equilibrium ( int arr [ ], int n ) { int i, j; int leftsum, rightsum; for ( i = 0; i < n; ++ i ) { leftsum = 0; for ( j = 0; j < i; j ++ ) leftsum += arr [ j ]; rightsum = 0; for ( j = i + 1; j < n; j ++ ) rightsum += arr [ j ]; if ( leftsum == rightsum ) return i; } return - 1; }
float circumferenceparallelogram ( float a, float b ) { return ( ( 2 * a ) + ( 2 * b ) ); }
int middleOfThree ( int a, int b, int c ) { if ( a > b ) { if ( b > c ) return b; else if ( a > c ) return c; else return a; } else { if ( a > c ) return a; else if ( b > c ) return c; else return b; } }
string convert ( string s ) { int n = s . length ( ); s [ 0 ] = tolower ( s [ 0 ] ); for ( int i = 1; i < n; i ++ ) { if ( s [ i ] == ' ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ); i ++; } else s [ i ] = toupper ( s [ i ] ); } return s; }
long long int calculateSum ( int n ) { long long int sum = 0; for ( int row = 0; row < n; row ++ ) { sum = sum + ( 1 << row ); } return sum; }
int getMinDiff ( int arr [ ], int n, int k ) { if ( n == 1 ) return 0; sort ( arr, arr + n ); int ans = arr [ n - 1 ] - arr [ 0 ]; int small = arr [ 0 ] + k; int big = arr [ n - 1 ] - k; if ( small > big ) swap ( small, big ); for ( int i = 1; i < n - 1; i ++ ) { int subtract = arr [ i ] - k; int add = arr [ i ] + k; if ( subtract >= small || add <= big ) continue; if ( big - subtract <= add - small ) small = subtract; else big = add; } return min ( ans, big - small ); }
int numberOfSquares ( int base ) { base = ( base - 2 ); base = base / 2; return base * ( base + 1 ) / 2; }
void findElements ( int arr [ ], int n ) { sort ( arr, arr + n ); for ( int i = 0; i < n - 2; i ++ ) cout << arr [ i ] << " "; }
void printAllAPTriplets ( int arr [ ], int n ) { unordered_set < int > s; for ( int i = 0; i < n - 1; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { int diff = arr [ j ] - arr [ i ]; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " " << arr [ i ] << " " << arr [ j ] << endl; } s . insert ( arr [ i ] ); } }
int octalToDecimal ( int n ) { int num = n; int dec_value = 0; int base = 1; int temp = num; while ( temp ) { int last_digit = temp % 10; temp = temp / 10; dec_value += last_digit * base; base = base * 8; } return dec_value; }
int subArraySum ( int arr [ ], int n, int sum ) { int curr_sum, i, j; for ( i = 0; i < n; i ++ ) { curr_sum = arr [ i ]; for ( j = i + 1; j <= n; j ++ ) { if ( curr_sum == sum ) { cout << "Sum found between indexes " << i << " and " << j - 1; return 1; } if ( curr_sum > sum || j == n ) break; curr_sum = curr_sum + arr [ j ]; } } cout << "No subarray found"; return 0; }
int numberofways ( int n, int m ) { int dp [ n + 2 ] [ n + 2 ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] [ n + 1 ] = 1; for ( int k = n; k >= m; k -- ) { for ( int i = 0; i <= n; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ]; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ); } } return dp [ n ] [ m ]; }
void minheapify ( int a [ ], int index ) { int small = index; int l = 2 * index + 1; int r = 2 * index + 2; if ( l < n && a [ l ] < a [ small ] ) small = l; if ( r < n && a [ r ] < a [ small ] ) small = r; if ( small != index ) { swap ( a [ small ], a [ index ] ); minheapify ( a, small ); } }
int findDiff ( int arr [ ], int n ) { sort ( arr, arr + n ); int count = 0, max_count = 0, min_count = n; for ( int i = 0; i < ( n - 1 ); i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1; continue; } else { max_count = max ( max_count, count ); min_count = min ( min_count, count ); count = 0; } } return ( max_count - min_count ); }
int minTime ( int arr [ ], int n ) { if ( n <= 0 ) return 0; int incl = arr [ 0 ]; int excl = 0; for ( int i = 1; i < n; i ++ ) { int incl_new = arr [ i ] + min ( excl, incl ); int excl_new = incl; incl = incl_new; excl = excl_new; } return min ( incl, excl ); }
void minimizeWithKSwaps ( int arr [ ], int n, int k ) { for ( int i = 0; i < n - 1 && k > 0; ++ i ) { int pos = i; for ( int j = i + 1; j < n; ++ j ) { if ( j - i > k ) break; if ( arr [ j ] < arr [ pos ] ) pos = j; } for ( int j = pos; j > i; -- j ) swap ( arr [ j ], arr [ j - 1 ] ); k -= pos - i; } }
double seriesSum ( int n ) { int i = 1; double res = 0.0; bool sign = true; while ( n > 0 ) { n --; if ( sign ) { sign = ! sign; res = res + ( double ) ++ i / ++ i; } else { sign = ! sign; res = res - ( double ) ++ i / ++ i; } } return res; }
int MinOperation ( int a [ ], int n, int k ) { int result = 0; for ( int i = 0; i < n; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k, k - a [ i ] % k ); } else { result = result + k - a [ i ]; } } return result; }
int findIndex ( int n ) { float fibo = 2.078087 * log ( n ) + 1.672276; return round ( fibo ); }
int distancesum ( int x [ ], int y [ ], int n ) { int sum = 0; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ); return sum; }
void twoWaySort ( int arr [ ], int n ) { for ( int i = 0; i < n; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1; sort ( arr, arr + n ); for ( int i = 0; i < n; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1; }
int binarySearch ( int arr [ ], int low, int high ) { if ( high >= low ) { int mid = ( low + high ) / 2; if ( mid == arr [ mid ] ) return mid; if ( mid > arr [ mid ] ) return binarySearch ( arr, ( mid + 1 ), high ); else return binarySearch ( arr, low, ( mid - 1 ) ); } return - 1; }
int binarySearch ( int arr [ ], int low, int high, int key ) { if ( high < low ) return - 1; int mid = ( low + high ) / 2; if ( key == arr [ mid ] ) return mid; if ( key > arr [ mid ] ) return binarySearch ( arr, ( mid + 1 ), high, key ); return binarySearch ( arr, low, ( mid - 1 ), key ); }
float areaOfInscribedCircle ( float a ) { return ( PI / 4 ) * a * a; }
void squareRoot ( int n, int p ) { n = n % p; for ( int x = 2; x < p; x ++ ) { if ( ( x * x ) % p == n ) { cout << "Square root is " << x; return; } } cout << "Square root doesn't exist"; }
int findSum ( int N, int K ) { int ans = 0; int y = N / K; int x = N % K; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2; return ans; }
int nobleInteger ( int arr [ ], int size ) { for ( int i = 0; i < size; i ++ ) { int count = 0; for ( int j = 0; j < size; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++; if ( count == arr [ i ] ) return arr [ i ]; } return - 1; }
int fun ( unsigned int n ) { return n & ( n - 1 ); }
int maxProduct ( int arr [ ], int n ) { if ( n < 3 ) return - 1; int max_product = INT_MIN; for ( int i = 0; i < n - 2; i ++ ) for ( int j = i + 1; j < n - 1; j ++ ) for ( int k = j + 1; k < n; k ++ ) max_product = max ( max_product, arr [ i ] * arr [ j ] * arr [ k ] ); return max_product; }
void countWaysToJump ( int arr [ ], int n ) { int count_jump [ n ]; memset ( count_jump, 0, sizeof ( count_jump ) ); for ( int i = n - 2; i >= 0; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++; for ( int j = i + 1; j < n - 1 && j <= arr [ i ] + i; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ]; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1; } for ( int i = 0; i < n; i ++ ) cout << count_jump [ i ] << " "; }
void kSmallestPair ( int arr1 [ ], int n1, int arr2 [ ], int n2, int k ) { if ( k > n1 * n2 ) { cout << "k pairs don't exist"; return; } int index2 [ n1 ]; memset ( index2, 0, sizeof ( index2 ) ); while ( k > 0 ) { int min_sum = INT_MAX; int min_index = 0; for ( int i1 = 0; i1 < n1; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ]; } } cout << "(" << arr1 [ min_index ] << ", " << arr2 [ index2 [ min_index ] ] << ") "; index2 [ min_index ] ++; k --; } }
int printbinomial ( int max ) { for ( int m = 0; m <= max; m ++ ) { printf ( "%2d", m ); int binom = 1; for ( int x = 0; x <= m; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x; printf ( "%4d", binom ); } printf ( "\n" ); } }
int minInsertionStepToSortArray ( int arr [ ], int N ) { int lis [ N ]; for ( int i = 0; i < N; i ++ ) lis [ i ] = 1; for ( int i = 1; i < N; i ++ ) for ( int j = 0; j < i; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1; int max = 0; for ( int i = 0; i < N; i ++ ) if ( max < lis [ i ] ) max = lis [ i ]; return ( N - max ); }
int knapSack ( int W, int wt [ ], int val [ ], int n ) { int i, w; int K [ n + 1 ] [ W + 1 ]; for ( i = 0; i <= n; i ++ ) { for ( w = 0; w <= W; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] ); else K [ i ] [ w ] = K [ i - 1 ] [ w ]; } } return K [ n ] [ W ]; }
string printNumbers ( int numbers [ ], int n ) { vector < int > oneTwoThree; for ( int i = 0; i < n; i ++ ) { if ( findContainsOneTwoThree ( numbers [ i ] ) ) oneTwoThree . push_back ( numbers [ i ] ); } sort ( oneTwoThree . begin ( ), oneTwoThree . end ( ) ); string result = ""; for ( auto number : oneTwoThree ) { int value = number; if ( result . length ( ) > 0 ) result += ", "; result += to_string ( value ); } return ( result . length ( ) > 0 ) ? result : "-1"; }
bool getParity ( unsigned int n ) { bool parity = 0; while ( n ) { parity = ! parity; n = n & ( n - 1 ); } return parity; }
void pushZerosToEnd ( int arr [ ], int n ) { int count = 0; for ( int i = 0; i < n; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ]; while ( count < n ) arr [ count ++ ] = 0; }
long int stirlingFactorial ( int n ) { if ( n == 1 ) return 1; long int z; float e = 2.71; z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ), n ); return z; }
int minimumflip ( int mat [ ] [ N ], int n ) { int flip = 0; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < i; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++; return flip; }
int countNumber ( int n ) { int result = 0; for ( int i = 1; i <= 9; i ++ ) { stack < int > s; if ( i <= n ) { s . push ( i ); result ++; } while ( ! s . empty ( ) ) { int tp = s . top ( ); s . pop ( ); for ( int j = tp % 10; j <= 9; j ++ ) { int x = tp * 10 + j; if ( x <= n ) { s . push ( x ); result ++; } } } } return result; }
int maxSubsequenceSubstring ( char x [ ], char y [ ], int n, int m ) { int dp [ MAX ] [ MAX ]; for ( int i = 0; i <= m; i ++ ) for ( int j = 0; j <= n; j ++ ) dp [ i ] [ j ] = 0; for ( int i = 1; i <= m; i ++ ) { for ( int j = 1; j <= n; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; } } int ans = 0; for ( int i = 1; i <= m; i ++ ) ans = max ( ans, dp [ i ] [ n ] ); return ans; }
int LCSubStr ( char * X, char * Y, int m, int n ) { int LCSuff [ m + 1 ] [ n + 1 ]; int result = 0; for ( int i = 0; i <= m; i ++ ) { for ( int j = 0; j <= n; j ++ ) { if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1; result = max ( result, LCSuff [ i ] [ j ] ); } else LCSuff [ i ] [ j ] = 0; } } return result; }
string findTwoscomplement ( string str ) { int n = str . length ( ); int i; for ( i = n - 1; i >= 0; i -- ) if ( str [ i ] == '1' ) break; if ( i == - 1 ) return '1' + str; for ( int k = i - 1; k >= 0; k -- ) { if ( str [ k ] == '1' ) str [ k ] = '0'; else str [ k ] = '1'; } return str; ; }
int countOnes ( bool arr [ ], int low, int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1; if ( arr [ mid ] == 1 ) return countOnes ( arr, ( mid + 1 ), high ); return countOnes ( arr, low, ( mid - 1 ) ); } return 0; }
void printNGE ( int arr [ ], int n ) { int next, i, j; for ( i = 0; i < n; i ++ ) { next = - 1; for ( j = i + 1; j < n; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ]; break; } } cout << arr [ i ] << " -- " << next << endl; } }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ); }
int solve ( int arr [ ], int n ) { sort ( arr, arr + n ); int a = 0, b = 0; for ( int i = 0; i < n; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ]; else b = b * 10 + arr [ i ]; } return a + b; }
void gnomeSort ( int arr [ ], int n ) { int index = 0; while ( index < n ) { if ( index == 0 ) index ++; if ( arr [ index ] >= arr [ index - 1 ] ) index ++; else { swap ( arr [ index ], arr [ index - 1 ] ); index --; } } return; }
void worstFit ( int blockSize [ ], int m, int processSize [ ], int n ) { int allocation [ n ]; memset ( allocation, - 1, sizeof ( allocation ) ); for ( int i = 0; i < n; i ++ ) { int wstIdx = - 1; for ( int j = 0; j < m; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( wstIdx == - 1 ) wstIdx = j; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx; blockSize [ wstIdx ] -= processSize [ i ]; } } cout << "\nProcess No.\tProcess Size\tBlock no.\n"; for ( int i = 0; i < n; i ++ ) { cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\t\t"; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1; else cout << "Not Allocated"; cout << endl; } }
int substringConversions ( string str, int k, int b ) { for ( int i = 0; i + k <= str . size ( ); i ++ ) { string sub = str . substr ( i, k ); int sum = 0, counter = 0; for ( int i = sub . size ( ) - 1; i >= 0; i -- ) { sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b, counter ) ); counter ++; } cout << sum << " "; } }
long long findDigits ( int n ) { if ( n < 0 ) return 0; if ( n <= 1 ) return 1; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ); return floor ( x ) + 1; }
unsigned countWords ( char * str ) { int state = OUT; unsigned wc = 0; while ( * str ) { if ( * str == ' ' || * str == '\n' || * str == '\t' ) state = OUT; else if ( state == OUT ) { state = IN; ++ wc; } ++ str; } return wc; }
int search ( int arr [ ], int n, int x ) { for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] == x ) return i; } return - 1; }
int maxLength ( char s [ ], int n ) { int invalidOpenBraces = 0; int invalidCloseBraces = 0; for ( int i = 0; i < n; i ++ ) { if ( s [ i ] == '(' ) { invalidOpenBraces ++; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++; } else { invalidOpenBraces --; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ); }
bool checkStackPermutation ( int ip [ ], int op [ ], int n ) { queue < int > input; for ( int i = 0; i < n; i ++ ) input . push ( ip [ i ] ); queue < int > output; for ( int i = 0; i < n; i ++ ) output . push ( op [ i ] ); stack < int > tempStack; while ( ! input . empty ( ) ) { int ele = input . front ( ); input . pop ( ); if ( ele == output . front ( ) ) { output . pop ( ); while ( ! tempStack . empty ( ) ) { if ( tempStack . top ( ) == output . front ( ) ) { tempStack . pop ( ); output . pop ( ); } else break; } } else tempStack . push ( ele ); } return ( input . empty ( ) && tempStack . empty ( ) ); }
void printFirstNegativeInteger ( int arr [ ], int n, int k ) { bool flag; for ( int i = 0; i < ( n - k + 1 ); i ++ ) { flag = false; for ( int j = 0; j < k; j ++ ) { if ( arr [ i + j ] < 0 ) { cout << arr [ i + j ] << " "; flag = true; break; } } if ( ! flag ) cout << "0" << " "; } }
int findRoot ( pair < int, int > arr [ ], int n ) { int root = 0; for ( int i = 0; i < n; i ++ ) root += ( arr [ i ] . first - arr [ i ] . second ); return root; }
int sumofsquare ( int n ) { int C [ n + 1 ] [ n + 1 ]; int i, j; for ( i = 0; i <= n; i ++ ) { for ( j = 0; j <= min ( i, n ); j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]; } } int sum = 0; for ( int i = 0; i <= n; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ); return sum; }
int getCount ( char keypad [ ] [ 3 ], int n ) { if ( keypad == NULL || n <= 0 ) return 0; if ( n == 1 ) return 10; int odd [ 10 ], even [ 10 ]; int i = 0, j = 0, useOdd = 0, totalCount = 0; for ( i = 0; i <= 9; i ++ ) odd [ i ] = 1; for ( j = 2; j <= n; j ++ ) { useOdd = 1 - useOdd; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ]; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ]; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ]; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ]; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ]; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ]; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ]; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ]; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ]; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ]; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ]; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ]; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ]; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ]; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ]; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ]; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ]; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ]; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ]; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ]; } } totalCount = 0; if ( useOdd == 1 ) { for ( i = 0; i <= 9; i ++ ) totalCount += even [ i ]; } else { for ( i = 0; i <= 9; i ++ ) totalCount += odd [ i ]; } return totalCount; }
bool areElementsContiguous ( int arr [ ], int n ) { unordered_set < int > us; for ( int i = 0; i < n; i ++ ) us . insert ( arr [ i ] ); int count = 1; int curr_ele = arr [ 0 ] - 1; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++; curr_ele --; } curr_ele = arr [ 0 ] + 1; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++; curr_ele ++; } return ( count == ( int ) ( us . size ( ) ) ); }
bool areElementsContiguous ( int arr [ ], int n ) { int max = * max_element ( arr, arr + n ); int min = * min_element ( arr, arr + n ); int m = max - min + 1; if ( m > n ) return false; bool visited [ m ]; memset ( visited, false, sizeof ( visited ) ); for ( int i = 0; i < n; i ++ ) visited [ arr [ i ] - min ] = true; for ( int i = 0; i < m; i ++ ) if ( visited [ i ] == false ) return false; return true; }
void rearrange ( int arr [ ], int n ) { int temp [ n ]; int small = 0, large = n - 1; int flag = true; for ( int i = 0; i < n; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ]; else temp [ i ] = arr [ small ++ ]; flag = ! flag; } for ( int i = 0; i < n; i ++ ) arr [ i ] = temp [ i ]; }
int sparseSearch ( string arr [ ], string x, int n ) { return binarySearch ( arr, 0, n - 1, x ); }
int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN; for ( int a = 0; a < N - 1; a ++ ) for ( int b = 0; b < N - 1; b ++ ) for ( int d = a + 1; d < N; d ++ ) for ( int e = b + 1; e < N; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ]; return maxValue; }
int solve ( int a [ ], int b [ ], int n ) { int i; long long int s = 0; for ( i = 0; i < n; i ++ ) s += ( a [ i ] + b [ i ] ); if ( n == 1 ) return a [ 0 ] + b [ 0 ]; if ( s % n != 0 ) return - 1; int x = s / n; for ( i = 0; i < n; i ++ ) { if ( a [ i ] > x ) return - 1; if ( i > 0 ) { a [ i ] += b [ i - 1 ]; b [ i - 1 ] = 0; } if ( a [ i ] == x ) continue; int y = a [ i ] + b [ i ]; if ( i + 1 < n ) y += b [ i + 1 ]; if ( y == x ) { a [ i ] = y; b [ i ] = b [ i + 1 ] = 0; continue; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ]; b [ i ] = 0; continue; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ]; b [ i + 1 ] = 0; continue; } return - 1; } for ( i = 0; i < n; i ++ ) if ( b [ i ] != 0 ) return - 1; return x; }
void digitsNum ( int N ) { if ( N == 0 ) cout << "0\n"; if ( N % 9 != 0 ) cout << ( N % 9 ); for ( int i = 1; i <= ( N / 9 ); ++ i ) cout << "9"; for ( int i = 1; i <= N; ++ i ) cout << "0"; cout << "\n"; }
void direction ( ll R, ll C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { cout << "Left" << endl; return; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { cout << "Up" << endl; return; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { cout << "Right" << endl; return; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { cout << "Left" << endl; return; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { cout << "Right" << endl; return; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { cout << "Down" << endl; return; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { cout << "Left" << endl; return; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { cout << "Up" << endl; return; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { cout << "Down" << endl; return; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { cout << "Right" << endl; return; } }
int minimumflip ( int mat [ ] [ N ], int n ) { int transpose [ n ] [ n ]; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < n; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ]; int flip = 0; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < n; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++; return flip / 2; }
int findHeight ( int * parent, int n ) { int res = 0; for ( int i = 0; i < n; i ++ ) { int p = i, current = 1; while ( parent [ p ] != - 1 ) { current ++; p = parent [ p ]; } res = max ( res, current ); } return res; }
void NFG ( int a [ ], int n, int freq [ ] ) { stack < int > s; s . push ( 0 ); int res [ n ] = { 0 }; for ( int i = 1; i < n; i ++ ) { if ( freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ); else { while ( freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ] && ! s . empty ( ) ) { res [ s . top ( ) ] = a [ i ]; s . pop ( ); } s . push ( i ); } } while ( ! s . empty ( ) ) { res [ s . top ( ) ] = - 1; s . pop ( ); } for ( int i = 0; i < n; i ++ ) { cout << res [ i ] << " "; } }
int minRotation ( int input, int unlock_code ) { int rotation = 0; int input_digit, code_digit; while ( input || unlock_code ) { input_digit = input % 10; code_digit = unlock_code % 10; rotation += min ( abs ( input_digit - code_digit ), 10 - abs ( input_digit - code_digit ) ); input /= 10; unlock_code /= 10; } return rotation; }
int smallest ( int x, int y, int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z; return ( ! ( x / z ) ) ? x : z; }
void LeibnizHarmonicTriangle ( int n ) { int C [ n + 1 ] [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) { for ( int j = 0; j <= min ( i, n ); j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]; } } for ( int i = 1; i <= n; i ++ ) { for ( int j = 1; j <= i; j ++ ) cout << "1/" << i * C [ i - 1 ] [ j - 1 ] << " "; cout << endl; } }
int addOne ( int x ) { return ( - ( ~ x ) ); }
int sumOfSeries ( int n ) { int sum = 0; for ( int i = 1; i <= n; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ); return sum; }
int countwalks ( int graph [ ] [ V ], int u, int v, int k ) { if ( k == 0 && u == v ) return 1; if ( k == 1 && graph [ u ] [ v ] ) return 1; if ( k <= 0 ) return 0; int count = 0; for ( int i = 0; i < V; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph, i, v, k - 1 ); return count; }
int numberOfPaths ( int m, int n ) { int dp [ n ] = { 1 }; dp [ 0 ] = 1; for ( int i = 0; i < m; i ++ ) { for ( int j = 1; j < n; j ++ ) { dp [ j ] += dp [ j - 1 ]; } } return dp [ n - 1 ]; }
int remAnagram ( string str1, string str2 ) { int count1 [ CHARS ] = { 0 }, count2 [ CHARS ] = { 0 }; for ( int i = 0; str1 [ i ] != '\0'; i ++ ) count1 [ str1 [ i ] - 'a' ] ++; for ( int i = 0; str2 [ i ] != '\0'; i ++ ) count2 [ str2 [ i ] - 'a' ] ++; int result = 0; for ( int i = 0; i < 26; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ); return result; }
int sumofoddFactors ( int n ) { int res = 1; while ( n % 2 == 0 ) n = n / 2; for ( int i = 3; i <= sqrt ( n ); i ++ ) { int count = 0, curr_sum = 1; int curr_term = 1; while ( n % i == 0 ) { count ++; n = n / i; curr_term *= i; curr_sum += curr_term; } res *= curr_sum; } if ( n >= 2 ) res *= ( 1 + n ); return res; }
int dealnnoy ( int n, int m ) { int dp [ m + 1 ] [ n + 1 ]; for ( int i = 0; i <= m; i ++ ) dp [ i ] [ 0 ] = 1; for ( int i = 0; i <= m; i ++ ) dp [ 0 ] [ i ] = 1; for ( int i = 1; i <= m; i ++ ) for ( int j = 1; j <= n; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ]; return dp [ m ] [ n ]; }
void myCopy ( char s1 [ ], char s2 [ ] ) { int i = 0; for ( i = 0; s1 [ i ] != '\0'; i ++ ) s2 [ i ] = s1 [ i ]; s2 [ i ] = '\0'; }
void psuedoBinary ( int n ) { while ( n > 0 ) { int temp = n, m = 0, p = 1; while ( temp ) { int rem = temp % 10; temp = temp / 10; if ( rem != 0 ) m += p; p *= 10; } cout << m << " "; n = n - m; } }
int playGame ( int arr [ ], int n ) { unordered_set < int > hash; for ( int i = 0; i < n; i ++ ) hash . insert ( arr [ i ] ); return ( hash . size ( ) % 2 == 0 ? 1 : 2 ); }
int SieveOfSundaram ( int n ) { int nNew = ( n - 2 ) / 2; bool marked [ nNew + 1 ]; memset ( marked, false, sizeof ( marked ) ); for ( int i = 1; i <= nNew; i ++ ) for ( int j = i; ( i + j + 2 * i * j ) <= nNew; j ++ ) marked [ i + j + 2 * i * j ] = true; if ( n > 2 ) cout << 2 << " "; for ( int i = 1; i <= nNew; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << " "; }
int findLength ( string str, int n ) { int ans = 0; for ( int i = 0; i <= n - 2; i ++ ) { int l = i, r = i + 1; int lsum = 0, rsum = 0; while ( r < n && l >= 0 ) { lsum += str [ l ] - '0'; rsum += str [ r ] - '0'; if ( lsum == rsum ) ans = max ( ans, r - l + 1 ); l --; r ++; } } return ans; }
int sumAtKthLevel ( string tree, int k ) { int level = - 1; int sum = 0; int n = tree . length ( ); for ( int i = 0; i < n; i ++ ) { if ( tree [ i ] == '(' ) level ++; else if ( tree [ i ] == ')' ) level --; else { if ( level == k ) sum += ( tree [ i ] - '0' ); } } return sum; }
bool isSubset ( int arr1 [ ], int arr2 [ ], int m, int n ) { int i = 0, j = 0; if ( m < n ) return 0; sort ( arr1, arr1 + m ); sort ( arr2, arr2 + n ); while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) j ++; else if ( arr1 [ j ] == arr2 [ i ] ) { j ++; i ++; } else if ( arr1 [ j ] > arr2 [ i ] ) return 0; } return ( i < n ) ? false : true; }
bool isComposite ( int n ) { if ( n <= 1 ) return false; if ( n <= 3 ) return false; if ( n % 2 == 0 || n % 3 == 0 ) return true; for ( int i = 5; i * i <= n; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true; return false; }
int maxProd ( int n ) { if ( n == 0 || n == 1 ) return 0; int max_val = 0; for ( int i = 1; i < n; i ++ ) max_val = max ( max_val, i * ( n - i ), maxProd ( n - i ) * i ); return max_val; }
int findMaximum ( int arr [ ], int low, int high ) { if ( low == high ) return arr [ low ]; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ]; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ]; int mid = ( low + high ) / 2; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ]; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr, low, mid - 1 ); else return findMaximum ( arr, mid + 1, high ); }
int solveQuery ( int start, int end, int arr [ ] ) { unordered_map < int, int > frequency; for ( int i = start; i <= end; i ++ ) frequency [ arr [ i ] ] ++; int count = 0; for ( auto x : frequency ) if ( x . first == x . second ) count ++; return count; }
void sort012 ( int a [ ], int arr_size ) { int lo = 0; int hi = arr_size - 1; int mid = 0; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( a [ lo ++ ], a [ mid ++ ] ); break; case 1 : mid ++; break; case 2 : swap ( a [ mid ], a [ hi -- ] ); break; } } }
bool match ( char * first, char * second ) { if ( * first == '\0' && * second == '\0' ) return true; if ( * first == '*' && * ( first + 1 ) != '\0' && * second == '\0' ) return false; if ( * first == '?' || * first == * second ) return match ( first + 1, second + 1 ); if ( * first == '*' ) return match ( first + 1, second ) || match ( first, second + 1 ); return false; }
int findRepeatingElement ( int arr [ ], int low, int high ) { if ( low > high ) return - 1; int mid = ( low + high ) / 2; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid; return findRepeatingElement ( arr, low, mid - 1 ); } return findRepeatingElement ( arr, mid + 1, high ); }
int areaSquare ( int side ) { int area = side * side; return area; }
int countPairs ( int arr [ ], int n ) { int result = 0; set < int > Hash; for ( int i = 0; i < n; i ++ ) Hash . insert ( arr [ i ] ); for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { int product = arr [ i ] * arr [ j ]; if ( Hash . find ( product ) != Hash . end ( ) ) result ++; } } return result; }
bool isPossible ( int n, int index, int sum, int M, int arr [ ], int dp [ ] [ MAX ] ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true; return false; } if ( dp [ index ] [ sum ] != - 1 ) return dp [ index ] [ sum ]; bool placeAdd = isPossible ( n, index + 1, sum + arr [ index ], M, arr, dp ); bool placeMinus = isPossible ( n, index + 1, sum - arr [ index ], M, arr, dp ); bool res = ( placeAdd || placeMinus ); dp [ index ] [ sum ] = res; return res; }
int lcsOf3 ( int i, int j, int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) return 0; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ]; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1, j - 1, k - 1 ); else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1, j, k ), lcsOf3 ( i, j - 1, k ) ), lcsOf3 ( i, j, k - 1 ) ); }
void divisibilityCheck ( int arr [ ], int n ) { unordered_set < int > s; int max_ele = INT_MIN; for ( int i = 0; i < n; i ++ ) { s . insert ( arr [ i ] ); max_ele = max ( max_ele, arr [ i ] ); } unordered_set < int > res; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2; j <= max_ele; j += arr [ i ] ) { if ( s . find ( j ) != s . end ( ) ) res . insert ( j ); } } } unordered_map < int, int > mp; for ( int i = 0; i < n; i ++ ) mp [ arr [ i ] ] ++; unordered_map < int, int > :: iterator it; vector < int > ans; for ( it = mp . begin ( ); it != mp . end ( ); it ++ ) { if ( it -> second >= 2 ) { if ( res . find ( it -> first ) == res . end ( ) ) { int val = it -> second; while ( val -- ) ans . push_back ( it -> first ); } } if ( res . find ( it -> first ) != res . end ( ) ) { int val = it -> second; while ( val -- ) ans . push_back ( it -> first ); } } for ( auto x : ans ) cout << x << " "; }
bool isPossible ( string str, int n ) { int len = str . length ( ); if ( len >= n ) return true; return false; }
int getMissingNo ( int a [ ], int n ) { int x1 = a [ 0 ]; int x2 = 1; for ( int i = 1; i < n; i ++ ) x1 = x1 ^ a [ i ]; for ( int i = 2; i <= n + 1; i ++ ) x2 = x2 ^ i; return ( x1 ^ x2 ); }
bool canMakeStr2 ( string str1, string str2 ) { int count [ MAX ] = { 0 }; for ( int i = 0; i < str1 . length ( ); i ++ ) count [ str1 [ i ] ] ++; for ( int i = 0; i < str2 . length ( ); i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false; count [ str2 [ i ] ] --; } return true; }
int minSum ( int a [ ], int n ) { sort ( a, a + n ); int num1 = 0; int num2 = 0; for ( int i = 0; i < n; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ]; else num2 = num2 * 10 + a [ i ]; } return num2 + num1; }
void findMissing ( int a [ ], int b [ ], int n, int m ) { unordered_set < int > s; for ( int i = 0; i < m; i ++ ) s . insert ( b [ i ] ); for ( int i = 0; i < n; i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " "; }
int calcMaxValue ( string str ) { int res = str [ 0 ] - '0'; for ( int i = 1; i < str . length ( ); i ++ ) { if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) res += ( str [ i ] - '0' ); else res *= ( str [ i ] - '0' ); } return res; }
void findMax ( int arr [ ] [ N ] ) { int row = 0, i, j; for ( i = 0, j = N - 1; i < N; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i; j --; } } cout << "Row number = " << row + 1; cout << ", MaxCount = " << N - 1 - j; }
bool ispalindrome ( string s ) { int l = s . length ( ); int j; for ( int i = 0, j = l - 1; i <= j; i ++, j -- ) { if ( s [ i ] != s [ j ] ) return false; } return true; }
int numofsubset ( int arr [ ], int n ) { sort ( arr, arr + n ); int count = 1; for ( int i = 0; i < n - 1; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++; } return count; }
int countSol ( int coeff [ ], int n, int rhs ) { int dp [ rhs + 1 ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] = 1; for ( int i = 0; i < n; i ++ ) for ( int j = coeff [ i ]; j <= rhs; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ]; return dp [ rhs ]; }
int findMinRooms ( string slots [ ], int n, int m ) { int counts [ m ] = { 0 }; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++; return * max_element ( counts, counts + m ); }
int countEndless ( bool input [ ] [ MAX ], int n ) { bool row [ n ] [ n ], col [ n ] [ n ]; for ( int j = 0; j < n; j ++ ) { bool isEndless = 1; for ( int i = n - 1; i >= 0; i -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0; col [ i ] [ j ] = isEndless; } } for ( int i = 0; i < n; i ++ ) { bool isEndless = 1; for ( int j = n - 1; j >= 0; j -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0; row [ i ] [ j ] = isEndless; } } int ans = 0; for ( int i = 0; i < n; i ++ ) for ( int j = 1; j < n; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++; return ans; }
int breakSum ( int n ) { int dp [ n + 1 ]; dp [ 0 ] = 0, dp [ 1 ] = 1; for ( int i = 2; i <= n; i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ], i ); return dp [ n ]; }
int countPS ( string str ) { int N = str . length ( ); int cps [ N + 1 ] [ N + 1 ]; memset ( cps, 0, sizeof ( cps ) ); for ( int i = 0; i < N; i ++ ) cps [ i ] [ i ] = 1; for ( int L = 2; L <= N; L ++ ) { for ( int i = 0; i < N; i ++ ) { int k = L + i - 1; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ]; } } return cps [ 0 ] [ N - 1 ]; }
int findLongestRepeatingSubSeq ( string str ) { int n = str . length ( ); int dp [ n + 1 ] [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) for ( int j = 0; j <= n; j ++ ) dp [ i ] [ j ] = 0; for ( int i = 1; i <= n; i ++ ) { for ( int j = 1; j <= n; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] ); } } return dp [ n ] [ n ]; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0; if ( n && ! ( n & ( n - 1 ) ) ) return n; while ( n != 0 ) { n >>= 1; count += 1; } return 1 << count; }
int findDiff ( int arr [ ], int n ) { unordered_map < int, int > hm; for ( int i = 0; i < n; i ++ ) hm [ arr [ i ] ] ++; int max_count = 0, min_count = n; for ( auto x : hm ) { max_count = max ( max_count, x . second ); min_count = min ( min_count, x . second ); } return ( max_count - min_count ); }
int minPerimeter ( int n ) { int l = sqrt ( n ); int sq = l * l; if ( sq == n ) return l * 4; else { long long int row = n / l; long long int perimeter = 2 * ( l + row ); if ( n % l != 0 ) perimeter += 2; return perimeter; } }
int maxLower ( string str ) { int n = str . length ( ); int i = 0; for (; i < n; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { i ++; break; } } int maxCount = 0; int count [ MAX_CHAR ] = { 0 }; for (; i < n; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { int currCount = 0; for ( int j = 0; j < MAX_CHAR; j ++ ) if ( count [ j ] > 0 ) currCount ++; maxCount = max ( maxCount, currCount ); memset ( count, 0, sizeof ( count ) ); } if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) count [ str [ i ] - 'a' ] ++; } return maxCount; }
bool isMagicSquare ( int mat [ ] [ N ] ) { int sum = 0, sum2 = 0; for ( int i = 0; i < N; i ++ ) sum = sum + mat [ i ] [ i ]; for ( int i = 0; i < N; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ]; if ( sum != sum2 ) return false; for ( int i = 0; i < N; i ++ ) { int rowSum = 0; for ( int j = 0; j < N; j ++ ) rowSum += mat [ i ] [ j ]; if ( rowSum != sum ) return false; } for ( int i = 0; i < N; i ++ ) { int colSum = 0; for ( int j = 0; j < N; j ++ ) colSum += mat [ j ] [ i ]; if ( sum != colSum ) return false; } return true; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ], int N, int k ) { int maxSum = 0; sort ( arr, arr + N ); for ( int i = N - 1; i > 0; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ]; maxSum += arr [ i - 1 ]; -- i; } } return maxSum; }
ll calculate ( ll a [ ], ll n ) { sort ( a, a + n ); vector < ll > s; for ( int i = 0, j = n - 1; i < j; i ++, j -- ) s . push_back ( a [ i ] + a [ j ] ); ll mini = * min_element ( s . begin ( ), s . end ( ) ); ll maxi = * max_element ( s . begin ( ), s . end ( ) ); return abs ( maxi - mini ); }
long long int MaximumDecimalValue ( int mat [ ] [ N ], int n ) { int dp [ n ] [ n ]; memset ( dp, 0, sizeof ( dp ) ); if ( mat [ 0 ] [ 0 ] == 1 ) dp [ 0 ] [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2, i ); else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]; } for ( int i = 1; i < n; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2, i ); else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]; } for ( int i = 1; i < n; i ++ ) { for ( int j = 1; j < n; j ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] ) + pow ( 2, i + j ); else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] ); } } return dp [ n - 1 ] [ n - 1 ]; }
int maxvolume ( int s ) { int length = s / 3; s -= length; int breadth = s / 2; int height = s - breadth; return length * breadth * height; }
int getSingle ( int arr [ ], int n ) { int ones = 0, twos = 0; int common_bit_mask; for ( int i = 0; i < n; i ++ ) { twos = twos | ( ones & arr [ i ] ); ones = ones ^ arr [ i ]; common_bit_mask = ~ ( ones & twos ); ones &= common_bit_mask; twos &= common_bit_mask; } return ones; }
long exponentiation ( long base, long exp ) { long t = 1L; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N; base = ( base * base ) % N; exp /= 2; } return t % N; }
void middlesum ( int mat [ ] [ MAX ], int n ) { int row_sum = 0, col_sum = 0; for ( int i = 0; i < n; i ++ ) row_sum += mat [ n / 2 ] [ i ]; cout << "Sum of middle row = " << row_sum << endl; for ( int i = 0; i < n; i ++ ) col_sum += mat [ i ] [ n / 2 ]; cout << "Sum of middle column = " << col_sum; }
long long int MaxDotProduct ( int A [ ], int B [ ], int m, int n ) { long long int dp [ n + 1 ] [ m + 1 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 1; i <= n; i ++ ) for ( int j = i; j <= m; j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ), dp [ i ] [ j - 1 ] ); return dp [ n ] [ m ]; }
void Round_off ( double N, double n ) { int h; double l, a, b, c, d, e, i, j, m, f, g; b = N; c = floor ( N ); for ( i = 0; b >= 1; ++ i ) b = b / 10; d = n - i; b = N; b = b * pow ( 10, d ); e = b + 0.5; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ( ceil ( b ) ); h = f - 2; if ( h % 2 != 0 ) { e = e - 1; } } j = floor ( e ); m = pow ( 10, d ); j = j / m; cout << "The number after rounding-off is " << j; }
int difference ( int arr [ ] [ MAX ], int n ) { int d1 = 0, d2 = 0; for ( int i = 0; i < n; i ++ ) { d1 += arr [ i ] [ i ]; d2 += arr [ i ] [ n - i - 1 ]; } return abs ( d1 - d2 ); }
int summingSeries ( long n ) { return pow ( n, 2 ); }
bool areDisjoint ( int set1 [ ], int set2 [ ], int m, int n ) { sort ( set1, set1 + m ); sort ( set2, set2 + n ); int i = 0, j = 0; while ( i < m && j < n ) { if ( set1 [ i ] < set2 [ j ] ) i ++; else if ( set2 [ j ] < set1 [ i ] ) j ++; else return false; } return true; }
int countUnique ( int mat [ ] [ MAX ], int n, int m ) { int rowsum [ n ], colsum [ m ]; memset ( colsum, 0, sizeof ( colsum ) ); memset ( rowsum, 0, sizeof ( rowsum ) ); for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) if ( mat [ i ] [ j ] ) { rowsum [ i ] ++; colsum [ j ] ++; } int uniquecount = 0; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++; return uniquecount; }
void solve ( int i, int par, int a [ ], int n, int k, int current_ans ) { if ( par > k ) return; if ( par == k && i == n - 1 ) { ans = min ( ans, current_ans ); return; } for ( int j = i + 1; j < n; j ++ ) solve ( j, par + 1, a, n, k, current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ); }
int sum ( int a [ ], int n ) { unordered_map < int, int > cnt; int ans = 0, pre_sum = 0; for ( int i = 0; i < n; i ++ ) { ans += ( i * a [ i ] ) - pre_sum; pre_sum += a [ i ]; if ( cnt [ a [ i ] - 1 ] ) ans -= cnt [ a [ i ] - 1 ]; if ( cnt [ a [ i ] + 1 ] ) ans += cnt [ a [ i ] + 1 ]; cnt [ a [ i ] ] ++; } return ans; }
int findSmallest ( int arr [ ], int n ) { int res = 1; for ( int i = 0; i < n && arr [ i ] <= res; i ++ ) res = res + arr [ i ]; return res; }
int subsetGraph ( int C [ ] [ N ] ) { set < int > vertices; for ( int i = 0; i < N; ++ i ) vertices . insert ( i ); while ( ! vertices . empty ( ) ) { if ( vertices . size ( ) == 1 ) return 1; bool someone_removed = false; for ( int x : vertices ) { set < int > values; for ( int y : vertices ) if ( y != x ) values . insert ( C [ x ] [ y ] ); if ( values . size ( ) == 1 ) { vertices . erase ( x ); someone_removed = true; break; } } if ( ! someone_removed ) break; } return ( vertices . size ( ) ); }
string censor ( string text, string word ) { vector < string > word_list; boost :: split ( word_list, text, boost :: is_any_of ( "\\ +" ) ); string result = ""; string stars = ""; for ( int i = 0; i < word . size ( ); i ++ ) stars += '*'; int index = 0; for ( string i : word_list ) { if ( i . compare ( word ) == 0 ) { word_list [ index ] = stars; } index ++; } for ( string i : word_list ) { result += i + ' '; } return result; }
void bitonicGenerator ( int arr [ ], int n ) { int i = 1; int j = n - 1; if ( j % 2 != 0 ) j --; while ( i < j ) { swap ( arr [ i ], arr [ j ] ); i += 2; j -= 2; } sort ( arr, arr + ( n + 1 ) / 2 ); sort ( arr + ( n + 1 ) / 2, arr + n, greater < int > ( ) ); }
int getSingle ( int arr [ ], int n ) { int result = 0; int x, sum; for ( int i = 0; i < INT_SIZE; i ++ ) { sum = 0; x = ( 1 << i ); for ( int j = 0; j < n; j ++ ) { if ( arr [ j ] & x ) sum ++; } if ( sum % 3 ) result |= x; } return result; }
ll mulmod ( ll a, ll b, ll mod ) { ll res = 0; a = a % mod; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod; a = ( a * 2 ) % mod; b /= 2; } return res % mod; }
void manipulated_seive ( int N ) { isprime [ 0 ] = isprime [ 1 ] = false; for ( long long int i = 2; i < N; i ++ ) { if ( isprime [ i ] ) { prime . push_back ( i ); SPF [ i ] = i; } for ( long long int j = 0; j < ( int ) prime . size ( ) && i * prime [ j ] < N && prime [ j ] <= SPF [ i ]; j ++ ) { isprime [ i * prime [ j ] ] = false; SPF [ i * prime [ j ] ] = prime [ j ]; } } }
void bubbleSort ( int arr [ ], int n ) { int i, j; bool swapped; for ( i = 0; i < n - 1; i ++ ) { swapped = false; for ( j = 0; j < n - i - 1; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( & arr [ j ], & arr [ j + 1 ] ); swapped = true; } } if ( swapped == false ) break; } }
int numberOfPermWithKInversion ( int N, int K ) { if ( N == 0 ) return 0; if ( K == 0 ) return 1; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ]; int sum = 0; for ( int i = 0; i <= K; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1, K - i ); } memo [ N ] [ K ] = sum; return sum; }
int removeConsecutiveSame ( vector < string > v ) { stack < string > st; for ( int i = 0; i < v . size ( ); i ++ ) { if ( st . empty ( ) ) st . push ( v [ i ] ); else { string str = st . top ( ); if ( str . compare ( v [ i ] ) == 0 ) st . pop ( ); else st . push ( v [ i ] ); } } return st . size ( ); }
char findExtraCharcter ( string strA, string strB ) { int res = 0, i; for ( i = 0; i < strA . length ( ); i ++ ) { res ^= strA [ i ]; } for ( i = 0; i < strB . length ( ); i ++ ) { res ^= strB [ i ]; } return ( ( char ) ( res ) ); }
void bestApproximate ( int x [ ], int y [ ], int n ) { float m, c, sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0; for ( int i = 0; i < n; i ++ ) { sum_x += x [ i ]; sum_y += y [ i ]; sum_xy += x [ i ] * y [ i ]; sum_x2 += pow ( x [ i ], 2 ); } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x, 2 ) ); c = ( sum_y - m * sum_x ) / n; cout << "m =" << m; cout << "\nc =" << c; }
int countFriendsPairings ( int n ) { int dp [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) { if ( i <= 2 ) dp [ i ] = i; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]; } return dp [ n ]; }
void reverse ( char str [ ] ) { int n = strlen ( str ), i; for ( i = 0; i < n / 2; i ++ ) swap ( & str [ i ], & str [ n - i - 1 ] ); }
public : int power ( int x, unsigned int y ) { if ( y == 0 ) return 1; else if ( y % 2 == 0 ) return power ( x, y / 2 ) * power ( x, y / 2 ); else return x * power ( x, y / 2 ) * power ( x, y / 2 ); }
void zodiac_sign ( int day, string month ) { string astro_sign = ""; if ( month == "december" ) { if ( day < 22 ) astro_sign = "Sagittarius"; else astro_sign = "capricorn"; } else if ( month == "january" ) { if ( day < 20 ) astro_sign = "Capricorn"; else astro_sign = "aquarius"; } else if ( month == "february" ) { if ( day < 19 ) astro_sign = "Aquarius"; else astro_sign = "pisces"; } else if ( month == "march" ) { if ( day < 21 ) astro_sign = "Pisces"; else astro_sign = "aries"; } else if ( month == "april" ) { if ( day < 20 ) astro_sign = "Aries"; else astro_sign = "taurus"; } else if ( month == "may" ) { if ( day < 21 ) astro_sign = "Taurus"; else astro_sign = "gemini"; } else if ( month == "june" ) { if ( day < 21 ) astro_sign = "Gemini"; else astro_sign = "cancer"; } else if ( month == "july" ) { if ( day < 23 ) astro_sign = "Cancer"; else astro_sign = "leo"; } else if ( month == "august" ) { if ( day < 23 ) astro_sign = "Leo"; else astro_sign = "virgo"; } else if ( month == "september" ) { if ( day < 23 ) astro_sign = "Virgo"; else astro_sign = "libra"; } else if ( month == "october" ) { if ( day < 23 ) astro_sign = "Libra"; else astro_sign = "scorpio"; } else if ( month == "november" ) { if ( day < 22 ) astro_sign = "scorpio"; else astro_sign = "sagittarius"; } cout << astro_sign; }
int turnOffK ( int n, int k ) { if ( k <= 0 ) return n; return ( n & ~ ( 1 << ( k - 1 ) ) ); }
void maxOverlap ( vector < int > & start, vector < int > & end ) { int n = start . size ( ); int maxa = * max_element ( start . begin ( ), start . end ( ) ); int maxb = * max_element ( end . begin ( ), end . end ( ) ); int maxc = max ( maxa, maxb ); int x [ maxc + 2 ]; memset ( x, 0, sizeof x ); int cur = 0, idx; for ( int i = 0; i < n; i ++ ) { ++ x [ start [ i ] ]; -- x [ end [ i ] + 1 ]; } int maxy = INT_MIN; for ( int i = 0; i <= maxc; i ++ ) { cur += x [ i ]; if ( maxy < cur ) { maxy = cur; idx = i; } } cout << "Maximum value is " << maxy << " at position " << idx << endl; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ]; if ( n == 0 ) return sum [ n ] = 0; if ( n == 1 ) return sum [ n ] = arr [ 0 ]; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ]; return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ), maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ), arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ); }
int findIndex ( int n ) { if ( n <= 1 ) return n; int a = 0, b = 1, c = 1; int res = 1; while ( c < n ) { c = a + b; res ++; a = b; b = c; } return res; }
int findSum ( int N, int K ) { int ans = 0; for ( int i = 1; i <= N; i ++ ) ans += ( i % K ); return ans; }
int subset ( int arr [ ], int n ) { unordered_map < int, int > mp; for ( int i = 0; i < n; i ++ ) mp [ arr [ i ] ] ++; int res = 0; for ( auto x : mp ) res = max ( res, x . second ); return res; }
float findArea ( float a ) { float area; area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4; return area; }
void timeToMeet ( double s, double v ) { double V = 3 * v / 2; double time = s / V; cout << time; }
void printSquares ( int n ) { int square = 0, odd = 1; for ( int x = 0; x < n; x ++ ) { cout << square << " "; square = square + odd; odd = odd + 2; } }
int lps ( string & s ) { int n = s . length ( ); int a [ n ]; for ( int i = n - 1; i >= 0; i -- ) { int back_up = 0; for ( int j = i; j < n; j ++ ) { if ( j == i ) a [ j ] = 1; else if ( s [ i ] == s [ j ] ) { int temp = a [ j ]; a [ j ] = back_up + 2; back_up = temp; } else { back_up = a [ j ]; a [ j ] = max ( a [ j - 1 ], a [ j ] ); } } } return a [ n - 1 ]; }
int LCIS ( int arr1 [ ], int n, int arr2 [ ], int m ) { int table [ m ]; for ( int j = 0; j < m; j ++ ) table [ j ] = 0; for ( int i = 0; i < n; i ++ ) { int current = 0; for ( int j = 0; j < m; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ]; } } int result = 0; for ( int i = 0; i < m; i ++ ) if ( table [ i ] > result ) result = table [ i ]; return result; }
int gcdOfFactorial ( int m, int n ) { return factorial ( min ( m, n ) ); }
int longestSubseqWithDiffOne ( int arr [ ], int n ) { int dp [ n ]; for ( int i = 0; i < n; i ++ ) dp [ i ] = 1; for ( int i = 1; i < n; i ++ ) { for ( int j = 0; j < i; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); } } int result = 1; for ( int i = 0; i < n; i ++ ) if ( result < dp [ i ] ) result = dp [ i ]; return result; }
int countPairs ( int a [ ], int n ) { int count = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2; } return count; }
void splitString ( string str ) { string alpha, num, special; for ( int i = 0; i < str . length ( ); i ++ ) { if ( isdigit ( str [ i ] ) ) num . push_back ( str [ i ] ); else if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( str [ i ] >= 'a' && str [ i ] <= 'z' ) ) alpha . push_back ( str [ i ] ); else special . push_back ( str [ i ] ); } cout << alpha << endl; cout << num << endl; cout << special << endl; }
int maxSum ( int stack1 [ ], int stack2 [ ], int stack3 [ ], int n1, int n2, int n3 ) { int sum1 = 0, sum2 = 0, sum3 = 0; for ( int i = 0; i < n1; i ++ ) sum1 += stack1 [ i ]; for ( int i = 0; i < n2; i ++ ) sum2 += stack2 [ i ]; for ( int i = 0; i < n3; i ++ ) sum3 += stack3 [ i ]; int top1 = 0, top2 = 0, top3 = 0; int ans = 0; while ( 1 ) { if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0; if ( sum1 == sum2 && sum2 == sum3 ) return sum1; if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ]; else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ]; else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ]; } }
int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ); }
int countPairs ( string s ) { int cnt [ MAX ] = { 0 }; for ( int i = 0; i < s . length ( ); i ++ ) cnt [ s [ i ] ] ++; int ans = 0; for ( int i = 0; i < MAX; i ++ ) ans += cnt [ i ] * cnt [ i ]; return ans; }
int maximumDifferenceSum ( int arr [ ], int N ) { int dp [ N ] [ 2 ]; for ( int i = 0; i < N; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0; for ( int i = 0; i < ( N - 1 ); i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ], dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ); dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ), dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ); } return max ( dp [ N - 1 ] [ 0 ], dp [ N - 1 ] [ 1 ] ); }
int gcd ( int a, int b ) { if ( a == 0 ) return b; return gcd ( b % a, a ); }
void productArray ( int arr [ ], int n ) { if ( n == 1 ) { cout << 0; return; } int * left = new int [ sizeof ( int ) * n ]; int * right = new int [ sizeof ( int ) * n ]; int * prod = new int [ sizeof ( int ) * n ]; int i, j; left [ 0 ] = 1; right [ n - 1 ] = 1; for ( i = 1; i < n; i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ]; for ( j = n - 2; j >= 0; j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ]; for ( i = 0; i < n; i ++ ) prod [ i ] = left [ i ] * right [ i ]; for ( i = 0; i < n; i ++ ) cout << prod [ i ] << " "; return; }
int maxGameByWinner ( int N ) { int dp [ N ]; dp [ 0 ] = 1; dp [ 1 ] = 2; int i = 2; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; } while ( dp [ i ++ ] <= N ); return ( i - 2 ); }
int numOfways ( int n, int k ) { int p = 1; if ( k % 2 ) p = - 1; return ( pow ( n - 1, k ) + p * ( n - 1 ) ) / n; }
int findMaxSegment ( string & s, int k ) { int seg_len = s . length ( ) - k; int res = 0; for ( int i = 0; i < seg_len; i ++ ) res = res * 10 + ( s [ i ] - '0' ); int seg_len_pow = pow ( 10, seg_len - 1 ); int curr_val = res; for ( int i = 1; i <= ( s . length ( ) - seg_len ); i ++ ) { curr_val = curr_val - ( s [ i - 1 ] - '0' ) * seg_len_pow; curr_val = curr_val * 10 + ( s [ i + seg_len - 1 ] - '0' ); res = max ( res, curr_val ); } return res; }
bool isDivisibleBy10 ( string bin ) { int n = bin . size ( ); if ( bin [ n - 1 ] == '1' ) return false; int sum = 0; for ( int i = n - 2; i >= 0; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1; if ( posFromRight % 4 == 1 ) sum = sum + 2; else if ( posFromRight % 4 == 2 ) sum = sum + 4; else if ( posFromRight % 4 == 3 ) sum = sum + 8; else if ( posFromRight % 4 == 0 ) sum = sum + 6; } } if ( sum % 10 == 0 ) return true; return false; }
int findMaxPoints ( int A [ ] [ M ] ) { int P1S [ M + 1 ] [ N + 1 ], P1E [ M + 1 ] [ N + 1 ]; memset ( P1S, 0, sizeof ( P1S ) ); memset ( P1E, 0, sizeof ( P1E ) ); int P2S [ M + 1 ] [ N + 1 ], P2E [ M + 1 ] [ N + 1 ]; memset ( P2S, 0, sizeof ( P2S ) ); memset ( P2E, 0, sizeof ( P2E ) ); for ( int i = 1; i <= N; i ++ ) for ( int j = 1; j <= M; j ++ ) P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ], P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]; for ( int i = N; i >= 1; i -- ) for ( int j = M; j >= 1; j -- ) P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ], P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]; for ( int i = N; i >= 1; i -- ) for ( int j = 1; j <= M; j ++ ) P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ], P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]; for ( int i = 1; i <= N; i ++ ) for ( int j = M; j >= 1; j -- ) P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ], P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]; int ans = 0; for ( int i = 2; i < N; i ++ ) { for ( int j = 2; j < M; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ]; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ]; ans = max ( ans, max ( op1, op2 ) ); } } return ans; }
int countStrs ( int n ) { long int dp [ n + 1 ] [ 27 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 0; i <= 25; i ++ ) dp [ 1 ] [ i ] = 1; for ( int i = 2; i <= n; i ++ ) { for ( int j = 0; j <= 25; j ++ ) if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]; else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ); } long int sum = 0; for ( int i = 0; i <= 25; i ++ ) sum = ( sum + dp [ n ] [ i ] ); return sum; }
int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ); }
void fib ( int n ) { int a = 0, b = 1, c; if ( n >= 0 ) cout << a << " "; if ( n >= 1 ) cout << b << " "; for ( int i = 2; i <= n; i ++ ) { c = a + b; cout << c << " "; a = b; b = c; } }
void printSubsequences ( int arr [ ], int n ) { unsigned int opsize = pow ( 2, n ); for ( int counter = 1; counter < opsize; counter ++ ) { for ( int j = 0; j < n; j ++ ) { if ( counter & ( 1 << j ) ) cout << arr [ j ] << " "; } cout << endl; } }
bool checkOrigin ( int x1, int y1, int x2, int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ); }
int minJumps ( int arr [ ], int n ) { int * jumps = new int [ n ]; int i, j; if ( n == 0 || arr [ 0 ] == 0 ) return INT_MAX; jumps [ 0 ] = 0; for ( i = 1; i < n; i ++ ) { jumps [ i ] = INT_MAX; for ( j = 0; j < i; j ++ ) { if ( i <= j + arr [ j ] && jumps [ j ] != INT_MAX ) { jumps [ i ] = min ( jumps [ i ], jumps [ j ] + 1 ); break; } } } return jumps [ n - 1 ]; }
double polygonArea ( double X [ ], double Y [ ], int n ) { double area = 0.0; int j = n - 1; for ( int i = 0; i < n; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ); j = i; } return abs ( area / 2.0 ); }
int minMaxProduct ( int arr1 [ ], int arr2 [ ], int n1, int n2 ) { int max = arr1 [ 0 ]; int min = arr2 [ 0 ]; int i; for ( i = 1; i < n1 && i < n2; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ]; if ( arr2 [ i ] < min ) min = arr2 [ i ]; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ]; i ++; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ]; i ++; } return max * min; }
int search ( int arr [ ], int n, int x, int k ) { int i = 0; while ( i < n ) { if ( arr [ i ] == x ) return i; i = i + max ( 1, abs ( arr [ i ] - x ) / k ); } cout << "number is not present!"; return - 1; }
string lexSmallest ( string a [ ], int n ) { sort ( a, a + n, compare ); string answer = ""; for ( int i = 0; i < n; i ++ ) answer += a [ i ]; return answer; }
int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ]; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ); else return dp [ n ] = n; }
void minMaxLengthWords ( string input, string & minWord, string & maxWord ) { int len = input . length ( ); int si = 0, ei = 0; int min_length = len, min_start_index = 0, max_length = 0, max_start_index = 0; while ( ei <= len ) { if ( ei < len && input [ ei ] != ' ' ) ei ++; else { int curr_length = ei - si; if ( curr_length < min_length ) { min_length = curr_length; min_start_index = si; } if ( curr_length > max_length ) { max_length = curr_length; max_start_index = si; } ei ++; si = ei; } } minWord = input . substr ( min_start_index, min_length ); maxWord = input . substr ( max_start_index, max_length ); }
int search ( int arr [ ], int n, int x ) { int i; for ( i = 0; i < n; i ++ ) { if ( arr [ i ] == x ) return i; } return - 1; }
int minSwap ( int * arr, int n, int k ) { int count = 0; for ( int i = 0; i < n; ++ i ) if ( arr [ i ] <= k ) ++ count; int bad = 0; for ( int i = 0; i < count; ++ i ) if ( arr [ i ] > k ) ++ bad; int ans = bad; for ( int i = 0, j = count; j < n; ++ i, ++ j ) { if ( arr [ i ] > k ) -- bad; if ( arr [ j ] > k ) ++ bad; ans = min ( ans, bad ); } return ans; }
unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1; return n * factorial ( n - 1 ); }
int summingSeries ( long n ) { int S = 0; for ( int i = 1; i <= n; i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ); return S; }
bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0; while ( n != 1 ) { if ( n % 2 != 0 ) return 0; n = n / 2; } return 1; }
int findSubarraySum ( int arr [ ], int n, int sum ) { unordered_map < int, int > prevSum; int res = 0; int currsum = 0; for ( int i = 0; i < n; i ++ ) { currsum += arr [ i ]; if ( currsum == sum ) res ++; if ( prevSum . find ( currsum - sum ) != prevSum . end ( ) ) res += ( prevSum [ currsum - sum ] ); prevSum [ currsum ] ++; } return res; }
float slope ( float x1, float y1, float x2, float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ); }
int PowerOFPINnfactorial ( int n, int p ) { int ans = 0; int temp = p; while ( temp <= n ) { ans += n / temp; temp = temp * p; } return ans; }
bool isHeap ( int arr [ ], int n ) { for ( int i = 0; i <= ( n - 2 ) / 2; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false; } return true; }
string findSum ( string str1, string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1, str2 ); string str = ""; int n1 = str1 . length ( ), n2 = str2 . length ( ); int diff = n2 - n1; int carry = 0; for ( int i = n1 - 1; i >= 0; i -- ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i + diff ] - '0' ) + carry ); str . push_back ( sum % 10 + '0' ); carry = sum / 10; } for ( int i = n2 - n1 - 1; i >= 0; i -- ) { int sum = ( ( str2 [ i ] - '0' ) + carry ); str . push_back ( sum % 10 + '0' ); carry = sum / 10; } if ( carry ) str . push_back ( carry + '0' ); reverse ( str . begin ( ), str . end ( ) ); return str; }
int maxvolume ( int s ) { int maxvalue = 0; for ( int i = 1; i <= s - 2; i ++ ) { for ( int j = 1; j <= s - 1; j ++ ) { int k = s - i - j; maxvalue = max ( maxvalue, i * j * k ); } } return maxvalue; }
string Dragon_Curve_Sequence ( int n ) { string s = "1"; for ( int i = 2; i <= n; i ++ ) { string temp = "1"; char prev = '1', zero = '0', one = '1'; for ( int j = 0; j < s . length ( ); j ++ ) { temp += s [ j ]; if ( prev == '0' ) { temp += one; prev = one; } else { temp += zero; prev = zero; } } s = temp; } return s; }
int lcsOf3 ( string X, string Y, string Z, int m, int n, int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ]; for ( int i = 0; i <= m; i ++ ) { for ( int j = 0; j <= n; j ++ ) { for ( int k = 0; k <= o; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ], L [ i ] [ j - 1 ] [ k ] ), L [ i ] [ j ] [ k - 1 ] ); } } } return L [ m ] [ n ] [ o ]; }
int calculateEnergy ( int mat [ SIZE ] [ SIZE ], int n ) { int i_des, j_des, q; int tot_energy = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { q = mat [ i ] [ j ] / n; i_des = q; j_des = mat [ i ] [ j ] - ( n * q ); tot_energy += abs ( i_des - i ) + abs ( j_des - j ); } } return tot_energy; }
void sortArray ( int arr [ ], int n, int A, int B, int C ) { for ( int i = 0; i < n; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C; int index, maximum = INT_MIN; for ( int i = 0; i < n; i ++ ) { if ( maximum < arr [ i ] ) { index = i; maximum = arr [ i ]; } } int i = 0, j = n - 1; int new_arr [ n ], k = 0; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ]; else new_arr [ k ++ ] = arr [ j -- ]; } while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ]; while ( j > index ) new_arr [ k ++ ] = arr [ j -- ]; new_arr [ n - 1 ] = maximum; for ( int i = 0; i < n; i ++ ) arr [ i ] = new_arr [ i ]; }
int countWords ( string str [ ], int n ) { unordered_map < string, int > m; for ( int i = 0; i < n; i ++ ) m [ str [ i ] ] += 1; int res = 0; for ( auto it = m . begin ( ); it != m . end ( ); it ++ ) if ( ( it -> second == 2 ) ) res ++; return res; }
int assignValue ( int a, int b, bool x ) { int arr [ ] = { a, b }; return ( arr [ x ] ); }
bool isPresent ( string s, string q ) { int freq [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < s . length ( ); i ++ ) freq [ s [ i ] ] ++; for ( int i = 0; i < q . length ( ); i ++ ) { freq [ q [ i ] ] --; if ( freq [ q [ i ] ] < 0 ) return false; } return true; }
bool findPairs ( int arr [ ], int n ) { map < int, pair < int, int > > Hash; for ( int i = 0; i < n; ++ i ) { for ( int j = i + 1; j < n; ++ j ) { int sum = arr [ i ] + arr [ j ]; if ( Hash . find ( sum ) == Hash . end ( ) ) Hash [ sum ] = make_pair ( i, j ); else { pair < int, int > pp = Hash [ sum ]; cout << "(" << arr [ pp . first ] << ", " << arr [ pp . second ] << ") and (" << arr [ i ] << ", " << arr [ j ] << ")n"; return true; } } } cout << "No pairs found"; return false; }
void rearrange ( int a [ ], int size ) { int positive = 0, negative = 1; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2; while ( negative < size && a [ negative ] <= 0 ) negative += 2; if ( positive < size && negative < size ) swap ( a [ positive ], a [ negative ] ); else break; } }
void subarrayDivisibleByK ( int arr [ ], int n, int k ) { map < int, int > mp; int s = 0, e = 0, maxs = 0, maxe = 0; mp [ arr [ 0 ] % k ] ++; for ( int i = 1; i < n; i ++ ) { int mod = arr [ i ] % k; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] --; s ++; } mp [ mod ] ++; e ++; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e; maxs = s; } } cout << "The maximum size is " << maxe - maxs + 1 << " and " "the subarray is as follows\n"; for ( int i = maxs; i <= maxe; i ++ ) cout << arr [ i ] << " "; }
int findSDSFunc ( int n ) { int DP [ n + 1 ]; DP [ 0 ] = 0; DP [ 1 ] = 1; for ( int i = 2; i <= n; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ]; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ]; } return DP [ n ]; }
void findRandomIndexOfMax ( int arr [ ], int n ) { unordered_map < int, int > freq; for ( int i = 0; i < n; i ++ ) freq [ arr [ i ] ] += 1; int max_element; int max_so_far = INT_MIN; for ( pair < int, int > p : freq ) { if ( p . second > max_so_far ) { max_so_far = p . second; max_element = p . first; } } int r = ( rand ( ) % max_so_far ) + 1; for ( int i = 0, count = 0; i < n; i ++ ) { if ( arr [ i ] == max_element ) count ++; if ( count == r ) { cout << "Element with maximum frequency present " "at index " << i << endl; break; } } }
int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl; int ans = 0; int o = 0, c = 0; for ( int i = 0; i < s . length ( ); i ++ ) { if ( s [ i ] == '(' ) o ++; if ( s [ i ] == ')' ) c ++; } if ( o != c ) return - 1; int a [ s . size ( ) ]; if ( s [ 0 ] == '(' ) a [ 0 ] = 1; else a [ 0 ] = - 1; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ); for ( int i = 1; i < s . length ( ); i ++ ) { if ( s [ i ] == '(' ) a [ i ] = a [ i - 1 ] + 1; else a [ i ] = a [ i - 1 ] - 1; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ); } return ans; }
unsigned int factorial ( unsigned int n ) { int res = 1, i; for ( i = 2; i <= n; i ++ ) res *= i; return res; }
int minTimeForWritingChars ( int N, int insert, int remove, int copy ) { if ( N == 0 ) return 0; if ( N == 1 ) return insert; int dp [ N + 1 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 1; i <= N; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert, dp [ i / 2 ] + copy ); else dp [ i ] = min ( dp [ i - 1 ] + insert, dp [ ( i + 1 ) / 2 ] + copy + remove ); } return dp [ N ]; }
int findMaxGCD ( int arr [ ], int n ) { int high = 0; for ( int i = 0; i < n; i ++ ) high = max ( high, arr [ i ] ); int divisors [ high + 1 ] = { 0 }; for ( int i = 0; i < n; i ++ ) { for ( int j = 1; j <= sqrt ( arr [ i ] ); j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++; } } } for ( int i = high; i >= 1; i -- ) if ( divisors [ i ] > 1 ) return i; }
void shiftMatrixByK ( int mat [ N ] [ N ], int k ) { if ( k > N ) { cout << "shifting is not possible" << endl; return; } int j = 0; while ( j < N ) { for ( int i = k; i < N; i ++ ) cout << mat [ j ] [ i ] << " "; for ( int i = 0; i < k; i ++ ) cout << mat [ j ] [ i ] << " "; cout << endl; j ++; } }
void constructArr ( int arr [ ], int pair [ ], int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2; for ( int i = 1; i < n; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ]; }
int superSeq ( char * X, char * Y, int m, int n ) { int dp [ m + 1 ] [ n + 1 ]; for ( int i = 0; i <= m; i ++ ) { for ( int j = 0; j <= n; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j; else if ( ! j ) dp [ i ] [ j ] = i; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ); } } return dp [ m ] [ n ]; }
void swap ( int * xp, int * yp ) { * xp = * xp ^ * yp; * yp = * xp ^ * yp; * xp = * xp ^ * yp; }
int maxSubArraySum ( int a [ ], int size ) { int max_so_far = INT_MIN, max_ending_here = 0, start = 0, end = 0, s = 0; for ( int i = 0; i < size; i ++ ) { max_ending_here += a [ i ]; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here; start = s; end = i; } if ( max_ending_here < 0 ) { max_ending_here = 0; s = i + 1; } } return ( end - start + 1 ); }
void sortByPattern ( string & str, string pat ) { int count [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < str . length ( ); i ++ ) count [ str [ i ] - 'a' ] ++; int index = 0; for ( int i = 0; i < pat . length ( ); i ++ ) for ( int j = 0; j < count [ pat [ i ] - 'a' ]; j ++ ) str [ index ++ ] = pat [ i ]; }
void CountTriangles ( vector < int > A ) { int n = A . size ( ); sort ( A . begin ( ), A . end ( ) ); int count = 0; for ( int i = n - 1; i >= 1; i -- ) { int l = 0, r = i - 1; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l; r --; } else l ++; } } cout << "No of possible solutions: " << count; }
int findLargestSumPair ( int arr [ ], int n ) { int first, second; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ]; second = arr [ 1 ]; } else { first = arr [ 1 ]; second = arr [ 0 ]; } for ( int i = 2; i < n; i ++ ) { if ( arr [ i ] > first ) { second = first; first = arr [ i ]; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ]; } return ( first + second ); }
int minimumSquare ( int m, int n ) { int vertical_min = INT_MAX; int horizontal_min = INT_MAX; if ( m == n ) return 1; if ( dp [ m ] [ n ] ) return dp [ m ] [ n ]; for ( int i = 1; i <= m / 2; i ++ ) { horizontal_min = min ( minimumSquare ( i, n ) + minimumSquare ( m - i, n ), horizontal_min ); } for ( int j = 1; j <= n / 2; j ++ ) { vertical_min = min ( minimumSquare ( m, j ) + minimumSquare ( m, n - j ), vertical_min ); } dp [ m ] [ n ] = min ( vertical_min, horizontal_min ); return dp [ m ] [ n ]; }
int countPairsWithDiffK ( int arr [ ], int n, int k ) { int count = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++; } return count; }
long long int countBT ( int h ) { long long int dp [ h + 1 ]; dp [ 0 ] = dp [ 1 ] = 1; for ( int i = 2; i <= h; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod; } return dp [ h ]; }
void thirdLargest ( int arr [ ], int arr_size ) { if ( arr_size < 3 ) { printf ( " Invalid Input " ); return; } int first = arr [ 0 ], second = INT_MIN, third = INT_MIN; for ( int i = 1; i < arr_size; i ++ ) { if ( arr [ i ] > first ) { third = second; second = first; first = arr [ i ]; } else if ( arr [ i ] > second ) { third = second; second = arr [ i ]; } else if ( arr [ i ] > third ) third = arr [ i ]; } printf ( "The third Largest element is %d\n", third ); }
int cassini ( int n ) { return ( n & 1 ) ? - 1 : 1; }
int binarySearch ( int arr [ ], int l, int r, int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2; if ( arr [ mid ] == x ) return mid; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ); if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ); if ( arr [ mid ] > x ) return binarySearch ( arr, l, mid - 2, x ); return binarySearch ( arr, mid + 2, r, x ); } return - 1; }
int minOperations ( string str, int n ) { int i, lastUpper = - 1, firstLower = - 1; for ( i = n - 1; i >= 0; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i; break; } } for ( i = 0; i < n; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i; break; } } if ( lastUpper == - 1 || firstLower == - 1 ) return 0; int countUpper = 0; for ( i = firstLower; i < n; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++; } } int countLower = 0; for ( i = 0; i < lastUpper; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++; } } return min ( countLower, countUpper ); }
int maxSumBitonicSubArr ( int arr [ ], int n ) { int msis [ n ], msds [ n ]; int max_sum = INT_MIN; msis [ 0 ] = arr [ 0 ]; for ( int i = 1; i < n; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ]; else msis [ i ] = arr [ i ]; msds [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2; i >= 0; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ]; else msds [ i ] = arr [ i ]; for ( int i = 0; i < n; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ]; return max_sum; }
- 100000000 int findMaxValue ( int arr [ ], int n ) { if ( n < 4 ) { printf ( "The array should have atlest 4 elements\n" ); return MIN; } int table1 [ n + 1 ], table2 [ n ], table3 [ n - 1 ], table4 [ n - 2 ]; for ( int i = 0; i <= n; i ++ ) table1 [ i ] = table2 [ i ] = table3 [ i ] = table4 [ i ] = MIN; for ( int i = n - 1; i >= 0; i -- ) table1 [ i ] = max ( table1 [ i + 1 ], arr [ i ] ); for ( int i = n - 2; i >= 0; i -- ) table2 [ i ] = max ( table2 [ i + 1 ], table1 [ i + 1 ] - arr [ i ] ); for ( int i = n - 3; i >= 0; i -- ) table3 [ i ] = max ( table3 [ i + 1 ], table2 [ i + 1 ] + arr [ i ] ); for ( int i = n - 4; i >= 0; i -- ) table4 [ i ] = max ( table4 [ i + 1 ], table3 [ i + 1 ] - arr [ i ] ); return table4 [ 0 ]; }
bool isPower ( int x, long int y ) { if ( x == 1 ) return ( y == 1 ); long int pow = 1; while ( pow < y ) pow *= x; return ( pow == y ); }
void findDivision ( string & str, int a, int b ) { int len = str . length ( ); vector < int > lr ( len + 1, 0 ); lr [ 0 ] = ( str [ 0 ] - '0' ) % a; for ( int i = 1; i < len; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str [ i ] - '0' ) ) % a; vector < int > rl ( len + 1, 0 ); rl [ len - 1 ] = ( str [ len - 1 ] - '0' ) % b; int power10 = 10; for ( int i = len - 2; i >= 0; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( str [ i ] - '0' ) * power10 ) % b; power10 = ( power10 * 10 ) % b; } for ( int i = 0; i < len - 1; i ++ ) { if ( lr [ i ] != 0 ) continue; if ( rl [ i + 1 ] == 0 ) { cout << "YES\n"; for ( int k = 0; k <= i; k ++ ) cout << str [ k ]; cout << ", "; for ( int k = i + 1; k < len; k ++ ) cout << str [ k ]; return; } } cout << "NO\n"; }
int countNum ( int arr [ ], int n ) { int count = 0; sort ( arr, arr + n ); for ( int i = 0; i < n - 1; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1; return count; }
bool checkPair ( int arr [ ], int n ) { int sum = 0; for ( int i = 0; i < n; i ++ ) sum += arr [ i ]; if ( sum % 2 != 0 ) return false; sum = sum / 2; unordered_set < int > s; for ( int i = 0; i < n; i ++ ) { int val = sum - arr [ i ]; if ( s . find ( val ) != s . end ( ) ) { printf ( "Pair elements are %d and %d\n", arr [ i ], val ); return true; } s . insert ( arr [ i ] ); } return false; }
long long int findSum ( int n ) { long long int multiTerms = n * ( n + 1 ) / 2; long long int sum = multiTerms; for ( int i = 2; i <= n; i ++ ) { multiTerms = multiTerms - ( i - 1 ); sum = sum + multiTerms * i; } return sum; }
void printLevels ( vector < int > graph [ ], int V, int x ) { int level [ V ]; bool marked [ V ]; queue < int > que; que . push ( x ); level [ x ] = 0; marked [ x ] = true; while ( ! que . empty ( ) ) { x = que . front ( ); que . pop ( ); for ( int i = 0; i < graph [ x ] . size ( ); i ++ ) { int b = graph [ x ] [ i ]; if ( ! marked [ b ] ) { que . push ( b ); level [ b ] = level [ x ] + 1; marked [ b ] = true; } } } cout << "Nodes" << " " << "Level" << endl; for ( int i = 0; i < V; i ++ ) cout << " " << i << " --> " << level [ i ] << endl; }
int findMinDiff ( int arr [ ], int n, int m ) { if ( m == 0 || n == 0 ) return 0; sort ( arr, arr + n ); if ( n < m ) return - 1; int min_diff = INT_MAX; int first = 0, last = 0; for ( int i = 0; i + m - 1 < n; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ]; if ( diff < min_diff ) { min_diff = diff; first = i; last = i + m - 1; } } return ( arr [ last ] - arr [ first ] ); }
void printSumTricky ( int mat [ ] [ n ], int k ) { if ( k > n ) return; int stripSum [ n ] [ n ]; for ( int j = 0; j < n; j ++ ) { int sum = 0; for ( int i = 0; i < k; i ++ ) sum += mat [ i ] [ j ]; stripSum [ 0 ] [ j ] = sum; for ( int i = 1; i < n - k + 1; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ); stripSum [ i ] [ j ] = sum; } } for ( int i = 0; i < n - k + 1; i ++ ) { int sum = 0; for ( int j = 0; j < k; j ++ ) sum += stripSum [ i ] [ j ]; cout << sum << " "; for ( int j = 1; j < n - k + 1; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ); cout << sum << " "; } cout << endl; } }
double surface_area_octahedron ( double side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ); }
int MaximumPath ( int Mat [ ] [ N ] ) { int result = 0; int dp [ N ] [ N + 2 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 0; i < N; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ]; for ( int i = 1; i < N; i ++ ) for ( int j = 1; j <= N; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ], max ( dp [ i - 1 ] [ j ], dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ]; for ( int i = 0; i <= N; i ++ ) result = max ( result, dp [ N - 1 ] [ i ] ); return result; }
void SectorArea ( double radius, double angle ) { if ( angle >= 360 ) cout << "Angle not possible"; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ); cout << sector; } }
void midPointCircleDraw ( int x_centre, int y_centre, int r ) { int x = r, y = 0; cout << "(" << x + x_centre << ", " << y + y_centre << ") "; if ( r > 0 ) { cout << "(" << x + x_centre << ", " << - y + y_centre << ") "; cout << "(" << y + x_centre << ", " << x + y_centre << ") "; cout << "(" << - y + x_centre << ", " << x + y_centre << ")\n"; } int P = 1 - r; while ( x > y ) { y ++; if ( P <= 0 ) P = P + 2 * y + 1; else { x --; P = P + 2 * y - 2 * x + 1; } if ( x < y ) break; cout << "(" << x + x_centre << ", " << y + y_centre << ") "; cout << "(" << - x + x_centre << ", " << y + y_centre << ") "; cout << "(" << x + x_centre << ", " << - y + y_centre << ") "; cout << "(" << - x + x_centre << ", " << - y + y_centre << ")\n"; if ( x != y ) { cout << "(" << y + x_centre << ", " << x + y_centre << ") "; cout << "(" << - y + x_centre << ", " << x + y_centre << ") "; cout << "(" << y + x_centre << ", " << - x + y_centre << ") "; cout << "(" << - y + x_centre << ", " << - x + y_centre << ")\n"; } } }
vector < int > Restore_Tree ( int Start [ ], int End [ ] ) { vector < int > Identity ( N, 0 ); for ( int i = 0; i < N; i ++ ) { Identity [ Start [ i ] ] = i; } vector < int > parent ( N, - 1 ); int curr_parent = Identity [ 0 ]; for ( int j = 1; j < N; j ++ ) { int child = Identity [ j ]; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_parent; curr_parent = child; } else parent [ child ] = curr_parent; while ( End [ child ] == End [ parent [ child ] ] ) { child = parent [ child ]; curr_parent = parent [ child ]; if ( curr_parent == Identity [ 0 ] ) break; } } for ( int i = 0; i < N; i ++ ) parent [ i ] += 1; return parent; }
int countPairs ( string str ) { int result = 0; int n = str . length ( ); for ( int i = 0; i < n; i ++ ) for ( int j = 1; ( i + j ) < n && j <= MAX_CHAR; j ++ ) if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) result ++; return result; }
int countSquares ( int a, int b ) { int cnt = 0; for ( int i = a; i <= b; i ++ ) for ( int j = 1; j * j <= i; j ++ ) if ( j * j == i ) cnt ++; return cnt; }
bool isOverflow ( long long a, long long b ) { if ( a == 0 || b == 0 ) return false; long long result = a * b; if ( a == result / b ) return false; else return true; }
int countParenth ( char symb [ ], char oper [ ], int n ) { int F [ n ] [ n ], T [ n ] [ n ]; for ( int i = 0; i < n; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0; T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0; } for ( int gap = 1; gap < n; ++ gap ) { for ( int i = 0, j = gap; j < n; ++ i, ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0; for ( int g = 0; g < gap; g ++ ) { int k = i + g; int tik = T [ i ] [ k ] + F [ i ] [ k ]; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]; if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ); } if ( oper [ k ] == '|' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ); } if ( oper [ k ] == '^' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ]; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ]; } } } } return T [ 0 ] [ n - 1 ]; }
int findMaxSum ( int arr [ ], int n ) { int res = INT_MIN; for ( int i = 0; i < n; i ++ ) { int prefix_sum = arr [ i ]; for ( int j = 0; j < i; j ++ ) prefix_sum += arr [ j ]; int suffix_sum = arr [ i ]; for ( int j = n - 1; j > i; j -- ) suffix_sum += arr [ j ]; if ( prefix_sum == suffix_sum ) res = max ( res, prefix_sum ); } return res; }
int findRepeatFirst ( char * s ) { int p = - 1, i, k; int hash [ MAX_CHAR ] = { 0 }; int pos [ MAX_CHAR ]; for ( i = 0; i < strlen ( s ); i ++ ) { k = ( int ) s [ i ]; if ( hash [ k ] == 0 ) { hash [ k ] ++; pos [ k ] = i; } else if ( hash [ k ] == 1 ) hash [ k ] ++; } for ( i = 0; i < MAX_CHAR; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) p = pos [ i ]; else if ( p > pos [ i ] ) p = pos [ i ]; } } return p; }
int binaryToDecimal ( int n ) { int num = n; int dec_value = 0; int base = 1; int temp = num; while ( temp ) { int last_digit = temp % 10; temp = temp / 10; dec_value += last_digit * base; base = base * 2; } return dec_value; }
void generateSquare ( int n ) { int magicSquare [ n ] [ n ]; memset ( magicSquare, 0, sizeof ( magicSquare ) ); int i = n / 2; int j = n - 1; for ( int num = 1; num <= n * n; ) { if ( i == - 1 && j == n ) { j = n - 2; i = 0; } else { if ( j == n ) j = 0; if ( i < 0 ) i = n - 1; } if ( magicSquare [ i ] [ j ] ) { j -= 2; i ++; continue; } else magicSquare [ i ] [ j ] = num ++; j ++; i --; } cout << "The Magic Square for n=" << n << ":\nSum of " "each row or column " << n * ( n * n + 1 ) / 2 << ":\n\n"; for ( i = 0; i < n; i ++ ) { for ( j = 0; j < n; j ++ ) cout << magicSquare [ i ] [ j ] << " "; cout << endl; } }
int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ); }
bool containsOdd ( int G [ ] [ V ], int src ) { int colorArr [ V ]; for ( int i = 0; i < V; ++ i ) colorArr [ i ] = - 1; colorArr [ src ] = 1; queue < int > q; q . push ( src ); while ( ! q . empty ( ) ) { int u = q . front ( ); q . pop ( ); if ( G [ u ] [ u ] == 1 ) return true; for ( int v = 0; v < V; ++ v ) { if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ]; q . push ( v ); } else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ u ] ) return true; } } return false; }
bool isScalarMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0; i < N; i ++ ) for ( int j = 0; j < N; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false; for ( int i = 0; i < N - 1; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false; return true; }
bool isRectangle ( const vector < vector < int > > & matrix ) { int rows = matrix . size ( ); if ( rows == 0 ) return false; int columns = matrix [ 0 ] . size ( ); unordered_map < int, unordered_set < int > > table; for ( int i = 0; i < rows; ++ i ) { for ( int j = 0; j < columns - 1; ++ j ) { for ( int k = j + 1; k < columns; ++ k ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( table . find ( j ) != table . end ( ) && table [ j ] . find ( k ) != table [ j ] . end ( ) ) return true; table [ j ] . insert ( k ); } } } } return false; }
bool checkCount ( int arr [ ], int n, int k ) { int count; for ( int i = 0; i < n; i ++ ) { count = 0; for ( int j = 0; j < n; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++; if ( count > 2 * k ) return false; } } return true; }
int maxSum ( int arr [ ], int n ) { int sum = 0; sort ( arr, arr + n ); for ( int i = 0; i < n / 2; i ++ ) { sum -= ( 2 * arr [ i ] ); sum += ( 2 * arr [ n - i - 1 ] ); } return sum; }
int findMinX ( int num [ ], int rem [ ], int k ) { int x = 1; while ( true ) { int j; for ( j = 0; j < k; j ++ ) if ( x % num [ j ] != rem [ j ] ) break; if ( j == k ) return x; x ++; } return x; }
void generateGrayarr ( int n ) { if ( n <= 0 ) return; vector < string > arr; arr . push_back ( "0" ); arr . push_back ( "1" ); int i, j; for ( i = 2; i < ( 1 << n ); i = i << 1 ) { for ( j = i - 1; j >= 0; j -- ) arr . push_back ( arr [ j ] ); for ( j = 0; j < i; j ++ ) arr [ j ] = "0" + arr [ j ]; for ( j = i; j < 2 * i; j ++ ) arr [ j ] = "1" + arr [ j ]; } for ( i = 0; i < arr . size ( ); i ++ ) cout << arr [ i ] << endl; }
long long moduloMultiplication ( long long a, long long b, long long mod ) { long long res = 0; a %= mod; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod; a = ( 2 * a ) % mod; b >>= 1; } return res; }
int findLongestRepeatingSubSeq ( string X, int m, int n ) { if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ]; if ( m == 0 || n == 0 ) return dp [ m ] [ n ] = 0; if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X, m - 1, n - 1 ) + 1; return dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X, m, n - 1 ), findLongestRepeatingSubSeq ( X, m - 1, n ) ); }
int maxSquare ( int b, int m ) { return ( b / m - 1 ) * ( b / m ) / 2; }
void printSuperSeq ( string & a, string & b ) { int m = a . length ( ), n = b . length ( ); int dp [ m + 1 ] [ n + 1 ]; for ( int i = 0; i <= m; i ++ ) { for ( int j = 0; j <= n; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j; else if ( ! j ) dp [ i ] [ j ] = i; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ); } } int index = dp [ m ] [ n ]; string res ( index + 1, '\0' ); int i = m, j = n; while ( i > 0 && j > 0 ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ]; i --; j --; index --; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ]; i --; index --; } else { res [ index - 1 ] = b [ j - 1 ]; j --; index --; } } while ( i > 0 ) { res [ index - 1 ] = a [ i - 1 ]; i --; index --; } while ( j > 0 ) { res [ index - 1 ] = b [ j - 1 ]; j --; index --; } cout << res; }
int returnMaxSum ( int A [ ], int B [ ], int n ) { unordered_set < int > mp; int result = 0; int curr_sum = 0, curr_begin = 0; for ( int i = 0; i < n; ++ i ) { while ( mp . find ( A [ i ] ) != mp . end ( ) ) { mp . erase ( A [ curr_begin ] ); curr_sum -= B [ curr_begin ]; curr_begin ++; } mp . insert ( A [ i ] ); curr_sum += B [ i ]; result = max ( result, curr_sum ); } return result; }
int modInverse ( int a, int m ) { int m0 = m; int y = 0, x = 1; if ( m == 1 ) return 0; while ( a > 1 ) { int q = a / m; int t = m; m = a % m, a = t; t = y; y = x - q * y; x = t; } if ( x < 0 ) x += m0; return x; }
int findmin ( Point p [ ], int n ) { int a = 0, b = 0, c = 0, d = 0; for ( int i = 0; i < n; i ++ ) { if ( p [ i ] . x <= 0 ) a ++; else if ( p [ i ] . x >= 0 ) b ++; if ( p [ i ] . y >= 0 ) c ++; else if ( p [ i ] . y <= 0 ) d ++; } return min ( { a, b, c, d } ); }
string constructPalin ( string str, int len ) { int i = 0, j = len - 1; for (; i < j; i ++, j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue; else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) { str [ i ] = 'a'; str [ j ] = 'a'; continue; } else if ( str [ i ] == '*' ) { str [ i ] = str [ j ]; continue; } else if ( str [ j ] == '*' ) { str [ j ] = str [ i ]; continue; } cout << "Not Possible"; return ""; } return str; }
void printRect ( int X [ ], int Y [ ], int n ) { int Xmax = * max_element ( X, X + n ); int Xmin = * min_element ( X, X + n ); int Ymax = * max_element ( Y, Y + n ); int Ymin = * min_element ( Y, Y + n ); cout << "{" << Xmin << ", " << Ymin << "}" << endl; cout << "{" << Xmin << ", " << Ymax << "}" << endl; cout << "{" << Xmax << ", " << Ymax << "}" << endl; cout << "{" << Xmax << ", " << Ymin << "}" << endl; }
void findFibSubset ( int arr [ ], int n ) { int max = * std :: max_element ( arr, arr + n ); int a = 0, b = 1; unordered_set < int > hash; hash . insert ( a ); hash . insert ( b ); while ( b < max ) { int c = a + b; a = b; b = c; hash . insert ( b ); } for ( int i = 0; i < n; i ++ ) if ( hash . find ( arr [ i ] ) != hash . end ( ) ) printf ( "%d ", arr [ i ] ); }
double gcd ( double a, double b ) { if ( a < b ) return gcd ( b, a ); if ( fabs ( b ) < 0.001 ) return a; else return ( gcd ( b, a - floor ( a / b ) * b ) ); }
void printRepeating ( int arr [ ], int size ) { int i; cout << "The repeating elements are"; for ( i = 0; i < size; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ]; else cout << " " << abs ( arr [ i ] ) << " "; } }
int maxLen ( int arr [ ], int n ) { int max_len = 0; for ( int i = 0; i < n; i ++ ) { int curr_sum = 0; for ( int j = i; j < n; j ++ ) { curr_sum += arr [ j ]; if ( curr_sum == 0 ) max_len = max ( max_len, j - i + 1 ); } } return max_len; }
int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ], sum = 0; memset ( prime, 0, sizeof ( prime ) ); int max = n / 2; for ( int p = 2; p <= max; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2; i <= n; i += p ) prime [ i ] = p; } } for ( int p = 2; p <= n; p ++ ) { if ( prime [ p ] ) sum += prime [ p ]; else sum += p; } return sum; }
int countMinOperations ( unsigned int target [ ], int n ) { int result = 0; while ( 1 ) { int zero_count = 0; int i; for ( i = 0; i < n; i ++ ) { if ( target [ i ] & 1 ) break; else if ( target [ i ] == 0 ) zero_count ++; } if ( zero_count == n ) return result; if ( i == n ) { for ( int j = 0; j < n; j ++ ) target [ j ] = target [ j ] / 2; result ++; } for ( int j = i; j < n; j ++ ) { if ( target [ j ] & 1 ) { target [ j ] --; result ++; } } } }
double nthRoot ( int A, int N ) { double xPre = rand ( ) % 10; double eps = 1e - 3; double delX = INT_MAX; double xK; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre, N - 1 ) ) / ( double ) N; delX = abs ( xK - xPre ); xPre = xK; } return xK; }
int countDyckPaths ( unsigned int n ) { int res = 1; for ( int i = 0; i < n; ++ i ) { res *= ( 2 * n - i ); res /= ( i + 1 ); } return res / ( n + 1 ); }
string arrangeString ( string str ) { int char_count [ MAX_CHAR ] = { 0 }; int sum = 0; for ( int i = 0; i < str . length ( ); i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) char_count [ str [ i ] - 'A' ] ++; else sum = sum + ( str [ i ] - '0' ); } string res = ""; for ( int i = 0; i < MAX_CHAR; i ++ ) { char ch = ( char ) ( 'A' + i ); while ( char_count [ i ] -- ) res = res + ch; } if ( sum > 0 ) res = res + to_string ( sum ); return res; }
void counterClockspiralPrint ( int m, int n, int arr [ R ] [ C ] ) { int i, k = 0, l = 0; int cnt = 0; int total = m * n; while ( k < m && l < n ) { if ( cnt == total ) break; for ( i = k; i < m; ++ i ) { cout << arr [ i ] [ l ] << " "; cnt ++; } l ++; if ( cnt == total ) break; for ( i = l; i < n; ++ i ) { cout << arr [ m - 1 ] [ i ] << " "; cnt ++; } m --; if ( cnt == total ) break; if ( k < m ) { for ( i = m - 1; i >= k; -- i ) { cout << arr [ i ] [ n - 1 ] << " "; cnt ++; } n --; } if ( cnt == total ) break; if ( l < n ) { for ( i = n - 1; i >= l; -- i ) { cout << arr [ k ] [ i ] << " "; cnt ++; } k ++; } } }
unsigned int factorial ( unsigned int n ) { int res = 1, i; for ( i = 2; i <= n; i ++ ) res *= i; return res; }
int countPairs ( int arr1 [ ], int arr2 [ ], int m, int n, int x ) { int count = 0; for ( int i = 0; i < m; i ++ ) for ( int j = 0; j < n; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++; return count; }
void subArraySum ( int arr [ ], int n, int sum ) { unordered_map < int, int > map; int curr_sum = 0; for ( int i = 0; i < n; i ++ ) { curr_sum = curr_sum + arr [ i ]; if ( curr_sum == sum ) { cout << "Sum found between indexes " << 0 << " to " << i << endl; return; } if ( map . find ( curr_sum - sum ) != map . end ( ) ) { cout << "Sum found between indexes " << map [ curr_sum - sum ] + 1 << " to " << i << endl; return; } map [ curr_sum ] = i; } cout << "No subarray with given sum exists"; }
int kth ( int arr1 [ ], int arr2 [ ], int m, int n, int k ) { int sorted1 [ m + n ]; int i = 0, j = 0, d = 0; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ]; else sorted1 [ d ++ ] = arr2 [ j ++ ]; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ]; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ]; return sorted1 [ k - 1 ]; }
void printDivisors ( int n ) { vector < int > v; for ( int i = 1; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( "%d ", i ); else { printf ( "%d ", i ); v . push_back ( n / i ); } } } for ( int i = v . size ( ) - 1; i >= 0; i -- ) printf ( "%d ", v [ i ] ); }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ); }
int minSum ( int ar [ ], int n ) { if ( n <= 4 ) return * min_element ( ar, ar + n ); int sum [ n ]; sum [ 0 ] = ar [ 0 ]; sum [ 1 ] = ar [ 1 ]; sum [ 2 ] = ar [ 2 ]; sum [ 3 ] = ar [ 3 ]; for ( int i = 4; i < n; i ++ ) sum [ i ] = ar [ i ] + ( * min_element ( sum + i - 4, sum + i ) ); return * min_element ( sum + n - 4, sum + n ); }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n / 2 ); cout << n % 2; }
void rotatematrix ( int m, int n, int mat [ R ] [ C ] ) { int row = 0, col = 0; int prev, curr; while ( row < m && col < n ) { if ( row + 1 == m || col + 1 == n ) break; prev = mat [ row + 1 ] [ col ]; for ( int i = col; i < n; i ++ ) { curr = mat [ row ] [ i ]; mat [ row ] [ i ] = prev; prev = curr; } row ++; for ( int i = row; i < m; i ++ ) { curr = mat [ i ] [ n - 1 ]; mat [ i ] [ n - 1 ] = prev; prev = curr; } n --; if ( row < m ) { for ( int i = n - 1; i >= col; i -- ) { curr = mat [ m - 1 ] [ i ]; mat [ m - 1 ] [ i ] = prev; prev = curr; } } m --; if ( col < n ) { for ( int i = m - 1; i >= row; i -- ) { curr = mat [ i ] [ col ]; mat [ i ] [ col ] = prev; prev = curr; } } col ++; } for ( int i = 0; i < R; i ++ ) { for ( int j = 0; j < C; j ++ ) cout << mat [ i ] [ j ] << " "; cout << endl; } }
bool find3Numbers ( int A [ ], int arr_size, int sum ) { int l, r; for ( int i = 0; i < arr_size - 2; i ++ ) { for ( int j = i + 1; j < arr_size - 1; j ++ ) { for ( int k = j + 1; k < arr_size; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << "Triplet is " << A [ i ] << ", " << A [ j ] << ", " << A [ k ]; return true; } } } } return false; }
void reverseStr ( string & str ) { int n = str . length ( ); for ( int i = 0, j = n - 1; i < j; i ++, j -- ) swap ( str [ i ], str [ j ] ); }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ); }
void printSorted ( int arr [ ], int start, int end ) { if ( start > end ) return; printSorted ( arr, start * 2 + 1, end ); cout << arr [ start ] << " "; printSorted ( arr, start * 2 + 2, end ); }
int minAdjustmentCost ( int A [ ], int n, int target ) { int dp [ n ] [ M + 1 ]; for ( int j = 0; j <= M; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ); for ( int i = 1; i < n; i ++ ) { for ( int j = 0; j <= M; j ++ ) { dp [ i ] [ j ] = INT_MAX; for ( int k = max ( j - target, 0 ); k <= min ( M, j + target ); k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ], dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ); } } int res = INT_MAX; for ( int j = 0; j <= M; j ++ ) res = min ( res, dp [ n - 1 ] [ j ] ); return res; }
bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 }; for ( int i = 0; str [ i ]; i ++ ) count [ str [ i ] ] ++; int odd = 0; for ( int i = 0; i < NO_OF_CHARS; i ++ ) { if ( count [ i ] & 1 ) odd ++; if ( odd > 1 ) return false; } return true; }
void possibleOrNot ( long long a1, long long a2, long long b1, long long b2, long long c1, long long c2 ) { long long dis1 = pow ( b1 - a1, 2 ) + pow ( b2 - a2, 2 ); long long dis2 = pow ( c1 - b1, 2 ) + pow ( c2 - b2, 2 ); if ( dis1 != dis2 ) cout << "No"; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) cout << "No"; else cout << "Yes"; }
void interLeaveQueue ( queue < int > & q ) { if ( q . size ( ) % 2 != 0 ) cout << "Input even number of integers." << endl; stack < int > s; int halfSize = q . size ( ) / 2; for ( int i = 0; i < halfSize; i ++ ) { s . push ( q . front ( ) ); q . pop ( ); } while ( ! s . empty ( ) ) { q . push ( s . top ( ) ); s . pop ( ); } for ( int i = 0; i < halfSize; i ++ ) { q . push ( q . front ( ) ); q . pop ( ); } for ( int i = 0; i < halfSize; i ++ ) { s . push ( q . front ( ) ); q . pop ( ); } while ( ! s . empty ( ) ) { q . push ( s . top ( ) ); s . pop ( ); q . push ( q . front ( ) ); q . pop ( ); } }
int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1; return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1; }
void printSpiral ( int n ) { for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { int x; x = min ( min ( i, j ), min ( n - 1 - i, n - 1 - j ) ); if ( i <= j ) printf ( "%d\t ", ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) ); else printf ( "%d\t ", ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ); } printf ( "\n" ); } }
int check ( string str ) { int n = str . length ( ); int digitSum = 0; for ( int i = 0; i < n; i ++ ) digitSum += ( str [ i ] - '0' ); return ( digitSum % 9 == 0 ); }
void printSmall ( int arr [ ], int n, int k ) { for ( int i = k; i < n; ++ i ) { int max_var = arr [ k - 1 ]; int pos = k - 1; for ( int j = k - 2; j >= 0; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ]; pos = j; } } if ( max_var > arr [ i ] ) { int j = pos; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ]; j ++; } arr [ k - 1 ] = arr [ i ]; } } for ( int i = 0; i < k; i ++ ) cout << arr [ i ] << " "; }
int maxProductSubset ( int a [ ], int n ) { if ( n == 1 ) return a [ 0 ]; int max_neg = INT_MIN; int count_neg = 0, count_zero = 0; int prod = 1; for ( int i = 0; i < n; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++; continue; } if ( a [ i ] < 0 ) { count_neg ++; max_neg = max ( max_neg, a [ i ] ); } prod = prod * a [ i ]; } if ( count_zero == n ) return 0; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0; prod = prod / max_neg; } return prod; }
bool check ( string str ) { int n = str . length ( ); if ( n == 0 ) return false; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 4 == 0 ); int last = str [ n - 1 ] - '0'; int second_last = str [ n - 2 ] - '0'; return ( ( second_last * 10 + last ) % 4 == 0 ); }
int calculate ( int a [ ], int n ) { int * maximum = max_element ( a, a + 5 ); int frequency [ * maximum + 1 ] = { 0 }; for ( int i = 0; i < n; i ++ ) { frequency [ a [ i ] ] += 1; } int answer = 0; for ( int i = 0; i < ( * maximum ) + 1; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ); } return answer / 2; }
void solveWordWrap ( int arr [ ], int n, int k ) { int i, j; int currlen; int cost; int dp [ n ]; int ans [ n ]; dp [ n - 1 ] = 0; ans [ n - 1 ] = n - 1; for ( i = n - 2; i >= 0; i -- ) { currlen = - 1; dp [ i ] = INT_MAX; for ( j = i; j < n; j ++ ) { currlen += ( arr [ j ] + 1 ); if ( currlen > k ) break; if ( j == n - 1 ) cost = 0; else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ]; if ( cost < dp [ i ] ) { dp [ i ] = cost; ans [ i ] = j; } } } i = 0; while ( i < n ) { cout << i + 1 << " " << ans [ i ] + 1 << " "; i = ans [ i ] + 1; } }
int longestCommonSum ( bool arr1 [ ], bool arr2 [ ], int n ) { int maxLen = 0; for ( int i = 0; i < n; i ++ ) { int sum1 = 0, sum2 = 0; for ( int j = i; j < n; j ++ ) { sum1 += arr1 [ j ]; sum2 += arr2 [ j ]; if ( sum1 == sum2 ) { int len = j - i + 1; if ( len > maxLen ) maxLen = len; } } } return maxLen; }
int findMaximum ( int arr [ ], int low, int high ) { int max = arr [ low ]; int i; for ( i = low + 1; i <= high; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ]; else break; } return max; }
int power ( int n ) { if ( n == 1 ) return 2; return 2 * power ( n - 1 ); }
bool checkSorted ( int n, queue < int > & q ) { stack < int > st; int expected = 1; int fnt; while ( ! q . empty ( ) ) { fnt = q . front ( ); q . pop ( ); if ( fnt == expected ) expected ++; else { if ( st . empty ( ) ) { st . push ( fnt ); } else if ( ! st . empty ( ) && st . top ( ) < fnt ) { return false; } else st . push ( fnt ); } while ( ! st . empty ( ) && st . top ( ) == expected ) { st . pop ( ); expected ++; } } if ( expected - 1 == n && st . empty ( ) ) return true; return false; }
float calc_Expectation ( float a [ ], float n ) { float prb = ( 1 / n ); float sum = 0; for ( int i = 0; i < n; i ++ ) sum += a [ i ] * prb; return sum; }
void removeDuplicates ( char S [ ] ) { int n = strlen ( S ); if ( n < 2 ) return; int j = 0; for ( int i = 1; i < n; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++; S [ j ] = S [ i ]; } } j ++; S [ j ] = '\0'; }
void leafNode ( int preorder [ ], int n ) { stack < int > s; for ( int i = 0, j = 1; j < n; i ++, j ++ ) { bool found = false; if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ); else { while ( ! s . empty ( ) ) { if ( preorder [ j ] > s . top ( ) ) { s . pop ( ); found = true; } else break; } } if ( found ) cout << preorder [ i ] << " "; } cout << preorder [ n - 1 ]; }
int minTime ( int n, int k, int a [ ] ) { sort ( a, a + n, greater < int > ( ) ); int minTime = 0; for ( int i = 0; i < n; i += k ) minTime += ( 2 * a [ i ] ); return minTime; }
bool isPath ( int arr [ row ] [ col ] ) { arr [ 0 ] [ 0 ] = 1; for ( int i = 1; i < row; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ]; for ( int j = 1; j < col; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ]; for ( int i = 1; i < row; i ++ ) for ( int j = 1; j < col; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ], arr [ i - 1 ] [ j ] ); return ( arr [ row - 1 ] [ col - 1 ] == 1 ); }
long long int countNonDecreasing ( int n ) { long long int dp [ 10 ] [ n + 1 ]; memset ( dp, 0, sizeof dp ); for ( int i = 0; i < 10; i ++ ) dp [ i ] [ 1 ] = 1; for ( int digit = 0; digit <= 9; digit ++ ) { for ( int len = 2; len <= n; len ++ ) { for ( int x = 0; x <= digit; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ]; } } long long int count = 0; for ( int i = 0; i < 10; i ++ ) count += dp [ i ] [ n ]; return count; }
int findFlips ( char str [ ], int n ) { char last = ' '; int res = 0; for ( int i = 0; i < n; i ++ ) { if ( last != str [ i ] ) res ++; last = str [ i ]; } return res / 2; }
int countIslands ( int mat [ ] [ N ] ) { int count = 0; for ( int i = 0; i < M; i ++ ) { for ( int j = 0; j < N; j ++ ) { if ( mat [ i ] [ j ] == 'X' ) { if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) count ++; } } } return count; }
int findPossibleMoves ( int mat [ n ] [ m ], int p, int q ) { int X [ 8 ] = { 2, 1, - 1, - 2, - 2, - 1, 1, 2 }; int Y [ 8 ] = { 1, 2, 2, 1, - 1, - 2, - 2, - 1 }; int count = 0; for ( int i = 0; i < 8; i ++ ) { int x = p + X [ i ]; int y = q + Y [ i ]; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++; } return count; }
int decToBinary ( int n ) { for ( int i = 31; i >= 0; i -- ) { int k = n >> i; if ( k & 1 ) cout << "1"; else cout << "0"; } }
int count ( int n ) { if ( n < 4 ) return - 1; int rem = n % 4; if ( rem == 0 ) return n / 4; if ( rem == 1 ) { if ( n < 9 ) return - 1; return ( n - 9 ) / 4 + 1; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1; if ( rem == 3 ) { if ( n < 15 ) return - 1; return ( n - 15 ) / 4 + 2; } }
int modFact ( int n, int p ) { if ( n >= p ) return 0; int result = 1; for ( int i = 1; i <= n; i ++ ) result = ( result * i ) % p; return result; }
int MaxTotalRectangleArea ( int a [ ], int n ) { sort ( a, a + n, greater < int > ( ) ); int sum = 0; bool flag = false; int len; for ( int i = 0; i < n; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true; len = a [ i + 1 ]; i ++; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len; flag = false; i ++; } } return sum; }
int printRoman ( int number ) { int num [ ] = { 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; string sym [ ] = { "I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M" }; int i = 12; while ( number > 0 ) { int div = number / num [ i ]; number = number % num [ i ]; while ( div -- ) { cout << sym [ i ]; } i --; } }
int findRepeatFirstN2 ( char * s ) { int p = - 1, i, j; for ( i = 0; i < strlen ( s ); i ++ ) { for ( j = i + 1; j < strlen ( s ); j ++ ) { if ( s [ i ] == s [ j ] ) { p = i; break; } } if ( p != - 1 ) break; } return p; }
int countP ( int n, int k ) { if ( n == 0 || k == 0 || k > n ) return 0; if ( k == 1 || k == n ) return 1; return k * countP ( n - 1, k ) + countP ( n - 1, k - 1 ); }
int countObtuseAngles ( int a, int b, int k ) { int c1 = ( b - a ) - 1; int c2 = ( k - b ) + ( a - 1 ); if ( c1 == c2 ) return 0; return min ( c1, c2 ); }
void sortInWave ( int arr [ ], int n ) { sort ( arr, arr + n ); for ( int i = 0; i < n - 1; i += 2 ) swap ( & arr [ i ], & arr [ i + 1 ] ); }
int MaximumHeight ( int a [ ], int n ) { return floor ( ( - 1 + sqrt ( 1 + ( 8 * n ) ) ) / 2 ); }
int minSum ( int n ) { int sum = 0; while ( n > 0 ) { sum += ( n % 10 ); n /= 10; } if ( sum == 1 ) return 10; return sum; }
ll count_of_ways ( ll n ) { ll count = 0; for ( int i = 0; i <= n; i ++ ) for ( int j = 0; j <= n; j ++ ) for ( int k = 0; k <= n; k ++ ) if ( i + j + k == n ) count ++; return count; }
int countMinReversals ( string expr ) { int len = expr . length ( ); if ( len % 2 ) return - 1; stack < char > s; for ( int i = 0; i < len; i ++ ) { if ( expr [ i ] == '}' && ! s . empty ( ) ) { if ( s . top ( ) == '{' ) s . pop ( ); else s . push ( expr [ i ] ); } else s . push ( expr [ i ] ); } int red_len = s . size ( ); int n = 0; while ( ! s . empty ( ) && s . top ( ) == '{' ) { s . pop ( ); n ++; } return ( red_len / 2 + n % 2 ); }
public : unsigned int countSetBits ( int n ) { unsigned int count = 0; while ( n ) { n &= ( n - 1 ); count ++; } return count; }
int compute ( vector < int > graph [ ], int N ) { int count = 0; for ( int i = 1; i <= N; i ++ ) if ( graph [ i ] . size ( ) == 0 ) count ++; return count; }
bool isPerfectSquare ( int n ) { for ( int sum = 0, i = 1; sum < n; i += 2 ) { sum += i; if ( sum == n ) return true; } return false; }
void generate ( set < string > & st, string s ) { if ( s . size ( ) == 0 ) return; if ( st . find ( s ) == st . end ( ) ) { st . insert ( s ); for ( int i = 0; i < s . size ( ); i ++ ) { string t = s; t . erase ( i, 1 ); generate ( st, t ); } } return; }
void rearrange ( int arr [ ], int n ) { int max_ele = arr [ n - 1 ]; int min_ele = arr [ 0 ]; for ( int i = 0; i < n; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele; max_ele -= 1; } else { arr [ i ] = min_ele; min_ele += 1; } } }
int nearestSmallerEqFib ( int n ) { if ( n == 0 || n == 1 ) return n; int f1 = 0, f2 = 1, f3 = 1; while ( f3 <= n ) { f1 = f2; f2 = f3; f3 = f1 + f2; } return f2; }
bool isReversible ( string str ) { int i = 0, j = str . length ( ) - 1; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false; i ++; j --; } return true; }
void countFreq ( int a [ ], int n ) { unordered_map < int, int > hm; for ( int i = 0; i < n; i ++ ) hm [ a [ i ] ] ++; int cumul = 0; for ( int i = 0; i < n; i ++ ) { cumul += hm [ a [ i ] ]; if ( hm [ a [ i ] ] ) { cout << a [ i ] << "->" << cumul << endl; } hm [ a [ i ] ] = 0; } }
void search ( int mat [ ROW ] [ COL ], int fromRow, int toRow, int fromCol, int toCol, int key ) { int i = fromRow + ( toRow - fromRow ) / 2; int j = fromCol + ( toCol - fromCol ) / 2; if ( mat [ i ] [ j ] == key ) cout << "Found " << key << " at " << i << " " << j << endl; else { if ( i != toRow || j != fromCol ) search ( mat, fromRow, i, j, toCol, key ); if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) cout << "Found " << key << " at " << fromRow << " " << toCol << endl; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= toRow ) search ( mat, i + 1, toRow, fromCol, toCol, key ); } else { if ( j - 1 >= fromCol ) search ( mat, fromRow, toRow, fromCol, j - 1, key ); } } }
int getRemainder ( int num, int divisor ) { while ( num >= divisor ) num -= divisor; return num; }
int firstNonRepeating ( int arr [ ], int n ) { for ( int i = 0; i < n; i ++ ) { int j; for ( j = 0; j < n; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break; if ( j == n ) return arr [ i ]; } return - 1; }
void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2; if ( n % 4 == 0 ) { cout << "First subset sum = " << s / 2; cout << "\nSecond subset sum = " << s / 2; cout << "\nDifference = " << 0; } else { if ( n % 4 == 1 || n % 4 == 2 ) { cout << "First subset sum = " << s / 2; cout << "\nSecond subset sum = " << s / 2 + 1; cout << "\nDifference = " << 1; } else { cout << "First subset sum = " << s / 2; cout << "\nSecond subset sum = " << s / 2; cout << "\nDifference = " << 0; } } }
void longest ( int a [ ], int n, int k ) { unordered_map < int, int > freq; int start = 0, end = 0, now = 0, l = 0; for ( int i = 0; i < n; i ++ ) { freq [ a [ i ] ] ++; if ( freq [ a [ i ] ] == 1 ) now ++; while ( now > k ) { freq [ a [ l ] ] --; if ( freq [ a [ l ] ] == 0 ) now --; l ++; } if ( i - l + 1 >= end - start + 1 ) end = i, start = l; } for ( int i = start; i <= end; i ++ ) cout << a [ i ] << " "; }
int countSubStr ( char str [ ] ) { int m = 0; for ( int i = 0; str [ i ] != '\0'; i ++ ) { if ( str [ i ] == '1' ) m ++; } return m * ( m - 1 ) / 2; }
string reversingString ( string str, int start, int end ) { while ( start < end ) { str [ start ] ^= str [ end ]; str [ end ] ^= str [ start ]; str [ start ] ^= str [ end ]; ++ start; -- end; } return str; }
void translate ( char * str ) { int len = strlen ( str ); if ( len < 2 ) return; int i = 0; int j = 0; while ( j < len - 1 ) { if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) { j = j + 2; str [ i ++ ] = 'C'; continue; } str [ i ++ ] = str [ j ++ ]; } if ( j == len - 1 ) str [ i ++ ] = str [ j ]; str [ i ] = ''; }
int nextFit ( int weight [ ], int n, int c ) { int res = 0, bin_rem = c; for ( int i = 0; i < n; i ++ ) { if ( weight [ i ] > bin_rem ) { res ++; bin_rem = c - weight [ i ]; } else bin_rem -= weight [ i ]; } return res; }
int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n; return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ), n ); }
bool areSumSame ( int a [ ] [ MAX ], int n, int m ) { int sum1 = 0, sum2 = 0; for ( int i = 0; i < n; i ++ ) { sum1 = 0, sum2 = 0; for ( int j = 0; j < m; j ++ ) { sum1 += a [ i ] [ j ]; sum2 += a [ j ] [ i ]; } if ( sum1 == sum2 ) return true; } return false; }
int minSumPath ( vector < vector < int > > & A ) { int memo [ A . size ( ) ]; int n = A . size ( ) - 1; for ( int i = 0; i < A [ n ] . size ( ); i ++ ) memo [ i ] = A [ n ] [ i ]; for ( int i = A . size ( ) - 2; i >= 0; i -- ) for ( int j = 0; j < A [ i ] . size ( ); j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ], memo [ j + 1 ] ); return memo [ 0 ]; }
void productArray ( int arr [ ], int n ) { if ( n == 1 ) { cout << 0; return; } int i, temp = 1; int * prod = new int [ ( sizeof ( int ) * n ) ]; memset ( prod, 1, n ); for ( i = 0; i < n; i ++ ) { prod [ i ] = temp; temp *= arr [ i ]; } temp = 1; for ( i = n - 1; i >= 0; i -- ) { prod [ i ] *= temp; temp *= arr [ i ]; } for ( i = 0; i < n; i ++ ) cout << prod [ i ] << " "; return; }
void recaman ( int n ) { if ( n <= 0 ) return; printf ( "%d, ", 0 ); unordered_set < int > s; s . insert ( 0 ); int prev = 0; for ( int i = 1; i < n; i ++ ) { int curr = prev - i; if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr = prev + i; s . insert ( curr ); printf ( "%d, ", curr ); prev = curr; } }
int maxProfit ( int price [ ], int n, int k ) { int profit [ k + 1 ] [ n + 1 ]; for ( int i = 0; i <= k; i ++ ) profit [ i ] [ 0 ] = 0; for ( int j = 0; j <= n; j ++ ) profit [ 0 ] [ j ] = 0; for ( int i = 1; i <= k; i ++ ) { int prevDiff = INT_MIN; for ( int j = 1; j < n; j ++ ) { prevDiff = max ( prevDiff, profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ); profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ], price [ j ] + prevDiff ); } } return profit [ k ] [ n - 1 ]; }
int countNum ( int arr [ ], int n ) { unordered_set < int > s; int count = 0, maxm = INT_MIN, minm = INT_MAX; for ( int i = 0; i < n; i ++ ) { s . insert ( arr [ i ] ); if ( arr [ i ] < minm ) minm = arr [ i ]; if ( arr [ i ] > maxm ) maxm = arr [ i ]; } for ( int i = minm; i <= maxm; i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count ++; return count; }
void printSpiral ( int mat [ ] [ MAX ], int r, int c ) { int i, a = 0, b = 2; int low_row = ( 0 > a ) ? 0 : a; int low_column = ( 0 > b ) ? 0 : b - 1; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1; i <= high_column && i < c && low_row >= 0; ++ i ) cout << mat [ low_row ] [ i ] << " "; low_row -= 1; for ( i = low_row + 2; i <= high_row && i < r && high_column < c; ++ i ) cout << mat [ i ] [ high_column ] << " "; high_column += 1; for ( i = high_column - 2; i >= low_column && i >= 0 && high_row < r; -- i ) cout << mat [ high_row ] [ i ] << " "; high_row += 1; for ( i = high_row - 2; i > low_row && i >= 0 && low_column >= 0; -- i ) cout << mat [ i ] [ low_column ] << " "; low_column -= 1; } cout << endl; }
void findString ( string str, int n, int k ) { if ( k == 0 ) { cout << str << endl; return; } string str2 = str; int p = 0; for ( int i = 0; i < n; i ++ ) { if ( str2 [ i ] != 'a' ) { str2 [ i ] = 'a'; p ++; if ( p == k ) break; } } if ( p < k ) { for ( int i = n - 1; i >= 0; i -- ) if ( str [ i ] == 'a' ) { str2 [ i ] = 'b'; p ++; if ( p == k ) break; } } cout << str2 << endl; }
void evaluate ( long long int n ) { if ( n == 1 || n == 2 ) printf ( "No Pythagoras Triplet exists" ); else if ( n % 2 == 0 ) { long long int var = 1LL * n * n / 4; printf ( "Pythagoras Triplets exist i.e. " ); printf ( "%lld %lld %lld", n, var - 1, var + 1 ); } else if ( n % 2 != 0 ) { long long int var = 1LL * n * n + 1; printf ( "Pythagoras Triplets exist i.e. " ); printf ( "%lld %lld %lld", n, var / 2 - 1, var / 2 ); } }
int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ); }
void printTwoElements ( int arr [ ], int size ) { int i; cout << " The repeating element is "; for ( i = 0; i < size; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ]; else cout << abs ( arr [ i ] ) << "\n"; } cout << "and the missing element is "; for ( i = 0; i < size; i ++ ) { if ( arr [ i ] > 0 ) cout << ( i + 1 ); } }
int longSubarrWthSumDivByK ( int arr [ ], int n, int k ) { unordered_map < int, int > um; int mod_arr [ n ], max = 0; int curr_sum = 0; for ( int i = 0; i < n; i ++ ) { curr_sum += arr [ i ]; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k; } for ( int i = 0; i < n; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1; else if ( um . find ( mod_arr [ i ] ) == um . end ( ) ) um [ mod_arr [ i ] ] = i; else if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i - um [ mod_arr [ i ] ]; } return max; }
void findTriplets ( int x ) { vector < int > fact; unordered_set < int > factors; for ( int i = 2; i <= sqrt ( x ); i ++ ) { if ( x % i == 0 ) { fact . push_back ( i ); if ( x / i != i ) fact . push_back ( x / i ); factors . insert ( i ); factors . insert ( x / i ); } } bool found = false; int k = fact . size ( ); for ( int i = 0; i < k; i ++ ) { int a = fact [ i ]; for ( int j = 0; j < k; j ++ ) { int b = fact [ j ]; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { cout << a << " " << b << " " << ( x / ( a * b ) ); found = true; break; } } if ( found ) break; } if ( ! found ) cout << "-1"; }
bool checkSentence ( char str [ ] ) { int len = strlen ( str ); if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false; if ( str [ len - 1 ] != '.' ) return false; int prev_state = 0, curr_state = 0; int index = 1; while ( str [ index ] ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0; else if ( str [ index ] == ' ' ) curr_state = 1; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2; else if ( str [ index ] == '.' ) curr_state = 3; if ( prev_state == curr_state && curr_state != 2 ) return false; if ( prev_state == 2 && curr_state == 0 ) return false; if ( curr_state == 3 && prev_state != 1 ) return ( str [ index + 1 ] == '\0' ); index ++; prev_state = curr_state; } return false; }
long long int countNonDecreasing ( int n ) { int N = 10; long long count = 1; for ( int i = 1; i <= n; i ++ ) { count *= ( N + i - 1 ); count /= i; } return count; }
int binomialCoeffSum ( int n ) { return ( 1 << n ); }
int maxSum ( int arr [ ], int N, int k ) { int MS [ N ]; MS [ N - 1 ] = arr [ N - 1 ]; for ( int i = N - 2; i >= 0; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = max ( arr [ i ], MS [ i + 1 ] ); else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ], MS [ i + 1 ] ); } return MS [ 0 ]; }
int findNth ( int n ) { int count = 0; for ( int curr = 19; ; curr += 9 ) { int sum = 0; for ( int x = curr; x > 0; x = x / 10 ) sum = sum + x % 10; if ( sum == 10 ) count ++; if ( count == n ) return curr; } return - 1; }
bool isDDM ( int m [ N ] [ N ], int n ) { for ( int i = 0; i < n; i ++ ) { int sum = 0; for ( int j = 0; j < n; j ++ ) sum += abs ( m [ i ] [ j ] ); sum -= abs ( m [ i ] [ i ] ); if ( abs ( m [ i ] [ i ] ) < sum ) return false; } return true; }
pair < double, double > void lineFromPoints ( pdd P, pdd Q ) { double a = Q . second - P . second; double b = P . first - Q . first; double c = a * ( P . first ) + b * ( P . second ); if ( b < 0 ) { cout << "The line passing through points P and Q is: " << a << "x " << b << "y = " << c << endl; } else { cout << "The line passing through points P and Q is: " << a << "x + " << b << "y = " << c << endl; } }
int findLongestConseqSubseq ( int arr [ ], int n ) { unordered_set < int > S; int ans = 0; for ( int i = 0; i < n; i ++ ) S . insert ( arr [ i ] ); for ( int i = 0; i < n; i ++ ) { if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) { int j = arr [ i ]; while ( S . find ( j ) != S . end ( ) ) j ++; ans = max ( ans, j - arr [ i ] ); } } return ans; }
void longestString ( string str1, string str2 ) { int count1 [ 26 ] = { 0 }, count2 [ 26 ] = { 0 }; for ( int i = 0; i < str1 . length ( ); i ++ ) count1 [ str1 [ i ] - 'a' ] ++; for ( int i = 0; i < str2 . length ( ); i ++ ) count2 [ str2 [ i ] - 'a' ] ++; string result; for ( int i = 0; i < 26; i ++ ) for ( int j = 1; j <= min ( count1 [ i ], count2 [ i ] ); j ++ ) result . push_back ( 'a' + i ); cout << result; }
int count ( int n ) { int table [ n + 1 ], i; for ( int j = 0; j < n + 1; j ++ ) table [ j ] = 0; table [ 0 ] = 1; for ( i = 3; i <= n; i ++ ) table [ i ] += table [ i - 3 ]; for ( i = 5; i <= n; i ++ ) table [ i ] += table [ i - 5 ]; for ( i = 10; i <= n; i ++ ) table [ i ] += table [ i - 10 ]; return table [ n ]; }
bool flipsPossible ( int a [ ], int n ) { int count_odd = 0, count_even = 0; for ( int i = 0; i < n; i ++ ) { if ( a [ i ] & 1 ) count_odd ++; else count_even ++; } if ( count_odd % 2 && count_even % 2 ) return false; else return true; }
int findExtra ( int arr1 [ ], int arr2 [ ], int n ) { for ( int i = 0; i < n; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i; return n; }
void swap ( int * xp, int * yp ) { if ( xp == yp ) return; * xp = * xp + * yp; * yp = * xp - * yp; * xp = * xp - * yp; }
int maxSum ( int arr [ ], int n ) { int arrSum = 0; int currVal = 0; for ( int i = 0; i < n; i ++ ) { arrSum = arrSum + arr [ i ]; currVal = currVal + ( i * arr [ i ] ); } int maxVal = currVal; for ( int j = 1; j < n; j ++ ) { currVal = currVal + arrSum - n * arr [ n - j ]; if ( currVal > maxVal ) maxVal = currVal; } return maxVal; }
int minInitialPoints ( int points [ ] [ C ] ) { int dp [ R ] [ C ]; int m = R, n = C; dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : abs ( points [ m - 1 ] [ n - 1 ] ) + 1; for ( int i = m - 2; i >= 0; i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ], 1 ); for ( int j = n - 2; j >= 0; j -- ) dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ], 1 ); for ( int i = m - 2; i >= 0; i -- ) { for ( int j = n - 2; j >= 0; j -- ) { int min_points_on_exit = min ( dp [ i + 1 ] [ j ], dp [ i ] [ j + 1 ] ); dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ], 1 ); } } return dp [ 0 ] [ 0 ]; }
int countWays ( int n ) { int table [ n + 1 ]; memset ( table, 0, sizeof ( table ) ); table [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) for ( int j = i; j <= n; j ++ ) table [ j ] += table [ j - i ]; return table [ n ]; }
int countGroups ( int position, int previous_sum, int length, char * num ) { if ( position == length ) return 1; int res = 0; int sum = 0; for ( int i = position; i < length; i ++ ) { sum += ( num [ i ] - '0' ); if ( sum >= previous_sum ) res += countGroups ( i + 1, sum, length, num ); } return res; }
string wordReverse ( string str ) { int i = str . length ( ) - 1; int start, end = i + 1; string result = ""; while ( i >= 0 ) { if ( str [ i ] == ' ' ) { start = i + 1; while ( start != end ) result += str [ start ++ ]; result += ' '; end = i; } i --; } start = 0; while ( start != end ) result += str [ start ++ ]; return result; }
double squareRoot ( double n ) { return pow ( 2, 0.5 * log2 ( n ) ); }
int minXOR ( int arr [ ], int n ) { sort ( arr, arr + n ); int minXor = INT_MAX; int val = 0; for ( int i = 0; i < n - 1; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ]; minXor = min ( minXor, val ); } return minXor; }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6; }
int sumNodes ( int l ) { int leafNodeCount = pow ( 2, l - 1 ); int sumLastLevel = 0; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2; int sum = sumLastLevel * l; return sum; }
int eulerian ( int n, int m ) { int dp [ n + 1 ] [ m + 1 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 1; i <= n; i ++ ) { for ( int j = 0; j <= m; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ); } } } return dp [ n ] [ m ]; }
void findSymPairs ( int arr [ ] [ 2 ], int row ) { unordered_map < int, int > hM; for ( int i = 0; i < row; i ++ ) { int first = arr [ i ] [ 0 ]; int sec = arr [ i ] [ 1 ]; if ( hM . find ( sec ) != hM . end ( ) && hM [ sec ] == first ) cout << "(" << sec << ", " << first << ")" << endl; else hM [ first ] = sec; } }
string lexNext ( string s, int n ) { for ( int i = n - 1; i >= 0; i -- ) { if ( s [ i ] != 'z' ) { s [ i ] ++; return s; } s [ i ] = 'a'; } }
void arrayEvenAndOdd ( int arr [ ], int n ) { int i = - 1, j = 0; int t; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++; swap ( arr [ i ], arr [ j ] ); } j ++; } for ( int i = 0; i < n; i ++ ) cout << arr [ i ] << " "; }
bool isPrime ( int n ) { if ( n <= 1 ) return false; for ( int i = 2; i < n; i ++ ) if ( n % i == 0 ) return false; return true; }
int maxProduct ( int arr [ ], int n ) { if ( n < 3 ) return - 1; sort ( arr, arr + n ); return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ], arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ); }
int lcs ( int i, int j, int count ) { if ( i == 0 || j == 0 ) return count; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1, j - 1, count + 1 ); } count = max ( count, max ( lcs ( i, j - 1, 0 ), lcs ( i - 1, j, 0 ) ) ); return count; }
unsigned int nextPowerOf2 ( unsigned int n ) { n --; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; n ++; return n; }
int gcd ( int a, int b ) { if ( a == b ) return a; if ( a == 0 ) return b; if ( b == 0 ) return a; if ( ~ a & 1 ) { if ( b & 1 ) return gcd ( a >> 1, b ); else return gcd ( a >> 1, b >> 1 ) << 1; } if ( ~ b & 1 ) return gcd ( a, b >> 1 ); if ( a > b ) return gcd ( ( a - b ) >> 1, b ); return gcd ( ( b - a ) >> 1, a ); }
bool check ( int n ) { return 1162261467 % n == 0; }
void PerformQueries ( vector < int > & a, vector < pair < long long, int > > & vec ) { vector < int > ans; int n = ( int ) a . size ( ) - 1; int q = ( int ) vec . size ( ); for ( int i = 0; i < q; ++ i ) { long long t = vec [ i ] . first; int m = vec [ i ] . second; if ( m > n ) { ans . push_back ( - 1 ); continue; } int turn = t / n; int rem = t % n; if ( rem == 0 and turn % 2 == 1 ) { ans . push_back ( - 1 ); continue; } if ( rem == 0 and turn % 2 == 0 ) { ans . push_back ( a [ m ] ); continue; } if ( turn % 2 == 0 ) { int cursize = n - rem; if ( cursize < m ) { ans . push_back ( - 1 ); continue; } ans . push_back ( a [ m + rem ] ); } else { int cursize = rem; if ( cursize < m ) { ans . push_back ( - 1 ); continue; } ans . push_back ( a [ m ] ); } } for ( int i : ans ) cout << i << "\n"; }
string decode ( string str ) { stack < int > integerstack; stack < char > stringstack; string temp = "", result = ""; for ( int i = 0; i < str . length ( ); i ++ ) { int count = 0; if ( str [ i ] >= '0' && str [ i ] <= '9' ) { while ( str [ i ] >= '0' && str [ i ] <= '9' ) { count = count * 10 + str [ i ] - '0'; i ++; } i --; integerstack . push ( count ); } else if ( str [ i ] == ']' ) { temp = ""; count = 0; if ( ! integerstack . empty ( ) ) { count = integerstack . top ( ); integerstack . pop ( ); } while ( ! stringstack . empty ( ) && stringstack . top ( ) != '[' ) { temp = stringstack . top ( ) + temp; stringstack . pop ( ); } if ( ! stringstack . empty ( ) && stringstack . top ( ) == '[' ) stringstack . pop ( ); for ( int j = 0; j < count; j ++ ) result = result + temp; for ( int j = 0; j < result . length ( ); j ++ ) stringstack . push ( result [ j ] ); result = ""; } else if ( str [ i ] == '[' ) { if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) stringstack . push ( str [ i ] ); else { stringstack . push ( str [ i ] ); integerstack . push ( 1 ); } } else stringstack . push ( str [ i ] ); } while ( ! stringstack . empty ( ) ) { result = stringstack . top ( ) + result; stringstack . pop ( ); } return result; }
int getInvCount ( int arr [ ], int n ) { int inv_count = 0; for ( int i = 0; i < n - 1; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++; return inv_count; }
void arrangeString ( string str, int x, int y ) { int count_0 = 0; int count_1 = 0; int len = str . length ( ); for ( int i = 0; i < len; i ++ ) { if ( str [ i ] == '0' ) count_0 ++; else count_1 ++; } while ( count_0 > 0 || count_1 > 0 ) { for ( int j = 0; j < x && count_0 > 0; j ++ ) { if ( count_0 > 0 ) { cout << "0"; count_0 --; } } for ( int j = 0; j < y && count_1 > 0; j ++ ) { if ( count_1 > 0 ) { cout << "1"; count_1 --; } } } }
int xorZero ( string str ) { int one_count = 0, zero_count = 0; int n = str . length ( ); for ( int i = 0; i < n; i ++ ) if ( str [ i ] == '1' ) one_count ++; else zero_count ++; if ( one_count % 2 == 0 ) return zero_count; return one_count; }
string compute ( string str, int n ) { string reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba"; int l = str . length ( ); for ( int i = n; i < l; i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - 'a' ]; return str; }
void shuffle ( int card [ ], int n ) { srand ( time ( 0 ) ); for ( int i = 0; i < n; i ++ ) { int r = i + ( rand ( ) % ( 52 - i ) ); swap ( card [ i ], card [ r ] ); } }
int findMin ( int arr [ ], int low, int high ) { if ( high < low ) return arr [ 0 ]; if ( high == low ) return arr [ low ]; int mid = low + ( high - low ) / 2; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ]; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ]; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr, low, mid - 1 ); return findMin ( arr, mid + 1, high ); }
int countSeq ( int n ) { int nCr = 1, res = 1; for ( int r = 1; r <= n; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r; res += nCr * nCr; } return res; }
int getInvCount ( int arr [ ], int n ) { int invcount = 0; for ( int i = 0; i < n - 2; i ++ ) { for ( int j = i + 1; j < n - 1; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1; k < n; k ++ ) { if ( arr [ j ] > arr [ k ] ) invcount ++; } } } } return invcount; }
int maxProfit ( int price [ ], int n ) { int * profit = new int [ n ]; for ( int i = 0; i < n; i ++ ) profit [ i ] = 0; int max_price = price [ n - 1 ]; for ( int i = n - 2; i >= 0; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ]; profit [ i ] = max ( profit [ i + 1 ], max_price - price [ i ] ); } int min_price = price [ 0 ]; for ( int i = 1; i < n; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ]; profit [ i ] = max ( profit [ i - 1 ], profit [ i ] + ( price [ i ] - min_price ) ); } int result = profit [ n - 1 ]; delete [ ] profit; return result; }
void fib ( int n ) { int a = 0, b = 1; if ( n >= 0 ) cout << a << " "; if ( n >= 1 ) cout << b << " "; for ( int i = 2; i <= n; i ++ ) { cout << a + b << " "; b = a + b; a = b - a; } }
bool isSymmetric ( int mat [ ] [ MAX ], int N ) { for ( int i = 0; i < N; i ++ ) for ( int j = 0; j < N; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false; return true; }
char maxRepeating ( string str ) { int n = str . length ( ); int count = 0; char res = str [ 0 ]; int cur_count = 1; for ( int i = 0; i < n; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++; else { if ( cur_count > count ) { count = cur_count; res = str [ i ]; } cur_count = 1; } } return res; }
int smallest ( int x, int y, int z ) { int c = 0; while ( x && y && z ) { x --; y --; z --; c ++; } return c; }
void sortString ( string & str ) { int charCount [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < str . length ( ); i ++ ) charCount [ str [ i ] - 'a' ] ++; for ( int i = 0; i < MAX_CHAR; i ++ ) for ( int j = 0; j < charCount [ i ]; j ++ ) cout << ( char ) ( 'a' + i ); }
void minSpacePreferLarge ( int wall, int m, int n ) { int num_m = 0, num_n = 0, min_empty = wall; int p = 0, q = 0, rem; while ( wall >= n ) { p = wall / m; rem = wall % m; if ( rem <= min_empty ) { num_m = p; num_n = q; min_empty = rem; } q += 1; wall = wall - n; } cout << num_m << " " << num_n << " " << min_empty << endl; }
void alternateSort ( int arr [ ], int n ) { sort ( arr, arr + n ); int i = 0, j = n - 1; while ( i < j ) { cout << arr [ j -- ] << " "; cout << arr [ i ++ ] << " "; } if ( n % 2 != 0 ) cout << arr [ i ]; }
int maxProfit ( int price [ ], int n, int k ) { int profit [ k + 1 ] [ n + 1 ]; for ( int i = 0; i <= k; i ++ ) profit [ i ] [ 0 ] = 0; for ( int j = 0; j <= n; j ++ ) profit [ 0 ] [ j ] = 0; for ( int i = 1; i <= k; i ++ ) { for ( int j = 1; j < n; j ++ ) { int max_so_far = INT_MIN; for ( int m = 0; m < j; m ++ ) max_so_far = max ( max_so_far, price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ); profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ], max_so_far ); } } return profit [ k ] [ n - 1 ]; }
int maximumSum ( int a [ ] [ M ], int n ) { for ( int i = 0; i < n; i ++ ) sort ( a [ i ], a [ i ] + M ); int sum = a [ n - 1 ] [ M - 1 ]; int prev = a [ n - 1 ] [ M - 1 ]; int i, j; for ( i = n - 2; i >= 0; i -- ) { for ( j = M - 1; j >= 0; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ]; sum += prev; break; } } if ( j == - 1 ) return 0; } return sum; }
int minJumps ( int a, int b, int d ) { int temp = a; a = min ( a, b ); b = max ( temp, b ); if ( d >= b ) return ( d + b - 1 ) / b; if ( d == 0 ) return 0; if ( d == a ) return 1; return 2; }
int largestKSubmatrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ]; memset ( dp, sizeof ( dp ), 0 ); int result = 0; for ( int i = 0; i < Row; i ++ ) { for ( int j = 0; j < Col; j ++ ) { if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ), dp [ i - 1 ] [ j - 1 ] ) + 1; else dp [ i ] [ j ] = 1; } result = max ( result, dp [ i ] [ j ] ); } } return result; }
bool isProduct ( int arr [ ], int n, int x ) { if ( n < 2 ) return false; unordered_set < int > s; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true; else continue; } if ( x % arr [ i ] == 0 ) { if ( s . find ( x / arr [ i ] ) != s . end ( ) ) return true; s . insert ( arr [ i ] ); } } return false; }
int maxSum ( int grid [ 2 ] [ MAX ], int n ) { int incl = max ( grid [ 0 ] [ 0 ], grid [ 1 ] [ 0 ] ); int excl = 0, excl_new; for ( int i = 1; i < n; i ++ ) { excl_new = max ( excl, incl ); incl = excl + max ( grid [ 0 ] [ i ], grid [ 1 ] [ i ] ); excl = excl_new; } return max ( excl, incl ); }
int countFact ( int low, int high ) { int fact = 1, x = 1; while ( fact < low ) { fact = fact * x; x ++; } int res = 0; while ( fact <= high ) { res ++; fact = fact * x; x ++; } return res; }
string longDivision ( string number, int divisor ) { string ans; int idx = 0; int temp = number [ idx ] - '0'; while ( temp < divisor ) temp = temp * 10 + ( number [ ++ idx ] - '0' ); while ( number . size ( ) > idx ) { ans += ( temp / divisor ) + '0'; temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0'; } if ( ans . length ( ) == 0 ) return "0"; return ans; }
unsigned long long int int decimalToBinary ( int N ) { ull B_Number = 0; int cnt = 0; while ( N != 0 ) { int rem = N % 2; ull c = pow ( 10, cnt ); B_Number += rem * c; N /= 2; cnt ++; } return B_Number; }
int power ( int x, unsigned int y, int p ) { int res = 1; x = x % p; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p; y = y >> 1; x = ( x * x ) % p; } return res; }
int find_difference ( int arr [ ], int n, int m ) { int max = 0, min = 0; sort ( arr, arr + n ); for ( int i = 0, j = n - 1; i < m; i ++, j -- ) { min += arr [ i ]; max += arr [ j ]; } return ( max - min ); }
int solve ( char X [ ], char Y [ ], int l, int r, int k, int dp [ ] [ N ] [ N ] ) { if ( ! k ) return 0; if ( l < 0 | r < 0 ) return 1e9; if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [ k ]; int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ); return dp [ l ] [ r ] [ k ] = min ( { cost + solve ( X, Y, l - 1, r - 1, k - 1, dp ), solve ( X, Y, l - 1, r, k, dp ), solve ( X, Y, l, r - 1, k, dp ) } ); }
int countPairs ( int arr [ ], int n ) { unordered_map < int, int > mp; for ( int i = 0; i < n; i ++ ) mp [ arr [ i ] ] ++; int ans = 0; for ( auto it = mp . begin ( ); it != mp . end ( ); it ++ ) { int count = it -> second; ans += ( count * ( count - 1 ) ) / 2; } return ans; }
void query ( char s [ ], int i, int j ) { int n = strlen ( s ); i %= n; j %= n; ( s [ i ] == s [ j ] ) ? ( cout << "Yes" << endl ) : ( cout << "No" << endl ); }
void print_sequence ( int n, int k ) { int b = n / ( k * ( k + 1 ) / 2 ); if ( b == 0 ) { cout << - 1 << endl; } else { int r = 1; for ( int x = 1; x * x <= n; x ++ ) { if ( n % x != 0 ) continue; if ( x <= b && x > r ) r = x; if ( n / x <= b && n / x > r ) r = n / x; } for ( int i = 1; i < k; i ++ ) cout << r * i << " "; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ); cout << res << endl; } }
void section ( double x1, double x2, double y1, double y2, double m, double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ); double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ); cout << "(" << x << ", "; cout << y << ")" << endl; }
int carAssembly ( int a [ ] [ NUM_STATION ], int t [ ] [ NUM_STATION ], int * e, int * x ) { int T1 [ NUM_STATION ], T2 [ NUM_STATION ], i; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ]; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ]; for ( i = 1; i < NUM_STATION; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ], T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ); T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ], T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ); } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ], T2 [ NUM_STATION - 1 ] + x [ 1 ] ); }
int maxAlternateSum ( int arr [ ], int n ) { if ( n == 1 ) return arr [ 0 ]; int dec [ n ]; memset ( dec, 0, sizeof ( dec ) ); int inc [ n ]; memset ( inc, 0, sizeof ( inc ) ); dec [ 0 ] = inc [ 0 ] = arr [ 0 ]; int flag = 0; for ( int i = 1; i < n; i ++ ) { for ( int j = 0; j < i; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = max ( dec [ i ], inc [ j ] + arr [ i ] ); flag = 1; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = max ( inc [ i ], dec [ j ] + arr [ i ] ); } } int result = INT_MIN; for ( int i = 0; i < n; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ]; if ( result < dec [ i ] ) result = dec [ i ]; } return result; }
unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0; while ( n ) { count += n & 1; n >>= 1; } return count; }
int seiresSum ( int n, int a [ ] ) { int res = 0; for ( int i = 0; i < 2 * n; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ]; else res -= a [ i ] * a [ i ]; } return res; }
int findSum ( int n ) { int ans = 0; for ( int i = 1; i <= n; i ++ ) for ( int j = 1; j <= n; j ++ ) ans += ( i / j ); return ans; }
int findPosition ( int k, int n ) { unsigned long long int f1 = 0, f2 = 1, f3; for ( int i = 2; i <= MAX; i ++ ) { f3 = f1 + f2; f1 = f2; f2 = f3; if ( f2 % k == 0 ) return n * i; } }
int dealnnoy ( int n, int m ) { if ( m == 0 || n == 0 ) return 1; return dealnnoy ( m - 1, n ) + dealnnoy ( m - 1, n - 1 ) + dealnnoy ( m, n - 1 ); }
bool isPowerOfFour ( unsigned int n ) { int count = 0; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1; count += 1; } return ( count % 2 == 0 ) ? 1 : 0; } return 0; }
void printSumSimple ( int mat [ ] [ n ], int k ) { if ( k > n ) return; for ( int i = 0; i < n - k + 1; i ++ ) { for ( int j = 0; j < n - k + 1; j ++ ) { int sum = 0; for ( int p = i; p < k + i; p ++ ) for ( int q = j; q < k + j; q ++ ) sum += mat [ p ] [ q ]; cout << sum << " "; } cout << endl; } }
int sumofFactors ( int n ) { int res = 1; for ( int i = 2; i <= sqrt ( n ); i ++ ) { int curr_sum = 1; int curr_term = 1; while ( n % i == 0 ) { n = n / i; curr_term *= i; curr_sum += curr_term; } res *= curr_sum; } if ( n >= 2 ) res *= ( 1 + n ); return res; }
bool subArrayExists ( int arr [ ], int n ) { unordered_set < int > sumSet; int sum = 0; for ( int i = 0; i < n; i ++ ) { sum += arr [ i ]; if ( sum == 0 || sumSet . find ( sum ) != sumSet . end ( ) ) return true; sumSet . insert ( sum ); } return false; }
int countP ( int n, int k ) { int dp [ n + 1 ] [ k + 1 ]; for ( int i = 0; i <= n; i ++ ) dp [ i ] [ 0 ] = 0; for ( int i = 0; i <= k; i ++ ) dp [ 0 ] [ k ] = 0; for ( int i = 1; i <= n; i ++ ) for ( int j = 1; j <= i; j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ]; return dp [ n ] [ k ]; }
int findElement ( int arr [ ], int n ) { int leftMax [ n ]; leftMax [ 0 ] = INT_MIN; for ( int i = 1; i < n; i ++ ) leftMax [ i ] = max ( leftMax [ i - 1 ], arr [ i - 1 ] ); int rightMin = INT_MAX; for ( int i = n - 1; i >= 0; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i; rightMin = min ( rightMin, arr [ i ] ); } return - 1; }
int winner ( int a [ ], int n, int k ) { if ( k >= n - 1 ) return n; int best = 0, times = 0; for ( int i = 0; i < n; i ++ ) { if ( a [ i ] > best ) { best = a [ i ]; if ( i ) times = 1; } else times += 1; if ( times >= k ) return best; } return best; }
void modularEquation ( int a, int b ) { if ( a < b ) { cout << "No solution possible " << endl; return; } if ( a == b ) { cout << "Infinite Solution possible " << endl; return; } int count = 0; int n = a - b; int y = sqrt ( a - b ); for ( int i = 1; i <= y; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++; if ( i > b ) count ++; } } if ( y * y == n && y > b ) count --; cout << count << endl; }
public : int multiply ( int x, int y ) { if ( y == 0 ) return 0; if ( y > 0 ) return ( x + multiply ( x, y - 1 ) ); if ( y < 0 ) return - multiply ( x, - y ); }
int minimumBox ( int arr [ ], int n ) { queue < int > q; sort ( arr, arr + n ); q . push ( arr [ 0 ] ); for ( int i = 1; i < n; i ++ ) { int now = q . front ( ); if ( arr [ i ] >= 2 * now ) q . pop ( ); q . push ( arr [ i ] ); } return q . size ( ); }
string firstLetterWord ( string str ) { string result = ""; bool v = true; for ( int i = 0; i < str . length ( ); i ++ ) { if ( str [ i ] == ' ' ) v = true; else if ( str [ i ] != ' ' && v == true ) { result . push_back ( str [ i ] ); v = false; } } return result; }
int countDivisibles ( int arr [ ], int n ) { int res = 0; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++; return res; }
void recursiveReverse ( string & str ) { stack < char > st; for ( int i = 0; i < str . length ( ); i ++ ) st . push ( str [ i ] ); for ( int i = 0; i < str . length ( ); i ++ ) { str [ i ] = st . top ( ); st . pop ( ); } }
void findAndPrintUncommonChars ( string str1, string str2 ) { int present [ MAX_CHAR ]; for ( int i = 0; i < MAX_CHAR; i ++ ) present [ i ] = 0; int l1 = str1 . size ( ); int l2 = str2 . size ( ); for ( int i = 0; i < l1; i ++ ) present [ str1 [ i ] - 'a' ] = 1; for ( int i = 0; i < l2; i ++ ) { if ( present [ str2 [ i ] - 'a' ] == 1 || present [ str2 [ i ] - 'a' ] == - 1 ) present [ str2 [ i ] - 'a' ] = - 1; else present [ str2 [ i ] - 'a' ] = 2; } for ( int i = 0; i < MAX_CHAR; i ++ ) if ( present [ i ] == 1 || present [ i ] == 2 ) cout << ( char ( i + 'a' ) ) << " "; }
int findIndex ( string str ) { int len = str . length ( ); int open [ len + 1 ], close [ len + 1 ]; int index = - 1; memset ( open, 0, sizeof ( open ) ); memset ( close, 0, sizeof ( close ) ); open [ 0 ] = 0; close [ len ] = 0; if ( str [ 0 ] == '(' ) open [ 1 ] = 1; if ( str [ len - 1 ] == ')' ) close [ len - 1 ] = 1; for ( int i = 1; i < len; i ++ ) { if ( str [ i ] == '(' ) open [ i + 1 ] = open [ i ] + 1; else open [ i + 1 ] = open [ i ]; } for ( int i = len - 2; i >= 0; i -- ) { if ( str [ i ] == ')' ) close [ i ] = close [ i + 1 ] + 1; else close [ i ] = close [ i + 1 ]; } if ( open [ len ] == 0 ) return len; if ( close [ 0 ] == 0 ) return 0; for ( int i = 0; i <= len; i ++ ) if ( open [ i ] == close [ i ] ) index = i; return index; }
int search ( int arr [ ], int l, int h, int key ) { if ( l > h ) return - 1; int mid = ( l + h ) / 2; if ( arr [ mid ] == key ) return mid; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr, l, mid - 1, key ); return search ( arr, mid + 1, h, key ); } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr, mid + 1, h, key ); return search ( arr, l, mid - 1, key ); }
float power ( float x, int y ) { float temp; if ( y == 0 ) return 1; temp = power ( x, y / 2 ); if ( y % 2 == 0 ) return temp * temp; else { if ( y > 0 ) return x * temp * temp; else return ( temp * temp ) / x; } }
public : float squareRoot ( float n ) { float x = n; float y = 1; float e = 0.000001; while ( x - y > e ) { x = ( x + y ) / 2; y = n / x; } return x; }
int countOps ( int A [ ] [ MAX ], int B [ ] [ MAX ], int m, int n ) { for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ]; for ( int i = 1; i < n; i ++ ) for ( int j = 1; j < m; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1; int result = 0; for ( int i = 0; i < n; i ++ ) result += abs ( A [ i ] [ 0 ] ); for ( int j = 0; j < m; j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ); return ( result ); }
public : unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1; }
int jumpSearch ( int arr [ ], int x, int n ) { int step = sqrt ( n ); int prev = 0; while ( arr [ min ( step, n ) - 1 ] < x ) { prev = step; step += sqrt ( n ); if ( prev >= n ) return - 1; } while ( arr [ prev ] < x ) { prev ++; if ( prev == min ( step, n ) ) return - 1; } if ( arr [ prev ] == x ) return prev; return - 1; }
void splitArr ( int arr [ ], int n, int k ) { for ( int i = 0; i < k; i ++ ) { int x = arr [ 0 ]; for ( int j = 0; j < n - 1; ++ j ) arr [ j ] = arr [ j + 1 ]; arr [ n - 1 ] = x; } }
int CountSubstring ( char str [ ], int n ) { int ans = ( n * ( n + 1 ) ) / 2; int a_index = 0; int b_index = 0; int c_index = 0; for ( int i = 0; i < n; i ++ ) { if ( str [ i ] == 'a' ) { a_index = i + 1; ans -= min ( b_index, c_index ); } else if ( str [ i ] == 'b' ) { b_index = i + 1; ans -= min ( a_index, c_index ); } else { c_index = i + 1; ans -= min ( a_index, b_index ); } } return ans; }
float findVolume ( float l, float b, float h ) { float volume = ( l * b * h ) / 2; return volume; }
bool checkCorrectOrNot ( string s ) { int count1 [ MAX_CHAR ] = { 0 }; int count2 [ MAX_CHAR ] = { 0 }; int n = s . length ( ); if ( n == 1 ) return true; for ( int i = 0, j = n - 1; i < j; i ++, j -- ) { count1 [ s [ i ] - 'a' ] ++; count2 [ s [ j ] - 'a' ] ++; } for ( int i = 0; i < MAX_CHAR; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false; return true; }
int find ( int n, int k ) { if ( n + 1 >= k ) return ( k - 1 ); else return ( 2 * n + 1 - k ); }
int findRotations ( string str ) { string tmp = str + str; int n = str . length ( ); for ( int i = 1; i <= n; i ++ ) { string substring = tmp . substr ( i, str . size ( ) ); if ( str == substring ) return i; } return n; }
void thirdLargest ( int arr [ ], int arr_size ) { if ( arr_size < 3 ) { printf ( " Invalid Input " ); return; } int first = arr [ 0 ]; for ( int i = 1; i < arr_size; i ++ ) if ( arr [ i ] > first ) first = arr [ i ]; int second = INT_MIN; for ( int i = 0; i < arr_size; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ]; int third = INT_MIN; for ( int i = 0; i < arr_size; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ]; printf ( "The third Largest element is %d\n", third ); }
int findLargestPlus ( int mat [ N ] [ N ] ) { int left [ N ] [ N ], right [ N ] [ N ], top [ N ] [ N ], bottom [ N ] [ N ]; for ( int i = 0; i < N; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ]; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ]; left [ i ] [ 0 ] = mat [ i ] [ 0 ]; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ]; } for ( int i = 0; i < N; i ++ ) { for ( int j = 1; j < N; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1; else left [ i ] [ j ] = 0; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1; else top [ j ] [ i ] = 0; j = N - 1 - j; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1; else bottom [ j ] [ i ] = 0; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1; else right [ i ] [ j ] = 0; j = N - 1 - j; } } int n = 0; for ( int i = 0; i < N; i ++ ) { for ( int j = 0; j < N; j ++ ) { int len = min ( min ( top [ i ] [ j ], bottom [ i ] [ j ] ), min ( left [ i ] [ j ], right [ i ] [ j ] ) ); if ( len > n ) n = len; } } if ( n ) return 4 * ( n - 1 ) + 1; return 0; }
bool arekAnagrams ( string str1, string str2, int k ) { int n = str1 . length ( ); if ( str2 . length ( ) != n ) return false; int count1 [ MAX_CHAR ] = { 0 }; int count2 [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < n; i ++ ) count1 [ str1 [ i ] - 'a' ] ++; for ( int i = 0; i < n; i ++ ) count2 [ str2 [ i ] - 'a' ] ++; int count = 0; for ( int i = 0; i < MAX_CHAR; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] ); return ( count <= k ); }
void luDecomposition ( int mat [ ] [ MAX ], int n ) { int lower [ n ] [ n ], upper [ n ] [ n ]; memset ( lower, 0, sizeof ( lower ) ); memset ( upper, 0, sizeof ( upper ) ); for ( int i = 0; i < n; i ++ ) { for ( int k = i; k < n; k ++ ) { int sum = 0; for ( int j = 0; j < i; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ); upper [ i ] [ k ] = mat [ i ] [ k ] - sum; } for ( int k = i; k < n; k ++ ) { if ( i == k ) lower [ i ] [ i ] = 1; else { int sum = 0; for ( int j = 0; j < i; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ); lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ]; } } } cout << setw ( 6 ) << " Lower Triangular" << setw ( 32 ) << "Upper Triangular" << endl; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << "\t"; cout << "\t"; for ( int j = 0; j < n; j ++ ) cout << setw ( 6 ) << upper [ i ] [ j ] << "\t"; cout << endl; } }
long multiplyBySeven ( long n ) { return ( ( n << 3 ) - n ); }
void printknapSack ( int W, int wt [ ], int val [ ], int n ) { int i, w; int K [ n + 1 ] [ W + 1 ]; for ( i = 0; i <= n; i ++ ) { for ( w = 0; w <= W; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] ); else K [ i ] [ w ] = K [ i - 1 ] [ w ]; } } int res = K [ n ] [ W ]; printf ( "%d\n", res ); w = W; for ( i = n; i > 0 && res > 0; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue; else { printf ( "%d ", wt [ i - 1 ] ); res = res - val [ i - 1 ]; w = w - wt [ i - 1 ]; } } }
int MatrixChainOrder ( int p [ ], int n ) { int m [ n ] [ n ]; int i, j, k, L, q; for ( i = 1; i < n; i ++ ) m [ i ] [ i ] = 0; for ( L = 2; L < n; L ++ ) { for ( i = 1; i < n - L + 1; i ++ ) { j = i + L - 1; m [ i ] [ j ] = INT_MAX; for ( k = i; k <= j - 1; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ]; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q; } } } return m [ 1 ] [ n - 1 ]; }
string longestRepeatedSubstring ( string str ) { int n = str . length ( ); int LCSRe [ n + 1 ] [ n + 1 ]; memset ( LCSRe, 0, sizeof ( LCSRe ) ); string res; int res_length = 0; int i, index = 0; for ( i = 1; i <= n; i ++ ) { for ( int j = i + 1; j <= n; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) { LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1; if ( LCSRe [ i ] [ j ] > res_length ) { res_length = LCSRe [ i ] [ j ]; index = max ( i, index ); } } else LCSRe [ i ] [ j ] = 0; } } if ( res_length > 0 ) for ( i = index - res_length + 1; i <= index; i ++ ) res . push_back ( str [ i - 1 ] ); return res; }
int minOps ( int arr [ ], int n, int k ) { int max = * max_element ( arr, arr + n ); int res = 0; for ( int i = 0; i < n; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1; else res += ( max - arr [ i ] ) / k; } return res; }
int minCost ( int coin [ ], int n, int k ) { sort ( coin, coin + n ); int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ); int ans = 0; for ( int i = 0; i <= coins_needed - 1; i ++ ) ans += coin [ i ]; return ans; }
bool isDivisible ( long long int n ) { while ( n / 100 ) { int last_digit = n % 10; n /= 10; n += last_digit * 3; } return ( n % 29 == 0 ); }
void shuffleArray ( int a [ ], int n ) { for ( int i = 0, q = 1, k = n; i < n; i ++, k ++, q ++ ) for ( int j = k; j > i + q; j -- ) swap ( a [ j - 1 ], a [ j ] ); }
int smallestKFreq ( int a [ ], int n, int k ) { unordered_map < int, int > m; for ( int i = 0; i < n; i ++ ) m [ a [ i ] ] ++; int res = INT_MAX; for ( auto it = m . begin ( ); it != m . end ( ); ++ it ) if ( it -> second == k ) res = min ( res, it -> first ); return ( res != INT_MAX ) ? res : - 1; }
string nextGreater ( string num ) { int l = num . size ( ); for ( int i = l - 1; i >= 0; i -- ) { if ( num . at ( i ) == '0' ) { num . at ( i ) = '1'; break; } else num . at ( i ) = '0'; } if ( i < 0 ) num = "1" + num; return num; }
bool oppositeSigns ( int x, int y ) { return ( ( x ^ y ) < 0 ); }
void countToMake0lternate ( const string & s ) { int result = 0; for ( int i = 0; i < ( s . length ( ) - 1 ); i ++ ) if ( s [ i ] == s [ i + 1 ] ) result ++; return result; }
int longLenSub ( int arr [ ], int n ) { unordered_map < int, int > um; int longLen = 0; for ( int i = 0; i < n; i ++ ) { int len = 0; if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ]; if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ]; um [ arr [ i ] ] = len + 1; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ]; } return longLen; }
int countSubarrays ( int arr [ ], int n ) { int difference = 0; int ans = 0; int hash_positive [ n + 1 ], hash_negative [ n + 1 ]; fill_n ( hash_positive, n + 1, 0 ); fill_n ( hash_negative, n + 1, 0 ); hash_positive [ 0 ] = 1; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++; else difference --; if ( difference < 0 ) { ans += hash_negative [ - difference ]; hash_negative [ - difference ] ++; } else { ans += hash_positive [ difference ]; hash_positive [ difference ] ++; } } return ans; }
int lastPosition ( int n, int m, int k ) { if ( m <= n - k + 1 ) return m + k - 1; m = m - ( n - k + 1 ); return ( m % n == 0 ) ? n : ( m % n ); }
void cycleSort ( int arr [ ], int n ) { int writes = 0; for ( int cycle_start = 0; cycle_start <= n - 2; cycle_start ++ ) { int item = arr [ cycle_start ]; int pos = cycle_start; for ( int i = cycle_start + 1; i < n; i ++ ) if ( arr [ i ] < item ) pos ++; if ( pos == cycle_start ) continue; while ( item == arr [ pos ] ) pos += 1; if ( pos != cycle_start ) { swap ( item, arr [ pos ] ); writes ++; } while ( pos != cycle_start ) { pos = cycle_start; for ( int i = cycle_start + 1; i < n; i ++ ) if ( arr [ i ] < item ) pos += 1; while ( item == arr [ pos ] ) pos += 1; if ( item != arr [ pos ] ) { swap ( item, arr [ pos ] ); writes ++; } } } }
int replaceSpaces ( char str [ ] ) { int space_count = 0, i; for ( i = 0; str [ i ]; i ++ ) if ( str [ i ] == ' ' ) space_count ++; while ( str [ i - 1 ] == ' ' ) { space_count --; i --; } int new_length = i + space_count * 2 + 1; if ( new_length > MAX ) return - 1; int index = new_length - 1; str [ index -- ] = '\0'; for ( int j = i - 1; j >= 0; j -- ) { if ( str [ j ] == ' ' ) { str [ index ] = '0'; str [ index - 1 ] = '2'; str [ index - 2 ] = '%'; index = index - 3; } else { str [ index ] = str [ j ]; index --; } } return new_length; }
void findElements ( int arr [ ], int n ) { for ( int i = 0; i < n; i ++ ) { int count = 0; for ( int j = 0; j < n; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++; if ( count >= 2 ) cout << arr [ i ] << " "; } }
void convertOpposite ( string & str ) { int ln = str . length ( ); for ( int i = 0; i < ln; i ++ ) { if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) str [ i ] = str [ i ] - 32; else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) str [ i ] = str [ i ] + 32; } }
void fill0X ( int m, int n ) { int i, k = 0, l = 0; int r = m, c = n; char a [ m ] [ n ]; char x = 'X'; while ( k < m && l < n ) { for ( i = l; i < n; ++ i ) a [ k ] [ i ] = x; k ++; for ( i = k; i < m; ++ i ) a [ i ] [ n - 1 ] = x; n --; if ( k < m ) { for ( i = n - 1; i >= l; -- i ) a [ m - 1 ] [ i ] = x; m --; } if ( l < n ) { for ( i = m - 1; i >= k; -- i ) a [ i ] [ l ] = x; l ++; } x = ( x == '0' ) ? 'X' : '0'; } for ( i = 0; i < r; i ++ ) { for ( int j = 0; j < c; j ++ ) printf ( "%c ", a [ i ] [ j ] ); printf ( "\n" ); } }
void SternSequenceFunc ( vector < int > & BrocotSequence, int n ) { for ( int i = 1; BrocotSequence . size ( ) < n; i ++ ) { int considered_element = BrocotSequence [ i ]; int precedent = BrocotSequence [ i - 1 ]; BrocotSequence . push_back ( considered_element + precedent ); BrocotSequence . push_back ( considered_element ); } for ( int i = 0; i < 15; ++ i ) cout << BrocotSequence [ i ] << " "; }
int patternCount ( string str ) { char last = str [ 0 ]; int i = 1, counter = 0; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++; if ( str [ i ] == '1' ) counter ++; } last = str [ i ]; i ++; } return counter; }
int findMaxProduct ( int arr [ ], int n ) { int i; int ans = INT_MIN; int maxval = 1; int minval = 1; int prevMax; for ( i = 0; i < n; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ]; minval = min ( 1, minval * arr [ i ] ); } else if ( arr [ i ] == 0 ) { minval = 1; maxval = 0; } else if ( arr [ i ] < 0 ) { prevMax = maxval; maxval = minval * arr [ i ]; minval = prevMax * arr [ i ]; } ans = max ( ans, maxval ); if ( maxval <= 0 ) { maxval = 1; } } return ans; }
int fib ( int n ) { if ( n < 6 ) return f [ n ]; int t = 5, fn = 5; while ( t < n ) { fn = round ( fn * PHI ); t ++; } return fn; }
void KSwapMaximum ( int arr [ ], int n, int k ) { for ( int i = 0; i < n - 1 && k > 0; ++ i ) { int indexPosition = i; for ( int j = i + 1; j < n; ++ j ) { if ( k <= j - i ) break; if ( arr [ j ] > arr [ indexPosition ] ) indexPosition = j; } for ( int j = indexPosition; j > i; -- j ) swap ( arr [ j ], arr [ j - 1 ] ); k -= indexPosition - i; } }
bool isSparse ( int array [ ] [ MAX ], int m, int n ) { int counter = 0; for ( int i = 0; i < m; ++ i ) for ( int j = 0; j < n; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter; return ( counter > ( ( m * n ) / 2 ) ); }
int gcdExtended ( int a, int b, int * x, int * y ) { if ( a == 0 ) { * x = 0; * y = 1; return b; } int x1, y1; int gcd = gcdExtended ( b % a, a, & x1, & y1 ); * x = y1 - ( b / a ) * x1; * y = x1; return gcd; }
int eulerian ( int n, int m ) { if ( m >= n || n == 0 ) return 0; if ( m == 0 ) return 1; return ( n - m ) * eulerian ( n - 1, m - 1 ) + ( m + 1 ) * eulerian ( n - 1, m ); }
void firstnonrepeating ( char str [ ] ) { queue < char > q; int charCount [ MAX_CHAR ] = { 0 }; for ( int i = 0; str [ i ]; i ++ ) { q . push ( str [ i ] ); charCount [ str [ i ] - 'a' ] ++; while ( ! q . empty ( ) ) { if ( charCount [ q . front ( ) - 'a' ] > 1 ) q . pop ( ); else { cout << q . front ( ) << " "; break; } } if ( q . empty ( ) ) cout << - 1 << " "; } cout << endl; }
int CountPS ( char str [ ], int n ) { int dp [ n ] [ n ]; memset ( dp, 0, sizeof ( dp ) ); bool P [ n ] [ n ]; memset ( P, false, sizeof ( P ) ); for ( int i = 0; i < n; i ++ ) P [ i ] [ i ] = true; for ( int i = 0; i < n - 1; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true; dp [ i ] [ i + 1 ] = 1; } } for ( int gap = 2; gap < n; gap ++ ) { for ( int i = 0; i < n - gap; i ++ ) { int j = gap + i; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ]; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ]; } } return dp [ 0 ] [ n - 1 ]; }
int countLattice ( int r ) { if ( r <= 0 ) return 0; int result = 4; for ( int x = 1; x < r; x ++ ) { int ySquare = r * r - x * x; int y = sqrt ( ySquare ); if ( y * y == ySquare ) result += 4; } return result; }
bool isTriangular ( int num ) { if ( num < 0 ) return false; int c = ( - 2 * num ); int b = 1, a = 1; int d = ( b * b ) - ( 4 * a * c ); if ( d < 0 ) return false; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ); float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ); if ( root1 > 0 && floor ( root1 ) == root1 ) return true; if ( root2 > 0 && floor ( root2 ) == root2 ) return true; return false; }
int findArea ( int arr [ ], int n ) { unordered_set < int > s; int first = 0, second = 0; for ( int i = 0; i < n; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ); continue; } if ( arr [ i ] > first ) { second = first; first = arr [ i ]; } else if ( arr [ i ] > second ) second = arr [ i ]; } return ( first * second ); }
void printCommonElements ( int mat [ M ] [ N ] ) { unordered_map < int, int > mp; for ( int j = 0; j < N; j ++ ) mp [ mat [ 0 ] [ j ] ] = 1; for ( int i = 1; i < M; i ++ ) { for ( int j = 0; j < N; j ++ ) { if ( mp [ mat [ i ] [ j ] ] == i ) { mp [ mat [ i ] [ j ] ] = i + 1; if ( i == M - 1 ) cout << mat [ i ] [ j ] << " "; } } } }
int largest ( int arr [ ], int n ) { return * max_element ( arr, arr + n ); }
int count ( int n ) { int dp [ n + 1 ]; dp [ 0 ] = 0; for ( int i = 1; i <= n; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1; else if ( i == 4 ) dp [ i ] = 2; else dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ]; } return dp [ n ]; }
unsigned int russianPeasant ( unsigned int a, unsigned int b ) { int res = 0; while ( b > 0 ) { if ( b & 1 ) res = res + a; a = a << 1; b = b >> 1; } return res; }
int minDist ( int arr [ ], int n, int x, int y ) { int i = 0; int min_dist = INT_MAX; int prev; for ( i = 0; i < n; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i; break; } } for (; i < n; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) { min_dist = i - prev; prev = i; } else prev = i; } } return min_dist; }
int countDer ( int n ) { if ( n == 1 ) return 0; if ( n == 0 ) return 1; if ( n == 2 ) return 1; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ); }
int maxNumOfChocolates ( int arr [ ], int n, int k ) { unordered_map < int, int > um; int sum [ n ], curr_rem; int maxSum = 0; sum [ 0 ] = arr [ 0 ]; for ( int i = 1; i < n; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ]; for ( int i = 0; i < n; i ++ ) { curr_rem = sum [ i ] % k; if ( curr_rem == 0 ) { if ( maxSum < sum [ i ] ) maxSum = sum [ i ]; } else if ( um . find ( curr_rem ) == um . end ( ) ) um [ curr_rem ] = i; else if ( maxSum < ( sum [ i ] - sum [ um [ curr_rem ] ] ) ) maxSum = sum [ i ] - sum [ um [ curr_rem ] ]; } return ( maxSum / k ); }
int maxSumPairWithDifferenceLessThanK ( int arr [ ], int N, int K ) { sort ( arr, arr + N ); int dp [ N ]; dp [ 0 ] = 0; for ( int i = 1; i < N; i ++ ) { dp [ i ] = dp [ i - 1 ]; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = max ( dp [ i ], dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ); else dp [ i ] = max ( dp [ i ], arr [ i ] + arr [ i - 1 ] ); } } return dp [ N - 1 ]; }
int kthSmallest ( int arr [ ], int n, int k ) { sort ( arr, arr + n ); return arr [ k - 1 ]; }
int findSum ( int n ) { int sum = 0; for ( int i = 0; i < n; i ++ ) sum += i * ( n - i ); return 2 * sum; }
int countDigits ( int a, int b ) { if ( a == 0 || b == 0 ) return 1; return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1; }
int countTriangle ( int graph [ V ] [ V ], bool isDirected ) { int count_Triangle = 0; for ( int i = 0; i < V; i ++ ) { for ( int j = 0; j < V; j ++ ) { for ( int k = 0; k < V; k ++ ) { if ( graph [ i ] [ j ] && graph [ j ] [ k ] && graph [ k ] [ i ] ) count_Triangle ++; } } } isDirected ? count_Triangle /= 3 : count_Triangle /= 6; return count_Triangle; }
void minAbsSumPair ( int arr [ ], int arr_size ) { int inv_count = 0; int l, r, min_sum, sum, min_l, min_r; if ( arr_size < 2 ) { cout << "Invalid Input"; return; } min_l = 0; min_r = 1; min_sum = arr [ 0 ] + arr [ 1 ]; for ( l = 0; l < arr_size - 1; l ++ ) { for ( r = l + 1; r < arr_size; r ++ ) { sum = arr [ l ] + arr [ r ]; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum; min_l = l; min_r = r; } } } cout << "The two elements whose sum is minimum are " << arr [ min_l ] << " and " << arr [ min_r ]; }
int LCSubStr ( string X, string Y ) { int m = X . length ( ); int n = Y . length ( ); int result = 0; int len [ 2 ] [ n ]; int currRow = 0; for ( int i = 0; i <= m; i ++ ) { for ( int j = 0; j <= n; j ++ ) { if ( i == 0 || j == 0 ) { len [ currRow ] [ j ] = 0; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1; result = max ( result, len [ currRow ] [ j ] ); } else { len [ currRow ] [ j ] = 0; } } currRow = 1 - currRow; } return result; }
void printSorted ( int a, int b, int c ) { int get_max = max ( a, max ( b, c ) ); int get_min = - max ( - a, max ( - b, - c ) ); int get_mid = ( a + b + c ) - ( get_max + get_min ); cout << get_min << " " << get_mid << " " << get_max; }
int sumOfSubstrings ( string num ) { int n = num . length ( ); int sumofdigit [ n ]; sumofdigit [ 0 ] = toDigit ( num [ 0 ] ); int res = sumofdigit [ 0 ]; for ( int i = 1; i < n; i ++ ) { int numi = toDigit ( num [ i ] ); sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ]; res += sumofdigit [ i ]; } return res; }
int pairsInSortedRotated ( int arr [ ], int n, int x ) { int i; for ( i = 0; i < n - 1; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break; int l = ( i + 1 ) % n; int r = i; int cnt = 0; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++; if ( l == ( r - 1 + n ) % n ) { return cnt; } l = ( l + 1 ) % n; r = ( r - 1 + n ) % n; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n; else r = ( n + r - 1 ) % n; } return cnt; }
int maxTasks ( int high [ ], int low [ ], int n ) { if ( n <= 0 ) return 0; return max ( high [ n - 1 ] + maxTasks ( high, low, ( n - 2 ) ), low [ n - 1 ] + maxTasks ( high, low, ( n - 1 ) ) ); }
void findpath ( int graph [ ] [ 5 ], int n ) { vector < int > numofadj; for ( int i = 0; i < n; i ++ ) numofadj . push_back ( accumulate ( graph [ i ], graph [ i ] + 5, 0 ) ); int startpoint = 0, numofodd = 0; for ( int i = n - 1; i >= 0; i -- ) { if ( numofadj [ i ] % 2 == 1 ) { numofodd ++; startpoint = i; } } if ( numofodd > 2 ) { cout << "No Solution" << endl; return; } stack < int > stack; vector < int > path; int cur = startpoint; while ( ! stack . empty ( ) or accumulate ( graph [ cur ], graph [ cur ] + 5, 0 ) != 0 ) { if ( accumulate ( graph [ cur ], graph [ cur ] + 5, 0 ) == 0 ) { path . push_back ( cur ); cur = stack . top ( ); stack . pop ( ); } else { for ( int i = 0; i < n; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . push ( cur ); graph [ cur ] [ i ] = 0; graph [ i ] [ cur ] = 0; cur = i; break; } } } } for ( auto ele : path ) cout << ele << " -> "; cout << cur << endl; }
void rotate ( int arr [ ], int n ) { int x = arr [ n - 1 ], i; for ( i = n - 1; i > 0; i -- ) arr [ i ] = arr [ i - 1 ]; arr [ 0 ] = x; }
string maximumPalinUsingKChanges ( string str, int k ) { string palin = str; int l = 0; int r = str . length ( ) - 1; while ( l < r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = max ( str [ l ], str [ r ] ); k --; } l ++; r --; } if ( k < 0 ) return "Not possible"; l = 0; r = str . length ( ) - 1; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) palin [ l ] = '9'; } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) { k -= 2; palin [ l ] = palin [ r ] = '9'; } else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin [ r ] != str [ r ] ) ) { k --; palin [ l ] = palin [ r ] = '9'; } } l ++; r --; } return palin; }
int pageFaults ( int pages [ ], int n, int capacity ) { unordered_set < int > s; queue < int > indexes; int page_faults = 0; for ( int i = 0; i < n; i ++ ) { if ( s . size ( ) < capacity ) { if ( s . find ( pages [ i ] ) == s . end ( ) ) { s . insert ( pages [ i ] ); page_faults ++; indexes . push ( pages [ i ] ); } } else { if ( s . find ( pages [ i ] ) == s . end ( ) ) { int val = indexes . front ( ); indexes . pop ( ); s . erase ( val ); s . insert ( pages [ i ] ); indexes . push ( pages [ i ] ); page_faults ++; } } } return page_faults; }
int printKDistinct ( int arr [ ], int n, int k ) { unordered_map < int, int > h; for ( int i = 0; i < n; i ++ ) h [ arr [ i ] ] ++; if ( h . size ( ) < k ) return - 1; int dist_count = 0; for ( int i = 0; i < n; i ++ ) { if ( h [ arr [ i ] ] == 1 ) dist_count ++; if ( dist_count == k ) return arr [ i ]; } return - 1; }
int mostFrequent ( int arr [ ], int n ) { sort ( arr, arr + n ); int max_count = 1, res = arr [ 0 ], curr_count = 1; for ( int i = 1; i < n; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++; else { if ( curr_count > max_count ) { max_count = curr_count; res = arr [ i - 1 ]; } curr_count = 1; } } if ( curr_count > max_count ) { max_count = curr_count; res = arr [ n - 1 ]; } return res; }
int getOddOccurrence ( int arr [ ], int size ) { unordered_map < int, int > hash; for ( int i = 0; i < size; i ++ ) { hash [ arr [ i ] ] ++; } for ( auto i : hash ) { if ( i . second % 2 != 0 ) { return i . first; } } return - 1; }
int findRepeating ( int arr [ ], int n ) { int missingElement = 0; for ( int i = 0; i < n; i ++ ) { int element = arr [ abs ( arr [ i ] ) ]; if ( element < 0 ) { missingElement = arr [ i ]; break; } arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ]; } return abs ( missingElement ); }
void commonCharacters ( string str [ ], int n ) { bool prim [ MAX_CHAR ]; memset ( prim, true, sizeof ( prim ) ); for ( int i = 0; i < n; i ++ ) { bool sec [ MAX_CHAR ] = { false }; for ( int j = 0; str [ i ] [ j ]; j ++ ) { if ( prim [ str [ i ] [ j ] - 'a' ] ) sec [ str [ i ] [ j ] - 'a' ] = true; } memcpy ( prim, sec, MAX_CHAR ); } for ( int i = 0; i < 26; i ++ ) if ( prim [ i ] ) printf ( "%c ", i + 'a' ); }
string repeat ( string s, int n ) { string s1 = s; for ( int i = 1; i < n; i ++ ) s += s1; return s; }
void printPath ( string str ) { int i = 0; int curX = 0, curY = 0; while ( i < str . length ( ) ) { int nextX = ( str [ i ] - 'A' ) / 5; int nextY = ( str [ i ] - 'B' + 1 ) % 5; while ( curX > nextX ) { cout << "Move Up" << endl; curX --; } while ( curY > nextY ) { cout << "Move Left" << endl; curY --; } while ( curX < nextX ) { cout << "Move Down" << endl; curX ++; } while ( curY < nextY ) { cout << "Move Right" << endl; curY ++; } cout << "Press OK" << endl; i ++; } }
int getMinSquares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1; if ( n <= 3 ) return n; int res = n; for ( int x = 1; x <= n; x ++ ) { int temp = x * x; if ( temp > n ) break; else res = min ( res, 1 + getMinSquares ( n - temp ) ); } return res; }
void swapUpperToLower ( int arr [ n ] [ n ] ) { for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { int temp = arr [ i ] [ j ]; arr [ i ] [ j ] = arr [ j ] [ i ]; arr [ j ] [ i ] = temp; } } for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) cout << arr [ i ] [ j ] << " "; cout << endl; } }
int maxHamming ( int arr [ ], int n ) { int brr [ 2 * n + 1 ]; for ( int i = 0; i < n; i ++ ) brr [ i ] = arr [ i ]; for ( int i = 0; i < n; i ++ ) brr [ n + i ] = arr [ i ]; int maxHam = 0; for ( int i = 1; i < n; i ++ ) { int currHam = 0; for ( int j = i, k = 0; j < ( i + n ); j ++, k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++; if ( currHam == n ) return n; maxHam = max ( maxHam, currHam ); } return maxHam; }
int minimalSteps ( string s, int n ) { int dp [ n ]; for ( int i = 0; i < n; i ++ ) dp [ i ] = INT_MAX; string s1 = "", s2 = ""; dp [ 0 ] = 1; s1 += s [ 0 ]; for ( int i = 1; i < n; i ++ ) { s1 += s [ i ]; s2 = s . substr ( i + 1, i + 1 ); dp [ i ] = min ( dp [ i ], dp [ i - 1 ] + 1 ); if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1, dp [ i * 2 + 1 ] ); } return dp [ n - 1 ]; }
bool checkReverse ( int arr [ ], int n ) { if ( n == 1 ) return true; int i; for ( i = 1; i < n && arr [ i - 1 ] < arr [ i ]; i ++ ); if ( i == n ) return true; int j = i; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false; j ++; } if ( j == n ) return true; int k = j; if ( arr [ k ] < arr [ i - 1 ] ) return false; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false; k ++; } return true; }
int compute_average ( int a, int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ); }
int minCoins ( int coins [ ], int m, int V ) { int table [ V + 1 ]; table [ 0 ] = 0; for ( int i = 1; i <= V; i ++ ) table [ i ] = INT_MAX; for ( int i = 1; i <= V; i ++ ) { for ( int j = 0; j < m; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ]; if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1; } } return table [ V ]; }
int evaluateBoolExpr ( string s ) { int n = s . length ( ); for ( int i = 0; i < n; i += 2 ) { if ( s [ i + 1 ] == 'A' ) { if ( s [ i + 2 ] == '0' || s [ i ] == '0' ) s [ i + 2 ] = '0'; else s [ i + 2 ] = '1'; } else if ( s [ i + 1 ] == 'B' ) { if ( s [ i + 2 ] == '1' || s [ i ] == '1' ) s [ i + 2 ] = '1'; else s [ i + 2 ] = '0'; } else { if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = '0'; else s [ i + 2 ] = '1'; } } return s [ n - 1 ] - '0'; }
int countSubSeq ( int A [ ], int N, int M ) { int ans = 0; int h [ M ] = { 0 }; for ( int i = 0; i < N; i ++ ) { A [ i ] = A [ i ] % M; h [ A [ i ] ] ++; } for ( int i = 0; i < M; i ++ ) { for ( int j = i; j < M; j ++ ) { int rem = ( M - ( i + j ) % M ) % M; if ( rem < j ) continue; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2; else ans = ans + h [ i ] * h [ j ] * h [ rem ]; } } return ans; }
void printSubStr ( string str, int low, int high ) { for ( int i = low; i <= high; ++ i ) cout << str [ i ]; }
int findArea ( int arr [ ], int n ) { sort ( arr, arr + n, greater < int > ( ) ); int dimension [ 2 ] = { 0, 0 }; for ( int i = 0, j = 0; i < n - 1 && j < 2; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ]; return ( dimension [ 0 ] * dimension [ 1 ] ); }
void swapDiagonal ( int matrix [ ] [ N ] ) { for ( int i = 0; i < N; i ++ ) swap ( matrix [ i ] [ i ], matrix [ i ] [ N - i - 1 ] ); }
int findLength ( char * str ) { int n = strlen ( str ); int maxlen = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j += 2 ) { int length = j - i + 1; int leftsum = 0, rightsum = 0; for ( int k = 0; k < length / 2; k ++ ) { leftsum += ( str [ i + k ] - '0' ); rightsum += ( str [ i + k + length / 2 ] - '0' ); } if ( leftsum == rightsum && maxlen < length ) maxlen = length; } } return maxlen; }
float correlationCoefficient ( int X [ ], int Y [ ], int n ) { int sum_X = 0, sum_Y = 0, sum_XY = 0; int squareSum_X = 0, squareSum_Y = 0; for ( int i = 0; i < n; i ++ ) { sum_X = sum_X + X [ i ]; sum_Y = sum_Y + Y [ i ]; sum_XY = sum_XY + X [ i ] * Y [ i ]; squareSum_X = squareSum_X + X [ i ] * X [ i ]; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ]; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ); return corr; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0; if ( dist == 0 ) return 1; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ); }
int answer_query ( int a [ ], int n, int l, int r ) { int count = 0; for ( int i = l; i < r; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1; return count; }
void pythagoreanTriplets ( int limit ) { int a, b, c = 0; int m = 2; while ( c < limit ) { for ( int n = 1; n < m; ++ n ) { a = m * m - n * n; b = 2 * m * n; c = m * m + n * n; if ( c > limit ) break; printf ( "%d %d %d\n", a, b, c ); } m ++; } }
void merge ( int ar1 [ ], int ar2 [ ], int m, int n ) { for ( int i = n - 1; i >= 0; i -- ) { int j, last = ar1 [ m - 1 ]; for ( j = m - 2; j >= 0 && ar1 [ j ] > ar2 [ i ]; j -- ) ar1 [ j + 1 ] = ar1 [ j ]; if ( j != m - 2 || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ]; ar2 [ i ] = last; } } }
int longestPrefixSuffix ( string s ) { int n = s . length ( ); int lps [ n ]; lps [ 0 ] = 0; int len = 0; int i = 1; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++; lps [ i ] = len; i ++; } else { if ( len != 0 ) { len = lps [ len - 1 ]; } else { lps [ i ] = 0; i ++; } } } int res = lps [ n - 1 ]; return ( res > n / 2 ) ? n / 2 : res; }
int maximumSegments ( int n, int a, int b, int c ) { int dp [ n + 1 ]; memset ( dp, - 1, sizeof ( dp ) ); dp [ 0 ] = 0; for ( int i = 0; i < n; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = max ( dp [ i ] + 1, dp [ i + a ] ); if ( i + b <= n ) dp [ i + b ] = max ( dp [ i ] + 1, dp [ i + b ] ); if ( i + c <= n ) dp [ i + c ] = max ( dp [ i ] + 1, dp [ i + c ] ); } } return dp [ n ]; }
bool pairWiseConsecutive ( stack < int > s ) { stack < int > aux; while ( ! s . empty ( ) ) { aux . push ( s . top ( ) ); s . pop ( ); } bool result = true; while ( aux . empty ( ) > 1 ) { int x = aux . top ( ); aux . pop ( ); int y = aux . top ( ); aux . pop ( ); if ( abs ( x - y ) != 1 ) result = false; s . push ( x ); s . push ( y ); } if ( aux . size ( ) == 1 ) s . push ( aux . top ( ) ); return result; }
void antiSpiralTraversal ( int m, int n, int a [ R ] [ C ] ) { int i, k = 0, l = 0; stack < int > stk; while ( k <= m && l <= n ) { for ( i = l; i <= n; ++ i ) stk . push ( a [ k ] [ i ] ); k ++; for ( i = k; i <= m; ++ i ) stk . push ( a [ i ] [ n ] ); n --; if ( k <= m ) { for ( i = n; i >= l; -- i ) stk . push ( a [ m ] [ i ] ); m --; } if ( l <= n ) { for ( i = m; i >= k; -- i ) stk . push ( a [ i ] [ l ] ); l ++; } } while ( ! stk . empty ( ) ) { cout << stk . top ( ) << " "; stk . pop ( ); } }
void findMissing ( int a [ ], int b [ ], int n, int m ) { for ( int i = 0; i < n; i ++ ) { int j; for ( j = 0; j < m; j ++ ) if ( a [ i ] == b [ j ] ) break; if ( j == m ) cout << a [ i ] << " "; } }
bool areKAnagrams ( string str1, string str2, int k ) { int n = str1 . length ( ); if ( str2 . length ( ) != n ) return false; int hash_str1 [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < n; i ++ ) hash_str1 [ str1 [ i ] - 'a' ] ++; int count = 0; for ( int i = 0; i < n; i ++ ) { if ( hash_str1 [ str2 [ i ] - 'a' ] > 0 ) hash_str1 [ str2 [ i ] - 'a' ] --; else count ++; if ( count > k ) return false; } return true; }
void reorder ( int arr [ ], int index [ ], int n ) { int temp [ n ]; for ( int i = 0; i < n; i ++ ) temp [ index [ i ] ] = arr [ i ]; for ( int i = 0; i < n; i ++ ) { arr [ i ] = temp [ i ]; index [ i ] = i; } }
int findLength ( string str, int n ) { int current_sum = 0; int max_sum = 0; for ( int i = 0; i < n; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : - 1 ); if ( current_sum < 0 ) current_sum = 0; max_sum = max ( current_sum, max_sum ); } return max_sum == 0 ? - 1 : max_sum; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ); }
int singleNumber ( int a [ ], int n ) { unordered_set < int > s ( a, a + n ); int arr_sum = accumulate ( a, a + n, 0 ); int set_sum = accumulate ( s . begin ( ), s . end ( ), 0 ); return ( 3 * set_sum - arr_sum ) / 2; }
int countFriendsPairings ( int n ) { int a = 1, b = 2, c = 0; if ( n <= 2 ) { return n; } for ( int i = 3; i <= n; i ++ ) { c = b + ( i - 1 ) * a; a = b; b = c; } return c; }
bool isLucky ( int n ) { bool arr [ 10 ]; for ( int i = 0; i < 10; i ++ ) arr [ i ] = false; while ( n > 0 ) { int digit = n % 10; if ( arr [ digit ] ) return false; arr [ digit ] = true; n = n / 10; } return true; }
int minimumSquare ( int a, int b ) { long long result = 0, rem = 0; if ( a < b ) swap ( a, b ); while ( b > 0 ) { result += a / b; long long rem = a % b; a = b; b = rem; } return result; }
int countZeroes ( int mat [ N ] [ N ] ) { int row = N - 1, col = 0; int count = 0; while ( col < N ) { while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return count; count += ( row + 1 ); col ++; } return count; }
int horner ( int poly [ ], int n, int x ) { int result = poly [ 0 ]; for ( int i = 1; i < n; i ++ ) result = result * x + poly [ i ]; return result; }
int findInteger ( int arr [ ], int n ) { int neg = 0, pos = 0; int sum = 0; for ( int i = 0; i < n; i ++ ) { sum += arr [ i ]; if ( arr [ i ] < 0 ) neg ++; else pos ++; } return ( sum / abs ( neg - pos ) ); }
void nthPalindrome ( int n, int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ); int palindrome = ( int ) pow ( 10, temp ); palindrome += n - 1; printf ( "%d", palindrome ); if ( k & 1 ) palindrome /= 10; while ( palindrome ) { printf ( "%d", palindrome % 10 ); palindrome /= 10; } printf ( "\n" ); }
int maxSum ( int arr [ ], int n ) { int res = INT_MIN; for ( int i = 0; i < n; i ++ ) { int curr_sum = 0; for ( int j = 0; j < n; j ++ ) { int index = ( i + j ) % n; curr_sum += j * arr [ index ]; } res = max ( res, curr_sum ); } return res; }
public : int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1; else if ( n == 2 ) return 2; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ); }
int Resources ( int process, int need ) { int minResources = 0; minResources = process * ( need - 1 ) + 1; return minResources; }
int findExtra ( int arr1 [ ], int arr2 [ ], int n ) { int index = n; int left = 0, right = n - 1; while ( left <= right ) { int mid = ( left + right ) / 2; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1; else { index = mid; right = mid - 1; } } return index; }
int smallestSubWithSum ( int arr [ ], int n, int x ) { int curr_sum = 0, min_len = n + 1; int start = 0, end = 0; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ]; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start; curr_sum -= arr [ start ++ ]; } } return min_len; }
bool isValidString ( string str ) { int freq [ CHARS ] = { 0 }; for ( int i = 0; i < str . length ( ); i ++ ) freq [ str [ i ] - 'a' ] ++; int i, freq1 = 0, count_freq1 = 0; for ( i = 0; i < CHARS; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ]; count_freq1 = 1; break; } } int j, freq2 = 0, count_freq2 = 0; for ( j = i + 1; j < CHARS; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++; else { count_freq2 = 1; freq2 = freq [ j ]; break; } } } for ( int k = j + 1; k < CHARS; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++; if ( freq [ k ] == freq2 ) count_freq2 ++; else return false; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false; } return true; }
int binaryMedian ( int m [ ] [ MAX ], int r, int c ) { int min = INT_MAX, max = INT_MIN; for ( int i = 0; i < r; i ++ ) { if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ]; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ]; } int desired = ( r * c + 1 ) / 2; while ( min < max ) { int mid = min + ( max - min ) / 2; int place = 0; for ( int i = 0; i < r; ++ i ) place += upper_bound ( m [ i ], m [ i ] + c, mid ) - m [ i ]; if ( place < desired ) min = mid + 1; else max = mid; } return min; }
unsigned int swapBits ( unsigned int x ) { unsigned int even_bits = x & 0xAAAAAAAA; unsigned int odd_bits = x & 0x55555555; even_bits >>= 1; odd_bits <<= 1; return ( even_bits | odd_bits ); }
void transpose ( int A [ ] [ N ], int B [ ] [ M ] ) { int i, j; for ( i = 0; i < N; i ++ ) for ( j = 0; j < M; j ++ ) B [ i ] [ j ] = A [ j ] [ i ]; }
string findLeft ( string str ) { int n = str . length ( ); while ( n -- ) { if ( str [ n ] == 'd' ) { str [ n ] = 'c'; break; } if ( str [ n ] == 'b' ) { str [ n ] = 'a'; break; } if ( str [ n ] == 'a' ) str [ n ] = 'b'; else if ( str [ n ] == 'c' ) str [ n ] = 'd'; } return str; }
int pad ( int n ) { int pPrevPrev = 1, pPrev = 1, pCurr = 1, pNext = 1; for ( int i = 3; i <= n; i ++ ) { pNext = pPrevPrev + pPrev; pPrevPrev = pPrev; pPrev = pCurr; pCurr = pNext; } return pNext; }
int countSubarrWithEqualZeroAndOne ( int arr [ ], int n ) { map < int, int > mp; int sum = 0; int count = 0; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1; sum += arr [ i ]; if ( sum == 0 ) count ++; if ( mp [ sum ] ) count += mp [ sum ]; if ( mp [ sum ] == 0 ) mp [ sum ] = 1; else mp [ sum ] ++; } return count; }
int calculateSum ( string arr [ ], int n ) { if ( n == 0 ) return 0; string s = arr [ 0 ]; int value = stoi ( s ); int sum = value; for ( int i = 2; i < n; i = i + 2 ) { s = arr [ i ]; int value = stoi ( s ); char operation = arr [ i - 1 ] [ 0 ]; if ( operation == '+' ) sum += value; else sum -= value; } return sum; }
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ); }
double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ); }
int waysToArrange ( int N, int K, int k [ ] ) { int C [ N + 1 ] [ N + 1 ]; int i, j; for ( i = 0; i <= N; i ++ ) { for ( j = 0; j <= i; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ); } } int dp [ K ]; int count = 0; dp [ 0 ] = 1; for ( int i = 0; i < K; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ); count += k [ i ]; } return dp [ K ]; }
int search ( int arr [ ], int n, int x ) { int i = 0; while ( i < n ) { if ( arr [ i ] == x ) return i; i = i + abs ( arr [ i ] - x ); } cout << "number is not present!"; return - 1; }
int shortestSeq ( char * S, char * T ) { int m = strlen ( S ), n = strlen ( T ); int dp [ m + 1 ] [ n + 1 ]; for ( int i = 0; i <= m; i ++ ) dp [ i ] [ 0 ] = 1; for ( int i = 0; i <= n; i ++ ) dp [ 0 ] [ i ] = MAX; for ( int i = 1; i <= m; i ++ ) { for ( int j = 1; j <= n; j ++ ) { char ch = S [ i - 1 ]; int k; for ( k = j - 1; k >= 0; k -- ) if ( T [ k ] == ch ) break; if ( k == - 1 ) dp [ i ] [ j ] = 1; else dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ], dp [ i - 1 ] [ k ] + 1 ); } } int ans = dp [ m ] [ n ]; if ( ans >= MAX ) ans = - 1; return ans; }
int discreteLogarithm ( int a, int b, int m ) { int n = ( int ) sqrt ( m ) + 1; int an = 1; for ( int i = 0; i < n; ++ i ) an = ( an * a ) % m; unordered_map < int, int > value; for ( int i = 1, cur = an; i <= n; ++ i ) { if ( ! value [ cur ] ) value [ cur ] = i; cur = ( cur * an ) % m; } for ( int i = 0, cur = b; i <= n; ++ i ) { if ( value [ cur ] ) { int ans = value [ cur ] * n - i; if ( ans < m ) return ans; } cur = ( cur * a ) % m; } return - 1; }
public : bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0; while ( n != 1 ) { if ( n % 4 != 0 ) return 0; n = n / 4; } return 1; }
bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ); }
int minPalPartion ( char * str ) { int n = strlen ( str ); int C [ n ]; bool P [ n ] [ n ]; int i, j, k, L; for ( i = 0; i < n; i ++ ) { P [ i ] [ i ] = true; } for ( L = 2; L <= n; L ++ ) { for ( i = 0; i < n - L + 1; i ++ ) { j = i + L - 1; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ); else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ]; } } for ( i = 0; i < n; i ++ ) { if ( P [ 0 ] [ i ] == true ) C [ i ] = 0; else { C [ i ] = INT_MAX; for ( j = 0; j < i; j ++ ) { if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ]; } } } return C [ n - 1 ]; }
int maxDP ( int n ) { int res [ n + 1 ]; res [ 0 ] = 0; res [ 1 ] = 1; for ( int i = 2; i <= n; i ++ ) res [ i ] = max ( i, ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ); return res [ n ]; }
int lcs ( int dp [ MAX ] [ MAX ] [ MAX ], int arr1 [ ], int n, int arr2 [ ], int m, int k ) { if ( k < 0 ) return - 1e7; if ( n < 0 || m < 0 ) return 0; int & ans = dp [ n ] [ m ] [ k ]; if ( ans != - 1 ) return ans; ans = max ( lcs ( dp, arr1, n - 1, arr2, m, k ), lcs ( dp, arr1, n, arr2, m - 1, k ) ); if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans, 1 + lcs ( dp, arr1, n - 1, arr2, m - 1, k ) ); ans = max ( ans, 1 + lcs ( dp, arr1, n - 1, arr2, m - 1, k - 1 ) ); return ans; }
int sumAtKthLevel ( string tree, int k, int & i, int level ) { if ( tree [ i ++ ] == '(' ) { if ( tree [ i ] == ')' ) return 0; int sum = 0; if ( level == k ) sum = tree [ i ] - '0'; int leftsum = sumAtKthLevel ( tree, k, ++ i, level + 1 ); int rightsum = sumAtKthLevel ( tree, k, ++ i, level + 1 ); ++ i; return sum + leftsum + rightsum; } }
void concatenate ( char a [ ], char b [ ], char c [ ], int n1, int n2 ) { int i; for ( i = 0; i < n1; i ++ ) c [ i ] = a [ i ]; for ( int j = 0; j < n2; j ++ ) c [ i ++ ] = b [ j ]; c [ i ] = '\0'; }
int maxRevenue ( int m, int x [ ], int revenue [ ], int n, int t ) { int maxRev [ m + 1 ]; memset ( maxRev, 0, sizeof ( maxRev ) ); int nxtbb = 0; for ( int i = 1; i <= m; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ]; else { if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ], revenue [ nxtbb ] ); else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ], maxRev [ i - 1 ] ); nxtbb ++; } } else maxRev [ i ] = maxRev [ i - 1 ]; } return maxRev [ m ]; }
void printString ( string str, char ch, int count ) { int occ = 0, i; if ( count == 0 ) { cout << str; return; } for ( i = 0; i < str . length ( ); i ++ ) { if ( str [ i ] == ch ) occ ++; if ( occ == count ) break; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1, str . length ( ) - ( i + 1 ) ); else cout << "Empty string"; }
void stoogesort ( int arr [ ], int l, int h ) { if ( l >= h ) return; if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ], arr [ h ] ); if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3; stoogesort ( arr, l, h - t ); stoogesort ( arr, l + t, h ); stoogesort ( arr, l, h - t ); } }
void freq ( int ar [ ] [ MAX ], int m, int n ) { int even = 0, odd = 0; for ( int i = 0; i < m; ++ i ) { for ( int j = 0; j < n; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even; else ++ odd; } } printf ( " Frequency of odd number = %d \n", odd ); printf ( " Frequency of even number = %d \n", even ); }
int calculate ( int a [ ], int n ) { sort ( a, a + n ); int count = 1; int answer = 0; for ( int i = 1; i < n; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1; } else { answer = answer + ( count * ( count - 1 ) ) / 2; count = 1; } } answer = answer + ( count * ( count - 1 ) ) / 2; return answer; }
bool isSubSequence ( char str1 [ ], char str2 [ ], int m, int n ) { int j = 0; for ( int i = 0; i < n && j < m; i ++ ) if ( str1 [ j ] == str2 [ i ] ) j ++; return ( j == m ); }
void findCombinations ( string str, int index, string out ) { if ( index == str . length ( ) ) cout << out << endl; for ( int i = index; i < str . length ( ); i ++ ) findCombinations ( str, i + 1, out + "(" + str . substr ( index, i + 1 - index ) + ")" ); }
int Add ( int x, int y ) { while ( y != 0 ) { int carry = x & y; x = x ^ y; y = carry << 1; } return x; }
int getMinStepToReachEnd ( int arr [ ], int N ) { bool visit [ N ]; int distance [ N ]; vector < int > digit [ 10 ]; memset ( visit, false, sizeof ( visit ) ); for ( int i = 1; i < N; i ++ ) digit [ arr [ i ] ] . push_back ( i ); distance [ 0 ] = 0; visit [ 0 ] = true; queue < int > q; q . push ( 0 ); while ( ! q . empty ( ) ) { int idx = q . front ( ); q . pop ( ); if ( idx == N - 1 ) break; int d = arr [ idx ]; for ( int i = 0; i < digit [ d ] . size ( ); i ++ ) { int nextidx = digit [ d ] [ i ]; if ( ! visit [ nextidx ] ) { visit [ nextidx ] = true; q . push ( nextidx ); distance [ nextidx ] = distance [ idx ] + 1; } } digit [ d ] . clear ( ); if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true; q . push ( idx - 1 ); distance [ idx - 1 ] = distance [ idx ] + 1; } if ( idx + 1 < N && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true; q . push ( idx + 1 ); distance [ idx + 1 ] = distance [ idx ] + 1; } } return distance [ N - 1 ]; }
void decToHexa ( int n ) { char hexaDeciNum [ 100 ]; int i = 0; while ( n != 0 ) { int temp = 0; temp = n % 16; if ( temp < 10 ) { hexaDeciNum [ i ] = temp + 48; i ++; } else { hexaDeciNum [ i ] = temp + 55; i ++; } n = n / 16; } for ( int j = i - 1; j >= 0; j -- ) cout << hexaDeciNum [ j ]; }
bool isOneFlip ( string str ) { int sum = 0; int n = str . length ( ); for ( int i = 0; i < n; i ++ ) sum += str [ i ] - '0'; return ( sum == n - 1 || sum == 1 ); }
int offeringNumber ( int n, int templeHeight [ ] ) { int sum = 0; for ( int i = 0; i < n; ++ i ) { int left = 0, right = 0; for ( int j = i - 1; j >= 0; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left; else break; } for ( int j = i + 1; j < n; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right; else break; } sum += max ( right, left ) + 1; } return sum; }
void findPairs ( int arr1 [ ], int arr2 [ ], int n, int m, int x ) { unordered_set < int > s; for ( int i = 0; i < n; i ++ ) s . insert ( arr1 [ i ] ); for ( int j = 0; j < m; j ++ ) if ( s . find ( x - arr2 [ j ] ) != s . end ( ) ) cout << x - arr2 [ j ] << " " << arr2 [ j ] << endl; }
int findCommon ( int mat [ M ] [ N ] ) { unordered_map < int, int > cnt; int i, j; for ( i = 0; i < M; i ++ ) { cnt [ mat [ i ] [ 0 ] ] ++; for ( j = 1; j < N; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) cnt [ mat [ i ] [ j ] ] ++; } } for ( auto ele : cnt ) { if ( ele . second == M ) return ele . first; } return - 1; }
int maxSum ( int mat [ SIZE ] [ SIZE ], int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ]; int dp [ n ] [ n ]; int maxSum = INT_MIN, max; for ( int j = 0; j < n; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ]; for ( int i = n - 2; i >= 0; i -- ) { for ( int j = 0; j < n; j ++ ) { max = INT_MIN; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ]; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ]; dp [ i ] [ j ] = mat [ i ] [ j ] + max; } } for ( int j = 0; j < n; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ]; return maxSum; }
int count ( int n ) { if ( n < 3 ) return n; if ( n >= 3 && n < 10 ) return n - 1; int po = 1; while ( n / po > 9 ) po = po * 10; int msd = n / po; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ); else return count ( msd * po - 1 ); }
int countSub ( string str ) { vector < int > last ( MAX_CHAR, - 1 ); int n = str . length ( ); int dp [ n + 1 ]; dp [ 0 ] = 1; for ( int i = 1; i <= n; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ]; if ( last [ str [ i - 1 ] ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ str [ i - 1 ] ] ]; last [ str [ i - 1 ] ] = ( i - 1 ); } return dp [ n ]; }
int numberOfWays ( int x ) { int dp [ x + 1 ]; dp [ 0 ] = dp [ 1 ] = 1; for ( int i = 2; i <= x; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]; return dp [ x ]; }
bool checkcircle ( int r, int R, int r1, int x1, int y1 ) { int dis = sqrt ( x1 * x1 + y1 * y1 ); return ( dis - r1 >= R && dis + r1 <= r ); }
int findMaxPath ( int mat [ ] [ M ] ) { for ( int i = 1; i < N; i ++ ) { for ( int j = 0; j < M; j ++ ) { if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], max ( mat [ i - 1 ] [ j - 1 ], mat [ i - 1 ] [ j + 1 ] ) ); else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], mat [ i - 1 ] [ j - 1 ] ); else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], mat [ i - 1 ] [ j + 1 ] ); } } int res = 0; for ( int j = 0; j < M; j ++ ) res = max ( mat [ N - 1 ] [ j ], res ); return res; }
bool isMinHeap ( int level [ ], int n ) { for ( int i = ( n / 2 - 1 ); i >= 0; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false; } } return true; }
int countFibs ( int low, int high ) { int f1 = 0, f2 = 1, f3 = 1; int result = 0; while ( f1 <= high ) { if ( f1 >= low ) result ++; f1 = f2; f2 = f3; f3 = f1 + f2; } return result; }
int fix ( int A [ ], int len ) { for ( int i = 0; i < len; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ]; while ( A [ x ] != - 1 && A [ x ] != x ) { int y = A [ x ]; A [ x ] = x; x = y; } A [ x ] = x; if ( A [ i ] != i ) { A [ i ] = - 1; } } } }
int findGreatest ( int arr [ ], int n ) { unordered_map < int, int > m; for ( int i = 0; i < n; i ++ ) m [ arr [ i ] ] ++; sort ( arr, arr + n ); for ( int i = n - 1; i > 1; i -- ) { for ( int j = 0; j < i && arr [ j ] <= sqrt ( arr [ i ] ); j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ]; if ( result != arr [ j ] && m [ result ] > 0 ) return arr [ i ]; else if ( result == arr [ j ] && m [ result ] > 1 ) return arr [ i ]; } } } return - 1; }
int firstFactorialDivisibleNumber ( int x ) { int i = 1; int fact = 1; for ( i = 1; i < x; i ++ ) { fact = fact * i; if ( fact % x == 0 ) break; } return i; }
int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN; int maxArr [ N ] [ N ]; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ]; int maxv = mat [ N - 1 ] [ N - 1 ]; for ( int j = N - 2; j >= 0; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ]; maxArr [ N - 1 ] [ j ] = maxv; } maxv = mat [ N - 1 ] [ N - 1 ]; for ( int i = N - 2; i >= 0; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ]; maxArr [ i ] [ N - 1 ] = maxv; } for ( int i = N - 2; i >= 0; i -- ) { for ( int j = N - 2; j >= 0; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ]; maxArr [ i ] [ j ] = max ( mat [ i ] [ j ], max ( maxArr [ i ] [ j + 1 ], maxArr [ i + 1 ] [ j ] ) ); } } return maxValue; }
string printSequence ( string arr [ ], string input ) { string output = ""; int n = input . length ( ); for ( int i = 0; i < n; i ++ ) { if ( input [ i ] == ' ' ) output = output + "0"; else { int position = input [ i ] - 'A'; output = output + arr [ position ]; } } return output; }
void printTreeEdges ( int prufer [ ], int m ) { int vertices = m + 2; int vertex_set [ vertices ]; for ( int i = 0; i < vertices; i ++ ) vertex_set [ i ] = 0; for ( int i = 0; i < vertices - 2; i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1; cout << "\nThe edge set E(G) is :\n"; int j = 0; for ( int i = 0; i < vertices - 2; i ++ ) { for ( j = 0; j < vertices; j ++ ) { if ( vertex_set [ j ] == 0 ) { vertex_set [ j ] = - 1; cout << "(" << ( j + 1 ) << ", " << prufer [ i ] << ") "; vertex_set [ prufer [ i ] - 1 ] --; break; } } } j = 0; for ( int i = 0; i < vertices; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) { cout << "(" << ( i + 1 ) << ", "; j ++; } else if ( vertex_set [ i ] == 0 && j == 1 ) cout << ( i + 1 ) << ")\n"; } }
int maxRowDiff ( int mat [ ] [ MAX ], int m, int n ) { int rowSum [ m ]; for ( int i = 0; i < m; i ++ ) { int sum = 0; for ( int j = 0; j < n; j ++ ) sum += mat [ i ] [ j ]; rowSum [ i ] = sum; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ]; int min_element = rowSum [ 0 ]; for ( int i = 1; i < m; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ]; } return max_diff; }
long int evenFib ( int n ) { if ( n < 1 ) return n; if ( n == 1 ) return 2; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ); }
int CountPairs ( int n ) { int k = n; int imin = 1; int ans = 0; while ( imin <= n ) { int imax = n / k; ans += k * ( imax - imin + 1 ); imin = imax + 1; k = n / imin; } return ans; }
bool isInorder ( int arr [ ], int n ) { if ( n == 0 || n == 1 ) return true; for ( int i = 1; i < n; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false; return true; }
int possibleWays ( int n, int m, int k ) { int dp [ N ] [ N ]; int presum [ N ] [ N ]; memset ( dp, 0, sizeof dp ); memset ( presum, 0, sizeof presum ); for ( int i = 1; i < n + 1; i ++ ) { dp [ 0 ] [ i ] = 0; presum [ 0 ] [ i ] = 1; } for ( int i = 0; i < m + 1; i ++ ) presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1; for ( int i = 1; i < m + 1; i ++ ) { for ( int j = 1; j < n + 1; j ++ ) { dp [ i ] [ j ] = presum [ i - 1 ] [ j ]; if ( j > k ) { dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ]; } } for ( int j = 1; j < n + 1; j ++ ) presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ]; } return dp [ m ] [ n ]; }
void printMaxSubSquare ( bool M [ R ] [ C ] ) { int i, j; int S [ R ] [ C ]; int max_of_s, max_i, max_j; for ( i = 0; i < R; i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ]; for ( j = 0; j < C; j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ]; for ( i = 1; i < R; i ++ ) { for ( j = 1; j < C; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = min ( S [ i ] [ j - 1 ], min ( S [ i - 1 ] [ j ], S [ i - 1 ] [ j - 1 ] ) ) + 1; else S [ i ] [ j ] = 0; } } max_of_s = S [ 0 ] [ 0 ]; max_i = 0; max_j = 0; for ( i = 0; i < R; i ++ ) { for ( j = 0; j < C; j ++ ) { if ( max_of_s < S [ i ] [ j ] ) { max_of_s = S [ i ] [ j ]; max_i = i; max_j = j; } } } cout << "Maximum size sub-matrix is: \n"; for ( i = max_i; i > max_i - max_of_s; i -- ) { for ( j = max_j; j > max_j - max_of_s; j -- ) { cout << M [ i ] [ j ] << " "; } cout << "\n"; } }
int maxProd ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ); int res = 1; while ( n > 4 ) { n -= 3; res *= 3; } return ( n * res ); }
int maxArea ( bool mat [ R ] [ C ] ) { int hist [ R + 1 ] [ C + 1 ]; for ( int i = 0; i < C; i ++ ) { hist [ 0 ] [ i ] = mat [ 0 ] [ i ]; for ( int j = 1; j < R; j ++ ) hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1; } for ( int i = 0; i < R; i ++ ) { int count [ R + 1 ] = { 0 }; for ( int j = 0; j < C; j ++ ) count [ hist [ i ] [ j ] ] ++; int col_no = 0; for ( int j = R; j >= 0; j -- ) { if ( count [ j ] > 0 ) { for ( int k = 0; k < count [ j ]; k ++ ) { hist [ i ] [ col_no ] = j; col_no ++; } } } } int curr_area, max_area = 0; for ( int i = 0; i < R; i ++ ) { for ( int j = 0; j < C; j ++ ) { curr_area = ( j + 1 ) * hist [ i ] [ j ]; if ( curr_area > max_area ) max_area = curr_area; } } return max_area; }
int getMaxGold ( int gold [ ] [ MAX ], int m, int n ) { int goldTable [ m ] [ n ]; memset ( goldTable, 0, sizeof ( goldTable ) ); for ( int col = n - 1; col >= 0; col -- ) { for ( int row = 0; row < m; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ]; int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ]; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ]; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right, max ( right_up, right_down ) ); } } int res = goldTable [ 0 ] [ 0 ]; for ( int i = 1; i < m; i ++ ) res = max ( res, goldTable [ i ] [ 0 ] ); return res; }
void printFirstNegativeInteger ( int arr [ ], int n, int k ) { deque < int > Di; int i; for ( i = 0; i < k; i ++ ) if ( arr [ i ] < 0 ) Di . push_back ( i ); for (; i < n; i ++ ) { if ( ! Di . empty ( ) ) cout << arr [ Di . front ( ) ] << " "; else cout << "0" << " "; while ( ( ! Di . empty ( ) ) && Di . front ( ) < ( i - k + 1 ) ) Di . pop_front ( ); if ( arr [ i ] < 0 ) Di . push_back ( i ); } if ( ! Di . empty ( ) ) cout << arr [ Di . front ( ) ] << " "; else cout << "0" << " "; }
int count ( int n, int x ) { int count == 0; for ( int i = 1; i <= n && i <= x; i ++ ) { if ( x / i <= n && x % i == 0 ) count ++; } return count; }
void printRepeating ( int arr [ ], int size ) { int i, j; printf ( " Repeating elements are " ); for ( i = 0; i < size; i ++ ) for ( j = i + 1; j < size; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " "; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2; }
float sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10, n ) ); }
int sortedCount ( int mat [ ] [ MAX ], int r, int c ) { int result = 0; for ( int i = 0; i < r; i ++ ) { int j; for ( j = 0; j < c - 1; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break; if ( j == c - 1 ) result ++; } for ( int i = 0; i < r; i ++ ) { int j; for ( j = c - 1; j > 0; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break; if ( c > 1 && j == 0 ) result ++; } return result; }
void strToBinary ( string s ) { int n = s . length ( ); for ( int i = 0; i <= n; i ++ ) { int val = int ( s [ i ] ); string bin = ""; while ( val > 0 ) { ( val % 2 ) ? bin . push_back ( '1' ) : bin . push_back ( '0' ); val /= 2; } reverse ( bin . begin ( ), bin . end ( ) ); cout << bin << " "; } }
int findS ( int s ) { int sum = 0; for ( int n = 1; sum < s; n ++ ) { sum += n * n * n; if ( sum == s ) return n; } return - 1; }
int countSubstrs ( string str, int i, int j, int n ) { if ( n == 1 ) return 1; if ( n <= 0 ) return 0; int res = countSubstrs ( str, i + 1, j, n - 1 ) + countSubstrs ( str, i, j - 1, n - 1 ) - countSubstrs ( str, i + 1, j - 1, n - 2 ); if ( str [ i ] == str [ j ] ) res ++; return res; }
int getPairsCount ( int arr [ ], int n, int sum ) { int count = 0; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++; return count; }
int sumoflength ( int arr [ ], int n ) { unordered_set < int > s; int j = 0, ans = 0; for ( int i = 0; i < n; i ++ ) { while ( j < n && s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ j ] ); j ++; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2; s . erase ( arr [ i ] ); } return ans; }
void subsequence ( char s [ ], char t [ ], int n, int k ) { int last = 0, cnt = 0, new_last = 0, size = 0; for ( char ch = 'z'; ch >= 'a'; ch -- ) { cnt = 0; for ( int i = last; i < n; i ++ ) { if ( s [ i ] == ch ) cnt ++; } if ( cnt >= k ) { for ( int i = last; i < n; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch; new_last = i; } } last = new_last; } } t [ size ] = '\0'; }
int countPaths ( int n, int m ) { int dp [ n + 1 ] [ m + 1 ]; for ( int i = 0; i <= n; i ++ ) dp [ i ] [ 0 ] = 1; for ( int i = 0; i <= m; i ++ ) dp [ 0 ] [ i ] = 1; for ( int i = 1; i <= n; i ++ ) for ( int j = 1; j <= m; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ]; return dp [ n ] [ m ]; }
string lexicographicSubConcat ( string s ) { int n = s . length ( ); int sub_count = n * ( n + 1 ) / 2; string arr [ sub_count ]; int index = 0; for ( int i = 0; i < n; i ++ ) for ( int len = 1; len <= n - i; len ++ ) arr [ index ++ ] = s . substr ( i, len ); sort ( arr, arr + sub_count ); string res = ""; for ( int i = 0; i < sub_count; i ++ ) res += arr [ i ]; return res; }
bool isPossible ( int a [ ], int b [ ], int n, int k ) { sort ( a, a + n ); sort ( b, b + n, greater < int > ( ) ); for ( int i = 0; i < n; i ++ ) if ( a [ i ] + b [ i ] < k ) return false; return true; }
int minRemove ( int a [ ], int b [ ], int n, int m ) { unordered_map < int, int > countA, countB; for ( int i = 0; i < n; i ++ ) countA [ a [ i ] ] ++; for ( int i = 0; i < m; i ++ ) countB [ b [ i ] ] ++; int res = 0; for ( auto x : countA ) if ( countB . find ( x . first ) != countB . end ( ) ) res += min ( x . second, countB [ x . first ] ); return res; }
bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true; while ( num != 0 ) { if ( num / 10 == 0 ) return true; int digit1 = num % 10; int digit2 = ( num / 10 ) % 10; if ( abs ( digit2 - digit1 ) > 1 ) return false; num = num / 10; } return true; }
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ]; if ( d1 % 2 != 0 ) return ( 0 ); int d2 = ( int ) num [ num . length ( ) - 2 ]; int sum = 0; for ( int i = 0; i < num . length ( ); i ++ ) sum += num [ i ]; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ); } else { int number = stoi ( num ); return ( number % 12 == 0 ); } }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0; int res = 1; for ( int i = 2; i <= sqrt ( n ); i ++ ) { int count = 0, curr_sum = 1, curr_term = 1; while ( n % i == 0 ) { count ++; n = n / i; if ( i == 2 && count == 1 ) curr_sum = 0; curr_term *= i; curr_sum += curr_term; } res *= curr_sum; } if ( n >= 2 ) res *= ( 1 + n ); return res; }
int printKDistinct ( int arr [ ], int n, int k ) { int dist_count = 0; for ( int i = 0; i < n; i ++ ) { int j; for ( j = 0; j < n; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break; if ( j == n ) dist_count ++; if ( dist_count == k ) return arr [ i ]; } return - 1; }
char maxRepeating ( string str ) { int len = str . length ( ); int count = 0; char res = str [ 0 ]; for ( int i = 0; i < len; i ++ ) { int cur_count = 1; for ( int j = i + 1; j < len; j ++ ) { if ( str [ i ] != str [ j ] ) break; cur_count ++; } if ( cur_count > count ) { count = cur_count; res = str [ i ]; } } return res; }
int longLenStrictBitonicSub ( int arr [ ], int n ) { unordered_map < int, int > inc, dcr; int len_inc [ n ], len_dcr [ n ]; int longLen = 0; for ( int i = 0; i < n; i ++ ) { int len = 0; if ( inc . find ( arr [ i ] - 1 ) != inc . end ( ) ) len = inc [ arr [ i ] - 1 ]; inc [ arr [ i ] ] = len_inc [ i ] = len + 1; } for ( int i = n - 1; i >= 0; i -- ) { int len = 0; if ( dcr . find ( arr [ i ] - 1 ) != dcr . end ( ) ) len = dcr [ arr [ i ] - 1 ]; dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1; } for ( int i = 0; i < n; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1; return longLen; }
int divSum ( int num ) { int result = 0; for ( int i = 2; i <= sqrt ( num ); i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i; else result += ( i + num / i ); } } return ( result + 1 ); }
int remainder ( string str ) { int len = str . length ( ); int num, rem = 0; for ( int i = 0; i < len; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ); rem = num % 11; } return rem; }
void PrintMinNumberForPattern ( string arr ) { int curr_max = 0; int last_entry = 0; int j; for ( int i = 0; i < arr . length ( ); i ++ ) { int noOfNextD = 0; switch ( arr [ i ] ) { case 'I' : j = i + 1; while ( arr [ j ] == 'D' && j < arr . length ( ) ) { noOfNextD ++; j ++; } if ( i == 0 ) { curr_max = noOfNextD + 2; cout << " " << ++ last_entry; cout << " " << curr_max; last_entry = curr_max; } else { curr_max = curr_max + noOfNextD + 1; last_entry = curr_max; cout << " " << last_entry; } for ( int k = 0; k < noOfNextD; k ++ ) { cout << " " << -- last_entry; i ++; } break; case 'D' : if ( i == 0 ) { j = i + 1; while ( arr [ j ] == 'D' && j < arr . length ( ) ) { noOfNextD ++; j ++; } curr_max = noOfNextD + 2; cout << " " << curr_max << " " << curr_max - 1; last_entry = curr_max - 1; } else { cout << " " << last_entry - 1; last_entry --; } break; } } cout << endl; }
int countSolutions ( int n ) { int res = 0; for ( int x = 0; x * x < n; x ++ ) for ( int y = 0; x * x + y * y < n; y ++ ) res ++; return res; }
int countSubstringWithEqualEnds ( string s ) { int result = 0; int n = s . length ( ); int count [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < n; i ++ ) count [ s [ i ] - 'a' ] ++; for ( int i = 0; i < MAX_CHAR; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ); return result; }
int maximumSumSubarray ( int arr [ ], int n ) { int min_prefix_sum = 0; int res = numeric_limits < int > :: min ( ); int prefix_sum [ n ]; prefix_sum [ 0 ] = arr [ 0 ]; for ( int i = 1; i < n; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ]; for ( int i = 0; i < n; i ++ ) { res = max ( res, prefix_sum [ i ] - min_prefix_sum ); min_prefix_sum = min ( min_prefix_sum, prefix_sum [ i ] ); } return res; }
int bellNumber ( int n ) { int bell [ n + 1 ] [ n + 1 ]; bell [ 0 ] [ 0 ] = 1; for ( int i = 1; i <= n; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ]; for ( int j = 1; j <= i; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ]; } return bell [ n ] [ 0 ]; }
int knapSack ( int W, int wt [ ], int val [ ], int n ) { int i, w; int K [ n + 1 ] [ W + 1 ]; for ( i = 0; i <= n; i ++ ) { for ( w = 0; w <= W; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] ); else K [ i ] [ w ] = K [ i - 1 ] [ w ]; } } return K [ n ] [ W ]; }
void smallestSubsegment ( int a [ ], int n ) { unordered_map < int, int > left; unordered_map < int, int > count; int mx = 0; int mn, strindex; for ( int i = 0; i < n; i ++ ) { int x = a [ i ]; if ( count [ x ] == 0 ) { left [ x ] = i; count [ x ] = 1; } else count [ x ] ++; if ( count [ x ] > mx ) { mx = count [ x ]; mn = i - left [ x ] + 1; strindex = left [ x ]; } else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) { mn = i - left [ x ] + 1; strindex = left [ x ]; } } for ( int i = strindex; i < strindex + mn; i ++ ) cout << a [ i ] << " "; }
int maxcoefficientvalue ( int n ) { int C [ n + 1 ] [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) { for ( int j = 0; j <= min ( i, n ); j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]; } } int maxvalue = 0; for ( int i = 0; i <= n; i ++ ) maxvalue = max ( maxvalue, C [ n ] [ i ] ); return maxvalue; }
double maxAverageOfPath ( int cost [ M ] [ M ], int N ) { int dp [ N + 1 ] [ N + 1 ]; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]; for ( int i = 1; i < N; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ]; for ( int j = 1; j < N; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ]; for ( int i = 1; i < N; i ++ ) for ( int j = 1; j <= N; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ]; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ); }
void findPair ( int arr [ ], int n ) { unordered_set < int > s; for ( int i = 0; i < n; i ++ ) s . insert ( arr [ i ] ); bool found = false; for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { if ( s . find ( arr [ i ] + arr [ j ] ) != s . end ( ) ) { cout << arr [ i ] << " " << arr [ j ] << endl; found = true; } } } if ( found == false ) cout << "Not exist" << endl; }
int interpolationSearch ( int arr [ ], int n, int x ) { int lo = 0, hi = ( n - 1 ); while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) { if ( arr [ lo ] == x ) return lo; return - 1; } int pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ); if ( arr [ pos ] == x ) return pos; if ( arr [ pos ] < x ) lo = pos + 1; else hi = pos - 1; } return - 1; }
void countDistinct ( int arr [ ], int k, int n ) { map < int, int > hm; int dist_count = 0; for ( int i = 0; i < k; i ++ ) { if ( hm [ arr [ i ] ] == 0 ) { dist_count ++; } hm [ arr [ i ] ] += 1; } cout << dist_count << endl; for ( int i = k; i < n; i ++ ) { if ( hm [ arr [ i - k ] ] == 1 ) { dist_count --; } hm [ arr [ i - k ] ] -= 1; if ( hm [ arr [ i ] ] == 0 ) { dist_count ++; } hm [ arr [ i ] ] += 1; cout << dist_count << endl; } }
int mod ( string num, int a ) { int res = 0; for ( int i = 0; i < num . length ( ); i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a; return res; }
int chordCnt ( int A ) { int n = 2 * A; int dpArray [ n + 1 ] = { 0 }; dpArray [ 0 ] = 1; dpArray [ 2 ] = 1; for ( int i = 4; i <= n; i += 2 ) { for ( int j = 0; j < i - 1; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ); } } return dpArray [ n ]; }
bool isConvertible ( string str1, string str2, int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true; int commonLength = 0; for ( int i = 0; i < min ( str1 . length ( ), str2 . length ( ) ); i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++; else break; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true; return false; }
int maximumChars ( string & str ) { int n = str . length ( ); int res = - 1; for ( int i = 0; i < n - 1; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( str [ i ] == str [ j ] ) res = max ( res, abs ( j - i - 1 ) ); return res; }
int nonDecNums ( int n ) { int a [ n + 1 ] [ 10 ]; for ( int i = 0; i <= 9; i ++ ) a [ 0 ] [ i ] = 1; for ( int i = 1; i <= n; i ++ ) a [ i ] [ 9 ] = 1; for ( int i = 1; i <= n; i ++ ) for ( int j = 8; j >= 0; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ]; return a [ n ] [ 0 ]; }
int countPaths ( int n, int m ) { if ( n == 0 || m == 0 ) return 1; return ( countPaths ( n - 1, m ) + countPaths ( n, m - 1 ) ); }
long long int calculateSum ( int n ) { long long int sum = 0; sum = 1 << n; return ( sum - 1 ); }
void deleteElements ( int arr [ ], int n, int k ) { stack < int > s; s . push ( arr [ 0 ] ); int count = 0; for ( int i = 1; i < n; i ++ ) { while ( ! s . empty ( ) && s . top ( ) < arr [ i ] && count < k ) { s . pop ( ); count ++; } s . push ( arr [ i ] ); } int m = s . size ( ); vector < int > v ( m ); while ( ! s . empty ( ) ) { v [ -- m ] = s . top ( ); s . pop ( ); } for ( auto x : v ) cout << x << " "; cout << endl; }
long long int findSum ( int n ) { long long int sum = 0; for ( int i = 1; i <= n; i ++ ) for ( int j = i; j <= n; j ++ ) sum = sum + i * j; return sum; }
INT_MAX int shortestPath ( int graph [ ] [ V ], int u, int v, int k ) { int sp [ V ] [ V ] [ k + 1 ]; for ( int e = 0; e <= k; e ++ ) { for ( int i = 0; i < V; i ++ ) { for ( int j = 0; j < V; j ++ ) { sp [ i ] [ j ] [ e ] = INF; if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0; if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ]; if ( e > 1 ) { for ( int a = 0; a < V; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ], graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ); } } } } } return sp [ u ] [ v ] [ k ]; }
INT_MAX int shortestDist ( int graph [ N ] [ N ] ) { int dist [ N ]; dist [ N - 1 ] = 0; for ( int i = N - 2; i >= 0; i -- ) { dist [ i ] = INF; for ( int j = i; j < N; j ++ ) { if ( graph [ i ] [ j ] == INF ) continue; dist [ i ] = min ( dist [ i ], graph [ i ] [ j ] + dist [ j ] ); } } return dist [ 0 ]; }
void decToOctal ( int n ) { int octalNum [ 100 ]; int i = 0; while ( n != 0 ) { octalNum [ i ] = n % 8; n = n / 8; i ++; } for ( int j = i - 1; j >= 0; j -- ) cout << octalNum [ j ]; }
void interchangeFirstLast ( int m [ ] [ n ] ) { int rows = n; for ( int i = 0; i < n; i ++ ) { int t = m [ 0 ] [ i ]; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ]; m [ rows - 1 ] [ i ] = t; } }
bool modularSum ( int arr [ ], int n, int m ) { if ( n > m ) return true; bool DP [ m ]; memset ( DP, false, m ); for ( int i = 0; i < n; i ++ ) { if ( DP [ 0 ] ) return true; bool temp [ m ]; memset ( temp, false, m ); for ( int j = 0; j < m; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true; } } for ( int j = 0; j < m; j ++ ) if ( temp [ j ] ) DP [ j ] = true; DP [ arr [ i ] % m ] = true; } return DP [ 0 ]; }
int findMinimumAngle ( int arr [ ], int n ) { int l = 0, sum = 0, ans = 360; for ( int i = 0; i < n; i ++ ) { sum += arr [ i ]; while ( sum >= 180 ) { ans = min ( ans, 2 * abs ( 180 - sum ) ); sum -= arr [ l ]; l ++; } ans = min ( ans, 2 * abs ( 180 - sum ) ); } return ans; }
int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x; int start = 1, end = x, ans; while ( start <= end ) { int mid = ( start + end ) / 2; if ( mid * mid == x ) return mid; if ( mid * mid < x ) { start = mid + 1; ans = mid; } else end = mid - 1; } return ans; }
bool isPossibleTriangle ( int arr [ ], int N ) { if ( N < 3 ) return false; sort ( arr, arr + N ); for ( int i = 0; i < N - 2; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true; }
int MaximumHeight ( int a [ ], int n ) { int result = 1; for ( int i = 1; i <= n; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2; if ( y < n ) result = i; else break; } return result; }
long countWays ( int n, int k ) { long total = k; int mod = 1000000007; int same = 0, diff = k; for ( int i = 2; i <= n; i ++ ) { same = diff; diff = total * ( k - 1 ); diff = diff % mod; total = ( same + diff ) % mod; } return total; }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3; }
unsigned int nextPowerOf2 ( unsigned int n ) { n --; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; n ++; return n; }
int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ); }
int modInverse ( int a, int m ) { a = a % m; for ( int x = 1; x < m; x ++ ) if ( ( a * x ) % m == 1 ) return x; }
void overflow ( int H, int r, int h, int N, int R ) { float tank_cap = 3.14 * r * r * H; float water_vol = 3.14 * r * r * h; float balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R; float vol = water_vol + balls_vol; if ( vol > tank_cap ) { cout << "Overflow" << endl; } else { cout << "Not in overflow state" << endl; } }
void printClosest ( int arr [ ], int n, int x ) { int res_l, res_r; int l = 0, r = n - 1, diff = INT_MAX; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l; res_r = r; diff = abs ( arr [ l ] + arr [ r ] - x ); } if ( arr [ l ] + arr [ r ] > x ) r --; else l ++; } cout << " The closest pair is " << arr [ res_l ] << " and " << arr [ res_r ]; }
int circle ( int x1, int y1, int x2, int y2, int r1, int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ); int radSumSq = ( r1 + r2 ) * ( r1 + r2 ); if ( distSq == radSumSq ) return 1; else if ( distSq > radSumSq ) return - 1; else return 0; }
void longestAlternating ( int arr [ ], int n ) { int count [ n ]; count [ n - 1 ] = 1; for ( int i = n - 2; i >= 0; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1; else count [ i ] = 1; } for ( int i = 0; i < n; i ++ ) cout << count [ i ] << " "; }
void generate_derangement ( int N ) { int S [ N + 1 ]; for ( int i = 1; i <= N; i ++ ) S [ i ] = i; int D [ N + 1 ]; for ( int i = 1; i <= N; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] D [ N ] = D [ N - 1 ]; D [ N - 1 ] = temp; } else { D [ i ] = i + 1; D [ i + 1 ] = i; } } for ( int i = 1; i <= N; i ++ ) printf ( "%d ", D [ i ] ); printf ( "\n" ); }
void findPairs ( int arr1 [ ], int arr2 [ ], int n, int m, int x ) { for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) cout << arr1 [ i ] << " " << arr2 [ j ] << endl; }
string minLexRotation ( string str ) { int n = str . length ( ); string arr [ n ]; string concat = str + str; for ( int i = 0; i < n; i ++ ) arr [ i ] = concat . substr ( i, n ); sort ( arr, arr + n ); return arr [ 0 ]; }
int search ( int arr [ ], int n, int x ) { int i = 0; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i; i += abs ( arr [ i ] - x ); } return - 1; }
void printArray ( int arr [ ] [ 5 ], int row, int col ) { unordered_set < string > uset; for ( int i = 0; i < row; i ++ ) { string s = ""; for ( int j = 0; j < col; j ++ ) s += to_string ( arr [ i ] [ j ] ); if ( uset . count ( s ) == 0 ) { uset . insert ( s ); cout << s << endl; } } }
void findMaxGuests ( int arrl [ ], int exit [ ], int n ) { sort ( arrl, arrl + n ); sort ( exit, exit + n ); int guests_in = 1, max_guests = 1, time = arrl [ 0 ]; int i = 1, j = 0; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++; if ( guests_in > max_guests ) { max_guests = guests_in; time = arrl [ i ]; } i ++; } else { guests_in --; j ++; } } cout << "Maximum Number of Guests = " << max_guests << " at time " << time; }
int zigzag ( int n, int k ) { if ( n == 0 && k == 0 ) return 1; if ( k == 0 ) return 0; return zigzag ( n, k - 1 ) + zigzag ( n - 1, n - k ); }
void solution ( int a, int b, int n ) { for ( int i = 0; i * a <= n; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { cout << "x = " << i << ", y = " << ( n - ( i * a ) ) / b; return; } } cout << "No solution"; }
void scalarProductMat ( int mat [ ] [ N ], int k ) { for ( int i = 0; i < N; i ++ ) for ( int j = 0; j < N; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k; }
int isPossible ( int n, int index, int modulo, int M, int arr [ ], int dp [ ] [ MAX ] ) { modulo = ( ( modulo % M ) + M ) % M; if ( index == n ) { if ( modulo == 0 ) return 1; return 0; } if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ]; int placeAdd = isPossible ( n, index + 1, modulo + arr [ index ], M, arr, dp ); int placeMinus = isPossible ( n, index + 1, modulo - arr [ index ], M, arr, dp ); bool res = ( placeAdd || placeMinus ); dp [ index ] [ modulo ] = res; return res; }
int findInteger ( int arr [ ], int n ) { unordered_map < int, int > hash; int maximum = 0; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] < 0 ) hash [ abs ( arr [ i ] ) ] -= 1; else hash [ arr [ i ] ] += 1; } for ( int i = 0; i < n; i ++ ) if ( hash [ arr [ i ] ] != 0 ) return arr [ i ]; return - 1; }
void KMP ( int m, int n, string str2, string str1 ) { int pos = 0, len = 0; int p [ m + 1 ]; int k = 0; p [ 1 ] = 0; for ( int i = 2; i <= n; i ++ ) { while ( k > 0 && str1 [ k ] != str1 [ i - 1 ] ) k = p [ k ]; if ( str1 [ k ] == str1 [ i - 1 ] ) ++ k; p [ i ] = k; } for ( int j = 0, i = 0; i < m; i ++ ) { while ( j > 0 && str1 [ j ] != str2 [ i ] ) j = p [ j ]; if ( str1 [ j ] == str2 [ i ] ) j ++; if ( j > len ) { len = j; pos = i - j + 1; } } cout << "Shift = " << pos << endl; cout << "Prefix = " << str1 . substr ( 0, len ); }
void printMaxOfMin ( int arr [ ], int n ) { for ( int k = 1; k <= n; k ++ ) { int maxOfMin = INT_MIN; for ( int i = 0; i <= n - k; i ++ ) { int min = arr [ i ]; for ( int j = 1; j < k; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ]; } if ( min > maxOfMin ) maxOfMin = min; } cout << maxOfMin << " "; } }
bool distributingBalls ( int k, int n, string str ) { int a [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < n; i ++ ) { a [ str [ i ] - 'a' ] ++; } for ( int i = 0; i < MAX_CHAR; i ++ ) if ( a [ i ] > k ) return false; return true; }
float findArea ( float r ) { return ( pi * r * r ); }
void rotateMatrix ( int mat [ ] [ N ] ) { for ( int i = N - 1; i >= 0; i -- ) { for ( int j = N - 1; j >= 0; j -- ) printf ( "%d ", mat [ i ] [ j ] ); printf ( "\n" ); } }
int minSum ( int A [ ], int n ) { int min_val = * min_element ( A, A + n ); return ( min_val * ( n - 1 ) ); }
void printDistinct ( int arr [ ], int n ) { sort ( arr, arr + n ); for ( int i = 0; i < n; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++; cout << arr [ i ] << " "; } }
bool areConsecutive ( int arr [ ], int n ) { if ( n < 1 ) return false; int min = getMin ( arr, n ); int max = getMax ( arr, n ); if ( max - min + 1 == n ) { bool * visited = ( bool * ) calloc ( n, sizeof ( bool ) ); int i; for ( i = 0; i < n; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false; visited [ arr [ i ] - min ] = true; } return true; } return false; }
bool checkIsAP ( int arr [ ], int n ) { if ( n == 1 ) return true; sort ( arr, arr + n ); int d = arr [ 1 ] - arr [ 0 ]; for ( int i = 2; i < n; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false; return true; }
bool findthepath ( char * S, int v ) { result [ 0 ] = v + '0'; for ( int i = 1; S [ i ]; i ++ ) { if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] [ v ] ) { v = S [ i ] - 'A'; } else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i ] - 'A' + 5 ] [ v ] ) { v = S [ i ] - 'A' + 5; } else return false; result [ i ] = v + '0'; } return true; }
void maxMin ( int arr [ ] [ MAX ], int n ) { int min = INT_MAX; int max = INT_MIN; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j <= n / 2; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ]; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ]; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ]; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ]; } } } cout << "Maximum = " << max; << ", Minimum = " << min; }
void printFirstRepeating ( int arr [ ], int n ) { int min = - 1; set < int > myset; for ( int i = n - 1; i >= 0; i -- ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i; else myset . insert ( arr [ i ] ); } if ( min != - 1 ) cout << "The first repeating element is " << arr [ min ]; else cout << "There are no repeating elements"; }
string to_upper ( string & in ) { for ( int i = 0; i < in . length ( ); i ++ ) if ( 'a' <= in [ i ] <= 'z' ) in [ i ] = in [ i ] - 'a' + 'A'; return in; }
int lis ( int arr [ ], int n ) { int lis [ n ]; lis [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) { lis [ i ] = 1; for ( int j = 0; j < i; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1; } return * max_element ( lis, lis + n ); }
int knapSack ( int W, int wt [ ], int val [ ], int n ) { if ( n == 0 || W == 0 ) return 0; if ( wt [ n - 1 ] > W ) return knapSack ( W, wt, val, n - 1 ); else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) ); }
int countManipulations ( string s1, string s2 ) { int count = 0; int char_count [ 26 ]; for ( int i = 0; i < 26; i ++ ) { char_count [ i ] = 0; } for ( int i = 0; i < s1 . length ( ); i ++ ) char_count [ s1 [ i ] - 'a' ] ++; for ( int i = 0; i < s2 . length ( ); i ++ ) { char_count [ s2 [ i ] - 'a' ] --; if ( char_count [ s2 [ i ] - 'a' ] < 0 ) count ++; } return count; }
int findMinZero ( int p ) { int first = 1, second = 1, number = 2, next = 1; while ( next ) { next = ( first + second ) % p; first = second; second = next; number ++; } return number; }
int numberOfPaths ( int m, int n ) { if ( m == 1 || n == 1 ) return 1; return numberOfPaths ( m - 1, n ) + numberOfPaths ( m, n - 1 ); }
int longestSubsequenceCommonSegment ( int k, string s1, string s2 ) { int n = s1 . length ( ); int m = s2 . length ( ); int lcs [ n + 1 ] [ m + 1 ]; int cnt [ n + 1 ] [ m + 1 ]; memset ( lcs, 0, sizeof ( lcs ) ); memset ( cnt, 0, sizeof ( cnt ) ); for ( int i = 1; i <= n; i ++ ) { for ( int j = 1; j <= m; j ++ ) { lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ], lcs [ i ] [ j - 1 ] ); if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k; a <= cnt [ i ] [ j ]; a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ], lcs [ i - a ] [ j - a ] + a ); } } } return lcs [ n ] [ m ]; }
bool checkForSorting ( int arr [ ], int n ) { for ( int i = 0; i < n - 1; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ], arr [ i + 1 ] ); else return false; } } return true; }
int check ( string str ) { int n = str . length ( ); int oddDigSum = 0, evenDigSum = 0; for ( int i = 0; i < n; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ); else evenDigSum += ( str [ i ] - '0' ); } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ); }
string decodeMedianString ( string s ) { int l = s . length ( ); string s1 = ""; bool isEven = ( l % 2 == 0 ) ? true : false; for ( int i = 0; i < l; i += 2 ) { if ( isEven ) { s1 = s [ i ] + s1; s1 += s [ i + 1 ]; } else { if ( l - i > 1 ) { s1 += s [ i ]; s1 = s [ i + 1 ] + s1; } else { s1 += s [ i ]; } } } return s1; }
unsigned int getAbs ( int n ) { int const mask = n >> ( sizeof ( int ) * CHARBIT - 1 ); return ( ( n + mask ) ^ mask ); }
int knapSack ( int W, int wt [ ], int val [ ], int n ) { if ( n == 0 || W == 0 ) return 0; if ( wt [ n - 1 ] > W ) return knapSack ( W, wt, val, n - 1 ); else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) ); }
bool negCyclefloydWarshall ( int graph [ ] [ V ] ) { int dist [ V ] [ V ], i, j, k; for ( i = 0; i < V; i ++ ) for ( j = 0; j < V; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ]; for ( k = 0; k < V; k ++ ) { for ( i = 0; i < V; i ++ ) { for ( j = 0; j < V; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ]; } } } for ( int i = 0; i < V; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true; return false; }
int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2; }
void printDuo ( string & str ) { int countChar [ MAX_CHAR ] = { 0 }; int n = str . length ( ); for ( int i = 0; i < n; i ++ ) countChar [ str [ i ] - 'a' ] ++; string str1 = "", str2 = ""; for ( int i = 0; i < MAX_CHAR; i ++ ) { if ( countChar [ i ] > 1 ) str2 = str2 + ( char ) ( i + 'a' ); else if ( countChar [ i ] == 1 ) str1 = str1 + ( char ) ( i + 'a' ); } cout << "String with characters occurring " << "once:\n"; cout << str1 << "\n"; cout << "String with characters occurring " << "multiple times:\n"; cout << str2 << "\n"; }
int mostFrequent ( int arr [ ], int n ) { unordered_map < int, int > hash; for ( int i = 0; i < n; i ++ ) hash [ arr [ i ] ] ++; int max_count = 0, res = - 1; for ( auto i : hash ) { if ( max_count < i . second ) { res = i . first; max_count = i . second; } } return res; }
string multiply ( string num1, string num2 ) { int len1 = num1 . size ( ); int len2 = num2 . size ( ); if ( len1 == 0 || len2 == 0 ) return "0"; vector < int > result ( len1 + len2, 0 ); int i_n1 = 0; int i_n2 = 0; for ( int i = len1 - 1; i >= 0; i -- ) { int carry = 0; int n1 = num1 [ i ] - '0'; i_n2 = 0; for ( int j = len2 - 1; j >= 0; j -- ) { int n2 = num2 [ j ] - '0'; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry; carry = sum / 10; result [ i_n1 + i_n2 ] = sum % 10; i_n2 ++; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry; i_n1 ++; } int i = result . size ( ) - 1; while ( i >= 0 && result [ i ] == 0 ) i --; if ( i == - 1 ) return "0"; string s = ""; while ( i >= 0 ) s += std :: to_string ( result [ i -- ] ); return s; }
int minimumCostOfBreaking ( int X [ ], int Y [ ], int m, int n ) { int res = 0; sort ( X, X + m, greater < int > ( ) ); sort ( Y, Y + n, greater < int > ( ) ); int hzntl = 1, vert = 1; int i = 0, j = 0; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert; hzntl ++; i ++; } else { res += Y [ j ] * hzntl; vert ++; j ++; } } int total = 0; while ( i < m ) total += X [ i ++ ]; res += total * vert; total = 0; while ( j < n ) total += Y [ j ++ ]; res += total * hzntl; return res; }
double polygonArea ( double X [ ], double Y [ ], int n ) { double area = 0.0; int j = n - 1; for ( int i = 0; i < n; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ); j = i; } return abs ( area / 2.0 ); }
int minSum ( int arr [ ], int n ) { int dp [ n ]; if ( n == 1 ) return arr [ 0 ]; if ( n == 2 ) return min ( arr [ 0 ], arr [ 1 ] ); if ( n == 3 ) return min ( arr [ 0 ], min ( arr [ 1 ], arr [ 2 ] ) ); if ( n == 4 ) return min ( min ( arr [ 0 ], arr [ 1 ] ), min ( arr [ 2 ], arr [ 3 ] ) ); dp [ 0 ] = arr [ 0 ]; dp [ 1 ] = arr [ 1 ]; dp [ 2 ] = arr [ 2 ]; dp [ 3 ] = arr [ 3 ]; for ( int i = 4; i < n; i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ], dp [ i - 2 ] ), min ( dp [ i - 3 ], dp [ i - 4 ] ) ); return min ( min ( dp [ n - 1 ], dp [ n - 2 ] ), min ( dp [ n - 4 ], dp [ n - 3 ] ) ); }
bool divisibleBy20 ( string num ) { int lastTwoDigits = stoi ( num . substr ( num . length ( ) - 2, num . length ( ) - 1 ) ); return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ); }
string findString ( int n, int k ) { string res = ""; for ( int i = 0; i < k; i ++ ) res = res + ( char ) ( 'a' + i ); int count = 0; for ( int i = 0; i < n - k; i ++ ) { res = res + ( char ) ( 'a' + count ); count ++; if ( count == k ) count = 0; } return res; }
string decToBin ( int n ) { if ( n == 0 ) return "0"; string bin = ""; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin; n >>= 1; } return bin; }
void findTriplets ( int arr [ ], int n ) { bool found = false; for ( int i = 0; i < n - 1; i ++ ) { unordered_set < int > s; for ( int j = i + 1; j < n; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ); if ( s . find ( x ) != s . end ( ) ) { printf ( "%d %d %d\n", x, arr [ i ], arr [ j ] ); found = true; } else s . insert ( arr [ j ] ); } } if ( found == false ) cout << " No Triplet Found" << endl; }
void findRoots ( int a, int b, int c ) { if ( a == 0 ) { cout << "Invalid"; return; } int d = b * b - 4 * a * c; double sqrt_val = sqrt ( abs ( d ) ); if ( d > 0 ) { cout << "Roots are real and different \n"; cout << ( double ) ( - b + sqrt_val ) / ( 2 * a ) << "\n" << ( double ) ( - b - sqrt_val ) / ( 2 * a ); } else if ( d == 0 ) { cout << "Roots are real and same \n"; cout << - ( double ) b / ( 2 * a ); } else { cout << "Roots are complex \n"; cout << - ( double ) b / ( 2 * a ) << " + i" << sqrt_val << "\n" << - ( double ) b / ( 2 * a ) << " - i" << sqrt_val; } }
string findSubString ( string str, string pat ) { int len1 = str . length ( ); int len2 = pat . length ( ); if ( len1 < len2 ) { cout << "No such window exists"; return ""; } int hash_pat [ no_of_chars ] = { 0 }; int hash_str [ no_of_chars ] = { 0 }; for ( int i = 0; i < len2; i ++ ) hash_pat [ pat [ i ] ] ++; int start = 0, start_index = - 1, min_len = INT_MAX; int count = 0; for ( int j = 0; j < len1; j ++ ) { hash_str [ str [ j ] ] ++; if ( hash_pat [ str [ j ] ] != 0 && hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) count ++; if ( count == len2 ) { while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] || hash_pat [ str [ start ] ] == 0 ) { if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) hash_str [ str [ start ] ] --; start ++; } int len_window = j - start + 1; if ( min_len > len_window ) { min_len = len_window; start_index = start; } } } if ( start_index == - 1 ) { cout << "No such window exists"; return ""; } return str . substr ( start_index, min_len ); }
void bonacciseries ( long n, int m ) { int a [ m ] = { 0 }; a [ n - 1 ] = 1; for ( int i = n; i < m; i ++ ) for ( int j = i - n; j < i; j ++ ) a [ i ] += a [ j ]; for ( int i = 0; i < m; i ++ ) cout << a [ i ] << " "; }
void printHosoya ( int n ) { int dp [ N ] [ N ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1; for ( int i = 2; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ]; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ]; } } for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j <= i; j ++ ) cout << dp [ i ] [ j ] << " "; cout << endl; } }
bool isPrime ( int n ) { if ( n <= 1 ) return false; for ( int i = 2; i < n; i ++ ) if ( n % i == 0 ) return false; return true; }
int nonFibonacci ( int n ) { int prevPrev = 1, prev = 2, curr = 3; while ( n > 0 ) { prevPrev = prev; prev = curr; curr = prevPrev + prev; n = n - ( curr - prev - 1 ); } n = n + ( curr - prev - 1 ); return prev + n; }
int solve ( int A [ ], int B [ ], int C [ ], int i, int j, int k ) { int min_diff, current_diff, max_term; min_diff = abs ( max ( A [ i ], max ( B [ j ], C [ k ] ) ) - min ( A [ i ], min ( B [ j ], C [ k ] ) ) ); while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = abs ( max ( A [ i ], max ( B [ j ], C [ k ] ) ) - min ( A [ i ], min ( B [ j ], C [ k ] ) ) ); if ( current_diff < min_diff ) min_diff = current_diff; max_term = max ( A [ i ], max ( B [ j ], C [ k ] ) ); if ( A [ i ] == max_term ) i -= 1; else if ( B [ j ] == max_term ) j -= 1; else k -= 1; } return min_diff; }
void printRotatedString ( char str [ ] ) { int n = strlen ( str ); char temp [ 2 * n + 1 ]; strcpy ( temp, str ); strcat ( temp, str ); for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j != n; j ++ ) printf ( "%c", temp [ i + j ] ); printf ( "\n" ); } }
void printRepeating ( int arr [ ], int size ) { int Xor = arr [ 0 ]; int set_bit_no; int i; int n = size - 2; int x = 0, y = 0; for ( i = 1; i < size; i ++ ) Xor ^= arr [ i ]; for ( i = 1; i <= n; i ++ ) Xor ^= i; set_bit_no = Xor & ~ ( Xor - 1 ); for ( i = 0; i < size; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ]; else y = y ^ arr [ i ]; } for ( i = 1; i <= n; i ++ ) { if ( i & set_bit_no ) x = x ^ i; else y = y ^ i; } cout << "The two repeating elements are " << y << " " << x; }
int find_Area ( int r ) { return ( 2 * r * r ); }
bool find3Numbers ( int A [ ], int arr_size, int sum ) { int l, r; sort ( A, A + arr_size ); for ( int i = 0; i < arr_size - 2; i ++ ) { l = i + 1; r = arr_size - 1; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { printf ( "Triplet is %d, %d, %d", A [ i ], A [ l ], A [ r ] ); return true; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++; else r --; } } return false; }
int countWays ( int n, int m ) { int count [ n + 1 ]; count [ 0 ] = 0; for ( int i = 1; i <= n; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ]; else if ( i < m ) count [ i ] = 1; else count [ i ] = 2; } return count [ n ]; }
int findSubArray ( int arr [ ], int n ) { int sum = 0; int maxsize = - 1, startindex; for ( int i = 0; i < n - 1; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1; for ( int j = i + 1; j < n; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += - 1 ) : ( sum += 1 ); if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1; startindex = i; } } } if ( maxsize == - 1 ) cout << "No such subarray"; else cout << startindex << " to " << startindex + maxsize - 1; return maxsize; }
int check ( string str ) { int n = str . length ( ); int digitSum = 0; for ( int i = 0; i < n; i ++ ) digitSum += ( str [ i ] - '0' ); return ( digitSum % 3 == 0 ); }
void fitOrNotFit ( int R, int r, int x, int y, int rad ) { double val = sqrt ( pow ( x, 2 ) + pow ( y, 2 ) ); if ( val + rad <= R && val - rad >= R - r ) cout << "Fits\n"; else cout << "Doesn't Fit\n"; }
long countWays ( int n ) { long dp [ 2 ] [ n + 1 ]; dp [ 0 ] [ 1 ] = 1; dp [ 1 ] [ 1 ] = 2; for ( int i = 2; i <= n; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ]; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]; }
int fib ( int n ) { if ( n <= 1 ) return n; return fib ( n - 1 ) + fib ( n - 2 ); }
int countDivisibleSubseq ( string str, int n ) { int len = str . length ( ); int dp [ len ] [ n ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++; for ( int i = 1; i < len; i ++ ) { dp [ i ] [ ( str [ i ] - '0' ) % n ] ++; for ( int j = 0; j < n; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ]; dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ]; } } return dp [ len - 1 ] [ 0 ]; }
int seiresSum ( int n, int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ); }
void alternateSubarray ( bool arr [ ], int n ) { int count = 1; int prev = arr [ 0 ]; for ( int i = 1; i < n; ++ i ) { if ( ( arr [ i ] ^ prev ) == 0 ) { while ( count ) cout << count -- << " "; } ++ count; prev = arr [ i ]; } while ( count ) cout << count -- << " "; }
int maxTripletSum ( int arr [ ], int n ) { int maxA = INT_MIN, maxB = INT_MIN, maxC = INT_MIN; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB; maxB = maxA; maxA = arr [ i ]; } else if ( arr [ i ] > maxB ) { maxC = maxB; maxB = arr [ i ]; } else if ( arr [ i ] > maxC ) maxC = arr [ i ]; } return ( maxA + maxB + maxC ); }
int countPattern ( string str ) { int len = str . size ( ); bool oneSeen = 0; int count = 0; for ( int i = 0; i < len; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1; continue; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0; } return count; }
int findSubsequenceCount ( string S, string T ) { int m = T . length ( ), n = S . length ( ); if ( m > n ) return 0; int mat [ m + 1 ] [ n + 1 ]; for ( int i = 1; i <= m; i ++ ) mat [ i ] [ 0 ] = 0; for ( int j = 0; j <= n; j ++ ) mat [ 0 ] [ j ] = 1; for ( int i = 1; i <= m; i ++ ) { for ( int j = 1; j <= n; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ]; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ]; } } return mat [ m ] [ n ]; }
int findoptimal ( int N ) { if ( N <= 6 ) return N; int screen [ N ]; int b; int n; for ( n = 1; n <= 6; n ++ ) screen [ n - 1 ] = n; for ( n = 7; n <= N; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ], max ( 3 * screen [ n - 5 ], 4 * screen [ n - 6 ] ) ); } return screen [ N - 1 ]; }
void tower ( int n, char sourcePole, char destinationPole, char auxiliaryPole ) { if ( 0 == n ) return; tower ( n - 1, sourcePole, auxiliaryPole, destinationPole ); cout << "Move the disk " << n << " from " << sourcePole << " to " << destinationPole << endl; tower ( n - 1, auxiliaryPole, destinationPole, sourcePole ); }
public : int sumDigits ( int no ) { return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 ); }
bool checkDivisibility ( string num ) { int length = num . size ( ); if ( length == 1 && num [ 0 ] == '0' ) return true; if ( length % 3 == 1 ) { num += "00"; length += 2; } else if ( length % 3 == 2 ) { num += "0"; length += 1; } int sum = 0, p = 1; for ( int i = length - 1; i >= 0; i -- ) { int group = 0; group += num [ i -- ] - '0'; group += ( num [ i -- ] - '0' ) * 10; group += ( num [ i ] - '0' ) * 100; sum = sum + group * p; p *= ( - 1 ); } sum = abs ( sum ); return ( sum % 13 == 0 ); }
int minRemovalsDP ( int arr [ ], int n ) { int longest_start = - 1, longest_end = 0; for ( int start = 0; start < n; start ++ ) { int min = INT_MAX, max = INT_MIN; for ( int end = start; end < n; end ++ ) { int val = arr [ end ]; if ( val < min ) min = val; if ( val > max ) max = val; if ( 2 * min <= max ) break; if ( end - start > longest_end - longest_start || longest_start == - 1 ) { longest_start = start; longest_end = end; } } } if ( longest_start == - 1 ) return n; return ( n - ( longest_end - longest_start + 1 ) ); }
bool isPossibleToMakeDivisible ( int arr [ ], int n ) { int remainder = 0; for ( int i = 0; i < n; i ++ ) remainder = ( remainder + arr [ i ] ) % 3; return ( remainder == 0 ); }
void parabola ( float a, float b, float c ) { cout << "Vertex: (" << ( - b / ( 2 * a ) ) << ", " << ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) << ")" << endl; cout << "Focus: (" << ( - b / ( 2 * a ) ) << ", " << ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) << ")" << endl; cout << "Directrix: y=" << c - ( ( b * b ) + 1 ) * 4 * a << endl; }
void findSmallestRange ( int arr [ ] [ N ], int n, int k ) { int i, minval, maxval, minrange, minel, maxel, flag, minind; for ( i = 0; i <= k; i ++ ) ptr [ i ] = 0; minrange = INT_MAX; while ( 1 ) { minind = - 1; minval = INT_MAX; maxval = INT_MIN; flag = 0; for ( i = 0; i < k; i ++ ) { if ( ptr [ i ] == n ) { flag = 1; break; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i; minval = arr [ i ] [ ptr [ i ] ]; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ]; } } if ( flag ) break; ptr [ minind ] ++; if ( ( maxval - minval ) < minrange ) { minel = minval; maxel = maxval; minrange = maxel - minel; } } printf ( "The smallest range is [%d , %d]\n", minel, maxel ); }
int findMaxAverage ( int arr [ ], int n, int k ) { if ( k > n ) return - 1; int * csum = new int [ n ]; csum [ 0 ] = arr [ 0 ]; for ( int i = 1; i < n; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ]; int max_sum = csum [ k - 1 ], max_end = k - 1; for ( int i = k; i < n; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ]; if ( curr_sum > max_sum ) { max_sum = curr_sum; max_end = i; } } delete [ ] csum; return max_end - k + 1; }
int getMissingNo ( int a [ ], int n ) { int total = ( n + 1 ) * ( n + 2 ) / 2; for ( int i = 0; i < n; i ++ ) total -= a [ i ]; return total; }
bool find3Numbers ( int A [ ], int arr_size, int sum ) { for ( int i = 0; i < arr_size - 2; i ++ ) { unordered_set < int > s; int curr_sum = sum - A [ i ]; for ( int j = i + 1; j < arr_size; j ++ ) { if ( s . find ( curr_sum - A [ j ] ) != s . end ( ) ) { printf ( "Triplet is %d, %d, %d", A [ i ], A [ j ], curr_sum - A [ j ] ); return true; } s . insert ( A [ j ] ); } } return false; }
int largestGCDSubsequence ( int arr [ ], int n ) { int ans = 0; int maxele = * max_element ( arr, arr + n ); for ( int i = 2; i <= maxele; ++ i ) { int count = 0; for ( int j = 0; j < n; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count; } ans = max ( ans, count ); } return ans; }
bool checkplusperfect ( int x ) { int temp = x; int n = 0; while ( x != 0 ) { x /= 10; n ++; } x = temp; int sum = 0; while ( x != 0 ) { sum += pow ( x % 10, n ); x /= 10; } return ( sum == temp ); }
void carveCross ( string str ) { int n = str . length ( ); if ( n % 2 == 0 ) { cout << "Not possible. Please enter " << "odd length string.\n"; } else { char arr [ max ] [ max ]; int m = n / 2; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { arr [ i ] [ j ] = 'X'; } } for ( int i = 0; i < n; i ++ ) { arr [ i ] [ m ] = str [ i ]; } for ( int i = 0; i < n; i ++ ) { arr [ m ] [ i ] = str [ i ]; } for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { cout << arr [ i ] [ j ] << " "; } cout << "\n"; } } }
int divSum ( int n ) { int result = 0; for ( int i = 2; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i; else result += ( i + n / i ); } } return ( result + n + 1 ); }
int countSubstringWithEqualEnds ( string s ) { int result = 0; int n = s . length ( ); for ( int i = 0; i < n; i ++ ) for ( int j = i; j < n; j ++ ) if ( s [ i ] == s [ j ] ) result ++; return result; }
void printDuplicates ( int arr [ ], int n ) { unordered_map < int, int > freq; for ( int i = 0; i < n; i ++ ) freq [ arr [ i ] ] ++; bool dup = false; unordered_map < int, int > :: iterator itr; for ( itr = freq . begin ( ); itr != freq . end ( ); itr ++ ) { if ( itr -> second > 1 ) { cout << itr -> first << " "; dup = true; } } if ( dup == false ) cout << "-1"; }
int countSubsequences ( string s ) { int aCount = 0; int bCount = 0; int cCount = 0; for ( unsigned int i = 0; i < s . size ( ); i ++ ) { if ( s [ i ] == 'a' ) aCount = ( 1 + 2 * aCount ); else if ( s [ i ] == 'b' ) bCount = ( aCount + 2 * bCount ); else if ( s [ i ] == 'c' ) cCount = ( bCount + 2 * cCount ); } return cCount; }
void printFibonacciNumbers ( int n ) { int f1 = 0, f2 = 1, i; if ( n < 1 ) return; for ( i = 1; i <= n; i ++ ) { cout << f2 << " "; int next = f1 + f2; f1 = f2; f2 = next; } }
void printGrouped ( string str ) { int n = str . length ( ); int count [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < n; i ++ ) count [ str [ i ] - 'a' ] ++; for ( int i = 0; i < n; i ++ ) { while ( count [ str [ i ] - 'a' ] -- ) cout << str [ i ]; count [ str [ i ] - 'a' ] = 0; } }
int getPairsCount ( int arr [ ], int n, int sum ) { unordered_map < int, int > m; for ( int i = 0; i < n; i ++ ) m [ arr [ i ] ] ++; int twice_count = 0; for ( int i = 0; i < n; i ++ ) { twice_count += m [ sum - arr [ i ] ]; if ( sum - arr [ i ] == arr [ i ] ) twice_count --; } return twice_count / 2; }
int countSquares ( int a, int b ) { return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ); }
int lcs ( string & X, string & Y ) { int m = X . length ( ), n = Y . length ( ); int L [ 2 ] [ n + 1 ]; bool bi; for ( int i = 0; i <= m; i ++ ) { bi = i & 1; for ( int j = 0; j <= n; j ++ ) { if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ], L [ bi ] [ j - 1 ] ); } } return L [ bi ] [ n ]; }
void printFactorialNums ( int n ) { int fact = 1; int x = 2; while ( fact <= n ) { cout << fact << " "; fact = fact * x; x ++; } }
int countWays ( string s ) { int count [ 26 ] = { 0 }; for ( char x : s ) count [ x - 'a' ] ++; count [ s [ 0 ] - 'a' ] = 1; int ans = 1; for ( int i = 0; i < 26; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ]; return ans; }
void reverse ( string str ) { if ( str . size ( ) == 0 ) { return; } reverse ( str . substr ( 1 ) ); cout << str [ 0 ]; }
int findMaxVal ( int arr [ ], int n, int num, int maxLimit ) { int ind; int val; int dp [ n ] [ maxLimit + 1 ]; for ( ind = 0; ind < n; ind ++ ) { for ( val = 0; val <= maxLimit; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1; } else { dp [ ind ] [ val ] = 0; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ]; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ]; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ]; } else { dp [ ind ] [ val ] = 0; } } } } for ( val = maxLimit; val >= 0; val -- ) { if ( dp [ n - 1 ] [ val ] ) { return val; } } return - 1; }
int gcd ( int a, int b ) { if ( a == 0 ) return b; if ( b == 0 ) return a; int k; for ( k = 0; ( ( a | b ) && 1 ) == 0; ++ k ) { a >>= 1; b >>= 1; } while ( ( a > 1 ) == 0 ) a >>= 1; do { while ( ( b > 1 ) == 0 ) b >>= 1; if ( a > b ) swap ( a, b ); b = ( b - a ); } while ( b != 0 ); return a << k; }
bool isSubSeqDivisible ( string str ) { for ( int i = 0; i < l; i ++ ) { for ( int j = i; j < l; j ++ ) { for ( int k = j; k < l; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true; } } } return false; }
int binarySearch ( int arr [ ], int left, int right ) { if ( left <= right ) { int mid = ( left + right ) / 2; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr, mid + 1, right ); else return binarySearch ( arr, left, mid - 1 ); } return - 1; }
int possibleStrings ( int n, int r, int b, int g ) { int fact [ n + 1 ]; fact [ 0 ] = 1; for ( int i = 1; i <= n; i ++ ) fact [ i ] = fact [ i - 1 ] * i; int left = n - ( r + g + b ); int sum = 0; for ( int i = 0; i <= left; i ++ ) { for ( int j = 0; j <= left - i; j ++ ) { int k = left - ( i + j ); sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ); } } return sum; }
int search ( int mat [ 4 ] [ 4 ], int n, int x ) { if ( n == 0 ) return - 1; int smallest = a [ 0 ] [ 0 ], largest = a [ n - 1 ] [ n - 1 ]; if ( x < smallest || x > largest ) return - 1; int i = 0, j = n - 1; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << "n Found at " << i << ", " << j; return 1; } if ( mat [ i ] [ j ] > x ) j --; else i ++; } cout << "n Element not found"; return 0; }
int minOperation ( bool arr [ N ] [ M ] ) { int ans = 0; for ( int i = N - 1; i >= 0; i -- ) { for ( int j = M - 1; j >= 0; j -- ) { if ( arr [ i ] [ j ] == 0 ) { ans ++; for ( int k = 0; k <= i; k ++ ) { for ( int h = 0; h <= j; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0; else arr [ k ] [ h ] = 1; } } } } } return ans; }
int findSum ( int n ) { int arr [ n ] [ n ]; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < n; j ++ ) arr [ i ] [ j ] = abs ( i - j ); int sum = 0; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < n; j ++ ) sum += arr [ i ] [ j ]; return sum; }
string smallestNumber ( string num ) { int n = num . size ( ); int rightMin [ n ], right; rightMin [ n - 1 ] = - 1; right = n - 1; for ( int i = n - 2; i >= 1; i -- ) { if ( num [ i ] >= num [ right ] ) rightMin [ i ] = right; else { if ( num [ i ] == num [ i + 1 ] ) { rightMin [ i ] = right; } else { rightMin [ i ] = - 1; right = i; } } } int small = - 1; for ( int i = 1; i < n; i ++ ) if ( num [ i ] != '0' ) { if ( small == - 1 ) { if ( num [ i ] < num [ 0 ] ) small = i; } else if ( num [ i ] <= num [ small ] ) small = i; } if ( small != - 1 ) swap ( num [ 0 ], num [ small ] ); else { for ( int i = 1; i < n; i ++ ) { if ( rightMin [ i ] != - 1 && num [ i ] != num [ rightMin [ i ] ] ) { swap ( num [ i ], num [ rightMin [ i ] ] ); break; } } } return num; }
int countTransformation ( string a, string b ) { int n = a . size ( ), m = b . size ( ); if ( m == 0 ) return 1; int dp [ m + 1 ] [ n + 1 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 0; i < m; i ++ ) { for ( int j = i; j < n; j ++ ) { if ( i == 0 ) { if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0; else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; } else { if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; } } } return dp [ m - 1 ] [ n - 1 ]; }
void printBracketNumber ( string exp, int n ) { int left_bnum = 1; stack < int > right_bnum; for ( int i = 0; i < n; i ++ ) { if ( exp [ i ] == '(' ) { cout << left_bnum << " "; right_bnum . push ( left_bnum ); left_bnum ++; } else if ( exp [ i ] == ')' ) { cout << right_bnum . top ( ) << " "; right_bnum . pop ( ); } } }
int computeLastDigit ( long long int A, long long int B ) { int variable = 1; if ( A == B ) return 1; else if ( ( B - A ) >= 5 ) return 0; else { for ( long long int i = A + 1; i <= B; i ++ ) variable = ( variable * ( i % 10 ) ) % 10; return variable % 10; } }
long long int yMod ( long long int y, long long int x ) { if ( log2 ( y ) < x ) return y; if ( x > 63 ) return y; return ( y % ( 1 << x ) ); }
int countWords ( char str [ ], int len ) { int count = 1; if ( len == 1 ) return count; if ( str [ 0 ] == str [ 1 ] ) count *= 1; else count *= 2; for ( int j = 1; j < len - 1; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1; else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str [ j + 1 ] || str [ j - 1 ] == str [ j + 1 ] ) count *= 2; else count *= 3; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1; else count *= 2; return count; }
void longestSubsequence ( int a [ ], int n ) { unordered_map < int, int > mp; int dp [ n ]; memset ( dp, 0, sizeof ( dp ) ); int maximum = INT_MIN; int index = - 1; for ( int i = 0; i < n; i ++ ) { if ( mp . find ( a [ i ] - 1 ) != mp . end ( ) ) { int lastIndex = mp [ a [ i ] - 1 ] - 1; dp [ i ] = 1 + dp [ lastIndex ]; } else dp [ i ] = 1; mp [ a [ i ] ] = i + 1; if ( maximum < dp [ i ] ) { maximum = dp [ i ]; index = i; } } for ( int curr = a [ index ] - maximum + 1; curr <= a [ index ]; curr ++ ) cout << curr << " "; }
void mergeIntervals ( Interval arr [ ], int n ) { sort ( arr, arr + n, mycomp ); int index = 0; for ( int i = 1; i < n; i ++ ) { if ( arr [ index ] . e >= arr [ i ] . s ) { arr [ index ] . e = max ( arr [ index ] . e, arr [ i ] . e ); arr [ index ] . s = min ( arr [ index ] . s, arr [ i ] . s ); } else { arr [ index ] = arr [ i ]; index ++; } } cout << "\n The Merged Intervals are: "; for ( int i = 0; i <= index; i ++ ) cout << "[" << arr [ i ] . s << ", " << arr [ i ] . e << "] "; }
int countWays ( int N ) { if ( N == 1 ) return 4; int countB = 1, countS = 1, prev_countB, prev_countS; for ( int i = 2; i <= N; i ++ ) { prev_countB = countB; prev_countS = countS; countS = prev_countB + prev_countS; countB = prev_countS; } int result = countS + countB; return ( result * result ); }
long int exponentiation ( long int base, long int exp ) { if ( exp == 0 ) return 1; if ( exp == 1 ) return base % N; long int t = exponentiation ( base, exp / 2 ); t = ( t * t ) % N; if ( exp % 2 == 0 ) return t; else return ( ( base % N ) * t ) % N; }
void findMinAvgSubarray ( int arr [ ], int n, int k ) { if ( n < k ) return; int res_index = 0; int curr_sum = 0; for ( int i = 0; i < k; i ++ ) curr_sum += arr [ i ]; int min_sum = curr_sum; for ( int i = k; i < n; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ]; if ( curr_sum < min_sum ) { min_sum = curr_sum; res_index = ( i - k + 1 ); } } cout << "Subarray between [" << res_index << ", " << res_index + k - 1 << "] has minimum average"; }
void checkEulerFourSquareIdentity ( int a, int b ) { int ab = a * b; bool flag = false; int i = 0; while ( i * i <= ab ) { int j = i; while ( i * i + j * j <= ab ) { int k = j; while ( i * i + j * j + k * k <= ab ) { double l = sqrt ( ab - ( i * i + j * j + k * k ) ); if ( floor ( l ) == ceil ( l ) && l >= k ) { flag = true; cout << "i = " << i << "\n"; cout << "j = " << j << "\n"; cout << "k = " << k << "\n"; cout << "l = " << ( int ) l << "\n"; cout << "Product of " << a << " and " << b << " can be written as sum of squares" << " of i, j, k, l \n"; cout << ab + " = " << i << "*" << i << " + " << j << "*" << j << " + " << k << "*" << k << " + " << ( int ) l << "*" << ( int ) l << "\n"; } k += 1; } j += 1; } i += 1; } if ( flag == false ) { cout << "Solution doesn't exist!\n"; return; } }
int maxPrefix ( char s [ ], char t [ ] ) { int count = 0; for ( int i = 0; i < strlen ( t ); i ++ ) { if ( count == strlen ( s ) ) break; if ( t [ i ] == s [ count ] ) count ++; } return count; }
int substringConversions ( string str, int k, int b ) { int i = 0, sum = 0, counter = k - 1; for ( i; i < k; i ++ ) { sum = sum + ( ( str . at ( i ) - '0' ) * pow ( b, counter ) ); counter --; } cout << sum << " "; int prev = sum; sum = 0, counter = 0; for ( i; i < str . size ( ); i ++ ) { sum = prev - ( ( str . at ( i - k ) - '0' ) * pow ( b, k - 1 ) ); sum = sum * b; sum = sum + ( str . at ( i ) - '0' ); cout << sum << " "; prev = sum; counter ++; } }
void randomize ( int arr [ ], int n ) { srand ( time ( NULL ) ); for ( int i = n - 1; i > 0; i -- ) { int j = rand ( ) % ( i + 1 ); swap ( & arr [ i ], & arr [ j ] ); } }
int findNumberOfTriangles ( int arr [ ], int n ) { qsort ( arr, n, sizeof ( arr [ 0 ] ), comp ); int count = 0; for ( int i = 0; i < n - 2; ++ i ) { int k = i + 2; for ( int j = i + 1; j < n; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k; if ( k > j ) count += k - j - 1; } } return count; }
bool findWinner ( int x, int y, int n ) { int dp [ n + 1 ]; dp [ 0 ] = false; dp [ 1 ] = true; for ( int i = 2; i <= n; i ++ ) { if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true; else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true; else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true; else dp [ i ] = false; } return dp [ n ]; }
int zigzag ( int n, int k ) { int dp [ n + 1 ] [ k + 1 ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] [ 0 ] = 1; for ( int i = 1; i <= n; i ++ ) dp [ i ] [ 0 ] = 0; for ( int i = 1; i <= n; i ++ ) { for ( int j = 1; j <= i; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ]; return dp [ n ] [ k ]; } int main ( ) { int n = 4, k = 3; cout << zigzag ( n, k ) << endl; return 0; }
bool checkReverse ( int arr [ ], int n ) { int temp [ n ]; for ( int i = 0; i < n; i ++ ) temp [ i ] = arr [ i ]; sort ( temp, temp + n ); int front; for ( front = 0; front < n; front ++ ) if ( temp [ front ] != arr [ front ] ) break; int back; for ( back = n - 1; back >= 0; back -- ) if ( temp [ back ] != arr [ back ] ) break; if ( front >= back ) return true; do { front ++; if ( arr [ front - 1 ] < arr [ front ] ) return false; } while ( front != back ); return true; }
int totalNodes ( vector < int > adjac [ ], int n, int x, int y ) { bool visited [ n + 1 ] = { 0 }; int p [ n ]; queue < int > q; q . push ( x ); visited [ x ] = true; int m; while ( ! q . empty ( ) ) { m = q . front ( ); q . pop ( ); for ( int i = 0; i < adjac [ m ] . size ( ); ++ i ) { int h = adjac [ m ] [ i ]; if ( ! visited [ h ] ) { visited [ h ] = true; p [ h ] = m; q . push ( h ); } } } int count = 0; int i = p [ y ]; while ( i != x ) { count ++; i = p [ i ]; } return count; }
int getRemainder ( int num, int divisor ) { return ( num - divisor * ( num / divisor ) ); }
float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ); }
int lenOfLongestGP ( int set [ ], int n ) { if ( n < 2 ) return n; if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ); sort ( set, set + n ); int L [ n ] [ n ]; int llgp = 1; for ( int i = 0; i < n; ++ i ) if ( set [ n - 1 ] % set [ i ] == 0 ) L [ i ] [ n - 1 ] = 2; else L [ i ] [ n - 1 ] = 1; for ( int j = n - 2; j >= 1; -- j ) { int i = j - 1, k = j + 1; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) ++ k; else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2; else L [ i ] [ j ] = 1; -- i; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1; if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ]; -- i; ++ k; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2; else L [ i ] [ j ] = 1; -- i; } } return llgp; }
int floorSearch ( int arr [ ], int n, int x ) { if ( x >= arr [ n - 1 ] ) return n - 1; if ( x < arr [ 0 ] ) return - 1; for ( int i = 1; i < n; i ++ ) if ( arr [ i ] > x ) return ( i - 1 ); return - 1; }
unsigned getNthUglyNo ( unsigned n ) { unsigned ugly [ n ]; unsigned i2 = 0, i3 = 0, i5 = 0; unsigned next_multiple_of_2 = 2; unsigned next_multiple_of_3 = 3; unsigned next_multiple_of_5 = 5; unsigned next_ugly_no = 1; ugly [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) { next_ugly_no = min ( next_multiple_of_2, min ( next_multiple_of_3, next_multiple_of_5 ) ); ugly [ i ] = next_ugly_no; if ( next_ugly_no == next_multiple_of_2 ) { i2 = i2 + 1; next_multiple_of_2 = ugly [ i2 ] * 2; } if ( next_ugly_no == next_multiple_of_3 ) { i3 = i3 + 1; next_multiple_of_3 = ugly [ i3 ] * 3; } if ( next_ugly_no == next_multiple_of_5 ) { i5 = i5 + 1; next_multiple_of_5 = ugly [ i5 ] * 5; } } return next_ugly_no; }
unsigned int getModulo ( unsigned int n, unsigned int d ) { return ( n & ( d - 1 ) ); }
INT_MAX int shortestPath ( int graph [ ] [ V ], int u, int v, int k ) { if ( k == 0 && u == v ) return 0; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ]; if ( k <= 0 ) return INF; int res = INF; for ( int i = 0; i < V; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph, i, v, k - 1 ); if ( rec_res != INF ) res = min ( res, graph [ u ] [ i ] + rec_res ); } } return res; }
string sortString ( string str, int n ) { string new_str = ""; for ( int i = 'a'; i <= 'z'; i ++ ) for ( int j = 0; j < n; j ++ ) if ( str [ j ] == i ) new_str += str [ j ]; return new_str; }
bool arraySortedOrNot ( int arr [ ], int n ) { if ( n == 0 || n == 1 ) return true; for ( int i = 1; i < n; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false; return true; }
int countSubarrWithEqualZeroAndOne ( int arr [ ], int n ) { unordered_map < int, int > um; int curr_sum = 0; for ( int i = 0; i < n; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ]; um [ curr_sum ] ++; } int count = 0; for ( auto itr = um . begin ( ); itr != um . end ( ); itr ++ ) { if ( itr -> second > 1 ) count += ( ( itr -> second * ( itr -> second - 1 ) ) / 2 ); } if ( um . find ( 0 ) != um . end ( ) ) count += um [ 0 ]; return count; }
int minTime ( int arr [ ], int n, int m ) { int t = 0; while ( 1 ) { int items = 0; for ( int i = 0; i < n; i ++ ) items += ( t / arr [ i ] ); if ( items >= m ) return t; t ++; } }
void printDistSum ( int arr [ ], int n ) { int sum = 0; for ( int i = 0; i < n; i ++ ) sum += arr [ i ]; bool dp [ n + 1 ] [ sum + 1 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 0; i <= n; i ++ ) dp [ i ] [ 0 ] = true; for ( int i = 1; i <= n; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true; for ( int j = 1; j <= sum; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true; dp [ i ] [ j + arr [ i - 1 ] ] = true; } } } for ( int j = 0; j <= sum; j ++ ) if ( dp [ n ] [ j ] == true ) cout << j << " "; }
void oddEvenSort ( int arr [ ], int n ) { bool isSorted = false; while ( ! isSorted ) { isSorted = true; for ( int i = 1; i <= n - 2; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( arr [ i ], arr [ i + 1 ] ); isSorted = false; } } for ( int i = 0; i <= n - 2; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( arr [ i ], arr [ i + 1 ] ); isSorted = false; } } } return; }
int stringReduction ( string str ) { int n = str . length ( ); int count [ 3 ] = { 0 }; for ( int i = 0; i < n; ++ i ) count [ str [ i ] - 'a' ] ++; if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n; if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2; return 1; }
void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ); for ( int j = i; j >= 0; j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ]; while ( i >= 0 ) str [ i -- ] = ' '; }
void countFreq ( int a [ ], int n ) { unordered_map < int, int > hm; for ( int i = 0; i < n; i ++ ) hm [ a [ i ] ] ++; set < pair < int, int > > st; for ( auto x : hm ) { st . insert ( { x . first, x . second } ); } int cumul = 0; for ( auto x : st ) { cumul += x . second; cout << x . first << " " << cumul << endl; } }
int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << " "; if ( limit > 3 ) cout << 3 << " "; bool sieve [ limit ]; for ( int i = 0; i < limit; i ++ ) sieve [ i ] = false; for ( int x = 1; x * x < limit; x ++ ) { for ( int y = 1; y * y < limit; y ++ ) { int n = ( 4 * x * x ) + ( y * y ); if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true; n = ( 3 * x * x ) + ( y * y ); if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true; n = ( 3 * x * x ) - ( y * y ); if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true; } } for ( int r = 5; r * r < limit; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r; i < limit; i += r * r ) sieve [ i ] = false; } } for ( int a = 5; a < limit; a ++ ) if ( sieve [ a ] ) cout << a << " "; }
void rearrangeArray ( int arr [ ], int n ) { sort ( arr, arr + n ); int tempArr [ n ]; int ArrIndex = 0; for ( int i = 0, j = n - 1; i <= n / 2 || j > n / 2; i ++, j -- ) { tempArr [ ArrIndex ] = arr [ i ]; ArrIndex ++; tempArr [ ArrIndex ] = arr [ j ]; ArrIndex ++; } for ( int i = 0; i < n; i ++ ) arr [ i ] = tempArr [ i ]; }
void sortSquares ( int arr [ ], int n ) { int K = 0; for ( K = 0; K < n; K ++ ) if ( arr [ K ] >= 0 ) break; int i = K - 1; int j = K; int ind = 0; int temp [ n ]; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ]; i --; } else { temp [ ind ] = arr [ j ] * arr [ j ]; j ++; } ind ++; } while ( i >= 0 ) { temp [ ind ] = arr [ i ] * arr [ i ]; i --; ind ++; } while ( j < n ) { temp [ ind ] = arr [ j ] * arr [ j ]; j ++; ind ++; } for ( int i = 0; i < n; i ++ ) arr [ i ] = temp [ i ]; }
void modularInverse ( int n, int prime ) { int dp [ n + 1 ]; dp [ 0 ] = dp [ 1 ] = 1; for ( int i = 2; i <= n; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime; for ( int i = 1; i <= n; i ++ ) cout << dp [ i ] << ' '; }
void findMin ( int V ) { vector < int > ans; for ( int i = n - 1; i >= 0; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ]; ans . push_back ( deno [ i ] ); } } for ( int i = 0; i < ans . size ( ); i ++ ) cout << ans [ i ] << " "; }
int maxSumWO3Consec ( int arr [ ], int n ) { int sum [ n ]; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ]; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ]; if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ], max ( arr [ 1 ] + arr [ 2 ], arr [ 0 ] + arr [ 2 ] ) ); for ( int i = 3; i < n; i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ], sum [ i - 2 ] + arr [ i ] ), arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ); return sum [ n - 1 ]; }
string longestRepeatedSubSeq ( string str ) { int n = str . length ( ); int dp [ n + 1 ] [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) for ( int j = 0; j <= n; j ++ ) dp [ i ] [ j ] = 0; for ( int i = 1; i <= n; i ++ ) for ( int j = 1; j <= n; j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] ); string res = ""; int i = n, j = n; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str [ i - 1 ]; i --; j --; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i --; else j --; } reverse ( res . begin ( ), res . end ( ) ); return res; }
int isMultipleOf3 ( int n ) { int odd_count = 0; int even_count = 0; if ( n < 0 ) n = - n; if ( n == 0 ) return 1; if ( n == 1 ) return 0; while ( n ) { if ( n & 1 ) odd_count ++; if ( n & 2 ) even_count ++; n = n >> 2; } return isMultipleOf3 ( abs ( odd_count - even_count ) ); }
int compute_average ( int a, int b ) { return ( a + b ) / 2; }
int findpos ( string n ) { int i = 0, pos = 0; while ( n [ i ] != '\0' ) { switch ( n [ i ] ) { case '4' : pos = pos * 2 + 1; break; case '7' : pos = pos * 2 + 2; break; } i ++; } return pos; }
int getMinSteps ( int n ) { int table [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) table [ i ] = n - i; for ( int i = n; i >= 1; i -- ) { if ( ! ( i % 2 ) ) table [ i / 2 ] = min ( table [ i ] + 1, table [ i / 2 ] ); if ( ! ( i % 3 ) ) table [ i / 3 ] = min ( table [ i ] + 1, table [ i / 3 ] ); } return table [ 1 ];
int maxCost ( int mat [ ] [ MAX ], int N ) { int dp [ N ] [ N ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]; for ( int i = 1; i < N; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ]; for ( int i = 1; i < N; i ++ ) for ( int j = 1; j < i + 1 && j < N; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ], dp [ i - 1 ] [ j ] ); int result = 0; for ( int i = 0; i < N; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ]; return result; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ); }
void makePermutation ( int a [ ], int n ) { unordered_map < int, int > count; for ( int i = 0; i < n; i ++ ) count [ a [ i ] ] ++; int next_missing = 1; for ( int i = 0; i < n; i ++ ) { if ( count [ a [ i ] ] != 1 || a [ i ] > n || a [ i ] < 1 ) { count [ a [ i ] ] --; while ( count . find ( next_missing ) != count . end ( ) ) next_missing ++; a [ i ] = next_missing; count [ next_missing ] = 1; } } }
bool isPrime ( int p ) { long long checkNumber = pow ( 2, p ) - 1; long long nextval = 4 % checkNumber; for ( int i = 1; i < p - 1; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber; return ( nextval == 0 ); }
void NextFit ( int blockSize [ ], int m, int processSize [ ], int n ) { int allocation [ n ], j = 0; memset ( allocation, - 1, sizeof ( allocation ) ); for ( int i = 0; i < n; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j; blockSize [ j ] -= processSize [ i ]; break; } j = ( j + 1 ) % m; } } cout << "\nProcess No.\tProcess Size\tBlock no.\n"; for ( int i = 0; i < n; i ++ ) { cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\t\t"; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1; else cout << "Not Allocated"; cout << endl; } }
int minCost ( int cost [ R ] [ C ], int m, int n ) { int i, j; int tc [ R ] [ C ]; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]; for ( i = 1; i <= m; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ]; for ( j = 1; j <= n; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ]; for ( i = 1; i <= m; i ++ ) for ( j = 1; j <= n; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ], tc [ i - 1 ] [ j ], tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ]; return tc [ m ] [ n ]; }
int lis ( int arr [ ], int n ) { int max = 1; _lis ( arr, n, & max ); return max; }
void findMajority ( int arr [ ], int n ) { int maxCount = 0; int index = - 1; for ( int i = 0; i < n; i ++ ) { int count = 0; for ( int j = 0; j < n; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++; } if ( count > maxCount ) { maxCount = count; index = i; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl; else cout << "No Majority Element" << endl; }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0; long long int ef1 = 0, ef2 = 2; long long int sum = ef1 + ef2; while ( ef2 <= limit ) { long long int ef3 = 4 * ef2 + ef1; if ( ef3 > limit ) break; ef1 = ef2; ef2 = ef3; sum += ef2; } return sum; }
int selectRandom ( int x ) { static int res; static int count = 0; count ++; if ( count == 1 ) res = x; else { int i = rand ( ) % count; if ( i == count - 1 ) res = x; } return res; }
int getOddOccurrence ( int arr [ ], int arr_size ) { for ( int i = 0; i < arr_size; i ++ ) { int count = 0; for ( int j = 0; j < arr_size; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++; } if ( count % 2 != 0 ) return arr [ i ]; } return - 1; }
void sortit ( int arr [ ], int n ) { for ( int i = 0; i < n; i ++ ) { arr [ i ] = i + 1; } }
void printMinIndexChar ( string str, string patt ) { int minIndex = INT_MAX; int m = str . size ( ); int n = patt . size ( ); for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < m; j ++ ) { if ( patt [ i ] == str [ j ] && j < minIndex ) { minIndex = j; break; } } } if ( minIndex != INT_MAX ) cout << "Minimum Index Character = " << str [ minIndex ]; else cout << "No character present"; }
bool ifPossible ( int arr [ ], int n ) { int cp [ n ]; copy ( arr, arr + n, cp ); sort ( cp, cp + n ); for ( int i = 0; i < n; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false; } return true; }
int minElements ( int arr [ ], int n ) { int halfSum = 0; for ( int i = 0; i < n; i ++ ) halfSum = halfSum + arr [ i ]; halfSum = halfSum / 2; sort ( arr, arr + n, greater < int > ( ) ); int res = 0, curr_sum = 0; for ( int i = 0; i < n; i ++ ) { curr_sum += arr [ i ]; res ++; if ( curr_sum > halfSum ) return res; } return res; }
public : int getSum ( int n ) { int sum = 0; while ( n != 0 ) { sum = sum + n % 10; n = n / 10; } return sum; }
void print ( int n, int k ) { int rem = 1; for ( int i = 0; i < k; i ++ ) { cout << ( 10 * rem ) / n; rem = ( 10 * rem ) % n; } }
int nCrModp ( int n, int r, int p ) { int C [ r + 1 ]; memset ( C, 0, sizeof ( C ) ); C [ 0 ] = 1; for ( int i = 1; i <= n; i ++ ) { for ( int j = min ( i, r ); j > 0; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p; } return C [ r ]; }
long long answer ( int n ) { int dp [ n + 1 ] [ 10 ]; if ( n == 1 ) return 10; for ( int j = 0; j <= 9; j ++ ) dp [ 1 ] [ j ] = 1; for ( int i = 2; i <= n; i ++ ) { for ( int j = 0; j <= 9; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ]; } } long long sum = 0; for ( int j = 1; j <= 9; j ++ ) sum += dp [ n ] [ j ]; return sum; }
int solve ( int dp [ ] [ MAX ], int a [ ], int low, int high, int turn ) { if ( low == high ) return a [ low ] * turn; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ]; dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp, a, low + 1, high, turn + 1 ), a [ high ] * turn + solve ( dp, a, low, high - 1, turn + 1 ) ); return dp [ low ] [ high ]; }
int productAtKthLevel ( string tree, int k ) { int level = - 1; int product = 1; int n = tree . length ( ); for ( int i = 0; i < n; i ++ ) { if ( tree [ i ] == '(' ) level ++; else if ( tree [ i ] == ')' ) level --; else { if ( level == k ) product *= ( tree [ i ] - '0' ); } } return product; }
void drawPattern ( int N ) { int n = N; int row = 1; int nst = 1; int nsp1 = n - 1; int nsp2 = - 1; int val1 = row; int val2 = 1; while ( row <= n ) { int csp1 = 1; while ( csp1 <= nsp1 ) { cout << " " << " "; csp1 = csp1 + 1; } int cst1 = 1; while ( cst1 <= nst ) { cout << val1 << " "; val1 = val1 - 1; cst1 = cst1 + 1; } int csp2 = 1; while ( csp2 <= nsp2 ) { cout << " " << " "; csp2 = csp2 + 1; } if ( row != 1 && row != n ) { int cst2 = 1; while ( cst2 <= nst ) { cout << val2 << " "; val2 = val2 + 1; cst2 = cst2 + 1; } } cout << endl; if ( row <= n / 2 ) { nst = nst + 1; nsp1 = nsp1 - 2; nsp2 = nsp2 + 2; val1 = row + 1; val2 = 1; } else { nst = nst - 1; nsp1 = nsp1 + 2; nsp2 = nsp2 - 2; val1 = n - row; val2 = 1; } row = row + 1; } }
bool HalfDiagonalSums ( int mat [ ] [ MAX ], int n ) { int diag1_left = 0, diag1_right = 0; int diag2_left = 0, diag2_right = 0; for ( int i = 0, j = n - 1; i < n; i ++, j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ]; diag2_left += mat [ j ] [ i ]; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ]; diag2_right += mat [ j ] [ i ]; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ); }
float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10, n ) - 1 - ( 9 * n ) ); }
int smallestSumSubarr ( int arr [ ], int n ) { int min_ending_here = INT_MAX; int min_so_far = INT_MAX; for ( int i = 0; i < n; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ]; else min_ending_here += arr [ i ]; min_so_far = min ( min_so_far, min_ending_here ); } return min_so_far; }
void countCurrency ( int amount ) { int notes [ 9 ] = { 2000, 500, 200, 100, 50, 20, 10, 5, 1 }; int noteCounter [ 9 ] = { 0 }; for ( int i = 0; i < 9; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ]; amount = amount - noteCounter [ i ] * notes [ i ]; } } cout << "Currency Count ->" << endl; for ( int i = 0; i < 9; i ++ ) { if ( noteCounter [ i ] != 0 ) { cout << notes [ i ] << " : " << noteCounter [ i ] << endl; } } }
int minJumps ( int arr [ ], int n ) { int * jumps = new int [ n ]; int min; jumps [ n - 1 ] = 0; for ( int i = n - 2; i >= 0; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1; else { min = INT_MAX; for ( int j = i + 1; j < n && j <= arr [ i ] + i; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ]; } if ( min != INT_MAX ) jumps [ i ] = min + 1; else jumps [ i ] = min; } } return jumps [ 0 ]; }
int count ( string a, string b ) { int m = a . length ( ); int n = b . length ( ); int lookup [ m + 1 ] [ n + 1 ] = { { 0 } }; for ( int i = 0; i <= n; ++ i ) lookup [ 0 ] [ i ] = 0; for ( int i = 0; i <= m; ++ i ) lookup [ i ] [ 0 ] = 1; for ( int i = 1; i <= m; i ++ ) { for ( int j = 1; j <= n; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ]; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]; } } return lookup [ m ] [ n ]; }
int insertSorted ( int arr [ ], int n, int key, int capacity ) { if ( n >= capacity ) return n; int i; for ( i = n - 1; ( i >= 0 && arr [ i ] > key ); i -- ) arr [ i + 1 ] = arr [ i ]; arr [ i + 1 ] = key; return ( n + 1 ); }
void bitonicGenerator ( int arr [ ], int n ) { vector < int > evenArr; vector < int > oddArr; for ( int i = 0; i < n; i ++ ) { if ( ! ( i % 2 ) ) evenArr . push_back ( arr [ i ] ); else oddArr . push_back ( arr [ i ] ); } sort ( evenArr . begin ( ), evenArr . end ( ) ); sort ( oddArr . begin ( ), oddArr . end ( ), greater < int > ( ) ); int i = 0; for ( int j = 0; j < evenArr . size ( ); j ++ ) arr [ i ++ ] = evenArr [ j ]; for ( int j = 0; j < oddArr . size ( ); j ++ ) arr [ i ++ ] = oddArr [ j ]; }
int PowerOFPINnfactorial ( int n, int p ) { int ans = 0; int temp = p; while ( temp <= n ) { ans += n / temp; temp = temp * p; } return ans; }
int height ( int N ) { return ceil ( log2 ( N + 1 ) ) - 1; }
int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9; int outliersCount = ( int ) log10 ( nthElement ) - 1; nthElement += 9 * outliersCount; return nthElement; }
bool isSubsetSum ( int set [ ], int n, int sum ) { if ( sum == 0 ) return true; if ( n == 0 && sum != 0 ) return false; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set, n - 1, sum ); return isSubsetSum ( set, n - 1, sum ) || isSubsetSum ( set, n - 1, sum - set [ n - 1 ] ); }
int dayofweek ( int d, int m, int y ) { static int t [ ] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 }; y -= m < 3; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7; }
int minStepToDeleteString ( string str ) { int N = str . length ( ); int dp [ N + 1 ] [ N + 1 ]; for ( int i = 0; i <= N; i ++ ) for ( int j = 0; j <= N; j ++ ) dp [ i ] [ j ] = 0; for ( int len = 1; len <= N; len ++ ) { for ( int i = 0, j = len - 1; j < N; i ++, j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ]; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ], dp [ i ] [ j ] ); for ( int K = i + 2; K <= j; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ], dp [ i ] [ j ] ); } } } return dp [ 0 ] [ N - 1 ]; }
string nextWord ( string s ) { if ( s == "" ) return "a"; int i = s . length ( ) - 1; while ( s [ i ] == 'z' && i >= 0 ) i --; if ( i == - 1 ) s = s + 'a'; else s [ i ] ++; return s; }
bool isAnBn ( string str ) { int n = str . length ( ); int i; for ( i = 0; i < n; i ++ ) if ( str [ i ] != 'a' ) break; if ( i * 2 != n ) return false; int j; for ( j = i; j < n; j ++ ) if ( str [ j ] != 'b' ) return false; return true; }
int calculate ( string s ) { int ans = 6; for ( int i = 0; i < 10; ++ i ) { for ( int j = 0; j < 10; ++ j ) { for ( int k = 0; k < 10; ++ k ) { for ( int l = 0; l < 10; ++ l ) { for ( int m = 0; m < 10; ++ m ) { for ( int n = 0; n < 10; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0; if ( i != s [ 0 ] - '0' ) c ++; if ( j != s [ 1 ] - '0' ) c ++; if ( k != s [ 2 ] - '0' ) c ++; if ( l != s [ 3 ] - '0' ) c ++; if ( m != s [ 4 ] - '0' ) c ++; if ( n != s [ 5 ] - '0' ) c ++; if ( c < ans ) ans = c; } } } } } } } return ans; }
int countWays ( int arr [ ], int m, int N ) { int count [ N + 1 ]; memset ( count, 0, sizeof ( count ) ); count [ 0 ] = 1; for ( int i = 1; i <= N; i ++ ) for ( int j = 0; j < m; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ]; return count [ N ]; }
int countSubStr ( char str [ ] ) { int res = 0; for ( int i = 0; str [ i ] != '\0'; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1; str [ j ] != '\0'; j ++ ) if ( str [ j ] == '1' ) res ++; } } return res; }
int lis ( int arr [ ], int n ) { int lis [ n ]; lis [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) { lis [ i ] = 1; for ( int j = 0; j < i; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1; } return * max_element ( lis, lis + n ); }
void printArray ( int * a, int n ) { for ( int i = 0; i < n; i ++ ) cout << a [ i ] << " "; cout << endl; return; }
void replaceOriginal ( string s, int n ) { string r ( n, ' ' ); for ( int i = 0; i < n; i ++ ) { r [ i ] = s [ n - 1 - i ]; if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' && s [ i ] != 'o' && s [ i ] != 'u' ) { cout << r [ i ]; } } cout << endl; }
void findMajority ( int arr [ ], int size ) { unordered_map < int, int > m; for ( int i = 0; i < size; i ++ ) m [ arr [ i ] ] ++; int count = 0; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1; cout << "Majority found :- " << i . first << endl; break; } } if ( count == 0 ) cout << "No Majority element" << endl; }
int findS ( int s ) { int sum = 0; for ( int n = 1; sum < s; n ++ ) { sum += n * n; if ( sum == s ) return n; } return - 1; }
void findPair ( int arr [ ], int n ) { bool found = false; for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { for ( int k = 0; k < n; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " " << arr [ j ] << endl; found = true; } } } } if ( found == false ) cout << "Not exist" << endl; }
int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3, n ) ) - 1; return ans; }
int countPS ( int i, int j ) { if ( i >= n || j < 0 ) return 0; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ]; if ( abs ( i - j ) == 1 ) { if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = 3; else return dp [ i ] [ j ] = 2; } if ( i == j ) return dp [ 1 ] [ j ] = 1; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1, j ) + countPS ( i, j - 1 ) + 1; else return dp [ i ] [ j ] = countPS ( i + 1, j ) + countPS ( i, j - 1 ) - countPS ( i + 1, j - 1 ); }
int findRepeatingNumber ( const int arr [ ], int n ) { int sq = sqrt ( n ); int range = ( n / sq ) + 1; int count [ range ] = { 0 }; for ( int i = 0; i <= n; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++; } int selected_block = range - 1; for ( int i = 0; i < range - 1; i ++ ) { if ( count [ i ] > sq ) { selected_block = i; break; } } unordered_map < int, int > m; for ( int i = 0; i <= n; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m [ arr [ i ] ] ++; if ( m [ arr [ i ] ] > 1 ) return arr [ i ]; } } return - 1; }
int findSum ( int A [ ], int B [ ], int n ) { unordered_map < int, int > hash; for ( int i = 0; i < n; i ++ ) { hash [ A [ i ] ] ++; hash [ B [ i ] ] ++; } int sum = 0; for ( auto x : hash ) if ( x . second == 1 ) sum += x . first; return sum; }
int removeConsecutiveSame ( vector < string > v ) { int n = v . size ( ); for ( int i = 0; i < n - 1; ) { if ( v [ i ] . compare ( v [ i + 1 ] ) == 0 ) { v . erase ( v . begin ( ) + i ); v . erase ( v . begin ( ) + i ); if ( i > 0 ) i --; n = n - 2; } else i ++; } return v . size ( ); }
string encrypt ( string text, int s ) { string result = ""; for ( int i = 0; i < text . length ( ); i ++ ) { if ( isupper ( text [ i ] ) ) result += char ( int ( text [ i ] + s - 65 ) % 26 + 65 ); else result += char ( int ( text [ i ] + s - 97 ) % 26 + 97 ); } return result; }
bool isPermutedMatrix ( int mat [ MAX ] [ MAX ], int n ) { string str_cat = ""; for ( int i = 0; i < n; i ++ ) str_cat = str_cat + "-" + to_string ( mat [ 0 ] [ i ] ); str_cat = str_cat + str_cat; for ( int i = 1; i < n; i ++ ) { string curr_str = ""; for ( int j = 0; j < n; j ++ ) curr_str = curr_str + "-" + to_string ( mat [ i ] [ j ] ); if ( str_cat . find ( curr_str ) == string :: npos ) return false; } return true; }
bool isTriangular ( int num ) { if ( num < 0 ) return false; int sum = 0; for ( int n = 1; sum <= num; n ++ ) { sum = sum + n; if ( sum == num ) return true; } return false; }
void printEqualSumSets ( int arr [ ], int n ) { int i, currSum; int sum = accumulate ( arr, arr + n, 0 ); if ( sum & 1 ) { cout << "-1"; return; } int k = sum >> 1; bool dp [ n + 1 ] [ k + 1 ]; for ( i = 1; i <= k; i ++ ) dp [ 0 ] [ i ] = false; for ( i = 0; i <= n; i ++ ) dp [ i ] [ 0 ] = true; for ( i = 1; i <= n; i ++ ) { for ( currSum = 1; currSum <= k; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ]; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ]; } } vector < int > set1, set2; if ( ! dp [ n ] [ k ] ) { cout << "-1\n"; return; } i = n; currSum = k; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i --; set2 . push_back ( arr [ i ] ); } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) { i --; currSum -= arr [ i ]; set1 . push_back ( arr [ i ] ); } } cout << "Set 1 elements: "; for ( i = 0; i < set1 . size ( ); i ++ ) cout << set1 [ i ] << " "; cout << "\nSet 2 elements: "; for ( i = 0; i < set2 . size ( ); i ++ ) cout << set2 [ i ] << " "; }
void printDiagonalSums ( int mat [ ] [ MAX ], int n ) { int principal = 0, secondary = 0; for ( int i = 0; i < n; i ++ ) { principal += mat [ i ] [ i ]; secondary += mat [ i ] [ n - i - 1 ]; } cout << "Principal Diagonal:" << principal << endl; cout << "Secondary Diagonal:" << secondary << endl; }
int countStrings ( int n ) { int a [ n ], b [ n ]; a [ 0 ] = b [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ]; b [ i ] = a [ i - 1 ]; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]; }
int maxXOR ( int mat [ ] [ MAX ], int N ) { int r_xor, c_xor; int max_xor = 0; for ( int i = 0; i < N; i ++ ) { r_xor = 0, c_xor = 0; for ( int j = 0; j < N; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ]; c_xor = c_xor ^ mat [ j ] [ i ]; } if ( max_xor < max ( r_xor, c_xor ) ) max_xor = max ( r_xor, c_xor ); } return max_xor; }
void printMat ( int degseq [ ], int n ) { int mat [ n ] [ n ]; memset ( mat, 0, sizeof ( mat ) ); for ( int i = 0; i < n; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] --; degseq [ j ] --; mat [ i ] [ j ] = 1; mat [ j ] [ i ] = 1; } } } cout << "\n" << setw ( 3 ) << " "; for ( int i = 0; i < n; i ++ ) cout << setw ( 3 ) << "(" << i << ")"; cout << "\n\n"; for ( int i = 0; i < n; i ++ ) { cout << setw ( 4 ) << "(" << i << ")"; for ( int j = 0; j < n; j ++ ) cout << setw ( 5 ) << mat [ i ] [ j ]; cout << "\n"; } }
int findFourElements ( int arr [ ], int n ) { unordered_map < int, pair < int, int > > mp; for ( int i = 0; i < n - 1; i ++ ) for ( int j = i + 1; j < n; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i, j }; int d = INT_MIN; for ( int i = 0; i < n - 1; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ); if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int, int > p = mp [ abs_diff ]; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d, max ( arr [ i ], arr [ j ] ) ); } } } return d; }
void factorize ( long long n ) { int count = 0; while ( ! ( n % 2 ) ) { n >>= 1; count ++; } if ( count ) cout << 2 << " " << count << endl; for ( long long i = 3; i <= sqrt ( n ); i += 2 ) { count = 0; while ( n % i == 0 ) { count ++; n = n / i; } if ( count ) cout << i << " " << count << endl; } if ( n > 2 ) cout << n << " " << 1 << endl; }
void sortString ( string & str ) { int charCount [ MAX_CHAR ] = { 0 }; for ( int i = 0; i < str . length ( ); i ++ ) charCount [ str [ i ] - 'a' ] ++; for ( int i = MAX_CHAR - 1; i >= 0; i -- ) for ( int j = 0; j < charCount [ i ]; j ++ ) cout << ( char ) ( 'a' + i ); }
int countNegative ( int M [ ] [ 4 ], int n, int m ) { int count = 0; int i = 0; int j = m - 1; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1; i += 1; } else j -= 1; } return count; }
void findTriplets ( int arr [ ], int n ) { bool found = true; for ( int i = 0; i < n - 2; i ++ ) { for ( int j = i + 1; j < n - 1; j ++ ) { for ( int k = j + 1; k < n; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { cout << arr [ i ] << " " << arr [ j ] << " " << arr [ k ] << endl; found = true; } } } } if ( found == false ) cout << " not exist " << endl; }
bool isPrime ( int n, int i = 2 ) { if ( n <= 2 ) return ( n == 2 ) ? true : false; if ( n % i == 0 ) return false; if ( i * i > n ) return true; return isPrime ( n, i + 1 ); }
int minHeight ( int base, int area ) { return ceil ( ( float ) ( 2 * area ) / base ); }
int countStrings ( int n, int k ) { int dp [ n + 1 ] [ k + 1 ] [ 2 ]; memset ( dp, 0, sizeof ( dp ) ); dp [ 1 ] [ 0 ] [ 0 ] = 1; dp [ 1 ] [ 0 ] [ 1 ] = 1; for ( int i = 2; i <= n; i ++ ) { for ( int j = 0; j < i; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ]; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]; if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]; }
void printRotatedString ( char str [ ] ) { int len = strlen ( str ); char temp [ len ]; for ( int i = 0; i < len; i ++ ) { int j = i; int k = 0; while ( str [ j ] != '\0' ) { temp [ k ] = str [ j ]; k ++; j ++; } j = 0; while ( j < i ) { temp [ k ] = str [ j ]; j ++; k ++; } printf ( "%s\n", temp ); } }
int countPairsWithDiffK ( int arr [ ], int n, int k ) { int count = 0; sort ( arr, arr + n ); int l = 0; int r = 0; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++; l ++; r ++; } else if ( arr [ r ] - arr [ l ] > k ) l ++; else r ++; } return count; }
bool pythagorean_quadruple ( int a, int b, int c, int d ) { int sum = a * a + b * b + c * c; if ( d * d == sum ) return true; else return false; }
int addOne ( int x ) { int m = 1; while ( x & m ) { x = x ^ m; m <<= 1; } x = x ^ m; return x; }
void transpose ( int A [ ] [ N ], int B [ ] [ N ] ) { int i, j; for ( i = 0; i < N; i ++ ) for ( j = 0; j < N; j ++ ) B [ i ] [ j ] = A [ j ] [ i ]; }
int findSum ( int n ) { int ans = 0, temp = 0, num; for ( int i = 1; i <= n && temp < n; i ++ ) { temp = i - 1; num = 1; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ); else ans += ( ( n - temp ) * num ); temp += i; num ++; } } return ans; }
int countWays ( int n ) { int DP [ n + 1 ]; DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1; DP [ 3 ] = 2; for ( int i = 4; i <= n; i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ]; return DP [ n ]; }
int binomialCoeffSum ( int n ) { int C [ n + 1 ] [ n + 1 ]; for ( int i = 0; i <= n; i ++ ) { for ( int j = 0; j <= min ( i, n ); j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]; } } int sum = 0; for ( int i = 0; i <= n; i ++ ) sum += C [ n ] [ i ]; return sum; }
void dfs ( vector < int > list [ ], int node, int arrival ) { cout << node << '\n'; for ( int i = 0; i < list [ node ] . size ( ); i ++ ) { if ( list [ node ] [ i ] != arrival ) dfs ( list, list [ node ] [ i ], node ); } }
int minimum_cost ( int a [ ], int n ) { int mn = INT_MAX; int sum = 0; for ( int i = 0; i < n; i ++ ) { mn = min ( a [ i ], mn ); sum += a [ i ]; } return mn * ( sum - mn ); }
void computeTotient ( int n ) { long long phi [ n + 1 ]; for ( int i = 1; i <= n; i ++ ) phi [ i ] = i; for ( int p = 2; p <= n; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1; for ( int i = 2 * p; i <= n; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ); } } } for ( int i = 1; i <= n; i ++ ) cout << "Totient of " << i << " is " << phi [ i ] << endl; }
int KnapSack ( int val [ ], int wt [ ], int n, int W ) { int dp [ W + 1 ]; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 0; i < n; i ++ ) for ( int j = W; j >= wt [ i ]; j -- ) dp [ j ] = max ( dp [ j ], val [ i ] + dp [ j - wt [ i ] ] ); return dp [ W ]; }
void findConsecutive ( int N ) { int start = 1, end = ( N + 1 ) / 2; while ( start < end ) { int sum = 0; for ( int i = start; i <= end; i ++ ) { sum = sum + i; if ( sum == N ) { for ( int j = start; j <= i; j ++ ) printf ( "%d ", j ); printf ( "\n" ); break; } if ( sum > N ) break; } sum = 0; start ++; } }
bool check ( string s1, string s2 ) { int n = s1 . length ( ); int m = s2 . length ( ); bool dp [ n + 1 ] [ m + 1 ]; for ( int i = 0; i <= n; i ++ ) { for ( int j = 0; j <= m; j ++ ) { dp [ i ] [ j ] = false; } } dp [ 0 ] [ 0 ] = true; for ( int i = 0; i < s1 . length ( ); i ++ ) { for ( int j = 0; j <= s2 . length ( ); j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true; if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true; } } } return ( dp [ n ] [ m ] ); }
int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ); }
int maxdiff ( int arr [ ], int n ) { unordered_map < int, int > freq; for ( int i = 0; i < n; i ++ ) freq [ arr [ i ] ] ++; int ans = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = max ( ans, freq [ arr [ i ] ] - freq [ arr [ j ] ] ); else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = max ( ans, freq [ arr [ j ] ] - freq [ arr [ i ] ] ); } } return ans; }
bool areAnagram ( string str1, string str2 ) { int n1 = str1 . length ( ); int n2 = str2 . length ( ); if ( n1 != n2 ) return false; sort ( str1 . begin ( ), str1 . end ( ) ); sort ( str2 . begin ( ), str2 . end ( ) ); for ( int i = 0; i < n1; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false; return true; }
int countSubsets ( int arr [ ], int n ) { unordered_set < int > us; int even_count = 0; for ( int i = 0; i < n; i ++ ) if ( arr [ i ] % 2 == 0 ) us . insert ( arr [ i ] ); unordered_set < int > :: iterator itr; for ( itr = us . begin ( ); itr != us . end ( ); itr ++ ) even_count ++; return ( pow ( 2, even_count ) - 1 ); }
double circumference ( double r ) { double cir = 2 * PI * r; return cir; }
void reverseFibonacci ( int n ) { int a [ n ]; a [ 0 ] = 0; a [ 1 ] = 1; for ( int i = 2; i < n; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ]; } for ( int i = n - 1; i >= 0; i -- ) { cout << a [ i ] << " "; } }
int countSink ( int n, int m, int edgeFrom [ ], int edgeTo [ ] ) { int mark [ n ]; memset ( mark, 0, sizeof mark ); for ( int i = 0; i < m; i ++ ) mark [ edgeFrom [ i ] ] = 1; int count = 0; for ( int i = 1; i <= n; i ++ ) if ( ! mark [ i ] ) count ++; return count; }
int minValue ( int A [ ], int B [ ], int n ) { sort ( A, A + n ); sort ( B, B + n ); int result = 0; for ( int i = 0; i < n; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ); return result; }
bool check ( string str ) { int n = str . length ( ); if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false; int digitSum = 0; for ( int i = 0; i < n; i ++ ) digitSum += ( str [ i ] - '0' ); return ( digitSum % 3 == 0 ); }
bool isPalindrome ( string str ) { int l = 0; int h = str . length ( ) - 1; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false; return true; }
int findMinSum ( int num ) { int sum = 0; for ( int i = 2; i * i <= num; i ++ ) { while ( num % i == 0 ) { sum += i; num /= i; } } sum += num; return sum; }
void maxelement ( int no_of_rows, int arr [ ] [ N ] ) { int i = 0; int max = 0; int result [ no_of_rows ]; while ( i < no_of_rows ) { for ( int j = 0; j < N; j ++ ) { if ( arr [ i ] [ j ] > max ) { max = arr [ i ] [ j ]; } } result [ i ] = max; max = 0; i ++; } printArray ( result, no_of_rows ); }
bool allCharactersSame ( string s ) { int n = s . length ( ); for ( int i = 1; i < n; i ++ ) if ( s [ i ] != s [ 0 ] ) return false; return true; }
string evenlength ( string n ) { string res = n; for ( int j = n . length ( ) - 1; j >= 0; -- j ) res += n [ j ]; return res; }
int numOfIncSubseqOfSizeK ( int arr [ ], int n, int k ) { int dp [ k ] [ n ], sum = 0; memset ( dp, 0, sizeof ( dp ) ); for ( int i = 0; i < n; i ++ ) dp [ 0 ] [ i ] = 1; for ( int l = 1; l < k; l ++ ) { for ( int i = l; i < n; i ++ ) { dp [ l ] [ i ] = 0; for ( int j = l - 1; j < i; j ++ ) { if ( arr [ j ] < arr [ i ] ) dp [ l ] [ i ] += dp [ l - 1 ] [ j ]; } } } for ( int i = k - 1; i < n; i ++ ) sum += dp [ k - 1 ] [ i ]; return sum; }
int countSubstr ( string s ) { int n = s . length ( ); int auxArr [ n ] = { 0 }; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1; for ( int i = 1; i < n; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1; else auxArr [ i ] = auxArr [ i - 1 ]; } int count = 0; for ( int i = n - 1; i >= 0; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ]; return count; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ); }
int findRepeating ( int arr [ ], int n ) { return accumulate ( arr, arr + n, 0 ) - ( ( n - 1 ) * n / 2 ); }
void shufleArray ( int a [ ], int f, int l ) { if ( l > f ) { return; } if ( l - f == 1 ) return; int mid = ( f + l ) / 2; int temp = mid + 1; int mmid = ( f + mid ) / 2; for ( int i = mmid + 1; i <= mid; i ++ ) swap ( a [ i ], a [ temp ++ ] ); shufleArray ( a, f, mid ); shufleArray ( a, mid + 1, l ); }
float area_of_segment ( float radius, float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ); float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ); return area_of_sector - area_of_triangle; }
void printSubsequences ( string str ) { int n = str . length ( ); unsigned int opsize = pow ( 2, n - 1 ); for ( int counter = 0; counter < opsize; counter ++ ) { for ( int j = 0; j < n; j ++ ) { cout << str [ j ]; if ( counter & ( 1 << j ) ) cout << " "; } cout << endl; } }
int maxLen ( int arr [ ], int n ) { unordered_map < int, int > presum; int sum = 0; int max_len = 0; for ( int i = 0; i < n; i ++ ) { sum += arr [ i ]; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1; if ( sum == 0 ) max_len = i + 1; if ( presum . find ( sum ) != presum . end ( ) ) { max_len = max ( max_len, i - presum [ sum ] ); } else { presum [ sum ] = i; } } return max_len; }
void kLargest ( int arr [ ], int n, int k ) { sort ( arr, arr + n, greater < int > ( ) ); for ( int i = 0; i < k; i ++ ) cout << arr [ i ] << " "; }
int minCost ( int a [ ], int n, int k ) { int dp [ n + 1 ] [ k + 1 ]; for ( int i = 0; i <= n; i ++ ) for ( int j = 0; j <= k; j ++ ) dp [ i ] [ j ] = inf; dp [ 0 ] [ 0 ] = 0; for ( int i = 1; i <= n; i ++ ) for ( int j = 1; j <= k; j ++ ) for ( int m = i - 1; m >= 0; m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ], dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ); return dp [ n ] [ k ]; }
int findGreatest ( int arr [ ], int n ) { int result = - 1; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < n - 1; j ++ ) for ( int k = j + 1; k < n; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result, arr [ i ] ); return result; }
int editDistDP ( string str1, string str2, int m, int n ) { int dp [ m + 1 ] [ n + 1 ]; for ( int i = 0; i <= m; i ++ ) { for ( int j = 0; j <= n; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j; else if ( j == 0 ) dp [ i ] [ j ] = i; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]; else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ], dp [ i - 1 ] [ j - 1 ] ); } } return dp [ m ] [ n ]; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1; if ( n && ! ( n & ( n - 1 ) ) ) return n; while ( p < n ) p <<= 1; return p; }
int exactPrimeFactorCount ( int n ) { int count = 0; if ( n % 2 == 0 ) { count ++; while ( n % 2 == 0 ) n = n / 2; } for ( int i = 3; i <= sqrt ( n ); i = i + 2 ) { if ( n % i == 0 ) { count ++; while ( n % i == 0 ) n = n / i; } } if ( n > 2 ) count ++; return count; }
int pow ( int a, int b ) { if ( b == 0 ) return 1; int answer = a; int increment = a; int i, j; for ( i = 1; i < b; i ++ ) { for ( j = 1; j < a; j ++ ) { answer += increment; } increment = answer; } return answer; }
int bool isLucky ( int n ) { static int counter = 2; int next_position = n; if ( counter > n ) return 1; if ( n % counter == 0 ) return 0; next_position -= next_position / counter; counter ++; return isLucky ( next_position ); }
void center ( int x1, int x2, int y1, int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << ", " << ( float ) ( y1 + y2 ) / 2; }
int countWays ( int n ) { int A [ n + 1 ], B [ n + 1 ]; A [ 0 ] = 1, A [ 1 ] = 0, B [ 0 ] = 0, B [ 1 ] = 1; for ( int i = 2; i <= n; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]; B [ i ] = A [ i - 1 ] + B [ i - 2 ]; } return A [ n ]; }
bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ); }
void printFun ( int test ) { if ( test < 1 ) return; else { cout << test << " "; printFun ( test - 1 ); cout << test << " "; return; } }
int minproduct ( int a [ ], int b [ ], int n, int k ) { int diff = 0, res = 0; int temp; for ( int i = 0; i < n; i ++ ) { int pro = a [ i ] * b [ i ]; res = res + pro; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ]; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ]; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ]; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ]; int d = abs ( pro - temp ); if ( d > diff ) diff = d; } return res - diff; }
int unique ( int mat [ R ] [ C ], int n, int m ) { int maximum = 0, flag = 0; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ]; int b [ maximum + 1 ] = { 0 }; for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) b [ mat [ i ] [ j ] ] ++; for ( int i = 1; i <= maximum; i ++ ) if ( b [ i ] == 1 ) cout << i << " "; flag = 1; if ( ! flag ) { cout << "No unique element in the matrix"; } }
int Circumference ( int l, int w ) { return ( 2 * ( l + w ) ); }
bool isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true; if ( n < 9 ) return false; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ); }
int findCountOfSolutions ( int n, int p ) { ll ans = 0; for ( ll x = 1; x < p; x ++ ) { if ( ( x * x ) % p == 1 ) { ll last = x + p * ( n / p ); if ( last > n ) last -= p; ans += ( ( last - x ) / p + 1 ); } } return ans; }
int numoffbt ( int arr [ ], int n ) { int maxvalue = INT_MIN, minvalue = INT_MAX; for ( int i = 0; i < n; i ++ ) { maxvalue = max ( maxvalue, arr [ i ] ); minvalue = min ( minvalue, arr [ i ] ); } int mark [ maxvalue + 2 ]; int value [ maxvalue + 2 ]; memset ( mark, 0, sizeof ( mark ) ); memset ( value, 0, sizeof ( value ) ); for ( int i = 0; i < n; i ++ ) { mark [ arr [ i ] ] = 1; value [ arr [ i ] ] = 1; } int ans = 0; for ( int i = minvalue; i <= maxvalue; i ++ ) { if ( mark [ i ] ) { for ( int j = i + i; j <= maxvalue && j / i <= i; j += i ) { if ( ! mark [ j ] ) continue; value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ); if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ); } } ans += value [ i ]; } return ans; }
char getSecondMostFreq ( string str ) { int count [ NO_OF_CHARS ] = { 0 }, i; for ( i = 0; str [ i ]; i ++ ) ( count [ str [ i ] ] ) ++; int first = 0, second = 0; for ( i = 0; i < NO_OF_CHARS; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first; first = i; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i; } return second; }
void spiralPrint ( int m, int n, int a [ R ] [ C ] ) { int i, k = 0, l = 0; while ( k < m && l < n ) { for ( i = l; i < n; ++ i ) { cout << a [ k ] [ i ] << " "; } k ++; for ( i = k; i < m; ++ i ) { cout << a [ i ] [ n - 1 ] << " "; } n --; if ( k < m ) { for ( i = n - 1; i >= l; -- i ) { cout << a [ m - 1 ] [ i ] << " "; } m --; } if ( l < n ) { for ( i = m - 1; i >= k; -- i ) { cout << a [ i ] [ l ] << " "; } l ++; } } }
bool isEven ( int n ) { return ( n % 2 == 0 ); }
int difference ( int arr [ ] [ MAX ], int n ) { int d1 = 0, d2 = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ]; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ]; } } return abs ( d1 - d2 ); }
int FirstRepeated ( string str ) { int checker = 0; for ( int i = 0; i < str . length ( ); ++ i ) { int val = ( str [ i ] - 'a' ); if ( ( checker & ( 1 << val ) ) > 0 ) return i; checker |= ( 1 << val ); } return - 1; }
int find_extra_element_index ( int arrA [ ], int arrB [ ], int n, int m ) { int extra_element = sum ( arrA, n ) - sum ( arrB, m ); return indexOf ( arrA, extra_element, n ); }
void printDiagonalSums ( int mat [ ] [ MAX ], int n ) { int principal = 0, secondary = 0; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ]; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ]; } } cout << "Principal Diagonal:" << principal << endl; cout << "Secondary Diagonal:" << secondary << endl; }
string LexicographicalMaxString ( string str ) { string mx = ""; for ( int i = 0; i < str . length ( ); ++ i ) mx = max ( mx, str . substr ( i ) ); return mx; }
void printRoots ( int n ) { double theta = M_PI * 2 / n; for ( int k = 0; k < n; k ++ ) { double real = cos ( k * theta ); double img = sin ( k * theta ); printf ( "%.6f", real ); img >= 0 ? printf ( " + i " ) : printf ( " - i " ); printf ( "%.6f\n", abs ( img ) ); } }
double findMod ( double a, double b ) { double mod; if ( a < 0 ) mod = - a; else mod = a; if ( b < 0 ) b = - b; while ( mod >= b ) mod = mod - b; if ( a < 0 ) return - mod; return mod; }
int cost ( int a [ ], int n ) { return ( n - 1 ) * ( * min_element ( a, a + n ) ); }
double compute ( int a, int b ) { double AM, GM, HM; AM = ( a + b ) / 2; GM = sqrt ( a * b ); HM = ( GM * GM ) / AM; return HM; }
int findFrequency ( int arr [ ], int n, int left, int right, int element ) { int count = 0; for ( int i = left - 1; i <= right; ++ i ) if ( arr [ i ] == element ) ++ count; return count; }
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q; q . push ( 1 ); int cnt = 0; int t; while ( ! q . empty ( ) ) { t = q . front ( ); q . pop ( ); if ( t <= N ) { cnt ++; q . push ( t * 10 ); q . push ( t * 10 + 1 ); } } return cnt; }
int binomialCoeff ( int n, int k ) { if ( k == 0 || k == n ) return 1; return binomialCoeff ( n - 1, k - 1 ) + binomialCoeff ( n - 1, k ); }
int count ( string a, string b, int m, int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1; if ( m == 0 ) return 0; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a, b, m - 1, n - 1 ) + count ( a, b, m - 1, n ); else return count ( a, b, m - 1, n ); }
int binaryToDecimal ( string n ) { string num = n; int dec_value = 0; int base = 1; int len = num . length ( ); for ( int i = len - 1; i >= 0; i -- ) { if ( num [ i ] == '1' ) dec_value += base; base = base * 2; } return dec_value; }
int subset ( int ar [ ], int n ) { int res = 0; sort ( ar, ar + n ); for ( int i = 0; i < n; i ++ ) { int count = 1; for (; i < n - 1; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++; else break; } res = max ( res, count ); } return res; }
int countSeq ( int n, int diff ) { if ( abs ( diff ) > n ) return 0; if ( n == 1 && diff == 0 ) return 2; if ( n == 1 && abs ( diff ) == 1 ) return 1; int res = countSeq ( n - 1, diff + 1 ) + 2 * countSeq ( n - 1, diff ) + countSeq ( n - 1, diff - 1 ); return res; }
int findLength ( string str, int n ) { int sum [ n + 1 ]; sum [ 0 ] = 0; for ( int i = 1; i <= n; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' ); int ans = 0; for ( int len = 2; len <= n; len += 2 ) { for ( int i = 0; i <= n - len; i ++ ) { int j = i + len - 1; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = max ( ans, len ); } } return ans; }
int maximumChars ( string & str ) { int n = str . length ( ); int res = - 1; int firstInd [ MAX_CHAR ]; for ( int i = 0; i < MAX_CHAR; i ++ ) firstInd [ i ] = - 1; for ( int i = 0; i < n; i ++ ) { int first_ind = firstInd [ str [ i ] ]; if ( first_ind == - 1 ) firstInd [ str [ i ] ] = i; else res = max ( res, abs ( i - first_ind - 1 ) ); } return res; }
int minPalPartion ( char * str ) { int n = strlen ( str ); int C [ n ] [ n ]; bool P [ n ] [ n ]; int i, j, k, L; for ( i = 0; i < n; i ++ ) { P [ i ] [ i ] = true; C [ i ] [ i ] = 0; } for ( L = 2; L <= n; L ++ ) { for ( i = 0; i < n - L + 1; i ++ ) { j = i + L - 1; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ); else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ]; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0; else { C [ i ] [ j ] = INT_MAX; for ( k = i; k <= j - 1; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ], C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ); } } } return C [ 0 ] [ n - 1 ]; }
int maxTripletSum ( int arr [ ], int n ) { sort ( arr, arr + n ); return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ]; }
int countRotations ( string n ) { int len = n . length ( ); if ( len == 1 ) { int oneDigit = n . at ( 0 ) - '0'; if ( oneDigit % 4 == 0 ) return 1; return 0; } int twoDigit, count = 0; for ( int i = 0; i < ( len - 1 ); i ++ ) { twoDigit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 ) - '0' ); if ( twoDigit % 4 == 0 ) count ++; } twoDigit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0 ) - '0' ); if ( twoDigit % 4 == 0 ) count ++; return count; }
bool checkMarkov ( double m [ ] [ n ] ) { for ( int i = 0; i < n; i ++ ) { double sum = 0; for ( int j = 0; j < n; j ++ ) sum = sum + m [ i ] [ j ]; if ( sum != 1 ) return false; } return true; }
int minOperation ( int arr [ ], int n ) { unordered_map < int, int > hash; for ( int i = 0; i < n; i ++ ) hash [ arr [ i ] ] ++; int max_count = 0; for ( auto i : hash ) if ( max_count < i . second ) max_count = i . second; return ( n - max_count ); }
int numberOfTriangles ( int n ) { int answer [ n + 1 ] = { 0 }; answer [ 0 ] = 1; for ( int i = 1; i <= n; i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2; return answer [ n ]; }
bool canFormPalindrome ( string str ) { vector < char > list; for ( int i = 0; i < str . length ( ); i ++ ) { auto pos = find ( list . begin ( ), list . end ( ), str [ i ] ); if ( pos != list . end ( ) ) { auto posi = find ( list . begin ( ), list . end ( ), str [ i ] ); list . erase ( posi ); } else list . push_back ( str [ i ] ); } if ( str . length ( ) % 2 == 0 && list . empty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true; else return false; }
void generate ( int ones, int zeroes, string str, int len ) { if ( len == str . length ( ) ) { cout << str << " "; return; } generate ( ones + 1, zeroes, str + "1", len ); if ( ones > zeroes ) generate ( ones, zeroes + 1, str + "0", len ); }
bool checkCorrectOrNot ( string s ) { int count [ MAX_CHAR ] = { 0 }; int n = s . length ( ); if ( n == 1 ) return true; for ( int i = 0, j = n - 1; i < j; i ++, j -- ) { count [ s [ i ] - 'a' ] ++; count [ s [ j ] - 'a' ] --; } for ( int i = 0; i < MAX_CHAR; i ++ ) if ( count [ i ] != 0 ) return false; return true; }
int binarySearch ( int arr [ ], int l, int r, int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2; if ( arr [ m ] == x ) return m; if ( arr [ m ] < x ) l = m + 1; else r = m - 1; } return - 1; }
void findDimen ( int H, int A ) { if ( H * H < 4 * A ) { cout << "Not Possible\n"; return; } double apb = sqrt ( H * H + 4 * A ); double asb = sqrt ( H * H - 4 * A ); cout . precision ( 2 ); cout << "P = " << fixed << ( apb - asb ) / 2.0 << "\n"; cout << "B = " << ( apb + asb ) / 2.0; }
int countInRange ( int arr [ ], int n, int x, int y ) { int count = 0; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++; } return count; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0; if ( n && ! ( n & ( n - 1 ) ) ) return n; while ( n != 0 ) { n >>= 1; count += 1; } return 1 << count; }
int recaman ( int n ) { int arr [ n ]; arr [ 0 ] = 0; printf ( "%d, ", arr [ 0 ] ); for ( int i = 1; i < n; i ++ ) { int curr = arr [ i - 1 ] - i; int j; for ( j = 0; j < i; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i; break; } } arr [ i ] = curr; printf ( "%d, ", arr [ i ] ); } }
int MatrixChainOrder ( int p [ ], int i, int j ) { if ( i == j ) return 0; int k; int min = INT_MAX; int count; for ( k = i; k < j; k ++ ) { count = MatrixChainOrder ( p, i, k ) + MatrixChainOrder ( p, k + 1, j ) + p [ i - 1 ] * p [ k ] * p [ j ]; if ( count < min ) min = count; } return min; }
float find_prob ( int N, float P ) { double dp [ N + 1 ]; dp [ 0 ] = 1; dp [ 1 ] = 0; dp [ 2 ] = P; dp [ 3 ] = 1 - P; for ( int i = 4; i <= N; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ]; return dp [ N ]; }
void pointClip ( int XY [ ] [ 2 ], int n, int Xmin, int Ymin, int Xmax, int Ymax ) { cout << "Point inside the viewing pane:" << endl; for ( int i = 0; i < n; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) { if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) cout << "[" << XY [ i ] [ 0 ] << "," << XY [ i ] [ 1 ] << "] "; } } cout << "\n" << endl; cout << "Point outside the viewing pane:" << endl; for ( int i = 0; i < n; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) cout << "[" << XY [ i ] [ 0 ] << "," << XY [ i ] [ 1 ] << "] "; if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) cout << "[" << XY [ i ] [ 0 ] << "," << XY [ i ] [ 1 ] << "] "; } }
int findPlatform ( int arr [ ], int dep [ ], int n ) { sort ( arr, arr + n ); sort ( dep, dep + n ); int plat_needed = 1, result = 1; int i = 1, j = 0; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat_needed ++; i ++; if ( plat_needed > result ) result = plat_needed; } else { plat_needed --; j ++; } } return result; }
int LowerInsertionPoint ( int arr [ ], int n, int X ) { if ( X < arr [ 0 ] ) return 0; else if ( X > arr [ n - 1 ] ) return n; int lowerPnt = 0; int i = 1; while ( i < n && arr [ i ] < X ) { lowerPnt = i; i = i * 2; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++; return lowerPnt; }
int countTrees ( int n ) { int BT [ n + 1 ]; memset ( BT, 0, sizeof ( BT ) ); BT [ 0 ] = BT [ 1 ] = 1; for ( int i = 2; i <= n; ++ i ) for ( int j = 0; j < i; j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ]; return BT [ n ]; }
int countStr ( int n, int bCount, int cCount ) { if ( bCount < 0 || cCount < 0 ) return 0; if ( n == 0 ) return 1; if ( bCount == 0 && cCount == 0 ) return 1; int res = countStr ( n - 1, bCount, cCount ); res += countStr ( n - 1, bCount - 1, cCount ); res += countStr ( n - 1, bCount, cCount - 1 ); return res; }
void bestFit ( int blockSize [ ], int m, int processSize [ ], int n ) { int allocation [ n ]; memset ( allocation, - 1, sizeof ( allocation ) ); for ( int i = 0; i < n; i ++ ) { int bestIdx = - 1; for ( int j = 0; j < m; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == - 1 ) bestIdx = j; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j; } } if ( bestIdx != - 1 ) { allocation [ i ] = bestIdx; blockSize [ bestIdx ] -= processSize [ i ]; } } cout << "\nProcess No.\tProcess Size\tBlock no.\n"; for ( int i = 0; i < n; i ++ ) { cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\t\t"; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1; else cout << "Not Allocated"; cout << endl; } }
int minRemove ( int arr [ ], int n ) { int LIS [ n ], len = 0; for ( int i = 0; i < n; i ++ ) LIS [ i ] = 1; for ( int i = 1; i < n; i ++ ) { for ( int j = 0; j < i; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = max ( LIS [ i ], LIS [ j ] + 1 ); } } len = max ( len, LIS [ i ] ); } return n - len; }
int sumNodes ( int l ) { int leafNodeCount = pow ( 2, l - 1 ); vector < int > vec [ l ]; for ( int i = 1; i <= leafNodeCount; i ++ ) vec [ l - 1 ] . push_back ( i ); for ( int i = l - 2; i >= 0; i -- ) { int k = 0; while ( k < vec [ i + 1 ] . size ( ) - 1 ) { vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ); k += 2; } } int sum = 0; for ( int i = 0; i < l; i ++ ) { for ( int j = 0; j < vec [ i ] . size ( ); j ++ ) sum += vec [ i ] [ j ]; } return sum; }
int findWays ( int m, int n, int x ) { int table [ n + 1 ] [ x + 1 ]; memset ( table, 0, sizeof ( table ) ); for ( int j = 1; j <= m && j <= x; j ++ ) table [ 1 ] [ j ] = 1; for ( int i = 2; i <= n; i ++ ) for ( int j = 1; j <= x; j ++ ) for ( int k = 1; k <= m && k < j; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ]; return table [ n ] [ x ]; }
int arraySortedOrNot ( int arr [ ], int n ) { if ( n == 1 || n == 0 ) return 1; if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0; return arraySortedOrNot ( arr, n - 1 ); }
int findRepeating ( int arr [ ], int n ) { unordered_set < int > s; for ( int i = 0; i < n; i ++ ) { if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ i ]; s . insert ( arr [ i ] ); } return - 1; }
int printCountDP ( int dist ) { int count [ dist + 1 ]; count [ 0 ] = 1, count [ 1 ] = 1, count [ 2 ] = 2; for ( int i = 3; i <= dist; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ]; return count [ dist ]; }
bool checkCount ( int arr [ ], int n, int k ) { unordered_map < int, int > hash; for ( int i = 0; i < n; i ++ ) hash [ arr [ i ] ] ++; for ( auto x : hash ) if ( x . second > 2 * k ) return false; return true; }
bool canRepresentBST ( int pre [ ], int n ) { stack < int > s; int root = INT_MIN; for ( int i = 0; i < n; i ++ ) { if ( pre [ i ] < root ) return false; while ( ! s . empty ( ) && s . top ( ) < pre [ i ] ) { root = s . top ( ); s . pop ( ); } s . push ( pre [ i ] ); } return true; }
int findCommon ( int mat [ M ] [ N ] ) { int column [ M ]; int min_row; int i; for ( i = 0; i < M; i ++ ) column [ i ] = N - 1; min_row = 0; while ( column [ min_row ] >= 0 ) { for ( i = 0; i < M; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i; } int eq_count = 0; for ( i = 0; i < M; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1; column [ i ] -= 1; } else eq_count ++; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ]; } return - 1; }
int printIntersection ( int arr1 [ ], int arr2 [ ], int m, int n ) { int i = 0, j = 0; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++; else if ( arr2 [ j ] < arr1 [ i ] ) j ++; else { cout << arr2 [ j ] << " "; i ++; j ++; } } }
void sortUsingHash ( int a [ ], int n ) { int max = * std :: max_element ( a, a + n ); int min = abs ( * std :: min_element ( a, a + n ) ); int hashpos [ max + 1 ] = { 0 }; int hashneg [ min + 1 ] = { 0 }; for ( int i = 0; i < n; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1; else hashneg [ abs ( a [ i ] ) ] += 1; } for ( int i = min; i > 0; i -- ) { if ( hashneg [ i ] ) { for ( int j = 0; j < hashneg [ i ]; j ++ ) { cout << ( - 1 ) * i << " "; } } } for ( int i = 0; i <= max; i ++ ) { if ( hashpos [ i ] ) { for ( int j = 0; j < hashpos [ i ]; j ++ ) { cout << i << " "; } } } }
void leftRotate ( int arr [ ], int n, int k ) { for ( int i = k; i < k + n; i ++ ) cout << arr [ i % n ] << " "; }
int find ( bool arr [ n ] [ n ] ) { int i = 0, j = n - 1; int res = - 1; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == 0 ) { while ( j >= 0 && ( arr [ i ] [ j ] == 0 || i == j ) ) j --; if ( j == - 1 ) { res = i; break; } else i ++; } else { while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) i ++; if ( i == n ) { res = j; break; } else j --; } } if ( res == - 1 ) return res; for ( int i = 0; i < n; i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return - 1; for ( int j = 0; j < n; j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return - 1; return res; }
int middleOfThree ( int a, int b, int c ) { int x = a - b; int y = b - c; int z = a - c; if ( x * y > 0 ) return b; else if ( x * z > 0 ) return c; else return a; }
void search ( int * arr, int low, int high ) { if ( low > high ) return; if ( low == high ) { printf ( "The required element is %d ", arr [ low ] ); return; } int mid = ( low + high ) / 2; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr, mid + 2, high ); else search ( arr, low, mid ); } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr, mid + 1, high ); else search ( arr, low, mid - 1 ); } }
bool isDivisible ( char str [ ], int k ) { int n = strlen ( str ); int c = 0; for ( int i = 0; i < k; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++; return ( c == k ); }
int check_duck ( char * num ) { int len = strlen ( num ); int count_zero = 0; char ch; for ( int i = 1; i < len; i ++ ) { ch = num [ i ]; if ( ch == '0' ) count_zero ++; } return count_zero; }
char encodedChar ( string str, int k ) { string expand = ""; string temp; int freq = 0; for ( int i = 0; str [ i ] != '\0'; ) { temp = ""; freq = 0; while ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { temp . push_back ( str [ i ] ); i ++; } while ( str [ i ] >= '1' && str [ i ] <= '9' ) { freq = freq * 10 + str [ i ] - '0'; i ++; } for ( int j = 1; j <= freq; j ++ ) expand . append ( temp ); } if ( freq == 0 ) expand . append ( temp ); return expand [ k - 1 ]; }
double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ); }
int lenOfLongSubarr ( int arr [ ], int n ) { unordered_map < int, int > um; int sum = 0, maxLen = 0; for ( int i = 0; i < n; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1; if ( sum == 1 ) maxLen = i + 1; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ]; } } return maxLen; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2; }
int getRemainder ( int num, int divisor ) { if ( divisor == 0 ) { cout << "Error: divisor can't be zero \n"; return - 1; } if ( divisor < 0 ) divisor = - divisor; if ( num < 0 ) num = - num; int i = 1; int product = 0; while ( product <= num ) { product = divisor * i; i ++; } return num - ( product - divisor ); }
void search ( int * arr, int low, int high ) { if ( low > high ) return; if ( low == high ) { printf ( "The required element is %d ", arr [ low ] ); return; } int mid = ( low + high ) / 2; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr, mid + 2, high ); else search ( arr, low, mid ); } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr, mid + 1, high ); else search ( arr, low, mid - 1 ); } }
void mergeTwoHalf ( int A [ ], int n ) { sort ( A, A + n ); }
int maxLevel ( int boxes [ ], int n ) { sort ( boxes, boxes + n ); int ans = 1; int prev_width = boxes [ 0 ]; int prev_count = 1; int curr_count = 0; int curr_width = 0; for ( int i = 1; i < n; i ++ ) { curr_width += boxes [ i ]; curr_count += 1; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width; prev_count = curr_count; curr_count = 0; curr_width = 0; ans ++; } } return ans; }
void pairs ( int arr [ ], int n, int k ) { int smallest = INT_MAX; int count = 0; for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = abs ( arr [ i ] + arr [ j ] - k ); count = 1; } else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++; } cout << "Minimal Value = " << smallest << "\n"; cout << "Total Pairs = " << count << "\n"; }
int sequence ( int n ) { int f [ n + 1 ]; int i; f [ 0 ] = 0; f [ 1 ] = 1; f [ 2 ] = 1; for ( i = 3; i <= n; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]; return f [ n ]; }
int divisible ( string num ) { int n = num . length ( ); int sum = accumulate ( begin ( num ), end ( num ), 0 ) - '0' * 1; if ( sum % 3 == 0 ) return 0; if ( n == 1 ) return - 1; for ( int i = 0; i < n; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1; if ( n == 2 ) return - 1; return 2; }
int findMinDiff ( int arr [ ], int n ) { int diff = INT_MAX; for ( int i = 0; i < n - 1; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ); return diff; }
void find3largest ( int arr [ ], int n ) { sort ( arr, arr + n ); int check = 0, count = 1; for ( int i = 1; i <= n; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { cout << arr [ n - i ] << " "; check = arr [ n - i ]; count ++; } } else break; } }
int unitnumber ( int x, int y ) { x = x % 10; if ( y != 0 ) y = y % 4 + 4; return ( ( ( int ) ( pow ( x, y ) ) ) % 10 ); }
bool isDivisible999 ( string num ) { int n = num . length ( ); if ( n == 0 && num [ 0 ] == '0' ) return true; if ( n % 3 == 1 ) num = "00" + num; if ( n % 3 == 2 ) num = "0" + num; int gSum = 0; for ( int i = 0; i < n; i ++ ) { int group = 0; group += ( num [ i ++ ] - '0' ) * 100; group += ( num [ i ++ ] - '0' ) * 10; group += num [ i ] - '0'; gSum += group; } if ( gSum > 1000 ) { num = to_string ( gSum ); n = num . length ( ); gSum = isDivisible999 ( num ); } return ( gSum == 999 ); }
int lps ( char * str ) { int n = strlen ( str ); int i, j, cl; int L [ n ] [ n ]; for ( i = 0; i < n; i ++ ) L [ i ] [ i ] = 1; for ( cl = 2; cl <= n; cl ++ ) { for ( i = 0; i < n - cl + 1; i ++ ) { j = i + cl - 1; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ], L [ i + 1 ] [ j ] ); } } return L [ 0 ] [ n - 1 ]; }
double largestSumOfAverages ( vector < int > & A, int K ) { int n = A . size ( ); double pre_sum [ n + 1 ]; pre_sum [ 0 ] = 0; for ( int i = 0; i < n; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ]; double dp [ n ] = { 0 }; double sum = 0; for ( int i = 0; i < n; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ); for ( int k = 0; k < K - 1; k ++ ) for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) dp [ i ] = max ( dp [ i ], ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ); return dp [ 0 ]; }
int findLIS ( int A [ ], int n ) { unordered_map < int, int > hash; int LIS_size = 1; int LIS_index = 0; hash [ A [ 0 ] ] = 1; for ( int i = 1; i < n; i ++ ) { hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1; if ( LIS_size < hash [ A [ i ] ] ) { LIS_size = hash [ A [ i ] ]; LIS_index = A [ i ]; } } cout << "LIS_size = " << LIS_size << "\n"; cout << "LIS : "; int start = LIS_index - LIS_size + 1; while ( start <= LIS_index ) { cout << start << " "; start ++; } }
int search ( int arr [ ], int n, int x ) { int i; for ( i = 0; i < n; i ++ ) if ( arr [ i ] == x ) return i; return - 1; }
int countSetBits ( int n ) { if ( n == 0 ) return 0; else return ( n & 1 ) + countSetBits ( n >> 1 ); }
unsigned int Calculate ( unsigned int A, unsigned int B, unsigned int C, unsigned int M ) { unsigned int res, ans; res = power ( B, C, M - 1 ); ans = power ( A, res, M ); return ans; }
int KnapSack ( int val [ ], int wt [ ], int n, int W ) { int mat [ 2 ] [ W + 1 ]; memset ( mat, 0, sizeof ( mat ) ); int i = 0; while ( i < n ) { int j = 0; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ], mat [ 0 ] [ j ] ); else mat [ 1 ] [ j ] = mat [ 0 ] [ j ]; } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ], mat [ 1 ] [ j ] ); else mat [ 0 ] [ j ] = mat [ 1 ] [ j ]; } } i ++; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ]; }
int calculate ( string N ) { int len = N . length ( ); int l = ( len ) / 2; int count = 0; for ( int i = 1; i <= l; i ++ ) { string s = N . substr ( 0, i ); int l1 = s . length ( ); string t = N . substr ( i, l1 ); if ( s [ 0 ] == '0' || t [ 0 ] == '0' ) continue; if ( s . compare ( t ) == 0 ) count ++; } return count; }
bool isPrime ( int n ) { if ( n <= 1 ) return false; if ( n <= 3 ) return true; if ( n % 2 == 0 || n % 3 == 0 ) return false; for ( int i = 5; i * i <= n; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false; return true; }
int maxPathSum ( int tri [ ] [ N ], int m, int n ) { for ( int i = m - 1; i >= 0; i -- ) { for ( int j = 0; j <= i; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ]; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ]; } } return tri [ 0 ] [ 0 ]; }
void myCopy ( char s1 [ ], char s2 [ ], int index = 0 ) { s2 [ index ] = s1 [ index ]; if ( s1 [ index ] == '\0' ) return; myCopy ( s1, s2, index + 1 ); }
int longestCommonSum ( bool arr1 [ ], bool arr2 [ ], int n ) { int maxLen = 0; int preSum1 = 0, preSum2 = 0; int diff [ 2 * n + 1 ]; memset ( diff, - 1, sizeof ( diff ) ); for ( int i = 0; i < n; i ++ ) { preSum1 += arr1 [ i ]; preSum2 += arr2 [ i ]; int curr_diff = preSum1 - preSum2; int diffIndex = n + curr_diff; if ( curr_diff == 0 ) maxLen = i + 1; else if ( diff [ diffIndex ] == - 1 ) diff [ diffIndex ] = i; else { int len = i - diff [ diffIndex ]; if ( len > maxLen ) maxLen = len; } } return maxLen; }
void assign ( int a [ ], int n ) { sort ( a, a + n ); int ans [ n ]; int p = 0, q = n - 1; for ( int i = 0; i < n; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ]; else ans [ i ] = a [ p ++ ]; } for ( int i = 0; i < n; i ++ ) cout << ans [ i ] << " "; }
int countSol ( int coeff [ ], int start, int end, int rhs ) { if ( rhs == 0 ) return 1; int result = 0; for ( int i = start; i <= end; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff, i, end, rhs - coeff [ i ] ); return result; }
void maxProduct ( int arr [ ], int n ) { if ( n < 2 ) { cout << "No pairs exists\n"; return; } if ( n == 2 ) { cout << arr [ 0 ] << " " << arr [ 1 ] << endl; return; } int posa = INT_MIN, posb = INT_MIN; int nega = INT_MIN, negb = INT_MIN; for ( int i = 0; i < n; i ++ ) { if ( arr [ i ] > posa ) { posb = posa; posa = arr [ i ]; } else if ( arr [ i ] > posb ) posb = arr [ i ]; if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) ) { negb = nega; nega = arr [ i ]; } else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb ) ) negb = arr [ i ]; } if ( nega * negb > posa * posb ) cout << "Max product pair is {" << nega << ", " << negb << "}"; else cout << "Max product pair is {" << posa << ", " << posb << "}"; }
string replace ( string s, char c1, char c2 ) { int l = s . length ( ); for ( int i = 0; i < l; i ++ ) { if ( s [ i ] == c1 ) s [ i ] = c2; else if ( s [ i ] == c2 ) s [ i ] = c1; } return s; }
int countPairs ( string str ) { int result = 0; int n = str . length ( ); for ( int i = 0; i < n; i ++ ) for ( int j = i + 1; j < n; j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++; return result; }
void printDistinct ( int arr [ ], int n ) { unordered_set < int > s; for ( int i = 0; i < n; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ); cout << arr [ i ] << " "; } } }
int ksmallest ( int arr [ ], int n, int k ) { int b [ MAX ]; memset ( b, 0, sizeof b ); for ( int i = 0; i < n; i ++ ) b [ arr [ i ] ] = 1; for ( int j = 1; j < MAX; j ++ ) { if ( b [ j ] != 1 ) k --; if ( ! k ) return j; } }
int getOddOccurrence ( int ar [ ], int ar_size ) { int res = 0; for ( int i = 0; i < ar_size; i ++ ) res = res ^ ar [ i ]; return res; }
void constructTree ( int n, int d, int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { cout << "1 2" << endl; return; } cout << "-1" << endl; return; } if ( d > 2 * h ) { cout << "-1" << endl; return; } for ( int i = 1; i <= h; i ++ ) cout << i << " " << i + 1 << endl; if ( d > h ) { cout << "1" << " " << h + 2 << endl; for ( int i = h + 2; i <= d; i ++ ) { cout << i << " " << i + 1 << endl; } } for ( int i = d + 1; i < n; i ++ ) { int k = 1; if ( d == h ) k = 2; cout << k << " " << i + 1 << endl; } }
bool checkValidity ( int a, int b, int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return false; else return true; }
void pairSum ( int mat [ ] [ MAX ], int n, int sum ) { for ( int i = 0; i < n; i ++ ) sort ( mat [ i ], mat [ i ] + n ); for ( int i = 0; i < n - 1; i ++ ) { for ( int j = i + 1; j < n; j ++ ) { int left = 0, right = n - 1; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { cout << "(" << mat [ i ] [ left ] << ", " << mat [ j ] [ right ] << "), "; left ++; right --; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++; else right --; } } } } }
int minCoins ( int coins [ ], int m, int V ) { if ( V == 0 ) return 0; int res = INT_MAX; for ( int i = 0; i < m; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins, m, V - coins [ i ] ); if ( sub_res != INT_MAX && sub_res + 1 < res ) res = sub_res + 1; } } return res; }
int largestSubset ( int a [ ], int n ) { sort ( a, a + n ); int dp [ n ]; dp [ n - 1 ] = 1; for ( int i = n - 2; i >= 0; i -- ) { int mxm = 0; for ( int j = i + 1; j < n; j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = max ( mxm, dp [ j ] ); dp [ i ] = 1 + mxm; } return * max_element ( dp, dp + n ); }
int Identity ( int num ) { int row, col; for ( row = 0; row < num; row ++ ) { for ( col = 0; col < num; col ++ ) { if ( row == col ) cout << 1 << " "; else cout << 0 << " "; } cout << endl; } return 0; }
int lcs ( char * X, char * Y, int m, int n ) { if ( m == 0 || n == 0 ) return 0; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X, Y, m - 1, n - 1 ); else return max ( lcs ( X, Y, m, n - 1 ), lcs ( X, Y, m - 1, n ) ); }
int floorSearch ( int arr [ ], int low, int high, int x ) { if ( low > high ) return - 1; if ( x >= arr [ high ] ) return high; int mid = ( low + high ) / 2; if ( arr [ mid ] == x ) return mid; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1; if ( x < arr [ mid ] ) return floorSearch ( arr, low, mid - 1, x ); return floorSearch ( arr, mid + 1, high, x ); }
bool canMakeAllSame ( string str ) { int zeros = 0, ones = 0; for ( char ch : str ) ( ch == '0' ) ? ++ zeros : ++ ones; return ( zeros == 1 || ones == 1 ); }
int maxSumIS ( int arr [ ], int n ) { int i, j, max = 0; int msis [ n ]; for ( i = 0; i < n; i ++ ) msis [ i ] = arr [ i ]; for ( i = 1; i < n; i ++ ) for ( j = 0; j < i; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ]; for ( i = 0; i < n; i ++ ) if ( max < msis [ i ] ) max = msis [ i ]; return max; }
unsigned long long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ); }
public : void printPowerSet ( char * set, int set_size ) { unsigned int pow_set_size = pow ( 2, set_size ); int counter, j; for ( counter = 0; counter < pow_set_size; counter ++ ) { for ( j = 0; j < set_size; j ++ ) { if ( counter & ( 1 << j ) ) cout << set [ j ]; } cout << endl; } }
int smallestSubWithSum ( int arr [ ], int n, int x ) { int curr_sum = 0, min_len = n + 1; int start = 0, end = 0; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end; curr_sum = 0; } curr_sum += arr [ end ++ ]; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start; curr_sum -= arr [ start ++ ]; } } return min_len; }
void findCount ( int n, int sum ) { int start = pow ( 10, n - 1 ); int end = pow ( 10, n ) - 1; int count = 0; int i = start; while ( i <= end ) { int cur = 0; int temp = i; while ( temp != 0 ) { cur += temp % 10; temp = temp / 10; } if ( cur == sum ) { count ++; i += 9; } else i ++; } cout << count; }
int findMinNumber ( int n ) { int count = 0, ans = 1; while ( n % 2 == 0 ) { count ++; n /= 2; } if ( count % 2 ) ans *= 2; for ( int i = 3; i <= sqrt ( n ); i += 2 ) { count = 0; while ( n % i == 0 ) { count ++; n /= i; } if ( count % 2 ) ans *= i; } if ( n > 2 ) ans *= n; return ans; }
int find_maximum ( int a [ ], int n, int k ) { unordered_map < int, int > b; for ( int i = 0; i < n; i ++ ) { int x = a [ i ]; int d = min ( 1 + i, n - i ); if ( b . find ( x ) == b . end ( ) ) b [ x ] = d; else b [ x ] = min ( d, b [ x ] ); } int ans = INT_MAX; for ( int i = 0; i < n; i ++ ) { int x = a [ i ]; if ( x != k - x && b . find ( k - x ) != b . end ( ) ) ans = min ( max ( b [ x ], b [ k - x ] ), ans ); } return ans; }
int FindMaxProduct ( int arr [ ] [ n ], int n ) { int max = 0, result; for ( int i = 0; i < n; i ++ ) { for ( int j = 0; j < n; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ]; if ( max < result ) max = result; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ]; if ( max < result ) max = result; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ]; if ( max < result ) max = result; } } } return max; }
int perfectSquare ( string s ) { int n = s . size ( ); int ans = - 1; string num; for ( int i = 1; i < ( 1 << n ); i ++ ) { string str = ""; for ( int j = 0; j < n; j ++ ) { if ( ( i >> j ) & 1 ) { str += s [ j ]; } } if ( str [ 0 ] != '0' ) { int temp = 0; for ( int j = 0; j < str . size ( ); j ++ ) temp = temp * 10 + ( int ) ( str [ j ] - '0' ); int k = sqrt ( temp ); if ( k * k == temp ) { if ( ans < ( int ) str . size ( ) ) { ans = ( int ) str . size ( ); num = str; } } } } if ( ans == - 1 ) return ans; else { cout << num << " "; return n - ans; } }
long long int maxDecimalValue ( int mat [ ] [ N ], int i, int j, int p ) { if ( i >= N || j >= N ) return 0; int result = max ( maxDecimalValue ( mat, i, j + 1, p + 1 ), maxDecimalValue ( mat, i + 1, j, p + 1 ) ); if ( mat [ i ] [ j ] == 1 ) return pow ( 2, p ) + result; else return result; }
void printPrevSmaller ( int arr [ ], int n ) { cout << "_, "; for ( int i = 1; i < n; i ++ ) { int j; for ( j = i - 1; j >= 0; j -- ) { if ( arr [ j ] < arr [ i ] ) { cout << arr [ j ] << ", "; break; } } if ( j == - 1 ) cout << "_, "; } }
int ceilSearch ( int arr [ ], int low, int high, int x ) { int mid; if ( x <= arr [ low ] ) return low; if ( x > arr [ high ] ) return - 1; mid = ( low + high ) / 2; if ( arr [ mid ] == x ) return mid; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1; else return ceilSearch ( arr, mid + 1, high, x ); } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid; else return ceilSearch ( arr, low, mid - 1, x ); } }
int countPairs ( int arr1 [ ], int arr2 [ ], int m, int n, int x ) { int count = 0; int l = 0, r = n - 1; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++; r --; count ++; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++; else r --; } return count; }
int binarySearch ( int arr [ ], int l, int r, int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2; if ( arr [ mid ] == x ) return mid; if ( arr [ mid ] > x ) return binarySearch ( arr, l, mid - 1, x ); return binarySearch ( arr, mid + 1, r, x ); } return - 1; }
void multiply ( int A [ ] [ N ], int B [ ] [ N ], int C [ ] [ N ] ) { int i, j; for ( i = 0; i < N; i ++ ) for ( j = 0; j < N; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]; }
bool sortedAfterSwap ( int A [ ], bool B [ ], int n ) { int i, j; for ( i = 0; i < n - 1; i ++ ) { if ( B [ i ] ) { j = i; while ( B [ j ] ) j ++; sort ( A + i, A + 1 + j ); i = j; } } for ( i = 0; i < n; i ++ ) { if ( A [ i ] != i + 1 ) return false; } return true; }
