bool checkDuplicatesWithinK ( int arr [ ], int n, int k ) { unordered_set < int > myset; for ( int i = 0; i < n; i ++ ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) return true; myset . insert ( arr [ i ] ); if ( i >= k ) myset . erase ( arr [ i - k ] ); } return false; }
bool isCornerPresent ( string str, string corner ) { int n = str . length ( ); int cl = corner . length ( ); if ( n < cl ) return false; return ( str . substr ( 0, cl ) . compare ( corner ) == 0 && str . substr ( n - cl, cl ) . compare ( corner ) == 0 ); }
void diagonalsquare ( int mat [ ] [ MAX ], int row, int column ) { cout << "Diagonal one : "; for ( int i = 0; i < row; i ++ ) { for ( int j = 0; j < column; j ++ ) if ( i == j ) cout << mat [ i ] [ j ] * mat [ i ] [ j ] << " "; } cout << " \n\nDiagonal two : "; for ( int i = 0; i < row; i ++ ) { for ( int j = 0; j < column; j ++ ) if ( i + j == column - 1 ) cout << mat [ i ] [ j ] * mat [ i ] [ j ] << " "; } }
int countkDist ( string str, int k ) { int n = str . length ( ); int res = 0; int cnt [ 26 ]; for ( int i = 0; i < n; i ++ ) { int dist_count = 0; memset ( cnt, 0, sizeof ( cnt ) ); for ( int j = i; j < n; j ++ ) { if ( cnt [ str [ j ] - 'a' ] == 0 ) dist_count ++; cnt [ str [ j ] - 'a' ] ++; if ( dist_count == k ) res ++; if ( dist_count > k ) break; } } return res; }
void midpoint ( int x1, int x2, int y1, int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , " << ( float ) ( y1 + y2 ) / 2; }
int unboundedKnapsack ( int W, int n, int val [ ], int wt [ ] ) { int dp [ W + 1 ]; memset ( dp, 0, sizeof dp ); int ans = 0; for ( int i = 0; i <= W; i ++ ) for ( int j = 0; j < n; j ++ ) if ( wt [ j ] <= i ) dp [ i ] = max ( dp [ i ], dp [ i - wt [ j ] ] + val [ j ] ); return dp [ W ]; }
int countSetBits ( int n ) { int i = 0; int ans = 0; while ( ( 1 << i ) <= n ) { bool k = 0; int change = 1 << i; for ( int j = 0; j <= n; j ++ ) { ans += k; if ( change == 1 ) { k = ! k; change = 1 << i; } else { change --; } } i ++; } return ans; }
long findWays ( int f, int d, int s ) { long mem [ d + 1 ] [ s + 1 ]; memset ( mem, 0, sizeof mem ); mem [ 0 ] [ 0 ] = 1; for ( int i = 1; i <= d; i ++ ) { for ( int j = i; j <= s; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ]; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ]; } } return mem [ d ] [ s ]; }
