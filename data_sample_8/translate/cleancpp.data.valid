int longestNull ( string str ) { vector < pair < char, int > > arr; arr . push_back ( { '@', - 1 } ); int maxlen = 0; for ( int i = 0; i < str . length ( ); ++ i ) { arr . push_back ( { str [ i ], i } ); while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] . first == '1' && arr [ arr . size ( ) - 2 ] . first == '0' && arr [ arr . size ( ) - 1 ] . first == '0' ) { arr . pop_back ( ); arr . pop_back ( ); arr . pop_back ( ); } int tmp = arr . back ( ) . second; maxlen = max ( maxlen, i - tmp ); } return maxlen; }
void find ( vector < string > list1, vector < string > list2 ) { vector < string > res; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2; for ( int sum = 0; sum <= max_possible_sum; sum ++ ) { for ( int i = 0; i <= sum; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 [ i ] == list2 [ sum - i ] ) res . push_back ( list1 [ i ] ); if ( res . size ( ) > 0 ) break; } for ( int i = 0; i < res . size ( ); i ++ ) cout << res [ i ] << " "; }
bool isSubsetSum ( int arr [ ], int n, int sum ) { bool subset [ 2 ] [ sum + 1 ]; for ( int i = 0; i <= n; i ++ ) { for ( int j = 0; j <= sum; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ]; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ]; } } return subset [ n % 2 ] [ sum ]; }
int MinimumCost ( int cost [ ], int n, int W ) { vector < int > val, wt; int size = 0; for ( int i = 0; i < n; i ++ ) { if ( cost [ i ] != - 1 ) { val . push_back ( cost [ i ] ); wt . push_back ( i + 1 ); size ++; } } n = size; int min_cost [ n + 1 ] [ W + 1 ]; for ( int i = 0; i <= W; i ++ ) min_cost [ 0 ] [ i ] = INF; for ( int i = 1; i <= n; i ++ ) min_cost [ i ] [ 0 ] = 0; for ( int i = 1; i <= n; i ++ ) { for ( int j = 1; j <= W; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]; else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ], min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ); } } return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n ] [ W ]; }
int perimeter ( int diameter, int height ) { return 2 * ( diameter + height ); }
bool findTriplet ( int a1 [ ], int a2 [ ], int a3 [ ], int n1, int n2, int n3, int sum ) { for ( int i = 0; i < n1; i ++ ) for ( int j = 0; j < n2; j ++ ) for ( int k = 0; k < n3; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true; return false; }
bool findDuplicateparenthesis ( string str ) { stack < char > Stack; for ( char ch : str ) { if ( ch == ')' ) { char top = Stack . top ( ); Stack . pop ( ); int elementsInside = 0; while ( top != '(' ) { elementsInside ++; top = Stack . top ( ); Stack . pop ( ); } if ( elementsInside < 1 ) { return 1; } } else Stack . push ( ch ); } return false; }
int findElement ( int arr [ ], int ranges [ ] [ 2 ], int rotations, int index ) { for ( int i = rotations - 1; i >= 0; i -- ) { int left = ranges [ i ] [ 0 ]; int right = ranges [ i ] [ 1 ]; if ( left <= index && right >= index ) { if ( index == left ) index = right; else index --; } } return arr [ index ]; }
