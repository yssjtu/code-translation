def checkDuplicatesWithinK ( arr , n , k ) : myset = [ ] for i in range ( n ) : if arr [ i ] in myset : return True myset . append ( arr [ i ] ) if ( i >= k ) : myset . remove ( arr [ i - k ] ) return False
def isCornerPresent ( str , corner ) : n = len ( str ) cl = len ( corner ) if ( n < cl ) : return False return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) )
def diagonalsquare ( mat , row , column ) : print ( "Diagonalone:" , end = "" ) for i in range ( 0 , row ) : for j in range ( 0 , column ) : if ( i == j ) : print ( "{}" . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = "" ) print ( "\n\nDiagonaltwo:" , end = "" ) for i in range ( 0 , row ) : for j in range ( 0 , column ) : if ( i + j == column - 1 ) : print ( "{}" . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = "" )
def countkDist ( str1 , k ) : n = len ( str1 ) res = 0 cnt = [ 0 ] * 27 for i in range ( 0 , n ) : dist_count = 0 cnt = [ 0 ] * 27 for j in range ( i , n ) : if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : dist_count += 1 cnt [ ord ( str1 [ j ] ) - 97 ] += 1 if ( dist_count == k ) : res += 1 if ( dist_count > k ) : break return res
def midpoint ( x1 , x2 , y1 , y2 ) : print ( ( x1 + x2 ) // 2 , "," , ( y1 + y2 ) // 2 )
def unboundedKnapsack ( W , n , val , wt ) : dp = [ 0 for i in range ( W + 1 ) ] ans = 0 for i in range ( W + 1 ) : for j in range ( n ) : if ( wt [ j ] <= i ) : dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) return dp [ W ]
def countSetBits ( n ) : i = 0 ans = 0 while ( ( 1 << i ) <= n ) : k = 0 change = 1 << i for j in range ( 0 , n + 1 ) : ans += k if change == 1 : k = not k change = 1 << i else : change -= 1 i += 1 return ans
def findWays ( f , d , s ) : mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] mem [ 0 ] [ 0 ] = 1 for i in range ( 1 , d + 1 ) : for j in range ( 1 , s + 1 ) : mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] if j - f - 1 >= 0 : mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] return mem [ d ] [ s ]
