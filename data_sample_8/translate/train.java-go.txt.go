func maxDepth(root *Node) int { if root == nil { return 0 } maxChildDepth := 0 for _, child := range root.Children { if childDepth := maxDepth(child); childDepth > maxChildDepth { maxChildDepth = childDepth } } return maxChildDepth + 1 }
func rotateRight(head *ListNode, k int) *ListNode { if k == 0 || head == nil || head.Next == nil { return head } n := 1 iter := head for iter.Next != nil { iter = iter.Next n++ } add := n - k%n if add == n { return head } iter.Next = head for add > 0 { iter = iter.Next add-- } ret := iter.Next iter.Next = nil return ret }
func findShortestSubArray(nums []int) (ans int) { mp := map[int]entry{} for i, v := range nums { if e, has := mp[v]; has { e.cnt++ e.r = i mp[v] = e } else { mp[v] = entry{1, i, i} } } maxCnt := 0 for _, e := range mp { if e.cnt > maxCnt { maxCnt, ans = e.cnt, e.r-e.l+1 } else if e.cnt == maxCnt { ans = min(ans, e.r-e.l+1) } } return }
func maxSlidingWindow(nums []int, k int) []int { n := len(nums) prefixMax := make([]int, n) suffixMax := make([]int, n) for i, v := range nums { if i%k == 0 { prefixMax[i] = v } else { prefixMax[i] = max(prefixMax[i-1], v) } } for i := n - 1; i >= 0; i-- { if i == n-1 || (i+1)%k == 0 { suffixMax[i] = nums[i] } else { suffixMax[i] = max(suffixMax[i+1], nums[i]) } } ans := make([]int, n-k+1) for i := range ans { ans[i] = max(suffixMax[i], prefixMax[i+k-1]) } return ans }
func predictPartyVictory(senate string) string { var radiant, dire []int for i, s := range senate { if s == 'R' { radiant = append(radiant, i) } else { dire = append(dire, i) } } for len(radiant) > 0 && len(dire) > 0 { if radiant[0] < dire[0] { radiant = append(radiant, radiant[0]+len(senate)) } else { dire = append(dire, dire[0]+len(senate)) } radiant = radiant[1:] dire = dire[1:] } if len(radiant) > 0 { return "Radiant" } return "Dire" }
func totalHammingDistance(nums []int) (ans int) { n := len(nums) for i := 0; i < 30; i++ { c := 0 for _, val := range nums { c += val >> i & 1 } ans += c * (n - c) } return }
func numRescueBoats(people []int, limit int) (ans int) { sort.Ints(people) light, heavy := 0, len(people)-1 for light <= heavy { if people[light]+people[heavy] > limit { heavy-- } else { light++ heavy-- } ans++ } return }
func minDistance(word1, word2 string) int { m, n := len(word1), len(word2) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i, c1 := range word1 { for j, c2 := range word2 { if c1 == c2 { dp[i+1][j+1] = dp[i][j] + 1 } else { dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]) } } } lcs := dp[m][n] return m + n - lcs*2 }
