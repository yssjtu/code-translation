func minMoves(nums []int) (ans int) { min := nums[0] for _, num := range nums[1:] { if num < min { min = num } } for _, num := range nums { ans += num - min } return }
func isValid(s string) bool { n := len(s) if n % 2 == 1 { return false } pairs := map[byte]byte{ ')': '(', ']': '[', '}': '{', } stack := []byte{} for i := 0; i < n; i++ { if pairs[s[i]] > 0 { if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { return false } stack = stack[:len(stack)-1] } else { stack = append(stack, s[i]) } } return len(stack) == 0 }
func canPlaceFlowers(flowerbed []int, n int) bool { count := 0 m := len(flowerbed) prev := -1 for i := 0; i < m; i++ { if flowerbed[i] == 1 { if prev < 0 { count += i / 2 } else { count += (i - prev - 2) / 2 } prev = i } } if prev < 0 { count += (m + 1) / 2 } else { count += (m - prev - 1) / 2 } return count >= n }
func ladderLength(beginWord string, endWord string, wordList []string) int { wordId := map[string]int{} graph := [][]int{} addWord := func(word string) int { id, has := wordId[word] if !has { id = len(wordId) wordId[word] = id graph = append(graph, []int{}) } return id } addEdge := func(word string) int { id1 := addWord(word) s := []byte(word) for i, b := range s { s[i] = '*' id2 := addWord(string(s)) graph[id1] = append(graph[id1], id2) graph[id2] = append(graph[id2], id1) s[i] = b } return id1 } for _, word := range wordList { addEdge(word) } beginId := addEdge(beginWord) endId, has := wordId[endWord] if !has { return 0 } const inf int = math.MaxInt64 dist := make([]int, len(wordId)) for i := range dist { dist[i] = inf } dist[beginId] = 0 queue := []int{beginId} for len(queue) > 0 { v := queue[0] queue = queue[1:] if v == endId { return dist[endId]/2 + 1 } for _, w := range graph[v] { if dist[w] == inf { dist[w] = dist[v] + 1 queue = append(queue, w) } } } return 0 }
func isPerfectSquare(num int) bool { for x := 1; x*x <= num; x++ { if x*x == num { return true } } return false }
func productExceptSelf(nums []int) []int { length := len(nums) answer := make([]int, length) answer[0] = 1 for i := 1; i < length; i++ { answer[i] = nums[i-1] * answer[i-1] } R := 1 for i := length - 1; i >= 0; i-- { answer[i] = answer[i] * R R *= nums[i] } return answer }
func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return &TreeNode{Val: val} } p := root for p != nil { if val < p.Val { if p.Left == nil { p.Left = &TreeNode{Val: val} break } p = p.Left } else { if p.Right == nil { p.Right = &TreeNode{Val: val} break } p = p.Right } } return root }
func integerBreak(n int) int { dp := make([]int, n + 1) for i := 2; i <= n; i++ { curMax := 0 for j := 1; j < i; j++ { curMax = max(curMax, max(j * (i - j), j * dp[i - j])) } dp[i] = curMax } return dp[n] }
