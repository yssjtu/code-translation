def minMoves(self, nums: List[int]) -> int: min_num = min(nums) res = 0 for num in nums: res += num - min_num return res
def isValid(self, s: str) -> bool: if len(s) % 2 == 1: return False pairs = { ")": "(", "]": "[", "}": "{", } stack = list() for ch in s: if ch in pairs: if not stack or stack[-1] != pairs[ch]: return False stack.pop() else: stack.append(ch) return not stack
def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool: count, m, prev = 0, len(flowerbed), -1 for i in range(m): if flowerbed[i] == 1: if prev < 0: count += i // 2 else: count += (i - prev - 2) // 2 prev = i if prev < 0: count += (m + 1) // 2 else: count += (m - prev - 1) // 2 return count >= n
def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int: def addWord(word: str): if word not in wordId: nonlocal nodeNum wordId[word] = nodeNum nodeNum += 1 def addEdge(word: str): addWord(word) id1 = wordId[word] chars = list(word) for i in range(len(chars)): tmp = chars[i] chars[i] = "*" newWord = "".join(chars) addWord(newWord) id2 = wordId[newWord] edge[id1].append(id2) edge[id2].append(id1) chars[i] = tmp wordId = dict() edge = collections.defaultdict(list) nodeNum = 0 for word in wordList: addEdge(word) addEdge(beginWord) if endWord not in wordId: return 0 dis = [float("inf")] * nodeNum beginId, endId = wordId[beginWord], wordId[endWord] dis[beginId] = 0 que = collections.deque([beginId]) while que: x = que.popleft() if x == endId: return dis[endId] // 2 + 1 for it in edge[x]: if dis[it] == float("inf"): dis[it] = dis[x] + 1 que.append(it) return 0
def isPerfectSquare(self, num: int) -> bool: x = 1 square = 1 while square <= num: if square == num: return True x += 1 square = x * x return False
def productExceptSelf(self, nums: List[int]) -> List[int]: length = len(nums) answer = [0]*length answer[0] = 1 for i in range(1, length): answer[i] = nums[i - 1] * answer[i - 1] R = 1; for i in reversed(range(length)): answer[i] = answer[i] * R R *= nums[i] return answer
def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode: if not root: return TreeNode(val) pos = root while pos: if val < pos.val: if not pos.left: pos.left = TreeNode(val) break else: pos = pos.left else: if not pos.right: pos.right = TreeNode(val) break else: pos = pos.right return root
def integerBreak(self, n: int) -> int: dp = [0] * (n + 1) for i in range(2, n + 1): for j in range(i): dp[i] = max(dp[i], j * (i - j), j * dp[i - j]) return dp[n]
