func minPairSum(nums []int) (ans int) { sort.Ints(nums) n := len(nums) for i, val := range nums[:n/2] { ans = max(ans, val+nums[n-1-i]) } return }
func merge(nums1 []int, m int, nums2 []int, n int) { for p1, p2, tail := m-1, n-1, m+n-1; p1 >= 0 || p2 >= 0; tail-- { var cur int if p1 == -1 { cur = nums2[p2] p2-- } else if p2 == -1 { cur = nums1[p1] p1-- } else if nums1[p1] > nums2[p2] { cur = nums1[p1] p1-- } else { cur = nums2[p2] p2-- } nums1[tail] = cur } }
func deleteDuplicates(head *ListNode) *ListNode { if head == nil { return nil } cur := head for cur.Next != nil { if cur.Val == cur.Next.Val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return head }
func wiggleMaxLength(nums []int) int { n := len(nums) if n < 2 { return n } up := make([]int, n) down := make([]int, n) up[0] = 1 down[0] = 1 for i := 1; i < n; i++ { if nums[i] > nums[i-1] { up[i] = max(up[i-1], down[i-1]+1) down[i] = down[i-1] } else if nums[i] < nums[i-1] { up[i] = up[i-1] down[i] = max(up[i-1]+1, down[i-1]) } else { up[i] = up[i-1] down[i] = down[i-1] } } return max(up[n-1], down[n-1]) }
func rangeSumBST(root *TreeNode, low, high int) int { if root == nil { return 0 } if root.Val > high { return rangeSumBST(root.Left, low, high) } if root.Val < low { return rangeSumBST(root.Right, low, high) } return root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high) }
func checkRecord(s string) bool { absents, lates := 0, 0 for _, ch := range s { if ch == 'A' { absents++ if absents >= 2 { return false } } if ch == 'L' { lates++ if lates >= 3 { return false } } else { lates = 0 } } return true }
func candy(ratings []int) (ans int) { n := len(ratings) left := make([]int, n) for i, r := range ratings { if i > 0 && r > ratings[i-1] { left[i] = left[i-1] + 1 } else { left[i] = 1 } } right := 0 for i := n - 1; i >= 0; i-- { if i < n-1 && ratings[i] > ratings[i+1] { right++ } else { right = 1 } ans += max(left[i], right) } return }
func hIndex(citations []int) (h int) { sort.Ints(citations) for i := len(citations) - 1; i >= 0 && citations[i] > h; i-- { h++ } return }
