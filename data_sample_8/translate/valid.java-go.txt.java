public int minPairSum(int[] nums) { int n = nums.length; int res = 0; Arrays.sort(nums); for (int i = 0; i < n / 2; ++i) { res = Math.max(res, nums[i] + nums[n - 1 - i]); } return res; }
public void merge(int[] nums1, int m, int[] nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 >= 0 || p2 >= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] > nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } }
public ListNode deleteDuplicates(ListNode head) { if (head == null) { return head; } ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) { cur.next = cur.next.next; } else { cur = cur.next; } } return head; }
public int wiggleMaxLength(int[] nums) { int n = nums.length; if (n < 2) { return n; } int[] up = new int[n]; int[] down = new int[n]; up[0] = down[0] = 1; for (int i = 1; i < n; i++) { if (nums[i] > nums[i - 1]) { up[i] = Math.max(up[i - 1], down[i - 1] + 1); down[i] = down[i - 1]; } else if (nums[i] < nums[i - 1]) { up[i] = up[i - 1]; down[i] = Math.max(up[i - 1] + 1, down[i - 1]); } else { up[i] = up[i - 1]; down[i] = down[i - 1]; } } return Math.max(up[n - 1], down[n - 1]); }
public int rangeSumBST(TreeNode root, int low, int high) { if (root == null) { return 0; } if (root.val > high) { return rangeSumBST(root.left, low, high); } if (root.val < low) { return rangeSumBST(root.right, low, high); } return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high); }
public boolean checkRecord(String s) { int absents = 0, lates = 0; int n = s.length(); for (int i = 0; i < n; i++) { char c = s.charAt(i); if (c == 'A') { absents++; if (absents >= 2) { return false; } } if (c == 'L') { lates++; if (lates >= 3) { return false; } } else { lates = 0; } } return true; }
public int candy(int[] ratings) { int n = ratings.length; int[] left = new int[n]; for (int i = 0; i < n; i++) { if (i > 0 && ratings[i] > ratings[i - 1]) { left[i] = left[i - 1] + 1; } else { left[i] = 1; } } int right = 0, ret = 0; for (int i = n - 1; i >= 0; i--) { if (i < n - 1 && ratings[i] > ratings[i + 1]) { right++; } else { right = 1; } ret += Math.max(left[i], right); } return ret; }
public int hIndex(int[] citations) { Arrays.sort(citations); int h = 0, i = citations.length - 1; while (i >= 0 && citations[i] > h) { h++; i--; } return h; }
