func xorQueries(arr []int, queries [][]int) []int { xors := make([]int, len(arr)+1) for i, v := range arr { xors[i+1] = xors[i] ^ v } ans := make([]int, len(queries)) for i, q := range queries { ans[i] = xors[q[0]] ^ xors[q[1]+1] } return ans }
func getMaximumGenerated(n int) (ans int) { if n == 0 { return } nums := make([]int, n+1) nums[1] = 1 for i := 2; i <= n; i++ { nums[i] = nums[i/2] + i%2*nums[i/2+1] } for _, v := range nums { ans = max(ans, v) } return }
func hasCycle(head *ListNode) bool { seen := map[*ListNode]struct{}{} for head != nil { if _, ok := seen[head]; ok { return true } seen[head] = struct{}{} head = head.Next } return false }
func findMaxAverage(nums []int, k int) float64 { sum := 0 for _, v := range nums[:k] { sum += v } maxSum := sum for i := k; i < len(nums); i++ { sum = sum - nums[i-k] + nums[i] maxSum = max(maxSum, sum) } return float64(maxSum) / float64(k) }
func convertToTitle(columnNumber int) string { ans := []byte{} for columnNumber > 0 { columnNumber-- ans = append(ans, 'A'+byte(columnNumber%26)) columnNumber /= 26 } for i, n := 0, len(ans); i < n/2; i++ { ans[i], ans[n-1-i] = ans[n-1-i], ans[i] } return string(ans) }
func diffWaysToCompute(input string) []int { if isDigit(input) { tmp, _ := strconv.Atoi(input) return []int{tmp} } var res []int for index, c := range input { tmpC := string(c) if tmpC == "+" || tmpC == "-" || tmpC == "*" { left := diffWaysToCompute(input[:index]) right := diffWaysToCompute(input[index+1:]) for _, leftNum := range left { for _, rightNum := range right { var addNum int if tmpC == "+" { addNum = leftNum + rightNum } else if tmpC == "-" { addNum = leftNum - rightNum } else { addNum = leftNum * rightNum } res = append(res, addNum) } } } } return res }
func findMaxConsecutiveOnes(nums []int) (maxCnt int) { cnt := 0 for _, v := range nums { if v == 1 { cnt++ } else { maxCnt = max(maxCnt, cnt) cnt = 0 } } maxCnt = max(maxCnt, cnt) return }
func circularArrayLoop(nums []int) bool { n := len(nums) next := func(cur int) int { return ((cur+nums[cur])%n + n) % n } for i, num := range nums { if num == 0 { continue } slow, fast := i, next(i) for nums[slow]*nums[fast] > 0 && nums[slow]*nums[next(fast)] > 0 { if slow == fast { if slow == next(slow) { break } return true } slow = next(slow) fast = next(next(fast)) } add := i for nums[add]*nums[next(add)] > 0 { tmp := add add = next(add) nums[tmp] = 0 } } return false }
